<html><head><meta name="viewport" content="width=device-width, initial-scale=1"><link href=//fonts.googleapis.com/css?family=Raleway:400,300,600 rel=stylesheet type=text/css><link rel="stylesheet" type="text/css" href="../common/css/normalize.css"><link rel="stylesheet" type="text/css" href="../common/css/skeleton.css"><link rel="stylesheet" type="text/css" href="../common/css/wiki.css"><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><title>Grove - I2C ADC</title><meta charset="utf-8"/><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-84386732-1', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body><div class"container"><a href="../"><img src="../common/logo.png"/></a></div><div class="mw-content-ltr container" dir="ltr" id="mw-content-text" lang="en"><h1>Grove - I2C ADC</h1><div class="thumb tright"><div class="thumbinner" style="width:502px;"><a href="http://www.seeedstudio.com/depot/grove-i2c-adc-p-1580.html"><img src="img/I2C_ADC_01.jpg" width="500"/></a> <div class="thumbcaption"></div></div></div>
<p>Grove - I2C ADC is a 12-bit precision ADC module based on ADC121C021. It helps you increase the accuracy of value collected from analog sensor by providing a constant reference voltage. Because its address is changeable, you can use up to 9 I2C ADC at the same time at most. At the other hand, this module provides auto sleep function which lowers the power consumption considerably.
</p><p><br/>
<a href="http://www.seeedstudio.com/depot/grove-i2c-adc-p-1580.html"><img src="../common/Get_One_Now_Banner.png" width="300"/></a>
</p><p><br/>
</p>
<p><br/>
</p>
<h2> Feature</h2>
<ul><li> Low power consumption
</li><li> High precision
</li><li> Automatic power-down mode
</li><li> Address changeable
</li></ul>
<p><br/>
</p>
<h2> Specification</h2>
<table  cellspacing="0" width="50%">
<tr>
<th scope="col"> Item
</th>
<th scope="col"> Typical
</th>
<th scope="col"> Unit
</th></tr>
<tr>
<th scope="row"> Working Voltage
</th>
<td> 5.0
</td>
<td> VDC
</td></tr>
<tr>
<th scope="row"> Resolution
</th>
<td> 12
</td>
<td> Bit
</td></tr>
<tr>
<th scope="row"> Sample Rate
</th>
<td> 188.9
</td>
<td> ksps
</td></tr>
<tr>
<th scope="row"> Dimension
</th>
<td> 40X20
</td>
<td> mm
</td></tr></table>
<p><br/>
</p>
<h2> Interface Function</h2>
<p><img src="img/IIC_ADC_Interface.png" width="500"/><br/>
<b>J1:</b> used to connect Arduino IIC Interface as Grove - I2C ADC output interface. <br/>
<b>J2:</b> used to connect analog sensor as Grove - I2C ADC input interface. <br/>
<b>U1:</b> ADC121C021 IC,12-Bit Analog-to-Digital Converter <br/>
<b>The black line area is used to set the IIC address. ADDR0 and ADDR1 are shipped connected to L. You can change them to "H" or floating by a little modification on the board(floating is neither connecting "H" nor connecting "L"). Find details in the Reference.</b>
</p>
<h2> Getting Started</h2>
<h3> With Arduino</h3>
<p>Grove - I2C ADC has two interfaces: input socket(J2) and output socket(J1). Connect an analog sensor to its input socket and connect the I2C ADC to Arduino/Seeeduino also via Grove cables. 
</p><p>Take Grove - Gas Sensor as an example, and now we learn how to read sensor data using Grove - I2C ADC.<br/>
The hardware installation should be like this:<br/>
</p><p><br/><img src="img/Read_gas_sensor_data_using_I2C_ADC.jpg" width="500"/><br/>
</p><p>Now you can read the gas sensor value using the code below.
</p>
<div class="mw-geshi mw-code mw-content-ltr container" dir="ltr"><div class="arduino source-arduino"><pre class="de1"><span class="co2">#include &lt;Wire.h&gt;</span>
 
<span class="co2">#define ADDR_ADC121             0x55</span>
 
<span class="co2">#define V_REF 3.00</span>
 
<span class="co2">#define REG_ADDR_RESULT         0x00</span>
<span class="co2">#define REG_ADDR_ALERT          0x01</span>
<span class="co2">#define REG_ADDR_CONFIG         0x02</span>
<span class="co2">#define REG_ADDR_LIMITL         0x03</span>
<span class="co2">#define REG_ADDR_LIMITH         0x04</span>
<span class="co2">#define REG_ADDR_HYST           0x05</span>
<span class="co2">#define REG_ADDR_CONVL          0x06</span>
<span class="co2">#define REG_ADDR_CONVH          0x07</span>
 
<span class="kw4">unsigned</span> <span class="kw4">int</span> getData<span class="sy4">;</span>
<span class="kw4">float</span> analogVal<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>         <span class="co1">// convert</span>
<span class="kw4">void</span> init_adc<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw2">Wire</span>.<span class="kw3">beginTransmission</span><span class="br0">(</span>ADDR_ADC121<span class="br0">)</span><span class="sy4">;</span>        <span class="co1">// transmit to device</span>
  <span class="kw2">Wire</span>.<span class="kw3">write</span><span class="br0">(</span>REG_ADDR_CONFIG<span class="br0">)</span><span class="sy4">;</span>                <span class="co1">// Configuration Register</span>
  <span class="kw2">Wire</span>.<span class="kw3">write</span><span class="br0">(</span><span class="nu12">0x20</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw2">Wire</span>.<span class="kw3">endTransmission</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>  
<span class="br0">}</span>
 
<span class="kw4">void</span> read_adc<span class="br0">(</span><span class="br0">)</span>     <span class="co1">//unsigned int *data</span>
<span class="br0">{</span>
 
 
    <span class="kw2">Wire</span>.<span class="kw3">beginTransmission</span><span class="br0">(</span>ADDR_ADC121<span class="br0">)</span><span class="sy4">;</span>        <span class="co1">// transmit to device</span>
    <span class="kw2">Wire</span>.<span class="kw3">write</span><span class="br0">(</span>REG_ADDR_RESULT<span class="br0">)</span><span class="sy4">;</span>                <span class="co1">// get result</span>
    <span class="kw2">Wire</span>.<span class="kw3">endTransmission</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="kw2">Wire</span>.<span class="kw3">requestFrom</span><span class="br0">(</span>ADDR_ADC121, <span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span>           <span class="co1">// request 2byte from device</span>
    <span class="kw3">delay</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">if</span><span class="br0">(</span><span class="kw2">Wire</span>.<span class="kw3">available</span><span class="br0">(</span><span class="br0">)</span><span class="sy1">&lt;=</span><span class="nu0">2</span><span class="br0">)</span>
    <span class="br0">{</span>
      getData <span class="sy1">=</span> <span class="br0">(</span><span class="kw2">Wire</span>.<span class="kw3">read</span><span class="br0">(</span><span class="br0">)</span><span class="sy3">&amp;</span><span class="nu12">0x0f</span><span class="br0">)</span><span class="sy1">&lt;&lt;</span><span class="nu0">8</span><span class="sy4">;</span>
      getData <span class="sy3">|</span><span class="sy1">=</span> <span class="kw2">Wire</span>.<span class="kw3">read</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
    <span class="kw2">Serial</span>.<span class="kw3">print</span><span class="br0">(</span><span class="st0">"getData:"</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span>getData<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw3">delay</span><span class="br0">(</span><span class="nu0">5</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw2">Serial</span>.<span class="kw3">print</span><span class="br0">(</span><span class="st0">"The analog value is:"</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw2">Serial</span>.<span class="kw3">print</span><span class="br0">(</span>getData<span class="sy2">*</span>V_REF<span class="sy2">*</span><span class="nu0">2</span><span class="sy2">/</span><span class="nu0">4096</span><span class="br0">)</span><span class="sy4">;</span> 
    <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"V"</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
<span class="kw4">void</span> <span class="kw2">setup</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw2">Serial</span>.<span class="kw3">begin</span><span class="br0">(</span><span class="nu0">9600</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="kw2">Wire</span>.<span class="kw3">begin</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
  init_adc<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> <span class="kw2">loop</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>  read_adc<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span><span class="co1">//adcRead);</span>
   <span class="kw3">delay</span><span class="br0">(</span><span class="nu0">50</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>In the code above, we defined the Vref as 3.0V which is decided by the I2C ADC module. This reference voltage is more accurate than one generated by microcontroller. And you can make that more accurate by measuring the voltage between VA and GND and use that value to replace 3.00 in the code above.<br/>
</p><p>Now you can upload the code. Please click <a href="/Upload_Code">here</a> if you do not know how to upload.<br/> 
Afterwards, open the serial monitor and read the values:<br/>
<img src="img/IIC_ADC_Read_Result.jpg" width="332"/><br/>
<font color="red">Note:</font> The address of Grove - I2C ADC is changeable which means you can redefine its address. That requires some hardware modification on the board. If you are thinking about using more than one I2C ADC at the same time, follow the instruction in the Reference part below to do so. The maximum of I2C ADC used simultaneously is 9, but there are only 4 I2C sockets on <a href="/Grove-Base_Shield_V1.3" title="Grove - Base Shield V1.3">Grove - Base Shield V1.3</a>, so if you want to use more than 4 I2C ADC, take a  <a href="/Grove-I2C_Hub" title="Grove - I2C Hub">Grove - I2C Hub</a> to create more I2C sockets.
</p>
<h3>  With Beaglebone Green</h3>
<p>To begin editing programs that live on BBG, you can use the Cloud9 IDE.<br/>
As a simple exercise to become familiar with Cloud9 IDE, creating a simple application to blink one of the 4 user programmable LEDs on the BeagleBone is a good start.
</p><p>If this is your first time to use Cloud9 IDE, please follow this <a href="/Beaglebone_green#Getting_Started"><b>link</b></a>.
<br/>
</p><p><br/>
<b>Step1:</b> Set the Grove - UART socket as a Grove - GPIO Socket, just follow this <a href="http://www.seeedstudio.com/recipe/362-how-to-use-the-grove-uart-port-as-a-gpio-on-bbg.html"><b>link</b></a>.
</p><p><b>Step2:</b> Click the "+" in the top-right to create a new file.
</p><p><img src="img/C9-create-tab.png" width="168"/>
</p><p><img src="img/C9_newfile.jpg" width="440"/>
</p><p><b>Step3:</b> Copy and paste the following code into the new tab
</p>
<div class="mw-geshi mw-code mw-content-ltr container" dir="ltr"><div class="python source-python"><pre class="de1"><span class="kw1">from</span> Adafruit_I2C <span class="kw1">import</span> Adafruit_I2C
<span class="kw1">import</span> <span class="kw3">time</span>
 
ADDR_ADC121 <span class="sy0">=</span> <span class="nu0">0x50</span>
 
REG_ADDR_RESULT <span class="sy0">=</span> <span class="nu0">0x00</span>
REG_ADDR_ALERT <span class="sy0">=</span> <span class="nu0">0x01</span>
REG_ADDR_CONFIG <span class="sy0">=</span> <span class="nu0">0x02</span>
REG_ADDR_LIMITL <span class="sy0">=</span> <span class="nu0">0x03</span>
REG_ADDR_LIMITH <span class="sy0">=</span> <span class="nu0">0x04</span>
REG_ADDR_HYST <span class="sy0">=</span> <span class="nu0">0x05</span>
REG_ADDR_CONVL <span class="sy0">=</span> <span class="nu0">0x06</span>
REG_ADDR_CONVH <span class="sy0">=</span> <span class="nu0">0x07</span>
 
i2c <span class="sy0">=</span> Adafruit_I2C<span class="br0">(</span>ADDR_ADC121<span class="br0">)</span>           
 
<span class="kw1">class</span> I2cAdc:
    <span class="kw1">def</span> <span class="kw4">__init__</span><span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
        i2c.<span class="me1">write8</span><span class="br0">(</span>REG_ADDR_CONFIG<span class="sy0">,</span> <span class="nu0">0x20</span><span class="br0">)</span>
 
    <span class="kw1">def</span> read_adc<span class="br0">(</span><span class="kw2">self</span><span class="br0">)</span>:
        <span class="st0">"Read ADC data 0-4095."</span>
        data_list <span class="sy0">=</span> i2c.<span class="me1">readList</span><span class="br0">(</span>REG_ADDR_RESULT<span class="sy0">,</span> <span class="nu0">2</span><span class="br0">)</span>
        <span class="co1">#print 'data list', data_list</span>
        data <span class="sy0">=</span> <span class="br0">(</span><span class="br0">(</span>data_list<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> &amp; <span class="nu0">0x0f</span><span class="br0">)</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">8</span> | data_list<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span><span class="br0">)</span> &amp; <span class="nu0">0xfff</span>
        <span class="kw1">return</span> data
 
<span class="kw1">if</span> __name__ <span class="sy0">==</span> <span class="st0">'__main__'</span>:
    <span class="co1"># Connect the Grove - I2C ADC to I2C Grove port of Beaglebone Green.</span>
    adc <span class="sy0">=</span> I2cAdc<span class="br0">(</span><span class="br0">)</span>
    <span class="kw1">while</span> <span class="kw2">True</span>:
        <span class="kw1">print</span> <span class="st0">'sensor value '</span><span class="sy0">,</span> adc.<span class="me1">read_adc</span><span class="br0">(</span><span class="br0">)</span>
        <span class="kw3">time</span>.<span class="me1">sleep</span><span class="br0">(</span><span class="nu0">.2</span><span class="br0">)</span></pre></div></div>
<p><b>Step4:</b> Save the file by clicking the disk icon and giving the file a name with the .py extension.
</p><p><b>Step5:</b> Connect Grove I2C ADC to Grove I2C socket on BBG.
</p><p><b>Step6:</b> Run the code.
You'll find that the terminal outputs AD value every 2 seconds.
</p>
<h2> Reference </h2>
<h3> I2C Address Setting</h3>
<p>The ADC I2C has a seven-bit hardware address which is decided by ADR0 and ADR1. ADR0 and ADR1 are connected to L inside the board as default. But you can change it. For example, use a knife to cut off the connection between L and ADR0(as the picture shown below), then you make the state of ADR0 into Floating(connected to nothing). And if you solder up ADR0 and H this time, then you make the value of ADR0 H.<br/>
<img src="img/Change_I2C_Address.jpg" width="500"/><br/>
You can find the relationship of hardware I2C address and the values of ADR0 and ADR1 in the following table.<br/>
</p>
<table  cellspacing="0" width="50%">
<tr>
<th rowspan="2" scope="col">  Slave Address[A6 - A0]
</th>
<th colspan="2" scope="col"> ADR0 and ADR1 inputs state
</th></tr>
<tr>
<td scope="col"> ADR1
</td>
<td scope="col"> ADR0
</td></tr>
<tr>
<td scope="row"> 1010000(0x50)
</td>
<td>Floating
</td>
<td>Floating
</td></tr>
<tr>
<td scope="row"> 1010001(0x51)
</td>
<td> Floating
</td>
<td> L
</td></tr>
<tr>
<td scope="row"> 1010010(0x52)
</td>
<td> Floating
</td>
<td> H
</td></tr>
<tr>
<td scope="row"> 1010100(0x54)
</td>
<td> L
</td>
<td> Floating
</td></tr>
<tr>
<td scope="row"> 1010101(default 0x55)
</td>
<td>L
</td>
<td>L
</td></tr>
<tr>
<td scope="row"> 1010110(0x56)
</td>
<td> L
</td>
<td> H
</td></tr>
<tr>
<td scope="row"> 1011000(0x58)
</td>
<td> H
</td>
<td> Floating
</td></tr>
<tr>
<td scope="row"> 1011001(0x59)
</td>
<td> H
</td>
<td> L
</td></tr>
<tr>
<td scope="row">1011010(0x5A)
</td>
<td> H
</td>
<td> H
</td></tr></table>
<h3> How much does the I2C ADC increase the accuracy? </h3>
<p>Here is an experiment we make to give you a sense about how much the I2C ADC increase the accuracy of an analog sensor.
First, let's check the values collected directly through analog port on Arduino/Seeeduino from an Grove - Gas Sensor(MQ5)
<br/>
<img src="img/Read_Gas_Sensor_data.jpg" width="400"/><br/>
We upload the code below to get the data.
</p>
<pre>/*
 * Grove - Gas Sensor(MQ5)  
 *
 * The Gas Sensor detect the related Gas density, 
 * Arduino get the result by analogread. the gas Density is 
 * 0~1, larger the output is, the denser the gas.
 * Connect the Sensor to A0 in this demo;
 * 
 *  By: http://www.seeedstudio.com
*/
#define Vref 4.95
void setup() {
  Serial.begin(9600);
}
 
void loop() {
  float vol;
  int sensorValue = analogRead(A0);
  vol=(float)sensorValue/1023*Vref;
  Serial.print("The sensorValue is ");
  Serial.println(sensorValue);
  Serial.print("The analog value is ");
  Serial.print(vol);
  Serial.println("V");
  delay(100);
}</pre>
<p>The result is:
<br/><img src="img/Read_ADC_2.jpg" width="333"/><br/>
</p><p>As default, Vref is generated by Arduino which is theoretically 5V. But actually that is a value afloat which results the deviation of the final data. This kind of inaccuracy is avoided when using Grove - I2C ADC, because it provides a strict 3.0V as Vref. <br/>
To contrast, in the same condition, sensor values collected by the circuit with Grove - I2C ADC in the scope is shown below: <br/>
<img src="img/IIC_ADC_Read_Result.jpg" width="350"/><br/>
</p><p>In order to find out which result is more close to the actual condition, here we use a multimeter to measure the voltage between the pin SIG and pin GND of the sensor.<br/>
<img src="img/Measure_the_real_sensor_value_using_DMM.JPG" width="300"/>
</p>
<h2> Resource</h2>
<ul><li> <a href="res/I2C_ADC_Eagle_File.zip">I2C ADC Eagle File</a><br/>
</li><li> <a href="res/ADC121C021_Datasheet.pdf">ADC121C021 Datasheet</a>
</li><li> 
</li></ul>
<p><br/>
</p>
<h2> Help us to make it better </h2>
<p><iframe frameborder="0" height="500" src="https://www.surveymonkey.com/r/LDPP93V" width="500"></iframe>
</p>
Copyright (c) 2008-2016 Seeed Development Limited (<a href="http://www.seeedstudio.com">www.seeedstudio.com</a> / <a href="http://www.seeed.cc">www.seeed.cc</a>)<h6>This static html page was created from http://www.seeedstudio.com/wiki</h6></div></body></html>