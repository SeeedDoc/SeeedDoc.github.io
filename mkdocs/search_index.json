{
    "docs": [
        {
            "location": "/",
            "text": "Seeed Wiki\n\n\nPreview site\n\n\nNot for production use. Internal links to other Wiki pages that are not yet migrated will be inaccessible.",
            "title": "Home"
        },
        {
            "location": "/#seeed-wiki",
            "text": "",
            "title": "Seeed Wiki"
        },
        {
            "location": "/#preview-site",
            "text": "Not for production use. Internal links to other Wiki pages that are not yet migrated will be inaccessible.",
            "title": "Preview site"
        },
        {
            "location": "/Arch_BLE/",
            "text": "Arch BLE\n\n\n\n\nIntroduction\n\n\nArch BLE is an mbed enabled development board based Nordic nRF51822. With Arduino form factor and Grove connectors, it is extremely easy to create a bluetooth low energy device.\n\n\nThe nRF51822 is a powerful multi-protocol single chip solution for ULP wireless applications. It incorporates Nordic\u2019s latest best-in-class performance radio transceiver, an ARM Cortex M0 MCU and 256kB flash + 16kB RAM memory. The nRF51822 supports Bluetooth\u00ae low energy and 2.4 GHz protocol stacks.\n\n\n\n\nFeatures\n\n\n\n\nmbed enabled\n\n\nOnline IDE\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\nCMSIS DAP based on LPC11U35\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS DAP standard\n\n\nUSB virtual serial for communication\n\n\n\n\n\n\nArduino form factor with Grove connectors\n\n\nNordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC\n\n\nARM Cortex M0 processor\n\n\n256kB flash/16kB RAM\n\n\nConfigurable I/O mapping for digital I/O\n\n\n\n\n\n\nUSB Micro B connector\n\n\n\n\nHardware Overview\n\n\n\n\nGet Started\n\n\n\n\n\n\nClick \nthis link\n to \nlogin or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download a compiled hex file.\n\n\nDrag-n-drop the downloaded hex file into the MBED disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1s\n\n\n    #include \"mbed.h\"\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\n\n\nNote\n\nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.\n\n\n\n\nApplications\n\n\n\n\n\n\nColor Pixels, a colorful LED strip, can be controlled by mobile phone.\n\n\n\n\nHardware\n\n\nArch BLE\n\n\nDigital RGB LED Strip\n\n\nAndroid device with BLE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it run\n\n\n\n\nDownload \nBLE_Color_Pixels_Arch_BLE.hex\n\n\nCopy the hex file to the MBED disk of your Arch BLE\n\n\nDownload \nthe Color Pixels Android app\n\n\n\n\n\n\n\n\n\n\n\n\nIf you want to change the program, click \nthis link\n to import the Color Pixels program to mbed online IDE.\n\n\nIf the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)\n\n\n#define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**< Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**< Maximum acceptable connection interval */\n\n\n\n\nUpdate or Restore Firmware\n\n\nThe latest firmware version for the Arch BLE is v0203 built at Oct 08 2014. To check your firmware version and built date, open the MBED.HTM file of your MBED disk in a text editor.\n\n\nChange log:\n\n\n\n\n2014-06-26: First version\n\n\n2014-08-25: Support to drag-n-drop hex file generated by gcc toolchain and without softdevice\n\n\n2014-10-08: Use USB EJECT INSET instead of reconnecting USB, increase intel hex data line buffer (from 64 bytes to 128 bytes)\n\n\n\n\nKnown issues:\n\n\n\n\nIssues when \ndirectly\n downloading the hex file into the MBED disk with the Chrome browser. The reason is Chrome creates a temporary file while downloading. If you are using Chrome, please save the hex file to a different location and \nthen\n copy it to the MBED disk.\n\n\n\n\nFirmware:\n\n\n\n\nThe firmware v0203 2014-10-08 for Arch BLE\n\n\nThe firmware v0203 2014-08-25 for Arch BLE\n\n\n\n\nTo flash a new firmware:\n\n\n\n\nHold the Arch BLE's button and power it ON.\n\n\nA CRP DISABLD disk will pop up.\n\n\nOn Windows, replace firmware.bin with the above firmware.\n\n\nOn Linux/Mac, use command: \ndd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nSchematic pdf\n\n\nEagle file\n\n\nLPC11U35 Firmware\n\n\nSeeed ble color pixels app for Android\n\n\nSources of ble color pixels app\n\n\n\n\nHelp us make it better",
            "title": "Arch BLE"
        },
        {
            "location": "/Arch_BLE/#arch-ble",
            "text": "",
            "title": "Arch BLE"
        },
        {
            "location": "/Arch_BLE/#introduction",
            "text": "Arch BLE is an mbed enabled development board based Nordic nRF51822. With Arduino form factor and Grove connectors, it is extremely easy to create a bluetooth low energy device.  The nRF51822 is a powerful multi-protocol single chip solution for ULP wireless applications. It incorporates Nordic\u2019s latest best-in-class performance radio transceiver, an ARM Cortex M0 MCU and 256kB flash + 16kB RAM memory. The nRF51822 supports Bluetooth\u00ae low energy and 2.4 GHz protocol stacks.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_BLE/#features",
            "text": "mbed enabled  Online IDE  Easy to use C/C++ SDK  Handy libraries    CMSIS DAP based on LPC11U35  Drag-n-drop programming  Debug using CMSIS DAP standard  USB virtual serial for communication    Arduino form factor with Grove connectors  Nordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC  ARM Cortex M0 processor  256kB flash/16kB RAM  Configurable I/O mapping for digital I/O    USB Micro B connector",
            "title": "Features"
        },
        {
            "location": "/Arch_BLE/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_BLE/#get-started",
            "text": "Click  this link  to  login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download a compiled hex file.  Drag-n-drop the downloaded hex file into the MBED disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1s      #include \"mbed.h\"\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }   Note \nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.",
            "title": "Get Started"
        },
        {
            "location": "/Arch_BLE/#applications",
            "text": "Color Pixels, a colorful LED strip, can be controlled by mobile phone.   Hardware  Arch BLE  Digital RGB LED Strip  Android device with BLE         Make it run   Download  BLE_Color_Pixels_Arch_BLE.hex  Copy the hex file to the MBED disk of your Arch BLE  Download  the Color Pixels Android app       If you want to change the program, click  this link  to import the Color Pixels program to mbed online IDE.  If the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)  #define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**< Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**< Maximum acceptable connection interval */",
            "title": "Applications"
        },
        {
            "location": "/Arch_BLE/#update-or-restore-firmware",
            "text": "The latest firmware version for the Arch BLE is v0203 built at Oct 08 2014. To check your firmware version and built date, open the MBED.HTM file of your MBED disk in a text editor.  Change log:   2014-06-26: First version  2014-08-25: Support to drag-n-drop hex file generated by gcc toolchain and without softdevice  2014-10-08: Use USB EJECT INSET instead of reconnecting USB, increase intel hex data line buffer (from 64 bytes to 128 bytes)   Known issues:   Issues when  directly  downloading the hex file into the MBED disk with the Chrome browser. The reason is Chrome creates a temporary file while downloading. If you are using Chrome, please save the hex file to a different location and  then  copy it to the MBED disk.   Firmware:   The firmware v0203 2014-10-08 for Arch BLE  The firmware v0203 2014-08-25 for Arch BLE   To flash a new firmware:   Hold the Arch BLE's button and power it ON.  A CRP DISABLD disk will pop up.  On Windows, replace firmware.bin with the above firmware.  On Linux/Mac, use command:  dd if={new_firmware.bin} of={firmware.bin} conv=notrunc",
            "title": "Update or Restore Firmware"
        },
        {
            "location": "/Arch_BLE/#resources",
            "text": "Schematic pdf  Eagle file  LPC11U35 Firmware  Seeed ble color pixels app for Android  Sources of ble color pixels app",
            "title": "Resources"
        },
        {
            "location": "/Arch_BLE/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_GPRS_V2/",
            "text": "Arch GPRS V2\n\n\n\n\nIntroduction\n\n\nArch GPRS V2 is the new and improved version of the \nArch GPRS\n development board from \nSeeed Studio\n. Like the original \nArch GPRS\n, it is also an \nmbed\n enabled development board that houses a cellular networking module along with a microcontroller. Arch GPRS V2 uses the LPC11U37 Microcontroller instead of the LPC11U24 used in the \nArch GPRS\n. You can use the mbed C/C++ SDK, libraries and optimizing online development tools to rapidly build your Arch GPRS V2 based prototype. The cellular networking module on the Arch GPRS is based on the SIM900 Quad-band GSM/GRPS engine from SIMCom. With this, data collection functions can be performed easily using the 2G GSM/GPRS based cellular network.\nArch GPRS V2 has a standard \nArduino\n interface as well as \nGrove\n connectors on board. It is convenient to connect existing Shields and \nGrove\n products to Arch GPRS V2. You can even connect a solar panel directly to the board to allow the battery to charge from it. A low-power design guarantees easy charging and long hour operations when outdoors!\n\n\n\n\n\n\nNote\n\nArch GPRS V2 does not come with \nan mbed interface\n. To output debug messages, please try \nUSBSerial\n.\n\n\n\n\nFeatures\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nOnline development tools\n\n\nEasy to use C/C++ SDK\n\n\nLots of published libraries, projects\n\n\n\n\n\n\n\n\nNXP LPC11U37 Controller\n\n\n\n\nLow power ARM Cortex-M0 Core\n\n\nOn chip 128KB Flash, 12KB SRAM, 4KB EEPROM\n\n\nUSB Device, UART, I2C\n\n\n\n\n\n\n\n\nSIM900 Module\n\n\n\n\nQuad-band (850/900/1800/1900MHz) GSM/GPRS support\n\n\nSupports external SIM card\uff1a 1.8V/3V\n\n\nControl with standard AT Commands\n\n\n\n\n\n\n\n\nSelect automatically USB5V or Solar panel to charge a battery\n\n\n\n\n\n\nArch GPRS V2 vs Arch GPRS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArch GPRS V2\n\n\nArch GPRS\n\n\n\n\n\n\nMCU\n\n\nLPC11U27\n\n\nLPC11U24\n\n\n\n\n\n\nGSM/GPRS Module\n\n\nSIM900\n\n\nEG-10\n\n\n\n\n\n\nMicroSD Card\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nGetting Started\n\n\n\n\n\n\nLogin into the mbed environment from \nhere\n\n\nImport the \nmbed_blinky\n program\n\n\nVerify that the code imported in main.cpp in the mbed_blinky folder in the mbed online Compiler environment is as indicated in the figure above under Step 3. Ensure that the platform selected for compiling the code for is the Seeeduino-Arch. Now go ahead and compile the code. When asked to save the resultant binary file (.bin), save it to a designated folder on your PC.\n\n\nNow connect your Arch board to your PC and long press the reset button. A removable USB drive named CRP DISABLD should automatically appear on your PC. Go to the CRP DISABLD drive, delete the existing firmware file that you see in the folder and copy the downloaded binary file to CRP DISABLD. Quick press the reset button to run the new binary.\n\n\nVerify that your code is running successfully by looking at the Arch GPRS V2 board. If the right-most LED from the Pinout shown above is blinking and the other 3 LEDs next to it are all ON, this implies that your code is working.\n\n\n\n\nYou can change the code to the following and see what happens:\n\n\n\n    #include \"mbed.h\"\n\n    DigitalOut myled1(LED2); //left most LED if board is held as shown in Pinout diagram above\n    DigitalOut myled2(LED3); //2nd from left\n    DigitalOut myled3(LED4); //3rd from left\n    DigitalOut myled4(LED1); //4th from left (right most)\n\n    int main() {\n        while(1) {\n\n            myled1 = 1; //left most LED turns ON, rest off\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1); //1 sec wait time\n            myled1 = 0;\n            myled2 = 1; //2nd from left LED turns ON, rest off\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 1; //3rd from left LED turns ON, rest off\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 1; //4th from left (right most) LED turns ON, rest off\n\n            wait(1);\n        }\n    }\n\n\n\n\nWhen you Compile and Run the above code on the Arch GPRS V2 board, you should see that the LEDs now blink in sequence.\n\n\nIf you get through the above steps successfully, this means that:\n\n\n\n\nYour Arch GPRS V2 is powering up correctly.\n\n\nYour code is being downloaded and run by the Arch GPRS V2 module correctly.\n\n\nYou are ready to take on more complex projects now!\n\n\n\n\nProgramming Arch on Windows, Linux or Mac\n\n\nArch does not have an mbed interface. It uses USB In-System-Programming (ISP) to upgrade the firmware.\n\n\nTo enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \"CRP DISABLD\" will appear.\n\n\n\n\n\n\nOn windows\n\n\n\n\ndelete firmware.bin in the \"CRP DISABLD\" disk.\n\n\ncopy a new firmware into the disk.\n\n\n\n\n\n\n\n\nOn linux\n\n\n\n\nif the disk is not mounted, mount the disk at \n{mnt_dir}\n\n\ndd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nOn mac you'll need to use Terminal to run the following script to copy you're .bin file to your Arch\n\n\n\n\ndd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nIf you are so inclined, you can also create an \nAutomator\n application to support drag-and-drop of the file to your board. Just create a \"\nRun Shell Script\n\" with the following command:\n\n\ndd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nYou will also need to change the \n\"Pass Input\"\n option from \n\"to stdin\"\n to \n\"as arguments\"\n--without this you will get an error \n\"The action 'Run Shell Script' encountered an error\"\n or \n\"dd: no value specified for if (1)\"\n in the log.\n\n\nAlso, an improved form of the script is:\n\ndd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nWhich should handle spaces in the file path and only uses the first file supplied.\nQuick press the button to run the new firmware.\n\n\nResources\n\n\nSchematic\n\n\n\n\nEagle file for Arch_GPRS_v2.0\n\n\nArch GPRS_v2.0.PDF\n\n\n\n\nApplications and Library\n\n\n\n\nGPRS library\n\n\nUse Seeeduino Arch as a debug adapter to debug another Seeeduino Arch\n\n\nSense environment\n\n\nPlay with Grove RTC\n\n\nPlay with Grove - Ultrasonic ranger\n\n\n\n\nSee also\n\n\n\n\nSIM900 GPRS Module Information\n\n\n\n\nHelp us make it better",
            "title": "Arch GPRS V2"
        },
        {
            "location": "/Arch_GPRS_V2/#arch-gprs-v2",
            "text": "",
            "title": "Arch GPRS V2"
        },
        {
            "location": "/Arch_GPRS_V2/#introduction",
            "text": "Arch GPRS V2 is the new and improved version of the  Arch GPRS  development board from  Seeed Studio . Like the original  Arch GPRS , it is also an  mbed  enabled development board that houses a cellular networking module along with a microcontroller. Arch GPRS V2 uses the LPC11U37 Microcontroller instead of the LPC11U24 used in the  Arch GPRS . You can use the mbed C/C++ SDK, libraries and optimizing online development tools to rapidly build your Arch GPRS V2 based prototype. The cellular networking module on the Arch GPRS is based on the SIM900 Quad-band GSM/GRPS engine from SIMCom. With this, data collection functions can be performed easily using the 2G GSM/GPRS based cellular network.\nArch GPRS V2 has a standard  Arduino  interface as well as  Grove  connectors on board. It is convenient to connect existing Shields and  Grove  products to Arch GPRS V2. You can even connect a solar panel directly to the board to allow the battery to charge from it. A low-power design guarantees easy charging and long hour operations when outdoors!    Note \nArch GPRS V2 does not come with  an mbed interface . To output debug messages, please try  USBSerial .",
            "title": "Introduction"
        },
        {
            "location": "/Arch_GPRS_V2/#features",
            "text": "mbed enabled   Online development tools  Easy to use C/C++ SDK  Lots of published libraries, projects     NXP LPC11U37 Controller   Low power ARM Cortex-M0 Core  On chip 128KB Flash, 12KB SRAM, 4KB EEPROM  USB Device, UART, I2C     SIM900 Module   Quad-band (850/900/1800/1900MHz) GSM/GPRS support  Supports external SIM card\uff1a 1.8V/3V  Control with standard AT Commands     Select automatically USB5V or Solar panel to charge a battery",
            "title": "Features"
        },
        {
            "location": "/Arch_GPRS_V2/#arch-gprs-v2-vs-arch-gprs",
            "text": "Arch GPRS V2  Arch GPRS    MCU  LPC11U27  LPC11U24    GSM/GPRS Module  SIM900  EG-10    MicroSD Card  Yes  No",
            "title": "Arch GPRS V2 vs Arch GPRS"
        },
        {
            "location": "/Arch_GPRS_V2/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_GPRS_V2/#getting-started",
            "text": "Login into the mbed environment from  here  Import the  mbed_blinky  program  Verify that the code imported in main.cpp in the mbed_blinky folder in the mbed online Compiler environment is as indicated in the figure above under Step 3. Ensure that the platform selected for compiling the code for is the Seeeduino-Arch. Now go ahead and compile the code. When asked to save the resultant binary file (.bin), save it to a designated folder on your PC.  Now connect your Arch board to your PC and long press the reset button. A removable USB drive named CRP DISABLD should automatically appear on your PC. Go to the CRP DISABLD drive, delete the existing firmware file that you see in the folder and copy the downloaded binary file to CRP DISABLD. Quick press the reset button to run the new binary.  Verify that your code is running successfully by looking at the Arch GPRS V2 board. If the right-most LED from the Pinout shown above is blinking and the other 3 LEDs next to it are all ON, this implies that your code is working.   You can change the code to the following and see what happens:  \n    #include \"mbed.h\"\n\n    DigitalOut myled1(LED2); //left most LED if board is held as shown in Pinout diagram above\n    DigitalOut myled2(LED3); //2nd from left\n    DigitalOut myled3(LED4); //3rd from left\n    DigitalOut myled4(LED1); //4th from left (right most)\n\n    int main() {\n        while(1) {\n\n            myled1 = 1; //left most LED turns ON, rest off\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1); //1 sec wait time\n            myled1 = 0;\n            myled2 = 1; //2nd from left LED turns ON, rest off\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 1; //3rd from left LED turns ON, rest off\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 1; //4th from left (right most) LED turns ON, rest off\n\n            wait(1);\n        }\n    }  When you Compile and Run the above code on the Arch GPRS V2 board, you should see that the LEDs now blink in sequence.  If you get through the above steps successfully, this means that:   Your Arch GPRS V2 is powering up correctly.  Your code is being downloaded and run by the Arch GPRS V2 module correctly.  You are ready to take on more complex projects now!",
            "title": "Getting Started"
        },
        {
            "location": "/Arch_GPRS_V2/#programming-arch-on-windows-linux-or-mac",
            "text": "Arch does not have an mbed interface. It uses USB In-System-Programming (ISP) to upgrade the firmware.  To enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \"CRP DISABLD\" will appear.    On windows   delete firmware.bin in the \"CRP DISABLD\" disk.  copy a new firmware into the disk.     On linux   if the disk is not mounted, mount the disk at  {mnt_dir}  dd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc     On mac you'll need to use Terminal to run the following script to copy you're .bin file to your Arch   dd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc     If you are so inclined, you can also create an  Automator  application to support drag-and-drop of the file to your board. Just create a \" Run Shell Script \" with the following command:  dd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  You will also need to change the  \"Pass Input\"  option from  \"to stdin\"  to  \"as arguments\" --without this you will get an error  \"The action 'Run Shell Script' encountered an error\"  or  \"dd: no value specified for if (1)\"  in the log.  Also, an improved form of the script is: dd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  Which should handle spaces in the file path and only uses the first file supplied.\nQuick press the button to run the new firmware.",
            "title": "Programming Arch on Windows, Linux or Mac"
        },
        {
            "location": "/Arch_GPRS_V2/#resources",
            "text": "Schematic   Eagle file for Arch_GPRS_v2.0  Arch GPRS_v2.0.PDF   Applications and Library   GPRS library  Use Seeeduino Arch as a debug adapter to debug another Seeeduino Arch  Sense environment  Play with Grove RTC  Play with Grove - Ultrasonic ranger   See also   SIM900 GPRS Module Information",
            "title": "Resources"
        },
        {
            "location": "/Arch_GPRS_V2/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_Link/",
            "text": "Arch Link\n\n\n\n\nIntroduction\n\n\nArch Link is an mbed enabled development board based on Nordic nRF51822 and WIZnet W5500 ethernet interface. With Arduino form factor, Grove connectors and micro SD interface, it is extremely easy to create a bluetooth low energy device.\n\n\n\n\nFeatures\n\n\n\n\nmbed enabled\n\n\nOnline IDE\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\nCMSIS DAP based on LPC11U35\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS DAP standard\n\n\nUSB virtual serial for communication\n\n\n\n\n\n\nArduino form factor with Grove connectors\n\n\nI2C and UART connecter on board\n\n\n\n\n\n\nNordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC\n\n\nARM Cortex M0 processor\n\n\n256kB flash/16kB RAM\n\n\nConfigurable I/O mapping for digital I/O\n\n\n\n\n\n\nWIZnet W5500 Ethernet\n\n\nSupports following Hardwired TCP/IP Protocols\u00a0: TCP, UDP, ICMP, IPv4, ARP, IGMP, PPPoE\n\n\nSupports Power down mode\n\n\nSupports Wake on LAN over UDP\n\n\nSupports High Speed Serial Peripheral Interface(SPI MODE 0, 3)\n\n\nInternal 32Kbytes Memory for Tx/Rx Buffers\n\n\n10BaseT/100BaseTX Ethernet PHY embedded\n\n\nwith RJ45 connector\n\n\n\n\n\n\nUSB Micro B connector\n\n\nMicro SD Card connector\n\n\n\n\nHardware Overview\n\n\n\n\nGet Started\n\n\n\n\n\n\nClick \nthis link\n to \nlogin or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download a compiled hex file.\n\n\nDrag-n-drop the downloaded hex file into the MBED disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1s\n\n\n    #include \"mbed.h\"\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\n\n\nNote\n\nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.\n\n\n\n\nApplications\n\n\n\n\n\n\nColor Pixels, a colorful LED strip, can be controlled by mobile phone.\n\n\n\n\nHardware\n\n\nArch Link\n\n\nDigital RGB LED Strip\n\n\nAndroid device with BLE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it run\n\n\n\n\nDownload \nBLE_Color_Pixels_Arch_BLE.hex\n\n\nCopy the hex file to the MBED disk of your Arch BLE\n\n\nDownload \nthe Color Pixels Android app\n\n\n\n\n\n\n\n\nIf you want to change the program, click \nthis link\n to import the Color Pixels program to mbed online IDE.\n\n\nIf the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)\n\n\n#define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**< Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**< Maximum acceptable connection interval */\n\n\n\n\n\n\n\nYou can use the Arch Link as a web dashboard.\n\n\n\n\n\n\n\n\nYou can also use the Arch Link as a Mobile APP dashboard.\n\n\n\n\n\n\n\n\nUpdate or Restore Firmware\n\n\nThe latest firmware version for the Arch Link is v0203 built at Jun 4 2015. To check your firmware version and built date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.\n\n\nChangelog:\n\n\n\n\n2015-06-4 first version\n\n\n\n\nFirmware:\n\n\nThe firmware v0203 2015-06-04 for Arch Link\nTo flash a new firmware:\n\n\n\n\nHold the Arch Link's button and power it ON\n\n\nA CRP DISABLD disk will show up\n\n\nOn Windows, replace firmware.bin with the above firmware\n\n\nOn Linux/Mac, use command: dd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nSchematic pdf\n\n\nEagle file\n\n\nLPC11U35 Firmware\n\n\nSeeed ble color pixels app for android\n\n\nSources of ble color pixels app\n\n\n\n\nSee Also\n\n\n\n\nArch BLE\n\n\nW5500 Ethernet Shield\n\n\n\n\nHelp us make it better",
            "title": "Arch Link"
        },
        {
            "location": "/Arch_Link/#arch-link",
            "text": "",
            "title": "Arch Link"
        },
        {
            "location": "/Arch_Link/#introduction",
            "text": "Arch Link is an mbed enabled development board based on Nordic nRF51822 and WIZnet W5500 ethernet interface. With Arduino form factor, Grove connectors and micro SD interface, it is extremely easy to create a bluetooth low energy device.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_Link/#features",
            "text": "mbed enabled  Online IDE  Easy to use C/C++ SDK  Handy libraries    CMSIS DAP based on LPC11U35  Drag-n-drop programming  Debug using CMSIS DAP standard  USB virtual serial for communication    Arduino form factor with Grove connectors  I2C and UART connecter on board    Nordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC  ARM Cortex M0 processor  256kB flash/16kB RAM  Configurable I/O mapping for digital I/O    WIZnet W5500 Ethernet  Supports following Hardwired TCP/IP Protocols\u00a0: TCP, UDP, ICMP, IPv4, ARP, IGMP, PPPoE  Supports Power down mode  Supports Wake on LAN over UDP  Supports High Speed Serial Peripheral Interface(SPI MODE 0, 3)  Internal 32Kbytes Memory for Tx/Rx Buffers  10BaseT/100BaseTX Ethernet PHY embedded  with RJ45 connector    USB Micro B connector  Micro SD Card connector",
            "title": "Features"
        },
        {
            "location": "/Arch_Link/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_Link/#get-started",
            "text": "Click  this link  to  login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download a compiled hex file.  Drag-n-drop the downloaded hex file into the MBED disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1s      #include \"mbed.h\"\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }   Note \nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.",
            "title": "Get Started"
        },
        {
            "location": "/Arch_Link/#applications",
            "text": "Color Pixels, a colorful LED strip, can be controlled by mobile phone.   Hardware  Arch Link  Digital RGB LED Strip  Android device with BLE         Make it run   Download  BLE_Color_Pixels_Arch_BLE.hex  Copy the hex file to the MBED disk of your Arch BLE  Download  the Color Pixels Android app     If you want to change the program, click  this link  to import the Color Pixels program to mbed online IDE.  If the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)  #define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**< Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**< Maximum acceptable connection interval */    You can use the Arch Link as a web dashboard.     You can also use the Arch Link as a Mobile APP dashboard.",
            "title": "Applications"
        },
        {
            "location": "/Arch_Link/#update-or-restore-firmware",
            "text": "The latest firmware version for the Arch Link is v0203 built at Jun 4 2015. To check your firmware version and built date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.  Changelog:   2015-06-4 first version   Firmware:  The firmware v0203 2015-06-04 for Arch Link\nTo flash a new firmware:   Hold the Arch Link's button and power it ON  A CRP DISABLD disk will show up  On Windows, replace firmware.bin with the above firmware  On Linux/Mac, use command: dd if={new_firmware.bin} of={firmware.bin} conv=notrunc",
            "title": "Update or Restore Firmware"
        },
        {
            "location": "/Arch_Link/#resources",
            "text": "Schematic pdf  Eagle file  LPC11U35 Firmware  Seeed ble color pixels app for android  Sources of ble color pixels app",
            "title": "Resources"
        },
        {
            "location": "/Arch_Link/#see-also",
            "text": "Arch BLE  W5500 Ethernet Shield",
            "title": "See Also"
        },
        {
            "location": "/Arch_Link/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_Max_v1.1/",
            "text": "Arch Max v1.1\n\n\n\n\nIntroduction\n\n\nThe Arch Max is a mbed enabled development board for rapid prototyping. It is based on an STM32F407VET6 microcontroller with an ARM Cortex-M4F core running at 168MHz. It provides \nSerial Wire Debug\n(SWD) debug, drag-and-drop programming and USB serial communication.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nName\n\n\nVersion\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nArch Max v1.0\n\n\nv1.0\n\n\n5V cannot be powered by USB, user should connect to ext-power\n\n\n\n\n\n\nArch Max v1.1\n\n\nv1.1\n\n\n5V cannot be powered by USB\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nmbed enabled\n\n\nOnline development tools(include IDE)\n\n\nComplete and straightforward C/C++ SDK\n\n\nMassive examples and tutorials\n\n\n\n\n\n\nHigh-performance STM32F407VET6\n\n\nARM Cortex-M4 MCU with FPU of 168MHz\n\n\n512 KB Flash memory, 192 KB RAM\n\n\n\n\n\n\nOn-board programming and debug\n\n\nDrag-and-drop programming\n\n\nUSB serial communication\n\n\nSWD debug with GDB+ pyOCD/OpenOCD, Keil or IAR\n\n\n\n\n\n\nArduino form factor, compatible with lots of shields\n\n\nBuilt-in Ethernet port, USB and SD card slot for Internet connectivity and data exchange\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nParameter/Item\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nWork Voltage\n\n\n5V\n\n\n\n\n\n\nMicrocontroller\n\n\nSTM32F407VET6\n\n\n\n\n\n\nFlash Memory\n\n\n512KB\n\n\n\n\n\n\nRAM\n\n\n192KB\n\n\n\n\n\n\nUART\n\n\n4\n\n\n\n\n\n\nI2C\n\n\n3\n\n\n\n\n\n\nSPI\n\n\n3\n\n\n\n\n\n\nCAN\n\n\n2\n\n\n\n\n\n\nSDIO\n\n\n1\n\n\n\n\n\n\nCamera interface\n\n\n1\n\n\n\n\n\n\nEth\n\n\n1\n\n\n\n\n\n\nADC Channels\n\n\n8\n\n\n\n\n\n\nI/O pins\n\n\n40\n\n\n\n\n\n\nDigital I/O Max Input Voltage\n\n\n5.0V\n\n\n\n\n\n\nDiameter\n\n\n90mm x 44mm\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nUsage\n\n\n\n\n\n\nClick \nhere\n to login or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download a compiled hex file.\n\n\nDrag-n-drop the downloaded bin file into the mbed disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1 second\n\n\n    #include \"mbed.h\"\n\n    DigitalOut led(LED1);          // on-board led is connected to D13\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\nDebug\n\n\nTo enable SWD debug or to get debug message through USB Virtual serial, please install \na driver from mbed\n.\n\n\nUpdate or Restore Firmware\n\n\nThe latest firmware version for the Arch Max is v0203 built at Oct 8, 2014. To check your firmware version and built date, open the mbed.HTM file of your mbed disk in a text editor.\n\n\nThe firmware v0203 2014-10-08 for Arch Max\n\n\n\n\nPress and hold the Arch Max's button to power it on.\n\n\nA CRP DISABLD disk will show\n\n\nOn Windows, replace firmware.bin with the above firmware\n\n\nOn Linux/Mac, enter command: \ndd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nSchematics Eagle file for ARCH Max\n\n\nSchematics PDF file for ARCH Max\n\n\nSTM32F407 datasheet\n\n\n\n\nHelp us make it better",
            "title": "Arch Max v1.1"
        },
        {
            "location": "/Arch_Max_v1.1/#arch-max-v11",
            "text": "",
            "title": "Arch Max v1.1"
        },
        {
            "location": "/Arch_Max_v1.1/#introduction",
            "text": "The Arch Max is a mbed enabled development board for rapid prototyping. It is based on an STM32F407VET6 microcontroller with an ARM Cortex-M4F core running at 168MHz. It provides  Serial Wire Debug (SWD) debug, drag-and-drop programming and USB serial communication.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_Max_v1.1/#version-tracker",
            "text": "Name  Version  Note      Arch Max v1.0  v1.0  5V cannot be powered by USB, user should connect to ext-power    Arch Max v1.1  v1.1  5V cannot be powered by USB",
            "title": "Version Tracker"
        },
        {
            "location": "/Arch_Max_v1.1/#features",
            "text": "mbed enabled  Online development tools(include IDE)  Complete and straightforward C/C++ SDK  Massive examples and tutorials    High-performance STM32F407VET6  ARM Cortex-M4 MCU with FPU of 168MHz  512 KB Flash memory, 192 KB RAM    On-board programming and debug  Drag-and-drop programming  USB serial communication  SWD debug with GDB+ pyOCD/OpenOCD, Keil or IAR    Arduino form factor, compatible with lots of shields  Built-in Ethernet port, USB and SD card slot for Internet connectivity and data exchange",
            "title": "Features"
        },
        {
            "location": "/Arch_Max_v1.1/#specifications",
            "text": "Parameter/Item  Value      Work Voltage  5V    Microcontroller  STM32F407VET6    Flash Memory  512KB    RAM  192KB    UART  4    I2C  3    SPI  3    CAN  2    SDIO  1    Camera interface  1    Eth  1    ADC Channels  8    I/O pins  40    Digital I/O Max Input Voltage  5.0V    Diameter  90mm x 44mm",
            "title": "Specifications"
        },
        {
            "location": "/Arch_Max_v1.1/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_Max_v1.1/#usage",
            "text": "Click  here  to login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download a compiled hex file.  Drag-n-drop the downloaded bin file into the mbed disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1 second      #include \"mbed.h\"\n\n    DigitalOut led(LED1);          // on-board led is connected to D13\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }",
            "title": "Usage"
        },
        {
            "location": "/Arch_Max_v1.1/#debug",
            "text": "To enable SWD debug or to get debug message through USB Virtual serial, please install  a driver from mbed .",
            "title": "Debug"
        },
        {
            "location": "/Arch_Max_v1.1/#update-or-restore-firmware",
            "text": "The latest firmware version for the Arch Max is v0203 built at Oct 8, 2014. To check your firmware version and built date, open the mbed.HTM file of your mbed disk in a text editor.  The firmware v0203 2014-10-08 for Arch Max   Press and hold the Arch Max's button to power it on.  A CRP DISABLD disk will show  On Windows, replace firmware.bin with the above firmware  On Linux/Mac, enter command:  dd if={new_firmware.bin} of={firmware.bin} conv=notrunc",
            "title": "Update or Restore Firmware"
        },
        {
            "location": "/Arch_Max_v1.1/#resources",
            "text": "Schematics Eagle file for ARCH Max  Schematics PDF file for ARCH Max  STM32F407 datasheet",
            "title": "Resources"
        },
        {
            "location": "/Arch_Max_v1.1/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_Pro/",
            "text": "Arch Pro\n\n\n\n\nIntroduction\n\n\nArch Pro is an mbed enabled development board for rapid prototyping. It is a variant of mbed LPC1768 with built-in Ethernet, USB Host/Device, Grove connectors and Arduino form factor. With a variety of Shield and Grove modules and lots of software libraries for Arch Pro, you can implement Ethernet, USB Host/Device and NFC applications rapidly and easily.\n\n\n\n\nFeatures\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nOnline development tools\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\n\n\nArduino form factor with two Grove connectors\n\n\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS-DAP\n\n\nUSB virtual serial for communication\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nParameter\n\n\nValue/Availability\n\n\n\n\n\n\n\n\n\n\nMCU\n\n\nNXP LPC1768 variant (with ARM Cortex-M3 core)\n\n\n\n\n\n\nClock Speed\n\n\n100 MHz\n\n\n\n\n\n\nFlash\n\n\n512 KB\n\n\n\n\n\n\nRAM\n\n\n64KB\n\n\n\n\n\n\nUART\n\n\n4 No.s\n\n\n\n\n\n\nI2C\n\n\n3 No.s\n\n\n\n\n\n\nSPI\n\n\n2 No.s\n\n\n\n\n\n\nEthernet\n\n\nYes\n\n\n\n\n\n\nUSB Host/Device\n\n\nYes\n\n\n\n\n\n\n\n\nPlatforms Supported\n\n\n\n\nmbed.\n\n\n\n\nApplication Ideas\n\n\n\n\nEthernet\n\n\nUSB Host\n or \nDevice\n\n\nNFC\n\n\nRTOS\n\n\nLua\n\n\n\n\nHardware Overview\n\n\n\n\nThere is \na monochrome version\n for you to print.\n\n\n\n\nNote\n\nThe Arch Pro silkscreen for the Grove connectors is labeled 3V3 on top of the PCB and 5V on the underside. Grove Vcc is by default 3V3, but can be changed to 5V by moving R50 to R51. SPI Vcc pin can be set by populating R52 (3V3) or R53 (5V) with 0R - neither populated by default.\n\n\n\n\nGetting Started\n\n\nAs the Arch Pro is compatible with mbed LPC1768, one can use the mbed C/C++ SDK, libraries and online development tools to rapidly build a prototype.\nHere we show how to light up an LED. This can be done in less than 10 minutes.\n\n\nStep one\uff1a Sign up for an mbed account.\n\n\n\n\nOpen \nmbed.org\n, click Login or signup. If you have already registered, please click login directly.\n\n\n\n\nStep two\uff1a Enter online development tools.\n\n\n\n\nClick Compiler\uff0c it opens the online mbed IDE. Before programming, it is better to read the mbed Complier \nGetting started\n.\n\n\n\n\n\n\nStep three\uff1aEdit code.\n\n\n\n\nClick \"New\" in the left top corner to create a Program and edit a blink program in main.cpp file.\n\n\n\n\n#include \"mbed.h\"\n\u00a0\nDigitalOut  led1(LED1);\n\u00a0\nint main() {\n    while(1) {\n        led1 = !led1; \n        wait(0.5); \n    }\n}\n\n\n\n\nStep four\uff1a Add a device.\n\n\n\n\nClick \u201dNo device selected\u201d in the top right corner, then click \u201dAdd a device\u201d button in the bottom left as seen in the picture below.\n\n\n\n\n\n\nNote\n\nIf you have already used an mbed device, it will be seen in the top right corner instead of \u201dNo device selected\u201d.\n\n\n\n\n\n\n\n\nA pop-up page appears with a list of devices as shown below. Select \u201dmbed LPC1768\u201d.\n\n\n\n\n\n\n\n\nEnter mbed LPC1768 page and click \u201dAdd to mbed Compiler\u201d. Now you have successfully added Mbed LPU1768. Return to mbed compiler page and click \u201dNo device selected\u201d. After you click \"LPC1768\" in the bottom left corner, a screen appears as shown below.\n\n\n\n\n\n\n\n\nYou can see the selected board in mbed online compiler after clicking \u201dSelect Platform\u201d.\n\n\n\n\nStep five\uff1a Compile, download.\n\n\n\n\nClick \"Compile\". On successful compilation, the mbed IDE generates a bin file. Save the bin file on your PC.\n\n\n\n\nStep six\uff1a Update firmware.\n\n\n\n\nConnect the USB interface (next to 'BUTTON') of Arch Pro to your PC using a USB Micro B cable; It automatically appears as a USB device named MBED.\n\n\nCopy the generated bin file to MBED device (on your PC). Now the USB device disappears and reappears.\n\n\nPress BUTTON of Arch Pro, you will see an LED flashing.\n\n\n\n\nDebug\n\n\nTo enable SWD debug or to get debug message through USB Virtual serial, please install \nthe driver from mbed\n.\n\n\nUpdate or Restore Firmware\n\n\nThe latest firmware version for the Arch Pro is v0221 built on Jan 28 2015. To check your firmware version and build date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.\n\n\n\n\n[\nFirmware v221 2015-01-28 for Arch Pro\n] Fix Mac OS X 10.10 Yosemite read only file system bug\n\n\n[\nFirmware v0203 2014-09-02 for Arch Pro\n]\n\n\n\n\nTo update:\n\n\n\n\nA Windows or Linux computer is needed.\n\n\nDownload the latest firmware.\n\n\nPress and hold the Arch Pro's BUTTON and power it ON.\n\n\nA disk named MBED LOADER will appear.\n\n\nDrag-n-drop the downloaded firmware into the disk.\n\n\n\n\n\n\nNotes\n\n\n 1. LocalFileSystem does not work:\nAs the Arch Pro does not have external flash to store files, the LocalFileSystem is not available for this board.\n\n\n\n 2. P0\\_27 & P0\\_28 do not work with DigitalOut:\nP0\\_28 & P0\\_27 are open-drain digital I/O for compatible with I2C. External pull-up resistors are needed to provide output functionality.\n\n\n\n 3. USB Serial Communication:\nIn Windows, install the mbed Windows serial port driver to use USB Serial Communication. Have a look at [Windows Serial Configuration](https://developer.mbed.org/handbook/Windows-serial-configuration)\n\n\n\n\n\nResources\n\n\n\n\nArch Pro V1.0 Schematic PDF\n\n\nArch Pro V1.0 Eagle Files\n\n\nLPC1768 datasheet\n\n\nLPC17xx User Manual\n\n\n\n\nHelp us make it better",
            "title": "Arch Pro"
        },
        {
            "location": "/Arch_Pro/#arch-pro",
            "text": "",
            "title": "Arch Pro"
        },
        {
            "location": "/Arch_Pro/#introduction",
            "text": "Arch Pro is an mbed enabled development board for rapid prototyping. It is a variant of mbed LPC1768 with built-in Ethernet, USB Host/Device, Grove connectors and Arduino form factor. With a variety of Shield and Grove modules and lots of software libraries for Arch Pro, you can implement Ethernet, USB Host/Device and NFC applications rapidly and easily.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_Pro/#features",
            "text": "mbed enabled   Online development tools  Easy to use C/C++ SDK  Handy libraries     Arduino form factor with two Grove connectors   Drag-n-drop programming  Debug using CMSIS-DAP  USB virtual serial for communication",
            "title": "Features"
        },
        {
            "location": "/Arch_Pro/#specifications",
            "text": "Parameter  Value/Availability      MCU  NXP LPC1768 variant (with ARM Cortex-M3 core)    Clock Speed  100 MHz    Flash  512 KB    RAM  64KB    UART  4 No.s    I2C  3 No.s    SPI  2 No.s    Ethernet  Yes    USB Host/Device  Yes",
            "title": "Specifications"
        },
        {
            "location": "/Arch_Pro/#platforms-supported",
            "text": "mbed.",
            "title": "Platforms Supported"
        },
        {
            "location": "/Arch_Pro/#application-ideas",
            "text": "Ethernet  USB Host  or  Device  NFC  RTOS  Lua",
            "title": "Application Ideas"
        },
        {
            "location": "/Arch_Pro/#hardware-overview",
            "text": "There is  a monochrome version  for you to print.   Note \nThe Arch Pro silkscreen for the Grove connectors is labeled 3V3 on top of the PCB and 5V on the underside. Grove Vcc is by default 3V3, but can be changed to 5V by moving R50 to R51. SPI Vcc pin can be set by populating R52 (3V3) or R53 (5V) with 0R - neither populated by default.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_Pro/#getting-started",
            "text": "As the Arch Pro is compatible with mbed LPC1768, one can use the mbed C/C++ SDK, libraries and online development tools to rapidly build a prototype.\nHere we show how to light up an LED. This can be done in less than 10 minutes.  Step one\uff1a Sign up for an mbed account.   Open  mbed.org , click Login or signup. If you have already registered, please click login directly.   Step two\uff1a Enter online development tools.   Click Compiler\uff0c it opens the online mbed IDE. Before programming, it is better to read the mbed Complier  Getting started .    Step three\uff1aEdit code.   Click \"New\" in the left top corner to create a Program and edit a blink program in main.cpp file.   #include \"mbed.h\"\n\u00a0\nDigitalOut  led1(LED1);\n\u00a0\nint main() {\n    while(1) {\n        led1 = !led1; \n        wait(0.5); \n    }\n}  Step four\uff1a Add a device.   Click \u201dNo device selected\u201d in the top right corner, then click \u201dAdd a device\u201d button in the bottom left as seen in the picture below.    Note \nIf you have already used an mbed device, it will be seen in the top right corner instead of \u201dNo device selected\u201d.    A pop-up page appears with a list of devices as shown below. Select \u201dmbed LPC1768\u201d.     Enter mbed LPC1768 page and click \u201dAdd to mbed Compiler\u201d. Now you have successfully added Mbed LPU1768. Return to mbed compiler page and click \u201dNo device selected\u201d. After you click \"LPC1768\" in the bottom left corner, a screen appears as shown below.     You can see the selected board in mbed online compiler after clicking \u201dSelect Platform\u201d.   Step five\uff1a Compile, download.   Click \"Compile\". On successful compilation, the mbed IDE generates a bin file. Save the bin file on your PC.   Step six\uff1a Update firmware.   Connect the USB interface (next to 'BUTTON') of Arch Pro to your PC using a USB Micro B cable; It automatically appears as a USB device named MBED.  Copy the generated bin file to MBED device (on your PC). Now the USB device disappears and reappears.  Press BUTTON of Arch Pro, you will see an LED flashing.",
            "title": "Getting Started"
        },
        {
            "location": "/Arch_Pro/#debug",
            "text": "To enable SWD debug or to get debug message through USB Virtual serial, please install  the driver from mbed .",
            "title": "Debug"
        },
        {
            "location": "/Arch_Pro/#update-or-restore-firmware",
            "text": "The latest firmware version for the Arch Pro is v0221 built on Jan 28 2015. To check your firmware version and build date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.   [ Firmware v221 2015-01-28 for Arch Pro ] Fix Mac OS X 10.10 Yosemite read only file system bug  [ Firmware v0203 2014-09-02 for Arch Pro ]   To update:   A Windows or Linux computer is needed.  Download the latest firmware.  Press and hold the Arch Pro's BUTTON and power it ON.  A disk named MBED LOADER will appear.  Drag-n-drop the downloaded firmware into the disk.    Notes   1. LocalFileSystem does not work:\nAs the Arch Pro does not have external flash to store files, the LocalFileSystem is not available for this board.   2. P0\\_27 & P0\\_28 do not work with DigitalOut:\nP0\\_28 & P0\\_27 are open-drain digital I/O for compatible with I2C. External pull-up resistors are needed to provide output functionality.   3. USB Serial Communication:\nIn Windows, install the mbed Windows serial port driver to use USB Serial Communication. Have a look at [Windows Serial Configuration](https://developer.mbed.org/handbook/Windows-serial-configuration)",
            "title": "Update or Restore Firmware"
        },
        {
            "location": "/Arch_Pro/#resources",
            "text": "Arch Pro V1.0 Schematic PDF  Arch Pro V1.0 Eagle Files  LPC1768 datasheet  LPC17xx User Manual",
            "title": "Resources"
        },
        {
            "location": "/Arch_Pro/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_V1.1/",
            "text": "Arch V1.1\n\n\n\n\nIntroduction\n\n\nArch V1.1 is an mbed enabled development board with Arduino form factor and Grove connectors for rapid prototyping. With a variety of Shield and Grove modules, mbed SDK and lots of software libraries, you can rapidly build a prototype.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRevision\n\n\nDescription\n\n\nRelease Date\n\n\n\n\n\n\n\n\n\n\nSeeeduino Arch V1.0\n\n\n\n\nInitial public release\n\n\n\n\n2013-6-17\n\n\n\n\n\n\nArch V1.1\n\n\n\n\nChange name from Seeeduino Arch to Arch\n\n\nSwitch D13 and D11\n\n\nAdd one Grove connector\n\n\nRemove dual diode\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nonline development tools\n\n\neasy to use C/C++ SDK\n\n\nlots of published libraries, projects\n\n\n\n\n\n\n\n\nArduino form factor, three Grove connectors\n\n\n\n\navailable with 3.3V compatible shields\n\n\na large number of grove modules\n\n\n\n\n\n\nDrag-n-drop programming\n\n\nNXP LPC11U24 MCU\n\n\nLow power ARM Cortex-M0 Core\n\n\n48MHz, 32KB Flash, 8KB RAM, 4KB EEPROM\n\n\nUSB Device, 2xSPI, UART, I2C\n\n\n\n\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\n\n\n\n\n\n\n\n\nWork Voltage\n\n\n7 ~ 12V\n\n\n\n\n\n\nMicrocontroller\n\n\nLPC11U24\n\n\n\n\n\n\nFlash Memory\n\n\n32KB\n\n\n\n\n\n\nEEPROM\n\n\n4KB\n\n\n\n\n\n\nRAM\n\n\n8KB\n\n\n\n\n\n\nUART\n\n\n1\n\n\n\n\n\n\nI2C\n\n\n1\n\n\n\n\n\n\nADC Channels\n\n\n8\n\n\n\n\n\n\nI/O pins\n\n\n40\n\n\n\n\n\n\nDigital I/O Max input voltage\n\n\n5.0V\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nThere is \na monochrome version\n for you to print.\n\n\nGet Started\n\n\n\n\n\n\nClick \nthis link\n to login or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nCoding! Then you can compile the code and download the output binary.\n\n\nNow connect your Arch board to your pc and long press the reset button, it will automatically appear as a USB driver named CRP DISABLD. Go to the CRP DISABLD, delete the firmware file and copy the download binary file to CRP DISABLD. Quick press the reset button to run the new binary.\n\n\n\n\nYou can change the code as following and try again.\n\n\n    #include \"mbed.h\"\n\n    BusOut leds(LED1, LED2, LED3, LED4);\n\n    int main() {\n        uint8_t count = 0;\n        while(1) {\n            leds = count++;\n            wait(1);\n        }\n    }\n\n\n\n\nProgramming Arch on Windows, Linux or Mac\n\n\nArch does not have an mbed interface. It uses USB In-System-Programming(ISP) to upgrade the firmware.\n\n\nTo enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \"CRP DISABLD\" will appear.\n\n\n\n\n\n\nOn Windows\n\n\n\n\ndelete firmware.bin in the \"CRP DISABLD\" disk.\n\n\ncopy a new firmware into the disk.\n\n\n\n\n\n\n\n\nOn Linux\n\n\n\n\nif the disk is not mounted, mount the disk at \n{mnt_dir}\n\n\ndd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nOn Mac you will need to use Terminal to run the following script to copy you're .bin file to your Arch\n\n\n\n\ndd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nIf you are so inclined, you can also create an \nAutomator\n application to support drag-and-drop of the file to your board. Just create a \"\nRun Shell Script\n\" with the following command:\n\n\ndd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nYou will also need to change the \n\"Pass Input\"\n option from \n\"to stdin\"\n to \n\"as arguments\"\n--without this you will get an error \n\"The action 'Run Shell Script' encountered an error\"\n or \n\"dd: no value specified for if (1)\"\n in the log.\n\n\nAlso, an improved form of the script is:\n\n\ndd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nWhich should handle spaces in the file path and only uses the first file supplied.\n\n\nQuick press the button to run the new firmware.\n\n\nApplications\n\n\n\n\nUse Seeeduino Arch as a debug adapter to debug another Seeeduino Arch\n\n\nSense environment\n\n\nPlay with Grove RTC\n\n\nPlay with Grove - Ultrasonic ranger\n\n\n\n\nResources\n\n\n\n\nSchematics of Arch V1.1\n\n\n\n\nHelp us make it better",
            "title": "Arch V1.1"
        },
        {
            "location": "/Arch_V1.1/#arch-v11",
            "text": "",
            "title": "Arch V1.1"
        },
        {
            "location": "/Arch_V1.1/#introduction",
            "text": "Arch V1.1 is an mbed enabled development board with Arduino form factor and Grove connectors for rapid prototyping. With a variety of Shield and Grove modules, mbed SDK and lots of software libraries, you can rapidly build a prototype.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_V1.1/#version-tracker",
            "text": "Revision  Description  Release Date      Seeeduino Arch V1.0   Initial public release   2013-6-17    Arch V1.1   Change name from Seeeduino Arch to Arch  Switch D13 and D11  Add one Grove connector  Remove dual diode",
            "title": "Version Tracker"
        },
        {
            "location": "/Arch_V1.1/#features",
            "text": "mbed enabled   online development tools  easy to use C/C++ SDK  lots of published libraries, projects     Arduino form factor, three Grove connectors   available with 3.3V compatible shields  a large number of grove modules    Drag-n-drop programming  NXP LPC11U24 MCU  Low power ARM Cortex-M0 Core  48MHz, 32KB Flash, 8KB RAM, 4KB EEPROM  USB Device, 2xSPI, UART, I2C",
            "title": "Features"
        },
        {
            "location": "/Arch_V1.1/#specifications",
            "text": "Item  Typical      Work Voltage  7 ~ 12V    Microcontroller  LPC11U24    Flash Memory  32KB    EEPROM  4KB    RAM  8KB    UART  1    I2C  1    ADC Channels  8    I/O pins  40    Digital I/O Max input voltage  5.0V",
            "title": "Specifications"
        },
        {
            "location": "/Arch_V1.1/#hardware-overview",
            "text": "There is  a monochrome version  for you to print.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_V1.1/#get-started",
            "text": "Click  this link  to login or signup to mbed  Import the mbed_blinky program  Coding! Then you can compile the code and download the output binary.  Now connect your Arch board to your pc and long press the reset button, it will automatically appear as a USB driver named CRP DISABLD. Go to the CRP DISABLD, delete the firmware file and copy the download binary file to CRP DISABLD. Quick press the reset button to run the new binary.   You can change the code as following and try again.      #include \"mbed.h\"\n\n    BusOut leds(LED1, LED2, LED3, LED4);\n\n    int main() {\n        uint8_t count = 0;\n        while(1) {\n            leds = count++;\n            wait(1);\n        }\n    }",
            "title": "Get Started"
        },
        {
            "location": "/Arch_V1.1/#programming-arch-on-windows-linux-or-mac",
            "text": "Arch does not have an mbed interface. It uses USB In-System-Programming(ISP) to upgrade the firmware.  To enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \"CRP DISABLD\" will appear.    On Windows   delete firmware.bin in the \"CRP DISABLD\" disk.  copy a new firmware into the disk.     On Linux   if the disk is not mounted, mount the disk at  {mnt_dir}  dd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc     On Mac you will need to use Terminal to run the following script to copy you're .bin file to your Arch   dd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc     If you are so inclined, you can also create an  Automator  application to support drag-and-drop of the file to your board. Just create a \" Run Shell Script \" with the following command:  dd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  You will also need to change the  \"Pass Input\"  option from  \"to stdin\"  to  \"as arguments\" --without this you will get an error  \"The action 'Run Shell Script' encountered an error\"  or  \"dd: no value specified for if (1)\"  in the log.  Also, an improved form of the script is:  dd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  Which should handle spaces in the file path and only uses the first file supplied.  Quick press the button to run the new firmware.",
            "title": "Programming Arch on Windows, Linux or Mac"
        },
        {
            "location": "/Arch_V1.1/#applications",
            "text": "Use Seeeduino Arch as a debug adapter to debug another Seeeduino Arch  Sense environment  Play with Grove RTC  Play with Grove - Ultrasonic ranger",
            "title": "Applications"
        },
        {
            "location": "/Arch_V1.1/#resources",
            "text": "Schematics of Arch V1.1",
            "title": "Resources"
        },
        {
            "location": "/Arch_V1.1/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/",
            "text": "Arduino IDE for RePhone Kit\n\n\n\n\nIntroduction\n\n\nRePhone can be a learning tool for you to start interesting projects. Currently, RePhone supports various development environments and development languages, you can build applications either with C/C++ based on Eclipse IDE, Arduino IDE, or with Lua and JavaScript.\n\n\nThis wiki is a User Guide to help you start your RePhone project with Arduino IDE.\n\n\nDownload Arduino IDE for RePhone\n\n\nBefore you download the Arduino IDE for RePhone, make sure you have an operation system as follows:\n\n\nWindows XP/Vista/7/8/8.1\n\n\nWe have put the Arduino IDE for RePhone on our GitHub, and you are quite welcome to send us a 'pull request' to help us optimize and improve it.\n\n\nIf you ever used the Arduino IDE before, then this should be just a piece of cake. If you are not familiar with Arduino, which is fine as well, just follow the instructions, and you will be getting started with Arduino IDE easily and quickly.\n\n\nNow click on\n\n\n\n\nOn the Github page, click the \nDownload ZIP\n to download the file as shown in the image below:\n\n\n\n\nWhen the download is complete, unzip the file to a proper location.\n\n\nInstall the Driver\n\n\nDisable Driver Signature Enforcement under Windows 8 / 8.1\n\n\nIf you are using the Windows8/8.1, you would need to disable \nDriver Signature Enforcement\n first to be able to install the driver.\n\n\nYou should save the files you are editing before trying to turn off the 'Driver Signature Enforcement' as your system will be shut down during the operation.\n\n\nNow follow the instructions below to disable the 'Driver Signature Enforcement.'\n\n\n\n\nPress \u201cWindows Key\u201d +\"R\"\n\n\nEnter shutdown.exe /r /o /f /t 00\n\n\nClick the \"OK\" button.\n\n\nSystem will restart to a \"Choose an option\" screen\n\n\nSelect \"Troubleshoot\" from \"Choose an option\" screen\n\n\nSelect \"Advanced options\" from \"Troubleshoot\" screen\n\n\nSelect \"Windows Startup Settings\" from \"Advanced options\" screen\n\n\nClick \"Restart\" button\n\n\nSystem will restart to \"Advanced Boot Options\" screen\n\n\nSelect \"Disable Driver Signature Enforcement\"\n\n\nOnce the system starts, you can install the Arduino drivers as same as Windows\n\n\n\n\nNormal Driver Installation\n\n\n\n\n\n\nFirst, power up your RePhone by \nplugging in the battery\n or \npower it with external power sources (3.3 ~ 4.2V(no SIM)/3.5 ~ 4.2V(with SIM)) \nto the battery socket on the Xadow GSM+BLE, \npress and hold the power key (PWR) for 2 seconds to\n \nturn it ON\n (LED indicator shows \nGREEN\n), then connect your RePhone to PC with a Micro USB cable.\n\n\n\n\n\n\n\n\nOpen \nDevice Manager\n by clicking the \nStart\n button, clicking \nControl Panel\n, clicking \nSystem and Security\n, and then, under \nSystem\n, clicking \nDevice Manager\n. If you're prompted for an administrator password or confirmation, type the password or provide confirmation.\nIn the \nDevice Manager\n, you will be seeing unknown devices as shown below:\n\n\n\n\n\n\n\n\nRight click on one of the unknown devices, choose \nUpdate Driver Software\n.\n\n\n\n\n\n\n\n\nChoose \nBrowse my computer for driver software\n.\n\n\n\n\n\n\n\n\nClick \nBrowse\n and the locate the folder which you've unzipped the Arduino IDE for RePhone .. \\Arduino_IDE_for_RePhone\\drivers\\mtk . Click \nNext\n to start the driver installation.\n\n\n\n\n\n\n\n\nWhen the driver software is successfully installed, you will be able to see the following \ncomplete\n page, click \nClose\n and \nstart over from step 1 to 6 to install the driver for another unknown device\n.\n\n\n\n\n\n\n\n\nInstall the Driver Manually\n\n\nYou can also install the driver manually:\n\n\n\n\n\n\nIn \"\nBrowse for driver software on your computer\n\" window, click \n\"Let me pick from a list of device drivers on my computer\n\"\n\n\n\n\n\n\nThen click \"\nPorts(COM&LPT)\n\" and go \"\nnext\n\"\n\n\n\n\n\n\nClick \"\nHave Disk\n\"\n\n\n\n\n\n\nAfterwards,\n\n\n\n\n\n\n-- if you are using \nWindows Vista 64bit\n, locate \"\nArduino_IDE_for_RePhone-master\\drivers\\mtk\\Vista\\usb2ser_Vista64.inf\\\n\"\n\n\n-- if you are using \nWindows 7 or higher with 64bit\n, locate \"\nArduino_IDE_for_RePhone-master\\drivers\\mtk\\Win7\\usb2ser_Win764.inf\n\"\n\n\nInstall the Driver with LinkIt Assist 2502 SDK 2.0.46\n\n\nLinkIt Assist 2502 SDK 2.0.46 also provides a driver installation program.\n\n\n\n\nThen find the driver installer in the path \n\"MediaTek_LinkIt_Assist_2502_SDK_2_0_46\\LINKIT_ASSIST_SDK\\Driver\\InstallMTKUSBCOMPortDriver.exe\"\n\n\nUpdate/Flash the Firmware\n\n\n\n\nNote\n\nPlease note that flashing the firmware will delete all the settings and files(images, musics) stored in the RePhone. Take a data backup before you flash/update the firmware.\n\n\n\n\nTo make use of the Arduino IDE for RePhone, you have to update/flash the firmware as well. The process is as simple as follows:\n\n\n\n\n\n\nDisconnect your RePhone with PC\n, \npress and hold the power key(PWR) for 2 seconds to turn it OFF\n (LED indicator turn \nRED\n and then goes out)\n\n\n\n\n\n\nOpen the \nFirmwareUpdater.exe\n under the path \n...Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\FirmwareUpdater.exe\n, be sure your platform on the Firmware Updater is \"\nRePhone\n\" as showing below, if not, click \"\nOthers\n\" and locate to \n...Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\firmware\\LinkIt_Device\\RePhone\\W15.19.p2-uart\\SEEED02A_DEMO_BB.cfg\n, then click \nDownload (The Green Button)\n.\n\n\n\n\n\n\n\n\nNow you will be asked to connect your RePhone to PC via USB cable, make sure your RePhone has been turned \nOFF\n and meantime a functional battery should be always connected ( Powered Up).\n\n\n\n\n\n\n\n\nWait until the downloading finishes. This might take about 1min, so it may remain stuck at 50% for quite a while, please \nbe patient\n.\n\n\n\n\n\n\n\n\nIn the \nComplete\n page click \nOK\n to finish the firmware update.\n\n\n\n\n\n\n\n\nReset to default\n\n\n\n\nNote\n\nPlease note that resetting your Rephone to default will delete all the settings and files(images, musics) in the RePhone. Take a data backup before you reset it to default.**\n\n\n\n\nTo reset your RePhone to \nDEFAULT\n:\n\n\n\n\n\n\nFollow the instructions in \"Update/Flash the Firmware\" section to flash the firmware\n\n\n\n\n\n\nDownload the RePhone_Create_Kit_VXP file\n\n\n\n\n\n\n\n\nEnter the \nRePhone Mass Storage Mode\n\n\n\n\n\n\nCopy everything under the file named \"RePhone Create Kit VXP\" into the RePhone 5MB mass storage.\n\n\n\n\n\n\nRestart your RePhone then its done. As reset would have deleted all the files, you would have to put an mp3 file in the mass storage as well for the use of ringtone.\n\n\n\n\n\n\nA demo: Hello World\n\n\nNow you have prepared things required, we are ready to rock on with RePhone.\n\n\nLet us start with a simple program \nHello World\n\n\n\n\n\n\nPress and hold the power key (PWR) for 2 seconds to turn it ON (LED indicator shows GREEN)\n\n\n\n\n\n\nOpen the \nArduino_IDE_for_RePhone.exe\n in the folder where you unzipped the Arduino IDE for RePhone, the software interface is as follows:\n\n\n\n\n\n\n\n\nOpen \nDevice Manager\n to check for the COM ports. There will be \ntwo COM ports\n:\n\n\n\n\nMTK USB Debug Port is used for uploading code\n\n\nMTK USB Modem Port is used for logs, like printing messages in the serial monitor with \nSerial.println()\n\n\n\n\n\n\n\n\n\n\nOn the Arduino IDE window, click \nTool => Port\n, select \nMTK USB Debug Port\n, which is \nCOM20\n in this case, the COM number might be different in your PC, just make sure it corresponds to the Debug Port.\n\n\n\n\n\n\n\n\nOn the Arduino IDE window, click \nTool => Board\n, select \nRePhone\n\n\n\n\n\n\n\n\nNow copy the following code to your Arduino IDE:\n\n\n// hello world for test RePhone\n// loovee@10-18-2015\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\u00a0\nvoid loop() {\n    // put your main code here, to run repeatedly:\n    Serial.println(\"Hello World, Hello RePhone!\");\n    delay(100);\n}\n\n\n\n\n\n\n\nNow press the \nUpload\n button to upload the code to your RePhone. You will see the \nDone uploading\n when the code is successfully uploaded.\n\n\n\n\n\n\n\n\nAs RePhone uses different COM ports for uploading software and logs, to read the logs, we need to switch the selected COM Port to \nMTK USB Modem Port\n. On the Arduino IDE window, click \nTool => Port\n, select \nMTK USB Modem Port\n, which is \nCOM48\n in this case.\n\n\nThen open the \nSerial Monitor\n.\n\n\n\n\n\n\n\n\nNow we can see the \nHello World\n we have printed with \nSerial.println()\n .\n\n\n\n\n\n\n\n\nMore Example Code\n\n\nPlaying with some example code would be a good start if you are heading into some even more interesting projects.\n\n\n\n\n\n\nSimply setup your \nsketchbook location\n in the \npreference\n as \nArduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\n (where you install the Arduino IDE for RePhone)\n\n\n\n\nthen restart the \nArduino_IDE_for_RePhone.exe\n, you will be able to see the example codes.\n\n\n\n\n\n\n\nYou can also find the Arduino example coded manually for all the RePhone modules in the following path:\n\nArduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\\libraries\n\n\n\n\n\n\n\n\nRePhone Community\n\n\n\n\nWe have been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the RePhone Community.\n\n\nNow join us in the \nRePhone Community\n!\n\n\nTogether we seek answers, make interesting stuff, care about each other, and share our experiences.\n\n\nMore\n\n\nYou have done a great job so far! RePhone comes with a big family of modules with different features and functionalities. Go to check the wiki for modules for more applications!\n\n\nHelp us make it better",
            "title": "Arduino IDE for RePhone Kit"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#arduino-ide-for-rephone-kit",
            "text": "",
            "title": "Arduino IDE for RePhone Kit"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#introduction",
            "text": "RePhone can be a learning tool for you to start interesting projects. Currently, RePhone supports various development environments and development languages, you can build applications either with C/C++ based on Eclipse IDE, Arduino IDE, or with Lua and JavaScript.  This wiki is a User Guide to help you start your RePhone project with Arduino IDE.",
            "title": "Introduction"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#download-arduino-ide-for-rephone",
            "text": "Before you download the Arduino IDE for RePhone, make sure you have an operation system as follows:  Windows XP/Vista/7/8/8.1  We have put the Arduino IDE for RePhone on our GitHub, and you are quite welcome to send us a 'pull request' to help us optimize and improve it.  If you ever used the Arduino IDE before, then this should be just a piece of cake. If you are not familiar with Arduino, which is fine as well, just follow the instructions, and you will be getting started with Arduino IDE easily and quickly.  Now click on   On the Github page, click the  Download ZIP  to download the file as shown in the image below:   When the download is complete, unzip the file to a proper location.",
            "title": "Download Arduino IDE for RePhone"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver",
            "text": "",
            "title": "Install the Driver"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#disable-driver-signature-enforcement-under-windows-8-81",
            "text": "If you are using the Windows8/8.1, you would need to disable  Driver Signature Enforcement  first to be able to install the driver.  You should save the files you are editing before trying to turn off the 'Driver Signature Enforcement' as your system will be shut down during the operation.  Now follow the instructions below to disable the 'Driver Signature Enforcement.'   Press \u201cWindows Key\u201d +\"R\"  Enter shutdown.exe /r /o /f /t 00  Click the \"OK\" button.  System will restart to a \"Choose an option\" screen  Select \"Troubleshoot\" from \"Choose an option\" screen  Select \"Advanced options\" from \"Troubleshoot\" screen  Select \"Windows Startup Settings\" from \"Advanced options\" screen  Click \"Restart\" button  System will restart to \"Advanced Boot Options\" screen  Select \"Disable Driver Signature Enforcement\"  Once the system starts, you can install the Arduino drivers as same as Windows",
            "title": "Disable Driver Signature Enforcement under Windows 8 / 8.1"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#normal-driver-installation",
            "text": "First, power up your RePhone by  plugging in the battery  or  power it with external power sources (3.3 ~ 4.2V(no SIM)/3.5 ~ 4.2V(with SIM))  to the battery socket on the Xadow GSM+BLE,  press and hold the power key (PWR) for 2 seconds to   turn it ON  (LED indicator shows  GREEN ), then connect your RePhone to PC with a Micro USB cable.     Open  Device Manager  by clicking the  Start  button, clicking  Control Panel , clicking  System and Security , and then, under  System , clicking  Device Manager . If you're prompted for an administrator password or confirmation, type the password or provide confirmation.\nIn the  Device Manager , you will be seeing unknown devices as shown below:     Right click on one of the unknown devices, choose  Update Driver Software .     Choose  Browse my computer for driver software .     Click  Browse  and the locate the folder which you've unzipped the Arduino IDE for RePhone .. \\Arduino_IDE_for_RePhone\\drivers\\mtk . Click  Next  to start the driver installation.     When the driver software is successfully installed, you will be able to see the following  complete  page, click  Close  and  start over from step 1 to 6 to install the driver for another unknown device .",
            "title": "Normal Driver Installation"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver-manually",
            "text": "You can also install the driver manually:    In \" Browse for driver software on your computer \" window, click  \"Let me pick from a list of device drivers on my computer \"    Then click \" Ports(COM&LPT) \" and go \" next \"    Click \" Have Disk \"    Afterwards,    -- if you are using  Windows Vista 64bit , locate \" Arduino_IDE_for_RePhone-master\\drivers\\mtk\\Vista\\usb2ser_Vista64.inf\\ \"  -- if you are using  Windows 7 or higher with 64bit , locate \" Arduino_IDE_for_RePhone-master\\drivers\\mtk\\Win7\\usb2ser_Win764.inf \"",
            "title": "Install the Driver Manually"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver-with-linkit-assist-2502-sdk-2046",
            "text": "LinkIt Assist 2502 SDK 2.0.46 also provides a driver installation program.   Then find the driver installer in the path  \"MediaTek_LinkIt_Assist_2502_SDK_2_0_46\\LINKIT_ASSIST_SDK\\Driver\\InstallMTKUSBCOMPortDriver.exe\"",
            "title": "Install the Driver with LinkIt Assist 2502 SDK 2.0.46"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#updateflash-the-firmware",
            "text": "Note \nPlease note that flashing the firmware will delete all the settings and files(images, musics) stored in the RePhone. Take a data backup before you flash/update the firmware.  To make use of the Arduino IDE for RePhone, you have to update/flash the firmware as well. The process is as simple as follows:    Disconnect your RePhone with PC ,  press and hold the power key(PWR) for 2 seconds to turn it OFF  (LED indicator turn  RED  and then goes out)    Open the  FirmwareUpdater.exe  under the path  ...Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\FirmwareUpdater.exe , be sure your platform on the Firmware Updater is \" RePhone \" as showing below, if not, click \" Others \" and locate to  ...Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\firmware\\LinkIt_Device\\RePhone\\W15.19.p2-uart\\SEEED02A_DEMO_BB.cfg , then click  Download (The Green Button) .     Now you will be asked to connect your RePhone to PC via USB cable, make sure your RePhone has been turned  OFF  and meantime a functional battery should be always connected ( Powered Up).     Wait until the downloading finishes. This might take about 1min, so it may remain stuck at 50% for quite a while, please  be patient .     In the  Complete  page click  OK  to finish the firmware update.",
            "title": "Update/Flash the Firmware"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#reset-to-default",
            "text": "Note \nPlease note that resetting your Rephone to default will delete all the settings and files(images, musics) in the RePhone. Take a data backup before you reset it to default.**  To reset your RePhone to  DEFAULT :    Follow the instructions in \"Update/Flash the Firmware\" section to flash the firmware    Download the RePhone_Create_Kit_VXP file     Enter the  RePhone Mass Storage Mode    Copy everything under the file named \"RePhone Create Kit VXP\" into the RePhone 5MB mass storage.    Restart your RePhone then its done. As reset would have deleted all the files, you would have to put an mp3 file in the mass storage as well for the use of ringtone.",
            "title": "Reset to default"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#a-demo-hello-world",
            "text": "Now you have prepared things required, we are ready to rock on with RePhone.  Let us start with a simple program  Hello World    Press and hold the power key (PWR) for 2 seconds to turn it ON (LED indicator shows GREEN)    Open the  Arduino_IDE_for_RePhone.exe  in the folder where you unzipped the Arduino IDE for RePhone, the software interface is as follows:     Open  Device Manager  to check for the COM ports. There will be  two COM ports :   MTK USB Debug Port is used for uploading code  MTK USB Modem Port is used for logs, like printing messages in the serial monitor with  Serial.println()      On the Arduino IDE window, click  Tool => Port , select  MTK USB Debug Port , which is  COM20  in this case, the COM number might be different in your PC, just make sure it corresponds to the Debug Port.     On the Arduino IDE window, click  Tool => Board , select  RePhone     Now copy the following code to your Arduino IDE:  // hello world for test RePhone\n// loovee@10-18-2015\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\u00a0\nvoid loop() {\n    // put your main code here, to run repeatedly:\n    Serial.println(\"Hello World, Hello RePhone!\");\n    delay(100);\n}    Now press the  Upload  button to upload the code to your RePhone. You will see the  Done uploading  when the code is successfully uploaded.     As RePhone uses different COM ports for uploading software and logs, to read the logs, we need to switch the selected COM Port to  MTK USB Modem Port . On the Arduino IDE window, click  Tool => Port , select  MTK USB Modem Port , which is  COM48  in this case.  Then open the  Serial Monitor .     Now we can see the  Hello World  we have printed with  Serial.println()  .",
            "title": "A demo: Hello World"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#more-example-code",
            "text": "Playing with some example code would be a good start if you are heading into some even more interesting projects.    Simply setup your  sketchbook location  in the  preference  as  Arduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk  (where you install the Arduino IDE for RePhone)   then restart the  Arduino_IDE_for_RePhone.exe , you will be able to see the example codes.    You can also find the Arduino example coded manually for all the RePhone modules in the following path: Arduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\\libraries",
            "title": "More Example Code"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#rephone-community",
            "text": "We have been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the RePhone Community.  Now join us in the  RePhone Community !  Together we seek answers, make interesting stuff, care about each other, and share our experiences.",
            "title": "RePhone Community"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#more",
            "text": "You have done a great job so far! RePhone comes with a big family of modules with different features and functionalities. Go to check the wiki for modules for more applications!",
            "title": "More"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/EL_Shield/",
            "text": "EL Shield\n\n\n\n\nIntroduction\n\n\nThis shield is used to control EL devices. It can control 4 EL devices simultaneously. The controlling method is as simple as controlling an LED. Driven by PWM, it can create a colorful and florid effect by controlling each EL wire with a simple program. Combined with our EL Inverter, it can drive an EL wire as long as 15m, which provides infinite possibility for your design. Besides, the Shield is covered by Acrylic board, which enhances user's safety.\n\n\n\n\nSpecifications\n\n\n\n\nOperating Voltage: 5V\n\n\nInvertor interface: JST 2.0\n\n\nControl channel interface: 2P - 2.5SM socket\n\n\n\n\nHardware Overview\n\n\n\n\nDemonstration\n\n\nHere is a simple demo involving EL shield, 4 EL tapes and the custom invertor that accompanies EL shield.\nHook all things up as in the picture below.\n\n\n\n\nUpload the code below to your microcontroller.\n\n\n// EL test code \n\u00a0\nvoid setup(){\n for(int i = 4; i<8; i++)\n { \n  pinMode(i, OUTPUT);\n }\n}\n\u00a0\nvoid setEL(int ch) // set a certain EL on\n{ \n for(int i = 4; i<8; i++) // all off\n digitalWrite(i, LOW);\n digitalWrite(ch+3, HIGH); // ch on\n} \n\u00a0\nint count = 0; \n\u00a0\nvoid loop()\n{ \n setEL(count%4 + 1);\n delay(200);\n if(count++ == 1000)\n { \n  count = 0;\n } \n}\n\n\n\n\nResources\n\n\n\n\nEL Shield eagle file\n\n\nEL Shield Source code file for Arduino 1.0\n\n\nBT134W-600D datasheet\n\n\nMOC 3063 datasheet\n\n\n\n\nHelp us make it better",
            "title": "EL Shield"
        },
        {
            "location": "/EL_Shield/#el-shield",
            "text": "",
            "title": "EL Shield"
        },
        {
            "location": "/EL_Shield/#introduction",
            "text": "This shield is used to control EL devices. It can control 4 EL devices simultaneously. The controlling method is as simple as controlling an LED. Driven by PWM, it can create a colorful and florid effect by controlling each EL wire with a simple program. Combined with our EL Inverter, it can drive an EL wire as long as 15m, which provides infinite possibility for your design. Besides, the Shield is covered by Acrylic board, which enhances user's safety.",
            "title": "Introduction"
        },
        {
            "location": "/EL_Shield/#specifications",
            "text": "Operating Voltage: 5V  Invertor interface: JST 2.0  Control channel interface: 2P - 2.5SM socket",
            "title": "Specifications"
        },
        {
            "location": "/EL_Shield/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/EL_Shield/#demonstration",
            "text": "Here is a simple demo involving EL shield, 4 EL tapes and the custom invertor that accompanies EL shield.\nHook all things up as in the picture below.   Upload the code below to your microcontroller.  // EL test code \n\u00a0\nvoid setup(){\n for(int i = 4; i<8; i++)\n { \n  pinMode(i, OUTPUT);\n }\n}\n\u00a0\nvoid setEL(int ch) // set a certain EL on\n{ \n for(int i = 4; i<8; i++) // all off\n digitalWrite(i, LOW);\n digitalWrite(ch+3, HIGH); // ch on\n} \n\u00a0\nint count = 0; \n\u00a0\nvoid loop()\n{ \n setEL(count%4 + 1);\n delay(200);\n if(count++ == 1000)\n { \n  count = 0;\n } \n}",
            "title": "Demonstration"
        },
        {
            "location": "/EL_Shield/#resources",
            "text": "EL Shield eagle file  EL Shield Source code file for Arduino 1.0  BT134W-600D datasheet  MOC 3063 datasheet",
            "title": "Resources"
        },
        {
            "location": "/EL_Shield/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/",
            "text": "Grove - 3-Axis Digital Gyro\n\n\n\n\nIntroduction\n\n\nGrove - 3-Axis Digital Gyro module based on ITG 3200. It is the world\u2019s first single-chip, digital-output, 3-axis MEMS motion processing gyro optimised for gaming, 3D mice, and motion-based remote control applications for Internet connected Digital TVs and Set Top Boxes. The ITG-3200 features three 16-bit analog-to-digital converters (ADCs) for digitising the gyro outputs, a user-selectable internal low-pass filter bandwidth, and a Fast-Mode \nI2C\n (400kHz) interface.\n\n\n\n\nFeatures\n\n\n\n\nSupply Voltage: 3.3V, 5V\n\n\nOperation Current: 6.5mA\n\n\nStandby current: 5\u03bcA\n\n\nSensitivity: 14 LSBs per \u00b0/sec\n\n\nFull scale range: \u00b12000\u00b0/sec\n\n\nAcceleration: 10,000g for 0.3ms\n\n\nI2C Interface\n\n\n\u00b12000\u00b0/s full scale range and 14.375 LSBs per \u00b0/s sensitivity\n\n\nThree integrated 16-bit ADCs\n\n\nOn-chip temperature sensor\n\n\nIntegrated amplifiers and low-pass filters\n\n\nHermetically sealed for temp and humidity resistance\n\n\nRoHS and Green compliant\n\n\n\n\nDemonstration\n\n\nThis demo will show you how to get data from this digital gyro, the data is in the unit of rad/s.\n\n\nHere we need a Grove - 3-Axis Digital Gyro and a Seeeduino V3.0.\n\n\nHardware Installation\n\n\nHardware installation is very easy, because there's an I2C Grove in Seeeduino,\n\n\nSo, what we need to do is connect it to I2C Grove via a Grove cable.\n\n\n\n\nDownload Code and Upload\n\n\nYou can download the library in github, click \nhere\n, then extract it to libraries folder of Arduino.\n\n\nThen open File -> examples -> Grove_3_Digital_Gyro -> ITG3200_gyro, you can open the demo code.\n\n\n\n\nClick Upload to upload the code, if you have any problem about how to start Arduino, please click \nhere\n for some help.\n\n\nCheck the result\n\n\nNow, you can open the serial monitor to check the result.\n\n\n\n\nReference\n\n\nThe diagram below shows the orientations of the 3 axes. You can use it to understand the physical meanings of the result.\n\n\n\n\nResources\n\n\n\n\nDatasheet of ITG-3200.\n\n\nGrove - 3-Axis Digital Gyro Eagle File\n\n\nDigital Gyro Library\n\n\n\n\nHelp us make it better",
            "title": "Grove 3 Axis Digital Gyro"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#grove-3-axis-digital-gyro",
            "text": "",
            "title": "Grove - 3-Axis Digital Gyro"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#introduction",
            "text": "Grove - 3-Axis Digital Gyro module based on ITG 3200. It is the world\u2019s first single-chip, digital-output, 3-axis MEMS motion processing gyro optimised for gaming, 3D mice, and motion-based remote control applications for Internet connected Digital TVs and Set Top Boxes. The ITG-3200 features three 16-bit analog-to-digital converters (ADCs) for digitising the gyro outputs, a user-selectable internal low-pass filter bandwidth, and a Fast-Mode  I2C  (400kHz) interface.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#features",
            "text": "Supply Voltage: 3.3V, 5V  Operation Current: 6.5mA  Standby current: 5\u03bcA  Sensitivity: 14 LSBs per \u00b0/sec  Full scale range: \u00b12000\u00b0/sec  Acceleration: 10,000g for 0.3ms  I2C Interface  \u00b12000\u00b0/s full scale range and 14.375 LSBs per \u00b0/s sensitivity  Three integrated 16-bit ADCs  On-chip temperature sensor  Integrated amplifiers and low-pass filters  Hermetically sealed for temp and humidity resistance  RoHS and Green compliant",
            "title": "Features"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#demonstration",
            "text": "This demo will show you how to get data from this digital gyro, the data is in the unit of rad/s.  Here we need a Grove - 3-Axis Digital Gyro and a Seeeduino V3.0.",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#hardware-installation",
            "text": "Hardware installation is very easy, because there's an I2C Grove in Seeeduino,  So, what we need to do is connect it to I2C Grove via a Grove cable.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#download-code-and-upload",
            "text": "You can download the library in github, click  here , then extract it to libraries folder of Arduino.  Then open File -> examples -> Grove_3_Digital_Gyro -> ITG3200_gyro, you can open the demo code.   Click Upload to upload the code, if you have any problem about how to start Arduino, please click  here  for some help.",
            "title": "Download Code and Upload"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#check-the-result",
            "text": "Now, you can open the serial monitor to check the result.",
            "title": "Check the result"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#reference",
            "text": "The diagram below shows the orientations of the 3 axes. You can use it to understand the physical meanings of the result.",
            "title": "Reference"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#resources",
            "text": "Datasheet of ITG-3200.  Grove - 3-Axis Digital Gyro Eagle File  Digital Gyro Library",
            "title": "Resources"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-EL_Driver/",
            "text": "Grove - EL Driver\n\n\n\n\nIntroduction\n\n\nGrove - EL Driver is designed for driving EL Wires. It integrates a very small inverter to drive the EL Wire, so you can easily light up the EL Wire with just one single Grove cable.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv1.0\n\n\nInitial public release\n\n\nDec 11, 2014\n\n\n\n\n\n\n\n\nSupported EL Wires:\n\n\n\n\nEL Wire-Green 3m\n\n\nEL Wire-Red 3m\n\n\nEL Wire-Blue 3m\n\n\nEL Wire-Yellow 3m\n\n\nEL Wire-White 3m\n\n\n\n\nFeatures\n\n\n\n\nGrove compatible interface\n\n\n3.3V/5V Compatible\n\n\nIntegrated Inverter Transformer\n\n\nInput Current: 300mA Max (According to the load)\n\n\nSupported max EL Capacitance: 15nF\n\n\n\n\nUsage\n\n\nHere we show how to use Arduino to control the state of the LED.\n\n\n\n\n\n\nConnect the Grove - EL Driver to Base Shield's \ndigital port 2\n with 4pin Grove Cable. Of course you can change to other valid digital ports if it's necessary and the definitions of the port should be changed too. Connect a EL Wire to EL Driver \nJ1\n port with the given cable in product package.\n\n\n\n\n\n\nPlug it onto the Arduino/Seeeduino. Connect the board to PC using USB cable.\n\n\n\n\n\n\nCopy the demo code to your sketch, then upload to Arudino or Seeeduino board. Please click \nhere\n if you do not know how to upload.\nYou will see the EL Wire blink every second.\n\n\n\n\n\n\n/*************************   2014 Seeedstudio   **************************\n* File Name         \u00a0: GroveELDriverDemoCode.ino\n* Author            \u00a0: Seeedteam\n* Version           \u00a0: V1.0\n* Date              \u00a0: 11/12/2014\n* Description       \u00a0: Demo code for Grove - EL Driver\n*************************************************************************/\n\u00a0\n#define ELPin 2 //connect EL Driver to digital pin2\nvoid setup() {                \n  // initialize the digital pin2 as an output.\n  pinMode(ELPin, OUTPUT);     \n}\n\u00a0\nvoid loop() {\n  digitalWrite(ELPin, HIGH);   // set the EL Wire on\n  delay(500);               // for 500ms\n  digitalWrite(ELPin, LOW);   // set the EL Wire off\n  delay(500);\n}\n\n\n\n\n\n\nResources\n\n\n\n\nsch_pcb_eagle\n\n\nsch_pdf\n\n\n\n\nHelp us make it better",
            "title": "Grove EL Driver"
        },
        {
            "location": "/Grove-EL_Driver/#grove-el-driver",
            "text": "",
            "title": "Grove - EL Driver"
        },
        {
            "location": "/Grove-EL_Driver/#introduction",
            "text": "Grove - EL Driver is designed for driving EL Wires. It integrates a very small inverter to drive the EL Wire, so you can easily light up the EL Wire with just one single Grove cable.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-EL_Driver/#version-tracker",
            "text": "Revision  Descriptions  Release      v1.0  Initial public release  Dec 11, 2014",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-EL_Driver/#supported-el-wires",
            "text": "EL Wire-Green 3m  EL Wire-Red 3m  EL Wire-Blue 3m  EL Wire-Yellow 3m  EL Wire-White 3m",
            "title": "Supported EL Wires:"
        },
        {
            "location": "/Grove-EL_Driver/#features",
            "text": "Grove compatible interface  3.3V/5V Compatible  Integrated Inverter Transformer  Input Current: 300mA Max (According to the load)  Supported max EL Capacitance: 15nF",
            "title": "Features"
        },
        {
            "location": "/Grove-EL_Driver/#usage",
            "text": "Here we show how to use Arduino to control the state of the LED.    Connect the Grove - EL Driver to Base Shield's  digital port 2  with 4pin Grove Cable. Of course you can change to other valid digital ports if it's necessary and the definitions of the port should be changed too. Connect a EL Wire to EL Driver  J1  port with the given cable in product package.    Plug it onto the Arduino/Seeeduino. Connect the board to PC using USB cable.    Copy the demo code to your sketch, then upload to Arudino or Seeeduino board. Please click  here  if you do not know how to upload.\nYou will see the EL Wire blink every second.    /*************************   2014 Seeedstudio   **************************\n* File Name         \u00a0: GroveELDriverDemoCode.ino\n* Author            \u00a0: Seeedteam\n* Version           \u00a0: V1.0\n* Date              \u00a0: 11/12/2014\n* Description       \u00a0: Demo code for Grove - EL Driver\n*************************************************************************/\n\u00a0\n#define ELPin 2 //connect EL Driver to digital pin2\nvoid setup() {                \n  // initialize the digital pin2 as an output.\n  pinMode(ELPin, OUTPUT);     \n}\n\u00a0\nvoid loop() {\n  digitalWrite(ELPin, HIGH);   // set the EL Wire on\n  delay(500);               // for 500ms\n  digitalWrite(ELPin, LOW);   // set the EL Wire off\n  delay(500);\n}",
            "title": "Usage"
        },
        {
            "location": "/Grove-EL_Driver/#resources",
            "text": "sch_pcb_eagle  sch_pdf",
            "title": "Resources"
        },
        {
            "location": "/Grove-EL_Driver/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-EMG_Detector/",
            "text": "Grove - EMG Detector\n\n\n\n\nIntroduction\n\n\nEMG detector is a bridge connects human body and electrical, the sensor gathers small muscle signal then process with 2th amplify and filter, the output signal can be recognized by Arduino. You can add this signal into your control system. \n\n\n\n\nNote\n\nThe sensor cannot be used for medical purposes.\n\n\n\n\nIn standby mode, the output voltage is 1.5V. When detect muscle active, the output signal rise up, the maximum voltage is 3.3V. You can use this sensor in 3.3V or 5V system.\n\n\n\n\nFeatures\n\n\n\n\nGrove Compatible\n\n\n3.5mm Connector\n\n\n6 Disposable Surface Electrodes\n\n\nPower supply voltage: 3.3V-5V\n\n\n1000mm Cable Leads\n\n\nNo additional power supply\n\n\n\n\nHardware Overview\n\n\n\n\n\n\nJ2: grove interface, connect to analog I/O;\n\n\nJ1: EMG Disposable Surface Electrodes connector.\n\n\nU1: INA331IDGKT, difference amplifier.\n\n\nU2, U3: OPA333, Zero drift amplifier.\n\n\n\n\nDemonstration\n\n\nThis demonstration will show you how to use Grove - LCD RGB Backlight, we need a \nSeeeduino V3.0\n, a \nGrove - LED Bar\n and \nGrove - Base Shield\n.\n\n\nHardware Installation\n\n\nPlug Grove - Base Shield to Seeeduino, then connect Grove - LED Bar to D8, connect Grove - EMG Sensor to A0.\n\n\nFinally, tack the three electrodes to your muscle, and keep a distance between each electrodes.\n\n\n\n\nDownload Code and Upload\n\n\nYou can download the demo code in github, click \nhere\n, then extract it to anywhere.\n\n\nThen upload the code to Seeeduino, if you have any problem about code uploading, please refer to \nGetting Started With Seeeduino\n\n\n\n\nMove\n\n\nWhen finish downloading demo code, it'll take about 5s to initialize, you should keep static when initializing.\n\n\nYou can see that when initializing, the Led Bar will go form level 10 to level 0. When Led Bar All off, you can move now.\n\n\nWhen you are moving, you can find that the level of Led Bar will change.\n\n\n\n\nResources\n\n\n\n\nGrove-EMG Sensor v1.0 Eagle File\n\n\nGrove-EMG Sensor v1.1 Eagle File\n\n\nGrove-EMG Sensor v1.1 schematic PDF\n\n\nDemo Code\n\n\n\n\nHelp us make it better",
            "title": "Grove EMG Detector"
        },
        {
            "location": "/Grove-EMG_Detector/#grove-emg-detector",
            "text": "",
            "title": "Grove - EMG Detector"
        },
        {
            "location": "/Grove-EMG_Detector/#introduction",
            "text": "EMG detector is a bridge connects human body and electrical, the sensor gathers small muscle signal then process with 2th amplify and filter, the output signal can be recognized by Arduino. You can add this signal into your control system.    Note \nThe sensor cannot be used for medical purposes.  In standby mode, the output voltage is 1.5V. When detect muscle active, the output signal rise up, the maximum voltage is 3.3V. You can use this sensor in 3.3V or 5V system.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-EMG_Detector/#features",
            "text": "Grove Compatible  3.5mm Connector  6 Disposable Surface Electrodes  Power supply voltage: 3.3V-5V  1000mm Cable Leads  No additional power supply",
            "title": "Features"
        },
        {
            "location": "/Grove-EMG_Detector/#hardware-overview",
            "text": "J2: grove interface, connect to analog I/O;  J1: EMG Disposable Surface Electrodes connector.  U1: INA331IDGKT, difference amplifier.  U2, U3: OPA333, Zero drift amplifier.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-EMG_Detector/#demonstration",
            "text": "This demonstration will show you how to use Grove - LCD RGB Backlight, we need a  Seeeduino V3.0 , a  Grove - LED Bar  and  Grove - Base Shield .",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-EMG_Detector/#hardware-installation",
            "text": "Plug Grove - Base Shield to Seeeduino, then connect Grove - LED Bar to D8, connect Grove - EMG Sensor to A0.  Finally, tack the three electrodes to your muscle, and keep a distance between each electrodes.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-EMG_Detector/#download-code-and-upload",
            "text": "You can download the demo code in github, click  here , then extract it to anywhere.  Then upload the code to Seeeduino, if you have any problem about code uploading, please refer to  Getting Started With Seeeduino",
            "title": "Download Code and Upload"
        },
        {
            "location": "/Grove-EMG_Detector/#move",
            "text": "When finish downloading demo code, it'll take about 5s to initialize, you should keep static when initializing.  You can see that when initializing, the Led Bar will go form level 10 to level 0. When Led Bar All off, you can move now.  When you are moving, you can find that the level of Led Bar will change.",
            "title": "Move"
        },
        {
            "location": "/Grove-EMG_Detector/#resources",
            "text": "Grove-EMG Sensor v1.0 Eagle File  Grove-EMG Sensor v1.1 Eagle File  Grove-EMG Sensor v1.1 schematic PDF  Demo Code",
            "title": "Resources"
        },
        {
            "location": "/Grove-EMG_Detector/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-FM_Receiver/",
            "text": "Grove - FM Receiver\n\n\n\n\nIntroduction\n\n\nGrove - FM Receiver is a wideband FM receiver module, this module is base on SX6119, it offers true single-chip voice FM receiver, which is built-in amplifier, VCO, filter and demodulator. The multifunction button provides greater convenience for users to control.\n\n\n\n\nFeatures\n\n\n\n\nGrove interface\n\n\nFM receiver with a tuning range of 64 MHz to 108 MHz covering Eastern Europe (OIRT), Japan, Europe and US bands\n\n\nLower power consumption\n\n\nMultifunction button\n\n\nLED Indicator\n\n\nHeadsets interface\n\n\n\n\nHardware Overview\n\n\n\n\n\n\n\u2460\uff1aHeadsets interface:It can drive 16 ohm or 32 ohm earphone or audio\u3002\n\n\n\n\n\u2461\uff1aMultifunction button \uff1aChange volume and select channel\n\n\n\n\nCenter\uff1aOpen FM/Close FM\uff08Keeping press 1S\uff09\n\n\nUp\uff1avolume add\n\n\nDown\uff1avolume sub\n\n\nLeft\uff1asearching down\n\n\nRight\uff1asearching up\n\n\n\n\n\n\n\n\n\u2462\uff1aGrove Interface\n\n\n\n\n\n\n\u2463\uff1aLED Indicator\n\n\n\n\nFM Close\uff1aLED off\n\n\nFM Open\uff1aLED light\n\n\nFM Searching\uff1aLED flash\n\n\n\n\n\n\n\n\nUsage\n\n\nPart list\uff1a\n\n\n\n\nGrove - USB Power\n\n\nGrove - FM Receiver\n\n\nMini Cable\n\n\nAudio\n\n\n\n\n\n\nResources\n\n\n\n\nGrove - FM Receiver Eagle File\n\n\nSchematic in pdf\n\n\nDatasheet of SX6119\n\n\n\n\nHelp us make it better",
            "title": "Grove FM Receiver"
        },
        {
            "location": "/Grove-FM_Receiver/#grove-fm-receiver",
            "text": "",
            "title": "Grove - FM Receiver"
        },
        {
            "location": "/Grove-FM_Receiver/#introduction",
            "text": "Grove - FM Receiver is a wideband FM receiver module, this module is base on SX6119, it offers true single-chip voice FM receiver, which is built-in amplifier, VCO, filter and demodulator. The multifunction button provides greater convenience for users to control.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-FM_Receiver/#features",
            "text": "Grove interface  FM receiver with a tuning range of 64 MHz to 108 MHz covering Eastern Europe (OIRT), Japan, Europe and US bands  Lower power consumption  Multifunction button  LED Indicator  Headsets interface",
            "title": "Features"
        },
        {
            "location": "/Grove-FM_Receiver/#hardware-overview",
            "text": "\u2460\uff1aHeadsets interface:It can drive 16 ohm or 32 ohm earphone or audio\u3002   \u2461\uff1aMultifunction button \uff1aChange volume and select channel   Center\uff1aOpen FM/Close FM\uff08Keeping press 1S\uff09  Up\uff1avolume add  Down\uff1avolume sub  Left\uff1asearching down  Right\uff1asearching up     \u2462\uff1aGrove Interface    \u2463\uff1aLED Indicator   FM Close\uff1aLED off  FM Open\uff1aLED light  FM Searching\uff1aLED flash",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-FM_Receiver/#usage",
            "text": "Part list\uff1a   Grove - USB Power  Grove - FM Receiver  Mini Cable  Audio",
            "title": "Usage"
        },
        {
            "location": "/Grove-FM_Receiver/#resources",
            "text": "Grove - FM Receiver Eagle File  Schematic in pdf  Datasheet of SX6119",
            "title": "Resources"
        },
        {
            "location": "/Grove-FM_Receiver/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-GSR_Sensor/",
            "text": "Grove - GSR Sensor\n\n\n\n\nIntroduction\n\n\nGSR, standing for galvanic skin response, is a method of measuring the electrical conductance of the skin. Strong emotion can cause stimulus to your sympathetic nervous system, resulting more sweat being secreted by the sweat glands. Grove \u2013 GSR allows you to spot such strong emotions by simple attaching two electrodes to two fingers on one hand, an interesting gear to create emotion related projects, like sleep quality monitor.\n\n\n\n\nSpecifications\n\n\n\n\nInput Voltage: 5V/3.3V\n\n\nSensitivity adjustable via a potentiometer\n\n\nExternal measuring finger cots\n\n\n\n\nDemonstration\n\n\nIn the following we are showing you how to use the Grove - GSR.\nConnect Grove - GSR Sensor to the analog port A2 of Grove-Basic Shield and Grove - Buzzer to digital port 3. \n\nCopy and paste the code below to a new Arduino sketch and upload it to Arduino.\n\n\nconst int BUZZER=3;\nconst int GSR=A2;\nint threshold=0;\nint sensorValue;\n\nvoid setup(){\n  long sum=0;\n  Serial.begin(9600);\n  pinMode(BUZZER,OUTPUT);\n  digitalWrite(BUZZER,LOW);\n  delay(1000);\n\n  for(int i=0;i<500;i++)\n  {\n  sensorValue=analogRead(GSR);\n  sum += sensorValue;\n  delay(5);\n  }\n  threshold = sum/500;\n   Serial.print(\"threshold =\");\n   Serial.println(threshold);\n  }\n\nvoid loop(){\n  int temp;\n  sensorValue=analogRead(GSR);\n  Serial.print(\"sensorValue=\");\n  Serial.println(sensorValue);\n  temp = threshold - sensorValue;\n  if(abs(temp)>50)\n  {\n    sensorValue=analogRead(GSR);\n    temp = threshold - sensorValue;\n    if(abs(temp)>50){\n    digitalWrite(BUZZER,HIGH);\n    Serial.println(\"YES!\");\n    delay(3000);\n    digitalWrite(BUZZER,LOW);\n    delay(1000);}\n  }\n  }\n\n\n\nWear the finger sheath and relax, Now open serial monitor, we can see:\n\n\n\n\nThen take a deep breath. The buzzer should buzz now. And an obvious change in the output value should be observed.\nThe below is a graphs which is created in Excel using the data above. X axis represents time. and Y axis GSR data.\n\n\n\n\nReference\n\n\nThere are several graphs which are created in excel using GSR data.You can open the \nGSR sensor data.xls\n to see the detail data.\n\n\n\n\n\nResources\n\n\n\n\nGrove - GSR Eagle File\n\n\nLM324 datasheet\n\n\nGSR sensor data.xls\n\n\n\n\nHelp us make it better",
            "title": "Grove GSR Sensor"
        },
        {
            "location": "/Grove-GSR_Sensor/#grove-gsr-sensor",
            "text": "",
            "title": "Grove - GSR Sensor"
        },
        {
            "location": "/Grove-GSR_Sensor/#introduction",
            "text": "GSR, standing for galvanic skin response, is a method of measuring the electrical conductance of the skin. Strong emotion can cause stimulus to your sympathetic nervous system, resulting more sweat being secreted by the sweat glands. Grove \u2013 GSR allows you to spot such strong emotions by simple attaching two electrodes to two fingers on one hand, an interesting gear to create emotion related projects, like sleep quality monitor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-GSR_Sensor/#specifications",
            "text": "Input Voltage: 5V/3.3V  Sensitivity adjustable via a potentiometer  External measuring finger cots",
            "title": "Specifications"
        },
        {
            "location": "/Grove-GSR_Sensor/#demonstration",
            "text": "In the following we are showing you how to use the Grove - GSR.\nConnect Grove - GSR Sensor to the analog port A2 of Grove-Basic Shield and Grove - Buzzer to digital port 3.  \nCopy and paste the code below to a new Arduino sketch and upload it to Arduino.  const int BUZZER=3;\nconst int GSR=A2;\nint threshold=0;\nint sensorValue;\n\nvoid setup(){\n  long sum=0;\n  Serial.begin(9600);\n  pinMode(BUZZER,OUTPUT);\n  digitalWrite(BUZZER,LOW);\n  delay(1000);\n\n  for(int i=0;i<500;i++)\n  {\n  sensorValue=analogRead(GSR);\n  sum += sensorValue;\n  delay(5);\n  }\n  threshold = sum/500;\n   Serial.print(\"threshold =\");\n   Serial.println(threshold);\n  }\n\nvoid loop(){\n  int temp;\n  sensorValue=analogRead(GSR);\n  Serial.print(\"sensorValue=\");\n  Serial.println(sensorValue);\n  temp = threshold - sensorValue;\n  if(abs(temp)>50)\n  {\n    sensorValue=analogRead(GSR);\n    temp = threshold - sensorValue;\n    if(abs(temp)>50){\n    digitalWrite(BUZZER,HIGH);\n    Serial.println(\"YES!\");\n    delay(3000);\n    digitalWrite(BUZZER,LOW);\n    delay(1000);}\n  }\n  }  Wear the finger sheath and relax, Now open serial monitor, we can see:   Then take a deep breath. The buzzer should buzz now. And an obvious change in the output value should be observed.\nThe below is a graphs which is created in Excel using the data above. X axis represents time. and Y axis GSR data.",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-GSR_Sensor/#reference",
            "text": "There are several graphs which are created in excel using GSR data.You can open the  GSR sensor data.xls  to see the detail data.",
            "title": "Reference"
        },
        {
            "location": "/Grove-GSR_Sensor/#resources",
            "text": "Grove - GSR Eagle File  LM324 datasheet  GSR sensor data.xls",
            "title": "Resources"
        },
        {
            "location": "/Grove-GSR_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/",
            "text": "Grove - Gas Sensor(MQ2)\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor(MQ2) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nH2, LPG, CH4, CO, Alcohol, Smoke or Propane\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer. \n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n800\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n3\n\n\n-\n\n\n30\n\n\nk\u03a9\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-2 sensor, please refer the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\n\n\n\nConnect the Grove - Gas Sensor(MQ2) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\n\nThese examples demonstrate ways to know the approximate concentration of Gas. As per the data-sheet of the MQx sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.8; // The ratio of RS/R0 is 9.8 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the graph, we can see that the minimum concentration we can test is 100ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.01% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat's LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-2 Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Gas Sensor MQ2"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#grove-gas-sensormq2",
            "text": "",
            "title": "Grove - Gas Sensor(MQ2)"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#introduction",
            "text": "The Grove - Gas Sensor(MQ2) module is useful for gas leakage detection (in home and industry). It is suitable for detecting  H2, LPG, CH4, CO, Alcohol, Smoke or Propane . Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.    Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#features",
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity",
            "title": "Features"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#specification",
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  800  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33  -  \u03a9    Rs  Sensing Resistance  3  -  30  k\u03a9",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#application-ideas",
            "text": "Gas leakage detection.  Toys.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#hardware-overview",
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-2 sensor, please refer the data-sheet provided in  Resources  section.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#getting-started",
            "text": "Connect the Grove - Gas Sensor(MQ2) to A0 port as shown in the picture above.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#gas-detection-basic-example",
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}",
            "title": "Gas Detection\u00a0: Basic Example"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#measurement-approximation",
            "text": "These examples demonstrate ways to know the approximate concentration of Gas. As per the data-sheet of the MQx sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.8; // The ratio of RS/R0 is 9.8 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the graph, we can see that the minimum concentration we can test is 100ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.01% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.",
            "title": "Measurement\u00a0: Approximation"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#resources",
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What's LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-2 Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/",
            "text": "Grove - Gas Sensor(MQ3)\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor(MQ3) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nAlcohol, Benzine, CH4, Hexane, LPG, CO.\n Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\n\n\n\nHigh sensitivity to alcohol and small sensitivity to Benzine\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n750\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n1\n\n\n-\n\n\n8\n\n\nM\u03a9\n\n\n\n\n\n\nScope\n\n\nDetecting Concentration\n\n\n0.05\n\n\n-\n\n\n10\n\n\nmg/L\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nAlcohol checker.\n\n\nBreathalyser.\n\n\nToys.\n\n\n\n\nHardware Overview\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-3 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\n\n\n\nConnect the Grove - Gas Sensor(MQ3) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ3 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in Alcohol\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/60.0; // The ratio of RS/R0 is 60 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 0.1mg/L and the maximum is 10mg/L. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.But also, we can convert mg/L to ppm, it's may convenient for us to watch the value.\n\n\n\n\n\n\nResources\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat's LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-3 Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Gas Sensor MQ3"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#grove-gas-sensormq3",
            "text": "",
            "title": "Grove - Gas Sensor(MQ3)"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#introduction",
            "text": "The Grove - Gas Sensor(MQ3) module is useful for gas leakage detection (in home and industry). It is suitable for detecting  Alcohol, Benzine, CH4, Hexane, LPG, CO.  Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.   Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#features",
            "text": "High sensitivity to alcohol and small sensitivity to Benzine  Stable and long life  Fast response and High sensitivity",
            "title": "Features"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#specification",
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  750  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33  -  \u03a9    Rs  Sensing Resistance  1  -  8  M\u03a9    Scope  Detecting Concentration  0.05  -  10  mg/L",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#application-ideas",
            "text": "Alcohol checker.  Breathalyser.  Toys.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#hardware-overview",
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-3 sensor, please refer to the data-sheet provided in  Resources  section.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#getting-started",
            "text": "Connect the Grove - Gas Sensor(MQ3) to A0 port as shown in the picture above.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#gas-detection-basic-example",
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}",
            "title": "Gas Detection\u00a0: Basic Example"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#measurement-approximation",
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ3 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in Alcohol\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/60.0; // The ratio of RS/R0 is 60 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 0.1mg/L and the maximum is 10mg/L. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.But also, we can convert mg/L to ppm, it's may convenient for us to watch the value.",
            "title": "Measurement\u00a0: Approximation"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#resources",
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What's LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-3 Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/",
            "text": "Grove - Gas Sensor(MQ5)\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor(MQ5) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nH2, LPG, CH4, CO, Alcohol\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n800\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n31\u00b110%\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n10\n\n\n-\n\n\n60\n\n\nk\u03a9\n\n\n\n\n\n\nScope\n\n\nDetecting Concentration\n\n\n200\n\n\n-\n\n\n10000\n\n\nppm\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-5 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\n\n\n\nConnect the Grove - Gas Sensor(MQ5) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\n\n\nNote\n\nYou need an extra tool to find a certain threshold for various air condition. And then set the threshold in code.\n\n\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ5 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/6.5; // The ratio of RS/R0 is 6.5 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat's LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-5 Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Gas Sensor MQ5"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#grove-gas-sensormq5",
            "text": "",
            "title": "Grove - Gas Sensor(MQ5)"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#introduction",
            "text": "The Grove - Gas Sensor(MQ5) module is useful for gas leakage detection (in home and industry). It is suitable for detecting  H2, LPG, CH4, CO, Alcohol . Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.   Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#features",
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity",
            "title": "Features"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#specification",
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  800  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  31\u00b110%  -  \u03a9    Rs  Sensing Resistance  10  -  60  k\u03a9    Scope  Detecting Concentration  200  -  10000  ppm",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#application-ideas",
            "text": "Gas leakage detection.  Toys.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#hardware-overview",
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-5 sensor, please refer to the data-sheet provided in  Resources  section.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#getting-started",
            "text": "Connect the Grove - Gas Sensor(MQ5) to A0 port as shown in the picture above.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#gas-detection-basic-example",
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.   Note \nYou need an extra tool to find a certain threshold for various air condition. And then set the threshold in code.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}",
            "title": "Gas Detection\u00a0: Basic Example"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#measurement-approximation",
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ5 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/6.5; // The ratio of RS/R0 is 6.5 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.",
            "title": "Measurement\u00a0: Approximation"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#resources",
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What's LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-5 Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/",
            "text": "Grove - Gas Sensor(MQ9)\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor(MQ9) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nLPG, CO, CH4\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n340\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\u03a9\u00b15%\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n2\n\n\n-\n\n\n20000\n\n\n\u03a9\n\n\n\n\n\n\nCO/CH4/LPG Scope\n\n\nDetecting Concentration\n\n\n200\n\n\n-\n\n\n1000/10000/10000\n\n\nppm\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-9 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\n\n\n\nConnect the Grove - Gas Sensor(MQ9) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ9 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in LPG\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.9; // The ratio of RS/R0 is 9.9 in LPG gas from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat's LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-9 Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Gas Sensor MQ9"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#grove-gas-sensormq9",
            "text": "",
            "title": "Grove - Gas Sensor(MQ9)"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#introduction",
            "text": "The Grove - Gas Sensor(MQ9) module is useful for gas leakage detection (in home and industry). It is suitable for detecting  LPG, CO, CH4 . Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.   Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#features",
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity",
            "title": "Features"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#specification",
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  340  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33\u03a9\u00b15%  -  \u03a9    Rs  Sensing Resistance  2  -  20000  \u03a9    CO/CH4/LPG Scope  Detecting Concentration  200  -  1000/10000/10000  ppm",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#application-ideas",
            "text": "Gas leakage detection.  Toys.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#hardware-overview",
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-9 sensor, please refer to the data-sheet provided in  Resources  section.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#getting-started",
            "text": "Connect the Grove - Gas Sensor(MQ9) to A0 port as shown in the picture above.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#gas-detection-basic-example",
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}",
            "title": "Gas Detection\u00a0: Basic Example"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#measurement-approximation",
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ9 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in LPG\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.9; // The ratio of RS/R0 is 9.9 in LPG gas from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.",
            "title": "Measurement\u00a0: Approximation"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#resources",
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What's LEL",
            "title": "Resources"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#schematic",
            "text": "Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-9 Datasheet",
            "title": "Schematic"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor/",
            "text": "Grove - Gas Sensor\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor module is useful for gas leakage detecting(in home and industry). It can detect LPG, i-butane, methane, alcohol, Hydrogen, smoke and so on. Measurements can be taken as soon as possible based on its fast response time. Also the sensitivity can be adjusted by the potentiometer.\n\n\nEach Grove - Gas Sensor Kit consists of one gas sensor base and four detectors. You can switch the detector on the base according to specific target gases.\n\n\n\n\nGrove - Gas Sensor(MQ2)\n\uff1aCombustible Gas, Smoke\n\n\nGrove - Gas Sensor(MQ3)\n\uff1aAlcohol Vapor\n\n\nGrove - Gas Sensor(MQ5)\n\uff1aLPG, Natural Gas, Town Gas\n\n\nGrove - Gas Sensor(MQ9)\n\uff1aCarbon Monoxide, Coal Gas, Liquefied Gas\n\n\n\n\nSpecification\n\n\n\n\nWorking Voltage: 4.9-5.1V\n\n\nHeating consumption: 0.5-800mW\n\n\nLoad resistance: can adjust\n\n\nHeater resistance: 33\u03a9\n\n\nSensing Resistance: 3-30k\u03a9\n\n\nWorking Temperature: -25~70 \u2103\n\n\n\n\nDemonstration\n\n\nConnect the module with Grove Shield using A0 like following picture and use the program below to gain the voltage. The higher the concentration of the gas is, the bigger the output voltage of the SIG pin gets. Sensitivity can be regulated by rotating the potentiometer. Please note that the best preheat time of the sensor is about 24 hours. For the detailed information about the sensor, please refer to the datasheet.\n\n\n\n\nResources\n\n\n\n\nMQ-2 Datasheet\n\n\nMQ-3 Datasheet\n\n\nMQ-5 Datasheet\n\n\nMQ-9 Datasheet\n\n\nDemo code on github",
            "title": "Grove Gas Sensor"
        },
        {
            "location": "/Grove-Gas_Sensor/#grove-gas-sensor",
            "text": "",
            "title": "Grove - Gas Sensor"
        },
        {
            "location": "/Grove-Gas_Sensor/#introduction",
            "text": "The Grove - Gas Sensor module is useful for gas leakage detecting(in home and industry). It can detect LPG, i-butane, methane, alcohol, Hydrogen, smoke and so on. Measurements can be taken as soon as possible based on its fast response time. Also the sensitivity can be adjusted by the potentiometer.  Each Grove - Gas Sensor Kit consists of one gas sensor base and four detectors. You can switch the detector on the base according to specific target gases.   Grove - Gas Sensor(MQ2) \uff1aCombustible Gas, Smoke  Grove - Gas Sensor(MQ3) \uff1aAlcohol Vapor  Grove - Gas Sensor(MQ5) \uff1aLPG, Natural Gas, Town Gas  Grove - Gas Sensor(MQ9) \uff1aCarbon Monoxide, Coal Gas, Liquefied Gas",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor/#specification",
            "text": "Working Voltage: 4.9-5.1V  Heating consumption: 0.5-800mW  Load resistance: can adjust  Heater resistance: 33\u03a9  Sensing Resistance: 3-30k\u03a9  Working Temperature: -25~70 \u2103",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor/#demonstration",
            "text": "Connect the module with Grove Shield using A0 like following picture and use the program below to gain the voltage. The higher the concentration of the gas is, the bigger the output voltage of the SIG pin gets. Sensitivity can be regulated by rotating the potentiometer. Please note that the best preheat time of the sensor is about 24 hours. For the detailed information about the sensor, please refer to the datasheet.",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-Gas_Sensor/#resources",
            "text": "MQ-2 Datasheet  MQ-3 Datasheet  MQ-5 Datasheet  MQ-9 Datasheet  Demo code on github",
            "title": "Resources"
        },
        {
            "location": "/Grove-Hall_Sensor/",
            "text": "Grove - Hall Sensor\n\n\n\n\nIntroduction\n\n\nThe Hall sensor is based on Hall Effect, which is the production of a voltage difference across an electrical conductor, transverse to an electric current in the conductor and a magnetic field perpendicular to the current. There is a continuous-time switch on this Grove. The output of these devices switches low (turns on) when a magnetic field (south polarity) perpendicular to the Hall sensor exceeds the operate point threshold BOP, and it switches high (turn off) when the magnetic field disappears. The twig can be used to measure RPM.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv0.9b\n\n\nInitial public release\n\n\n3,Oct,2011\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nGrove Compatible Interface\n\n\n400ns transition period for rise and fall.\n\n\nContinuous-time hall effect sensor\n\n\nReverse battery protection\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nSupply Voltage\n\n\n3.8\n\n\n5.0\n\n\n24\n\n\nV\n\n\n\n\n\n\nSupply Current\n\n\n4.1\n\n\n-\n\n\n24\n\n\nmA\n\n\n\n\n\n\nOperating Temperature\n\n\n-40\n\n\n-\n\n\n85\n\n\n\u00baC\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nRPM meter.\n\n\nSimple dc motor.\n\n\n\n\nGetting Started\n\n\nThe Hall Sensor is used by utilizing the external interrupts available on the arduino/seeeduino. In this example we are using interrupt 0, found on digital pin 2. For other interrupts, see the \nattachInterrupt()\n.\n\n\n\n\nConnect the Hall Sensor to Digital port 2 of the \nGrove - Base Shield\n using a 4 pin cable and connect Grove-LED to Digital Port 4.\n\n\nThen connect Arduino to PC by using a USB cable.\n\n\nDownload the \nHall Sensor Code\n\n\nOpen one of two code. For example Demo \nMagnetControlLED\n\n\n\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n\n\nWhen a magnet whose south pole is facing up is approaching to the onboard sensor, the LED will be turned on. Otherwise, the LED will be turned off.\n\n\n\n\nResources\n\n\n\n\nGrove-Hall Sensor Eagle File\n\n\nHall Sensor Demo Code\n\n\nA1101 datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Hall Sensor"
        },
        {
            "location": "/Grove-Hall_Sensor/#grove-hall-sensor",
            "text": "",
            "title": "Grove - Hall Sensor"
        },
        {
            "location": "/Grove-Hall_Sensor/#introduction",
            "text": "The Hall sensor is based on Hall Effect, which is the production of a voltage difference across an electrical conductor, transverse to an electric current in the conductor and a magnetic field perpendicular to the current. There is a continuous-time switch on this Grove. The output of these devices switches low (turns on) when a magnetic field (south polarity) perpendicular to the Hall sensor exceeds the operate point threshold BOP, and it switches high (turn off) when the magnetic field disappears. The twig can be used to measure RPM.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Hall_Sensor/#version-tracker",
            "text": "Revision  Descriptions  Release      v0.9b  Initial public release  3,Oct,2011",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-Hall_Sensor/#features",
            "text": "Grove Compatible Interface  400ns transition period for rise and fall.  Continuous-time hall effect sensor  Reverse battery protection",
            "title": "Features"
        },
        {
            "location": "/Grove-Hall_Sensor/#specifications",
            "text": "Item  Min  Typical  Max  Unit      Supply Voltage  3.8  5.0  24  V    Supply Current  4.1  -  24  mA    Operating Temperature  -40  -  85  \u00baC",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Hall_Sensor/#application-ideas",
            "text": "RPM meter.  Simple dc motor.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Hall_Sensor/#getting-started",
            "text": "The Hall Sensor is used by utilizing the external interrupts available on the arduino/seeeduino. In this example we are using interrupt 0, found on digital pin 2. For other interrupts, see the  attachInterrupt() .   Connect the Hall Sensor to Digital port 2 of the  Grove - Base Shield  using a 4 pin cable and connect Grove-LED to Digital Port 4.  Then connect Arduino to PC by using a USB cable.  Download the  Hall Sensor Code  Open one of two code. For example Demo  MagnetControlLED     Upload the code, Please click  here  if you do not know how to upload.  When a magnet whose south pole is facing up is approaching to the onboard sensor, the LED will be turned on. Otherwise, the LED will be turned off.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Hall_Sensor/#resources",
            "text": "Grove-Hall Sensor Eagle File  Hall Sensor Demo Code  A1101 datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Hall_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/",
            "text": "Grove - High Temperature Sensor\n\n\n\n\nIntroduction\n\n\nThermocouples are very sensitive devices. It requires a good amplifier with cold-junction compensation. The Grove - High Temperatire Sensor uses a K-Type themocouple and a thermocouple amplifier that measures ambient temperature using thermistor for cold-junction compensation. The detectable range of this Sensor is -50-600\u00b0C , and the accuracy is \u00b1(2.0% + 2\u00b0C)\n\n\n\n\nSpecifications\n\n\n\n\nVoltage\uff1a3.3 ~ 5V\n\n\nMax power rating at 25\u2103 \uff1a300mW\n\n\nOperating temperature range\uff1a-40 ~ +125 \u2103\n\n\nThe temperature measurement range is (-50 ~ +600\u2103)\n\n\nAmplifier output voltage range (0 ~ 3.3 V) mv\n\n\nCold junction compensation (environment temperature measurement)\n\n\nThermocouple temperature measurement accuracy of + / - 2.0% (+ 2 \u2103)\n\n\n\n\nGetting Started\n\n\nHere is an example to show you how to read temperature information from the sensor.\n\n\nWe need a Seeeduino V3.0 and a Grove - High Temperature Sensor.\n\n\nHardware Installation\n\n\nA4 and A5 are the I2C lines of Seeduino. Plug the sensor to the I2C port of Seeeduino to read data.\n\n\nDownload Code and Upload\n\n\nYou can download the library from \nhere\n\n\nThen extract the library to the Library folder of Arduino, open the demo in examples folder.\n\n\nThen upload it to your Seeeduino.\n\n\nOpen Serial Monitor and Get Data\n\n\nThen, open your Serial Monitor, you can find the temperature in Celsius here.\n\n\n\n\nK type thermocouple indexing table\n\n\nAs a reference, the following is K type thermocouple indexing table.\n\n\n\nResources\n\n\n\n\nGrove - High Temperature Sensor PDF\n\n\nGrove - High Temperature Sensor Eagle File\n\n\nHigh Temperature Sensor Library\n\n\nDatasheet OPA333 PDF\n\n\nDatasheet LMV358 PDF\n\n\n\n\nHelp us make it better",
            "title": "Grove High Temperature Sensor"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#grove-high-temperature-sensor",
            "text": "",
            "title": "Grove - High Temperature Sensor"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#introduction",
            "text": "Thermocouples are very sensitive devices. It requires a good amplifier with cold-junction compensation. The Grove - High Temperatire Sensor uses a K-Type themocouple and a thermocouple amplifier that measures ambient temperature using thermistor for cold-junction compensation. The detectable range of this Sensor is -50-600\u00b0C , and the accuracy is \u00b1(2.0% + 2\u00b0C)",
            "title": "Introduction"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#specifications",
            "text": "Voltage\uff1a3.3 ~ 5V  Max power rating at 25\u2103 \uff1a300mW  Operating temperature range\uff1a-40 ~ +125 \u2103  The temperature measurement range is (-50 ~ +600\u2103)  Amplifier output voltage range (0 ~ 3.3 V) mv  Cold junction compensation (environment temperature measurement)  Thermocouple temperature measurement accuracy of + / - 2.0% (+ 2 \u2103)",
            "title": "Specifications"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#getting-started",
            "text": "Here is an example to show you how to read temperature information from the sensor.  We need a Seeeduino V3.0 and a Grove - High Temperature Sensor.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#hardware-installation",
            "text": "A4 and A5 are the I2C lines of Seeduino. Plug the sensor to the I2C port of Seeeduino to read data.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#download-code-and-upload",
            "text": "You can download the library from  here  Then extract the library to the Library folder of Arduino, open the demo in examples folder.  Then upload it to your Seeeduino.",
            "title": "Download Code and Upload"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#open-serial-monitor-and-get-data",
            "text": "Then, open your Serial Monitor, you can find the temperature in Celsius here.",
            "title": "Open Serial Monitor and Get Data"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#k-type-thermocouple-indexing-table",
            "text": "As a reference, the following is K type thermocouple indexing table.",
            "title": "K type thermocouple indexing table"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#resources",
            "text": "Grove - High Temperature Sensor PDF  Grove - High Temperature Sensor Eagle File  High Temperature Sensor Library  Datasheet OPA333 PDF  Datasheet LMV358 PDF",
            "title": "Resources"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/",
            "text": "Grove - I2C FM Receiver\n\n\n\n\nIntroduction\n\n\nGrove - I2C FM Receiver is a wideband FM receiver module, this module is based on RDA5807M. The RDA5807M series is the newest generation single-chip broadcast FM stereo radio tuner with fully integrated synthesizer. The RDA5807M series has a powerful low-IF digital audio processor. The Grove - I2C FM Receiver has a headset jack, so it can connect to earphones or audio.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescription\n\n\nRelease date\n\n\n\n\n\n\n\n\n\n\nGrove - I2C FM Receiver v1.0\n\n\nInitial public release\n\n\n\n\n\n\n\n\nGrove - I2C FM Receiver v1.1\n\n\nFixed bug - DFM for J3\n\n\nDec 2, 2011\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nGrove interface\n\n\nSupports worldwide frequency band: 50 - 115MHz\n\n\nSupport RDS/RBDS\n\n\nLower power consumption\n\n\nHeadset interface\n\n\nDigital auto gain control\n\n\nInput voltage: 3.3V - 5V\n\n\n\n\nUsage\n\n\nWe can change channel by Grove - Button and adjust volume by Grove - Rotary\n\n\nHardware Installation\n\n\nPart list\uff1a\n\n\n\n\nSeeeduino Lotus\n\n\nGrove - I2C FM Receiver\n\n\nGrove - Button\n\n\nGrove - Rotary\n\n\nEarphone\n\n\n\n\n\n\nSoftware Part\n\n\n\n\nDownload the code \nI2C FM Receiver\n.\n\n\nUnzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.\n\n\nOpen the code directly from the path: File -> Example -> I2C_FM_Receiver.\n\n\nUpload the code. Note that you should select the correct board type and COM port.\n\n\n\n\nYou can see Center Frequency:\n\n\n\n\nResources\n\n\n\n\nGrove - I2C FM Receiver v1.0 Eagle File\n\n\nv1.0 Schematic in pdf\n\n\nDatasheet of RDA5807M\n\n\nGrove - I2C FM Receiver v1.1 Eagle File\n\n\n\n\nHelp us make it better",
            "title": "Grove I2C FM Receiver"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#grove-i2c-fm-receiver",
            "text": "",
            "title": "Grove - I2C FM Receiver"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#introduction",
            "text": "Grove - I2C FM Receiver is a wideband FM receiver module, this module is based on RDA5807M. The RDA5807M series is the newest generation single-chip broadcast FM stereo radio tuner with fully integrated synthesizer. The RDA5807M series has a powerful low-IF digital audio processor. The Grove - I2C FM Receiver has a headset jack, so it can connect to earphones or audio.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#version-tracker",
            "text": "Revision  Description  Release date      Grove - I2C FM Receiver v1.0  Initial public release     Grove - I2C FM Receiver v1.1  Fixed bug - DFM for J3  Dec 2, 2011",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#features",
            "text": "Grove interface  Supports worldwide frequency band: 50 - 115MHz  Support RDS/RBDS  Lower power consumption  Headset interface  Digital auto gain control  Input voltage: 3.3V - 5V",
            "title": "Features"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#usage",
            "text": "We can change channel by Grove - Button and adjust volume by Grove - Rotary",
            "title": "Usage"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#hardware-installation",
            "text": "Part list\uff1a   Seeeduino Lotus  Grove - I2C FM Receiver  Grove - Button  Grove - Rotary  Earphone",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#software-part",
            "text": "Download the code  I2C FM Receiver .  Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.  Open the code directly from the path: File -> Example -> I2C_FM_Receiver.  Upload the code. Note that you should select the correct board type and COM port.   You can see Center Frequency:",
            "title": "Software Part"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#resources",
            "text": "Grove - I2C FM Receiver v1.0 Eagle File  v1.0 Schematic in pdf  Datasheet of RDA5807M  Grove - I2C FM Receiver v1.1 Eagle File",
            "title": "Resources"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-I2C_Hub/",
            "text": "Grove - I2C Hub\n\n\n\n\nIntroduction\n\n\nI2C Hub Grove is an extension Grove module for connecting multiply I2C devices to Grove Base Shield. It can use with \nUniversal 4 Pin to X2 4 Pin cable\n and connects up to 3 I2C devices which may cover most developing purpose.\n\n\n\n\nFeatures\n\n\n\n\nChainable\n\n\n\n\nApplication Ideas\n\n\n\n\nUsing more I2C devices than you otherwise have room for on your Grove platform.\n\n\n\n\nUsage\n\n\nIt does not conflict if you use the same I2C Socket simultaneously because every I2C device has its own address. Hardware installation is shown below.\n\n\n\n\nHere we do not list a specific example.\n\n\nResources\n\n\nI2C Hub Eagle File\n\n\nHelp us make it better",
            "title": "Grove I2C Hub"
        },
        {
            "location": "/Grove-I2C_Hub/#grove-i2c-hub",
            "text": "",
            "title": "Grove - I2C Hub"
        },
        {
            "location": "/Grove-I2C_Hub/#introduction",
            "text": "I2C Hub Grove is an extension Grove module for connecting multiply I2C devices to Grove Base Shield. It can use with  Universal 4 Pin to X2 4 Pin cable  and connects up to 3 I2C devices which may cover most developing purpose.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-I2C_Hub/#features",
            "text": "Chainable",
            "title": "Features"
        },
        {
            "location": "/Grove-I2C_Hub/#application-ideas",
            "text": "Using more I2C devices than you otherwise have room for on your Grove platform.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-I2C_Hub/#usage",
            "text": "It does not conflict if you use the same I2C Socket simultaneously because every I2C device has its own address. Hardware installation is shown below.   Here we do not list a specific example.",
            "title": "Usage"
        },
        {
            "location": "/Grove-I2C_Hub/#resources",
            "text": "I2C Hub Eagle File",
            "title": "Resources"
        },
        {
            "location": "/Grove-I2C_Hub/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-I2C_Motor_Driver/",
            "text": "Grove - I2C Motor Driver\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrove - I2C Motor Driver V1.0\n\n\n\n\n\n\nGrove - I2C Motor Driver V1.2\n\n\n\n\n\n\nGrove - I2C Motor Driver V1.3",
            "title": "Grove I2C Motor Driver"
        },
        {
            "location": "/Grove-I2C_Motor_Driver/#grove-i2c-motor-driver",
            "text": "Grove - I2C Motor Driver V1.0    Grove - I2C Motor Driver V1.2    Grove - I2C Motor Driver V1.3",
            "title": "Grove - I2C Motor Driver"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/",
            "text": "Grove - I2C Motor Driver V1.3\n\n\n\n\nIntroduction\n\n\nThe Grove - I2C Motor Driver V1.3 (latest version) can directly control Stepper Motor or DC Motor. Its heart is a dual channel H-bridge driver chip\uff08L298N\uff09that can handle current up to 2A per channel, controlled by an Atmel ATmega8L which handles the I2C communication with for example an Arduino. Both motors can be driven simultaneously while set to a different speed and direction. It can power two brushed DC motors or one 4-wire two-phase stepper motor. It requires a 6V to 15V power supply to power the motor and has an onboard 5V voltage regulator which can power the I2C bus and the Arduino(selectable by jumper). All driver lines are protected by diodes from back-EMF.\n\n\nContrast to the \nGrove - I2C motor driver V1.2\n, the V1.3 enables users to control the stepper more easily. You do not need to control the steppers all the time anymore, simply send a command to I2C motor driver V1.3 to drive a stepper, and it will act as your command, which would save your Arduino resource and simplify your code.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv1.0\n\n\nInitial public release\n\n\nMay 17th, 2012\n\n\n\n\n\n\nv1.2\n\n\nModify the I2C address set by hardware\n\n\nJuly 2nd, 2012\n\n\n\n\n\n\nv1.3\n\n\nModify the firmware to support off-line Stepper\n\n\nFeb 18th, 2013\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nGrove Compatible\n\n\nI2C Interface\n\n\nAdjustable motor speed and rotation direction\n\n\nChangeable slave address by hardware\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n6\n\n\n\n\n-\n\n\n\n\n15\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nMax Output Current per channel\n\n\n\n\n0.5\n\n\n\n\nA\n\n\n\n\n\n\n\n\nMaximum Total current\n\n\n\n\n1.0\n\n\n\n\nA\n\n\n\n\n\n\n\n\nInput/output voltage on I2C bus\n\n\n\n\n5\n\n\n\n\nV\n\n\n\n\n\n\n\n\nCommunication protocol\n\n\n\n\nI2C\n\n\n\n\n/\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\n78M05 IC:\n 5V voltage regulator\n\n\nL298 IC:\n Dual full bridge driver\n\n\nATmega8 IC:\n Control Motor Rotate.\n\n\n\n\nNote\n\nInput voltage on screw terminals is regulated to 5V and connected to I2C +5V via a jumper (J4). Remove jumper if both external power via the screw terminals and power via the I2C header are used. Use jumper if 5V should be supplied to the I2C bus.\n\n\n\n\nApplication Ideas\n\n\n\n\nRobots\n\n\nHomebuilt RC cars\n\n\nCase fans\n\n\nHigh power LED illumination\n\n\n\n\n\n\nCaution\n\nThe board will be very hot while operating over 1Amp. Do keep your hands off!\n\n\n\n\nUsage\n\n\nThe I2C Motor Driver can control motor which is based on the chip L298. The L298 isn\u2019t just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. Hooking up to a motor means you can have it spin in both directions; and with PWM input, you can use your Arduino to make them spin at any speed. Because the L298 has 2 H-bridges, you can make a robot turn around by spinning each wheel in different directions, and of course go forwards and backwards.\n\n\nNow, let us use the I2C Motor Driver to control two DC motors or a stepper rotating clockwise and anticlockwise.\n\n\nSet the address of the I2C Motor Driver\n\n\n\n\nSet the address by dial switch is a new function added to the new I2C Motor Driver.\n\n\n\n\n\n\n\n\nThen keep the address setup in the program the same as the address setup on the I2C motor driver. The default address setup in the program is 0x0f.\n\n\n\n\n\n\n\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n\n\n\nHow to drive 2 DC motors\n\n\n\n\n\n\nNote\n\nThe first thing to notice however, is that you need an external power source for your DC motors. The 5V pin on the Arduino cannot provide enough power to drive 2 motors, you may damage your Arduino if you do so.\n\n\n\n\nAnd then program your Arduino as below:\n\n\n#include <Wire.h>\n     .......\n     .......\n    < Driver functions >\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n  while(1)  {\n    MotorSpeedSetAB(100,20);\n    delay(10); //this delay needed\n    MotorDirectionSet(0b1010);  //0b1010  Rotating in the positive direction \n    delay(1000); \n    MotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\n    delay(500);\n  }\n}\n\n\n\n\nIn this program, Arduino first set the speed of the 2 DC motors with the \nMotorSpeedSetAB()\ncommand, and then set the DC motors work directions with \nMotorDirectionSet()\n command. please refer to the \nFunction Reference\n for details, you can download all the demo code in the \nResources\n.\n\n\nHow to drive a stepper using I2C motor driver V1.3\n\n\nAs the upgraded version of \nI2C motor DriverV1.2\n, You can drive stepper via 2 methods for I2C motor driver V1.3.\n\n\n1. Control the stepper directly by Arduino\n\nThe I2C motor Driver can also be used to drive a 4-wire stepper. Connect your stepper to the output pins of I2C motor driver, and then connect motor driver to your Arduino/Seeeduino with I2C bus. Program your Arduino as below:\n\n\n#include <Wire.h>\n     .......\n     .......\n    < Driver functions >\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n while(1)  {\n    MotorSpeedSetAB(100,100);//when driving a stepper, the speed should be set to 100;\n    delay(10);\n    MotorDirectionSet(0b0001);\n    delay(4);\n      MotorDirectionSet(0b0011);\n    delay(4);  \n    MotorDirectionSet(0b0010);\n    delay(4);\n      MotorDirectionSet(0b0110);\n    delay(4);  \n    MotorDirectionSet(0b0100);\n    delay(4);  \n    MotorDirectionSet(0b1100);\n    delay(4);\n      MotorDirectionSet(0b1000);\n    delay(4);\n      MotorDirectionSet(0b1001);\n    delay(4);\n  }\n}\n\n\n\n\nThis connected 4-wire stepper will rotate; you can adjust the rotation speed or step number in your Arduino program. You can also use some other stepper libraries to control it. For all the demo code please refer to \nResources\n.\n\n\n\n\n2. Control the Stepper using the I2C motor Driver V1.3 on-chip ATmega8L.\n\n Take \n24BYJ48\n as an example, The hardware installation as shown below:\n\n\n\n\nThe connection between 24BYJ48 Stepper Motor and I2C Motor Driver is as shown below:\n\n\n\n\nDownload the \nGrove-I2C motor driver V1.3 demo code\n, and open the \nStepperControlMode2.ino\n:\n\n\n#include <Wire.h>\n#define MotorSpeedSet             0x82\n#define PWMFrequenceSet           0x84\n#define DirectionSet              0xaa\n#define MotorSetA                 0xa1\n#define MotorSetB                 0xa5\n#define Nothing                   0x01\n#define EnableStepper             0x1a\n#define UnenableStepper           0x1b\n#define Stepernu                  0x1c\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n// set the steps you want, if 255, the stepper will rotate continuously;\nvoid SteperStepset(unsigned char stepnu)\n{\n  Wire.beginTransmission(I2CMotorDriverAdd); // transmit to device I2CMotorDriverAdd\n  Wire.write(Stepernu);          // Send the stepernu command \n  Wire.write(stepnu);            // send the steps\n  Wire.write(Nothing);           // send nothing   \n  Wire.endTransmission();        // stop transmitting \n}\n     .......\n     .......\n     .......\n     .......\nvoid stepperrun()\n{\n Serial.println(\"sent command to + direction, very fast\");\n SteperStepset(255);\n StepperMotorEnable(1, 1);// ennable the i2c motor driver a stepper. \n  delay(5000);\n  Serial.println(\"sent command to - direction, slow\");\n  SteperStepset(255);\n  StepperMotorEnable(0, 20);\n  delay(5000);\n   Serial.println(\"sent command to - direction, fast\");\n  StepperMotorEnable(0, 2);// ennable the i2c motor driver a stepper. \n  delay(5000);\n Serial.println(\"sent command to + direction,100 steps, fast\");\n SteperStepset(100);\n  StepperMotorEnable(1,5);\n delay(3000);\n\u00a0\n Serial.println(\"sent command to shut down the stepper\");\n StepperMotorUnenable();\n delay(1000);\n\u00a0\n  Serial.println(\"sent command to - direction, slow, and 10 steps then stop\");\n SteperStepset(10);\n StepperMotorEnable(0,40);\n delay(5000);\n Serial.println(\"sent command to shut down the stepper\");\n StepperMotorUnenable();\n delay(5000);\n}\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000);\n  Serial.begin(9600);\n  Serial.println(\"setup begin\");\n  stepperrun();\n}\nvoid loop()  {\n\u00a0\n}\n\n\n\n\nIn this demo code, Arduino sends stepper-control command to I2C motor driver via I2C bus, with SteperStepset() to set the step number, and StepperMotorEnable() to set the direction and speed. Please refer to the \nFunction Reference\n for the details.\n\n\nNote that if you have I2C motor driver V1.2 and want to use the off-line Stepper control methods, you will need to upgrade your firmware in your V1.2 motor driver with a \nAVRISP\n and upload the .hex file to your I2C motor driver. Please download the .hex file and source code and related tips in the \nResources\n. \n\n\nFunction Reference\n\n\n1. void SteperStepset(unsigned char stepnu)\n\n\nDescription: Set the steps you want.\n\n\nstepnu: the Parameter can be 1~255. if 255, the stepper will rotate continuously;\n\n\nUsage:\n\n\nSerial.println(\"sent command to + direction,100 steps, fast\");\nSteperStepset(100);\n\n\n\n2. void StepperMotorEnable(unsigned char Direction, unsigned char motorspeed)\n\n\nDescription: Enable the IIC motor driver to drive a 4-wire stepper.\n\n\nDirection: Stepper direction 1/0\n\n\nmotorspeed: defines the time interval the i2C motor driver, Change it output to drive the stepper. The actual interval time is\u00a0: motorspeed * 4ms. That is , When motor speed is 10, the interval time would be 40 ms.\n\n\nUsage:\n\n\nStepperMotorEnable(1, 1);// enable the i2c motor driver a stepper.\n\n\n\n3. void StepperMotorUnenable()\n\n\nDescription: Uneanble IIC motor drive to drive the stepper.\n\n\nUsage:\n\n\nStepperMotorUnenable();\n\n\n\n4. void MotorSpeedSetAB(unsigned char MotorSpeedA , unsigned char MotorSpeedB)\n\n\nDescription: defines the speed of motor 1 and motor 2\n\n\nMotorSpeedA: the DC motor A speed, should be 0~100;\n\n\nMotorSpeedB: the DC motor B speed, should be 0~100;\n\n\nUsage:\n\n\nSerial.println(\"sent DC speed 100\");\nMotorSpeedSetAB(100,100);//defines the speed of motor 1 and motor 2;\ndelay(10); //this delay needed\n\n\n\n5. void MotorPWMFrequenceSet(unsigned char Frequence)\n\n\nDescription:set the prescale frequency of PWM, 0x03 default\n\n\nFrequency: the prescale frequency of PWM\n\n\n6. void MotorDirectionSet(unsigned char Direction)\n\n\nDescription: Adjust the direction of the motors\n\n\nDirection:can be Forward/Reverse rotating.\n\n\nUsage:\n\n\nMotorDirectionSet(0b1010);  //\"0b1010\" defines the output polarity, \"10\" means the M+ is \"positive\" while the M- is \"negative\"\n                         // make sure M+ and M- is different polarity when driving DC motors.\ndelay(1000); \nMotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\ndelay(500);\n\n\n\n7. void MotorDriectionAndSpeedSet(unsigned char Direction,unsigned char MotorSpeedA,unsigned char MotorSpeedB)\n\n\nDescription: Adjust the direction and speed altogether.\n\n\nResources\n\n\n\n\nGrove - I2C Motor Driver V1.3 Eagle File\n\n\nI2C Motor DriverV13 Demo Code\n\n\nL298 Datasheet\n\n\n78M05 Datasheet\n\n\nOn-Chip Firmware for I2C motor driver\n\n\n\n\nHelp us make it better",
            "title": "Grove I2C Motor Driver V1.3"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#grove-i2c-motor-driver-v13",
            "text": "",
            "title": "Grove - I2C Motor Driver V1.3"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#introduction",
            "text": "The Grove - I2C Motor Driver V1.3 (latest version) can directly control Stepper Motor or DC Motor. Its heart is a dual channel H-bridge driver chip\uff08L298N\uff09that can handle current up to 2A per channel, controlled by an Atmel ATmega8L which handles the I2C communication with for example an Arduino. Both motors can be driven simultaneously while set to a different speed and direction. It can power two brushed DC motors or one 4-wire two-phase stepper motor. It requires a 6V to 15V power supply to power the motor and has an onboard 5V voltage regulator which can power the I2C bus and the Arduino(selectable by jumper). All driver lines are protected by diodes from back-EMF.  Contrast to the  Grove - I2C motor driver V1.2 , the V1.3 enables users to control the stepper more easily. You do not need to control the steppers all the time anymore, simply send a command to I2C motor driver V1.3 to drive a stepper, and it will act as your command, which would save your Arduino resource and simplify your code.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#version-tracker",
            "text": "Revision  Descriptions  Release      v1.0  Initial public release  May 17th, 2012    v1.2  Modify the I2C address set by hardware  July 2nd, 2012    v1.3  Modify the firmware to support off-line Stepper  Feb 18th, 2013",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#features",
            "text": "Grove Compatible  I2C Interface  Adjustable motor speed and rotation direction  Changeable slave address by hardware",
            "title": "Features"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#specifications",
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n6  \n-  \n15  \nVDC    \nMax Output Current per channel  \n0.5  \nA    \nMaximum Total current  \n1.0  \nA    \nInput/output voltage on I2C bus  \n5  \nV    \nCommunication protocol  \nI2C  \n/",
            "title": "Specifications"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#hardware-overview",
            "text": "78M05 IC:  5V voltage regulator  L298 IC:  Dual full bridge driver  ATmega8 IC:  Control Motor Rotate.   Note \nInput voltage on screw terminals is regulated to 5V and connected to I2C +5V via a jumper (J4). Remove jumper if both external power via the screw terminals and power via the I2C header are used. Use jumper if 5V should be supplied to the I2C bus.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#application-ideas",
            "text": "Robots  Homebuilt RC cars  Case fans  High power LED illumination    Caution \nThe board will be very hot while operating over 1Amp. Do keep your hands off!",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#usage",
            "text": "The I2C Motor Driver can control motor which is based on the chip L298. The L298 isn\u2019t just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. Hooking up to a motor means you can have it spin in both directions; and with PWM input, you can use your Arduino to make them spin at any speed. Because the L298 has 2 H-bridges, you can make a robot turn around by spinning each wheel in different directions, and of course go forwards and backwards.  Now, let us use the I2C Motor Driver to control two DC motors or a stepper rotating clockwise and anticlockwise.",
            "title": "Usage"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#set-the-address-of-the-i2c-motor-driver",
            "text": "Set the address by dial switch is a new function added to the new I2C Motor Driver.     Then keep the address setup in the program the same as the address setup on the I2C motor driver. The default address setup in the program is 0x0f.    #define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver",
            "title": "Set the address of the I2C Motor Driver"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#how-to-drive-2-dc-motors",
            "text": "Note \nThe first thing to notice however, is that you need an external power source for your DC motors. The 5V pin on the Arduino cannot provide enough power to drive 2 motors, you may damage your Arduino if you do so.  And then program your Arduino as below:  #include <Wire.h>\n     .......\n     .......\n    < Driver functions >\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n  while(1)  {\n    MotorSpeedSetAB(100,20);\n    delay(10); //this delay needed\n    MotorDirectionSet(0b1010);  //0b1010  Rotating in the positive direction \n    delay(1000); \n    MotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\n    delay(500);\n  }\n}  In this program, Arduino first set the speed of the 2 DC motors with the  MotorSpeedSetAB() command, and then set the DC motors work directions with  MotorDirectionSet()  command. please refer to the  Function Reference  for details, you can download all the demo code in the  Resources .",
            "title": "How to drive 2 DC motors"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#how-to-drive-a-stepper-using-i2c-motor-driver-v13",
            "text": "As the upgraded version of  I2C motor DriverV1.2 , You can drive stepper via 2 methods for I2C motor driver V1.3.  1. Control the stepper directly by Arduino \nThe I2C motor Driver can also be used to drive a 4-wire stepper. Connect your stepper to the output pins of I2C motor driver, and then connect motor driver to your Arduino/Seeeduino with I2C bus. Program your Arduino as below:  #include <Wire.h>\n     .......\n     .......\n    < Driver functions >\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n while(1)  {\n    MotorSpeedSetAB(100,100);//when driving a stepper, the speed should be set to 100;\n    delay(10);\n    MotorDirectionSet(0b0001);\n    delay(4);\n      MotorDirectionSet(0b0011);\n    delay(4);  \n    MotorDirectionSet(0b0010);\n    delay(4);\n      MotorDirectionSet(0b0110);\n    delay(4);  \n    MotorDirectionSet(0b0100);\n    delay(4);  \n    MotorDirectionSet(0b1100);\n    delay(4);\n      MotorDirectionSet(0b1000);\n    delay(4);\n      MotorDirectionSet(0b1001);\n    delay(4);\n  }\n}  This connected 4-wire stepper will rotate; you can adjust the rotation speed or step number in your Arduino program. You can also use some other stepper libraries to control it. For all the demo code please refer to  Resources .   2. Control the Stepper using the I2C motor Driver V1.3 on-chip ATmega8L.  Take  24BYJ48  as an example, The hardware installation as shown below:   The connection between 24BYJ48 Stepper Motor and I2C Motor Driver is as shown below:   Download the  Grove-I2C motor driver V1.3 demo code , and open the  StepperControlMode2.ino :  #include <Wire.h>\n#define MotorSpeedSet             0x82\n#define PWMFrequenceSet           0x84\n#define DirectionSet              0xaa\n#define MotorSetA                 0xa1\n#define MotorSetB                 0xa5\n#define Nothing                   0x01\n#define EnableStepper             0x1a\n#define UnenableStepper           0x1b\n#define Stepernu                  0x1c\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n// set the steps you want, if 255, the stepper will rotate continuously;\nvoid SteperStepset(unsigned char stepnu)\n{\n  Wire.beginTransmission(I2CMotorDriverAdd); // transmit to device I2CMotorDriverAdd\n  Wire.write(Stepernu);          // Send the stepernu command \n  Wire.write(stepnu);            // send the steps\n  Wire.write(Nothing);           // send nothing   \n  Wire.endTransmission();        // stop transmitting \n}\n     .......\n     .......\n     .......\n     .......\nvoid stepperrun()\n{\n Serial.println(\"sent command to + direction, very fast\");\n SteperStepset(255);\n StepperMotorEnable(1, 1);// ennable the i2c motor driver a stepper. \n  delay(5000);\n  Serial.println(\"sent command to - direction, slow\");\n  SteperStepset(255);\n  StepperMotorEnable(0, 20);\n  delay(5000);\n   Serial.println(\"sent command to - direction, fast\");\n  StepperMotorEnable(0, 2);// ennable the i2c motor driver a stepper. \n  delay(5000);\n Serial.println(\"sent command to + direction,100 steps, fast\");\n SteperStepset(100);\n  StepperMotorEnable(1,5);\n delay(3000);\n\u00a0\n Serial.println(\"sent command to shut down the stepper\");\n StepperMotorUnenable();\n delay(1000);\n\u00a0\n  Serial.println(\"sent command to - direction, slow, and 10 steps then stop\");\n SteperStepset(10);\n StepperMotorEnable(0,40);\n delay(5000);\n Serial.println(\"sent command to shut down the stepper\");\n StepperMotorUnenable();\n delay(5000);\n}\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000);\n  Serial.begin(9600);\n  Serial.println(\"setup begin\");\n  stepperrun();\n}\nvoid loop()  {\n\u00a0\n}  In this demo code, Arduino sends stepper-control command to I2C motor driver via I2C bus, with SteperStepset() to set the step number, and StepperMotorEnable() to set the direction and speed. Please refer to the  Function Reference  for the details.  Note that if you have I2C motor driver V1.2 and want to use the off-line Stepper control methods, you will need to upgrade your firmware in your V1.2 motor driver with a  AVRISP  and upload the .hex file to your I2C motor driver. Please download the .hex file and source code and related tips in the  Resources .",
            "title": "How to drive a stepper using I2C motor driver V1.3"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#function-reference",
            "text": "1. void SteperStepset(unsigned char stepnu)  Description: Set the steps you want.  stepnu: the Parameter can be 1~255. if 255, the stepper will rotate continuously;  Usage:  Serial.println(\"sent command to + direction,100 steps, fast\");\nSteperStepset(100);  2. void StepperMotorEnable(unsigned char Direction, unsigned char motorspeed)  Description: Enable the IIC motor driver to drive a 4-wire stepper.  Direction: Stepper direction 1/0  motorspeed: defines the time interval the i2C motor driver, Change it output to drive the stepper. The actual interval time is\u00a0: motorspeed * 4ms. That is , When motor speed is 10, the interval time would be 40 ms.  Usage:  StepperMotorEnable(1, 1);// enable the i2c motor driver a stepper.  3. void StepperMotorUnenable()  Description: Uneanble IIC motor drive to drive the stepper.  Usage:  StepperMotorUnenable();  4. void MotorSpeedSetAB(unsigned char MotorSpeedA , unsigned char MotorSpeedB)  Description: defines the speed of motor 1 and motor 2  MotorSpeedA: the DC motor A speed, should be 0~100;  MotorSpeedB: the DC motor B speed, should be 0~100;  Usage:  Serial.println(\"sent DC speed 100\");\nMotorSpeedSetAB(100,100);//defines the speed of motor 1 and motor 2;\ndelay(10); //this delay needed  5. void MotorPWMFrequenceSet(unsigned char Frequence)  Description:set the prescale frequency of PWM, 0x03 default  Frequency: the prescale frequency of PWM  6. void MotorDirectionSet(unsigned char Direction)  Description: Adjust the direction of the motors  Direction:can be Forward/Reverse rotating.  Usage:  MotorDirectionSet(0b1010);  //\"0b1010\" defines the output polarity, \"10\" means the M+ is \"positive\" while the M- is \"negative\"\n                         // make sure M+ and M- is different polarity when driving DC motors.\ndelay(1000); \nMotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\ndelay(500);  7. void MotorDriectionAndSpeedSet(unsigned char Direction,unsigned char MotorSpeedA,unsigned char MotorSpeedB)  Description: Adjust the direction and speed altogether.",
            "title": "Function Reference"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#resources",
            "text": "Grove - I2C Motor Driver V1.3 Eagle File  I2C Motor DriverV13 Demo Code  L298 Datasheet  78M05 Datasheet  On-Chip Firmware for I2C motor driver",
            "title": "Resources"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/",
            "text": "Grove - I2C Touch Sensor\n\n\n\n\nIntroduction\n\n\nThe I2C Touch Sensor is based on the Proximity Capacitive Touch Sensor Controller from FreeScale - MPR121. It detects the touch or proximity of human fingers. This sensor includes a Touch Sensor controller and 4 finger feelers. One can insert the connectors of feelers into base of Sensor controller, and start sensing the touch. \n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nParameter\n\n\nValue/Range\n\n\n\n\n\n\n\n\n\n\nOperating voltage\n\n\n3~5.5V\n\n\n\n\n\n\nStandby Mode Current\n\n\n2\u03bcA\n\n\n\n\n\n\nTouch Channels\n\n\n12 (Including 4 with Touch feelers)\n\n\n\n\n\n\nCommunicating Protocol\n\n\nI2C\n\n\n\n\n\n\nI2C Address\n\n\n0x5A - 0x5D\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nThere are 12 electrodes CH0-CH11. CH0-CH3 are connected to 4 Touch feelers.\n\n\nThe CH4-CH11 are for customer expanding the function. If you need more, you can make the feelers by yourself.\n\n\nThe wires of feelers are twisted to reduce the impact of environment. The black(ground) wire can be cut off if high sensitivity is needed.\n\n\nThe INT pin has to be led out if customers want to use the interrupt pin of MPR121.\n\n\nGetting Started\n\n\nGrove - Help\n\n\nFollowing documents help in getting the user started with Grove.\n\n\n\n\nPreface - Getting Started\n\n\nIntroduction to Grove\n\n\n\n\n\n\nNote\n\nSince each electrode needs to be auto-configured by the MPR121 during power up and there is no power reset on the touch sensor controller, everytime you insert or remove a feeler, you need to reset the power of Seeeduino.\n\n\n\n\nThe feelers can also feel the human being fingers with something between, that's to say, you do not need to touch the feelers with your fingers indeed.\n\n\n\n\n\n\nWith a paperboard about 3 mm thick, the feeler can feel the touch of fingers, makes it a good solution for many applications.\n\n\nResources\n\n\n\n\nI2C Touch Sensor Library\n\n\nI2C Touch Sensor eagle files(v1.1).zip\n\n\nI2C Touch Sensor PDF\n\n\nHow to detect finger touch?\n\n\nI2C Touch Sensor Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove I2C Touch Sensor"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#grove-i2c-touch-sensor",
            "text": "",
            "title": "Grove - I2C Touch Sensor"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#introduction",
            "text": "The I2C Touch Sensor is based on the Proximity Capacitive Touch Sensor Controller from FreeScale - MPR121. It detects the touch or proximity of human fingers. This sensor includes a Touch Sensor controller and 4 finger feelers. One can insert the connectors of feelers into base of Sensor controller, and start sensing the touch.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#specifications",
            "text": "Parameter  Value/Range      Operating voltage  3~5.5V    Standby Mode Current  2\u03bcA    Touch Channels  12 (Including 4 with Touch feelers)    Communicating Protocol  I2C    I2C Address  0x5A - 0x5D",
            "title": "Specifications"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#hardware-overview",
            "text": "There are 12 electrodes CH0-CH11. CH0-CH3 are connected to 4 Touch feelers.  The CH4-CH11 are for customer expanding the function. If you need more, you can make the feelers by yourself.  The wires of feelers are twisted to reduce the impact of environment. The black(ground) wire can be cut off if high sensitivity is needed.  The INT pin has to be led out if customers want to use the interrupt pin of MPR121.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#grove-help",
            "text": "Following documents help in getting the user started with Grove.   Preface - Getting Started  Introduction to Grove    Note \nSince each electrode needs to be auto-configured by the MPR121 during power up and there is no power reset on the touch sensor controller, everytime you insert or remove a feeler, you need to reset the power of Seeeduino.  The feelers can also feel the human being fingers with something between, that's to say, you do not need to touch the feelers with your fingers indeed.    With a paperboard about 3 mm thick, the feeler can feel the touch of fingers, makes it a good solution for many applications.",
            "title": "Grove - Help"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#resources",
            "text": "I2C Touch Sensor Library  I2C Touch Sensor eagle files(v1.1).zip  I2C Touch Sensor PDF  How to detect finger touch?  I2C Touch Sensor Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-IMU_10DOF/",
            "text": "Grove - IMU 10DOF\n\n\n\n\nIntroduction\n\n\nGrove - IMU 10DOF is a combination of \nGrove - IMU 9DOF\n and \nGrove - Barometer Sensor (BMP180)\n. This module is base on MPU-9250 and BMP180, the MPU-9250 is a 9-axis MotionTracking device that combines a 3-axis gyroscope, 3-axis accelerometer, 3-axis magnetometer and a Digital Motion Processor(DMP), and BMP180 is a high precision, ultra-low power digital pressure sensors for consumer applications. This module is very suitable for the application of smartphones, tablets and wearable devices.\n\n\n\n\nSpecifications\n\n\n\n\nI2C interface\n\n\nMPU-9250 I2C address selectable\n\n\nLow Power Consumption\n\n\n400kHz Fast Mode I2C for communicating with all registers\n\n\nDigital-output X-, Y-, and Z-Axis angular rate sensors (gyroscopes) with a user-programmable full-scale range of \u00b1250, \u00b1500, \u00b11000, and \u00b12000\u00b0/sec\n\n\nDigital-output 3-Axis accelerometer with a programmable full scale range of \u00b12g, \u00b14g, \u00b18g and \u00b116g\n\n\nDigital-output magnetometer with a full scale range of \u00b14800uT\n\n\nDigital-output barometer with range of 300 ~ 1100hPa(+9000m ~ -500m relating to sea level)\n\n\nDimensions: 25.43mm x 20.35mm\n\n\n\n\nHardware Overview\n\n\n\n\n\n\n1\uff1aMPU-9250 I2C address select Pad, default connected \na\n and \nb\n address is 0x68, if connect \nb\n and \nc\n address is 0x69\n\n\n2\uff1aMPU-9250 interrupt pin, the interrupt should be configured, available interrupt sources are: motion detection, fifo overflow, data ready, i2c master error\n\n\n\n\nUsage\n\n\nWe will provide an example here to show you how to use this sensor.\n\n\nHardware Installation\n\n\n\n\nSoftware Setup\n\n\n\n\nDownload the library from \nhttps://github.com/Seeed-Studio/IMU_10DOF\n.\n\n\nUnzip it into the libraries file of Arduino IDE by the path.\n\n\nOpen the code directly by the path: File -> Example -> IMU_10DOF_Test.\n\n\nUpload the code. Note that you should select the correct board type and COM port.\n\n\n\n\nYou can see:\n\n\n\nOrientation of Axes\n\nThe diagram below shows the orientation of the axes of sensitivity and the polarity of rotation.\n\n\n\nResources\n\n\n\n\nGrove - IMU 10DOF v1.0 eagle file\n\n\nGrove - IMU 10DOF v1.0 schematics pdf file\n\n\nGrove - IMU 10DOF v1.1 eagle file\n\n\nGet library from github\n\n\nBMP180 datasheet\n\n\nMPU-9250 datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove IMU 10DOF"
        },
        {
            "location": "/Grove-IMU_10DOF/#grove-imu-10dof",
            "text": "",
            "title": "Grove - IMU 10DOF"
        },
        {
            "location": "/Grove-IMU_10DOF/#introduction",
            "text": "Grove - IMU 10DOF is a combination of  Grove - IMU 9DOF  and  Grove - Barometer Sensor (BMP180) . This module is base on MPU-9250 and BMP180, the MPU-9250 is a 9-axis MotionTracking device that combines a 3-axis gyroscope, 3-axis accelerometer, 3-axis magnetometer and a Digital Motion Processor(DMP), and BMP180 is a high precision, ultra-low power digital pressure sensors for consumer applications. This module is very suitable for the application of smartphones, tablets and wearable devices.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-IMU_10DOF/#specifications",
            "text": "I2C interface  MPU-9250 I2C address selectable  Low Power Consumption  400kHz Fast Mode I2C for communicating with all registers  Digital-output X-, Y-, and Z-Axis angular rate sensors (gyroscopes) with a user-programmable full-scale range of \u00b1250, \u00b1500, \u00b11000, and \u00b12000\u00b0/sec  Digital-output 3-Axis accelerometer with a programmable full scale range of \u00b12g, \u00b14g, \u00b18g and \u00b116g  Digital-output magnetometer with a full scale range of \u00b14800uT  Digital-output barometer with range of 300 ~ 1100hPa(+9000m ~ -500m relating to sea level)  Dimensions: 25.43mm x 20.35mm",
            "title": "Specifications"
        },
        {
            "location": "/Grove-IMU_10DOF/#hardware-overview",
            "text": "1\uff1aMPU-9250 I2C address select Pad, default connected  a  and  b  address is 0x68, if connect  b  and  c  address is 0x69  2\uff1aMPU-9250 interrupt pin, the interrupt should be configured, available interrupt sources are: motion detection, fifo overflow, data ready, i2c master error",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-IMU_10DOF/#usage",
            "text": "We will provide an example here to show you how to use this sensor.",
            "title": "Usage"
        },
        {
            "location": "/Grove-IMU_10DOF/#hardware-installation",
            "text": "",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-IMU_10DOF/#software-setup",
            "text": "Download the library from  https://github.com/Seeed-Studio/IMU_10DOF .  Unzip it into the libraries file of Arduino IDE by the path.  Open the code directly by the path: File -> Example -> IMU_10DOF_Test.  Upload the code. Note that you should select the correct board type and COM port.   You can see:  Orientation of Axes \nThe diagram below shows the orientation of the axes of sensitivity and the polarity of rotation.",
            "title": "Software Setup"
        },
        {
            "location": "/Grove-IMU_10DOF/#resources",
            "text": "Grove - IMU 10DOF v1.0 eagle file  Grove - IMU 10DOF v1.0 schematics pdf file  Grove - IMU 10DOF v1.1 eagle file  Get library from github  BMP180 datasheet  MPU-9250 datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-IMU_10DOF/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-NFC_Tag/",
            "text": "Grove - NFC Tag\n\n\n\n\nIntroduction\n\n\nGrove - NFC Tag is a highly integrated Near Field Communication Tag module,this module is I2C interface,which base on M24LR64E-R,M24LR64E-R have a 64-bit unique identifier and 64 -Kbit EEPROM.Grove - NFC Tag attach an independent PCB antenna which can easily stretch out of any enclosure you use, leaving more room for you to design the exterior of your project.\n\n\n\n\nSpecifications\n\n\n\n\nWorking Voltage:5V or 3V3\n\n\nWorking Current<1mA\n\n\nEffective range<2cm\n\n\nServe for contactless communication at 13.56MHz\n\n\nISO 15693 and ISO 18000-3 mode 1 compatible\n\n\n64-bit unique identifier (UID)\n\n\nRead Block & Write (32-bit blocks)\n\n\nGrove I2C Interface\n\n\n\n\nUsage\n\n\nRead/Write from Mobile\n\n\n\n\nDownload \nNfcV-reader for Android\n and install it\n\n\nWe can Read/Write it from Mobile\n\n\n\n\n\n\n\n\n\n\n\n\nControl LED\n\n\n\n\nHardware Installation\n\n\n\n\n\n\n\n\nDownload \nNfcV-reader for Android\n and install it\n\n\nDownload \nNFC Tag Lib\n, rename it to NFC_Tag_M24LR6E and put it into Arduino's library .\n\n\nOpen Arduino IDE. If Arduino IDE is already opened, restart it.\n\n\nIn Arduino IDE, click menus: File -> Example -> NFC_Tag_M24LR6E -> ledControl\n\n\nNow, you can control LED from your phone.\n\n\n\n\n\u00a0\n#include \"NfcTag.h\"\n#include <Wire.h>\n\u00a0\nNfcTag nfcTag;\nint led = 5;\nbool flag = false;\nbool preFlag = false;\nvoid setup(){\n  Serial.begin(9600);\n  pinMode(led,OUTPUT);\n  nfcTag.init();\n}\n\u00a0\nvoid loop(){\n  flag = nfcTag.readByte(EEPROM_I2C_LENGTH-1) == 0xff?true:false;\n  if(flag != preFlag){\n    Serial.println(\"get remote NFC control signal!\");\n    if(flag == true){\n      Serial.println(\"led will light up!\");\n      digitalWrite(led,HIGH);\n    }else{\n      Serial.println(\"led will turn dark!\");\n      digitalWrite(led,LOW);\n    }\n    preFlag = flag;\n  }\n  delay(5*1000);\n}\n\n\n\n\nResources\n\n\n\n\nGrove - NFC Tag.PDF\n\n\nGrove - NFC Tag Eagle file\n\n\nM24LR64E-R datasheet.pdf\n\n\nNfcV-reader for Android\n\n\nNFC Tag M24LR6E Lib\n\n\n\n\nHelp us make it better",
            "title": "Grove NFC Tag"
        },
        {
            "location": "/Grove-NFC_Tag/#grove-nfc-tag",
            "text": "",
            "title": "Grove - NFC Tag"
        },
        {
            "location": "/Grove-NFC_Tag/#introduction",
            "text": "Grove - NFC Tag is a highly integrated Near Field Communication Tag module,this module is I2C interface,which base on M24LR64E-R,M24LR64E-R have a 64-bit unique identifier and 64 -Kbit EEPROM.Grove - NFC Tag attach an independent PCB antenna which can easily stretch out of any enclosure you use, leaving more room for you to design the exterior of your project.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-NFC_Tag/#specifications",
            "text": "Working Voltage:5V or 3V3  Working Current<1mA  Effective range<2cm  Serve for contactless communication at 13.56MHz  ISO 15693 and ISO 18000-3 mode 1 compatible  64-bit unique identifier (UID)  Read Block & Write (32-bit blocks)  Grove I2C Interface",
            "title": "Specifications"
        },
        {
            "location": "/Grove-NFC_Tag/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/Grove-NFC_Tag/#readwrite-from-mobile",
            "text": "Download  NfcV-reader for Android  and install it  We can Read/Write it from Mobile",
            "title": "Read/Write from Mobile"
        },
        {
            "location": "/Grove-NFC_Tag/#control-led",
            "text": "Hardware Installation     Download  NfcV-reader for Android  and install it  Download  NFC Tag Lib , rename it to NFC_Tag_M24LR6E and put it into Arduino's library .  Open Arduino IDE. If Arduino IDE is already opened, restart it.  In Arduino IDE, click menus: File -> Example -> NFC_Tag_M24LR6E -> ledControl  Now, you can control LED from your phone.   \u00a0\n#include \"NfcTag.h\"\n#include <Wire.h>\n\u00a0\nNfcTag nfcTag;\nint led = 5;\nbool flag = false;\nbool preFlag = false;\nvoid setup(){\n  Serial.begin(9600);\n  pinMode(led,OUTPUT);\n  nfcTag.init();\n}\n\u00a0\nvoid loop(){\n  flag = nfcTag.readByte(EEPROM_I2C_LENGTH-1) == 0xff?true:false;\n  if(flag != preFlag){\n    Serial.println(\"get remote NFC control signal!\");\n    if(flag == true){\n      Serial.println(\"led will light up!\");\n      digitalWrite(led,HIGH);\n    }else{\n      Serial.println(\"led will turn dark!\");\n      digitalWrite(led,LOW);\n    }\n    preFlag = flag;\n  }\n  delay(5*1000);\n}",
            "title": "Control LED"
        },
        {
            "location": "/Grove-NFC_Tag/#resources",
            "text": "Grove - NFC Tag.PDF  Grove - NFC Tag Eagle file  M24LR64E-R datasheet.pdf  NfcV-reader for Android  NFC Tag M24LR6E Lib",
            "title": "Resources"
        },
        {
            "location": "/Grove-NFC_Tag/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Speaker/",
            "text": "Grove - Speaker\n\n\n\n\nIntroduction\n\n\nThe Grove- Speaker is a module which consists of power amplification and voice outputs. The loudness can be adjusted by the on-board potentiometer. With different input frequencies, the loud-speaker generates different tones. Coding the music into arduino, DIY your own music box!\n\n\n\n\nFeatures\n\n\n\n\nVolume Adjustable\n\n\nGrove Interface\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n4.0\n\n\n5.0\n\n\n5.5\n\n\nVDC\n\n\n\n\n\n\nVoltage Gain\n\n\n-\n\n\n-\n\n\n46\n\n\ndb\n\n\n\n\n\n\nBand Width\n\n\n-\n\n\n-\n\n\n20\n\n\nKHz\n\n\n\n\n\n\n\n\nUsage\n\n\nThe speaker can emit a variety of sounds like a car horn, doorbell and ignition . The different sounds are based on the frequency of the input signal.\n\n\nYou can supply different frequency signal to this module with Arduino. Arduino generates these signal via PWM or even digital write and delay.Here we are going to show you how to generate these signals using \ndelay()\n, the speaker sound bass 1~7.\n\n\n\n\n/*macro definition of Speaker pin*/\n#define SPEAKER 3\n\nint BassTab[]={1911,1702,1516,1431,1275,1136,1012};//bass 1~7\n\nvoid setup() \n{\n    pinInit();\n}\nvoid loop()\n{\n    /*sound bass 1~7*/\n    for(int note_index=0;note_index<7;note_index++)\n    {\n        sound(note_index);\n        delay(500);\n    }\n}\nvoid pinInit()\n{\n    pinMode(SPEAKER,OUTPUT);\n    digitalWrite(SPEAKER,LOW);\n}\nvoid sound(uint8_t note_index)\n{\n    for(int i=0;i<100;i++)   \n    {\n        digitalWrite(SPEAKER,HIGH);\n        delayMicroseconds(BassTab[note_index]);\n        digitalWrite(SPEAKER,LOW);\n        delayMicroseconds(BassTab[note_index]);\n    }\n}\n\n\n\n\n\nNote\n\nDue to the influence of the capacitance, the module can only output the bass signal, and the treble is unable to emit.\n\n\n\n\nResources\n\n\n\n\nGrove - Speaker Eagle File\n\n\nHow to generate different tone with MCU\n\n\nGrove_-_Speaker_v1.0_brd.pdf\n\n\nGrove_-_Speaker_v1.0_sch.pdf\n\n\nLM386 Low Voltage Audio Power Amplifier Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Speaker"
        },
        {
            "location": "/Grove-Speaker/#grove-speaker",
            "text": "",
            "title": "Grove - Speaker"
        },
        {
            "location": "/Grove-Speaker/#introduction",
            "text": "The Grove- Speaker is a module which consists of power amplification and voice outputs. The loudness can be adjusted by the on-board potentiometer. With different input frequencies, the loud-speaker generates different tones. Coding the music into arduino, DIY your own music box!",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Speaker/#features",
            "text": "Volume Adjustable  Grove Interface",
            "title": "Features"
        },
        {
            "location": "/Grove-Speaker/#specifications",
            "text": "Item  Min  Typical  Max  Unit      Working Voltage  4.0  5.0  5.5  VDC    Voltage Gain  -  -  46  db    Band Width  -  -  20  KHz",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Speaker/#usage",
            "text": "The speaker can emit a variety of sounds like a car horn, doorbell and ignition . The different sounds are based on the frequency of the input signal.  You can supply different frequency signal to this module with Arduino. Arduino generates these signal via PWM or even digital write and delay.Here we are going to show you how to generate these signals using  delay() , the speaker sound bass 1~7.   /*macro definition of Speaker pin*/\n#define SPEAKER 3\n\nint BassTab[]={1911,1702,1516,1431,1275,1136,1012};//bass 1~7\n\nvoid setup() \n{\n    pinInit();\n}\nvoid loop()\n{\n    /*sound bass 1~7*/\n    for(int note_index=0;note_index<7;note_index++)\n    {\n        sound(note_index);\n        delay(500);\n    }\n}\nvoid pinInit()\n{\n    pinMode(SPEAKER,OUTPUT);\n    digitalWrite(SPEAKER,LOW);\n}\nvoid sound(uint8_t note_index)\n{\n    for(int i=0;i<100;i++)   \n    {\n        digitalWrite(SPEAKER,HIGH);\n        delayMicroseconds(BassTab[note_index]);\n        digitalWrite(SPEAKER,LOW);\n        delayMicroseconds(BassTab[note_index]);\n    }\n}   Note \nDue to the influence of the capacitance, the module can only output the bass signal, and the treble is unable to emit.",
            "title": "Usage"
        },
        {
            "location": "/Grove-Speaker/#resources",
            "text": "Grove - Speaker Eagle File  How to generate different tone with MCU  Grove_-_Speaker_v1.0_brd.pdf  Grove_-_Speaker_v1.0_sch.pdf  LM386 Low Voltage Audio Power Amplifier Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Speaker/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Switch-P/",
            "text": "Grove - Switch(P)\n\n\n\n\n\n\nIntroduction\n\n\nThis Grove \u2013 Switch is a mini SPDT slide, great for \u201cON/OFF\u201d situations. It is such a reliable switch of great build quality that we adopt it on many of our boards. You should stock some for your Grove prototyping system.\n\n\nWhat does \u201cP\u201d mean? \u201cP\u201d is for \u201cpanel mount\u201d in this product.\n\n\n\n\nFeatures\n\n\n\n\nGrove Interface\n\n\nEasy to use\n\n\nBasic Grove element\n\n\n\n\nUsage\n\n\nBelow is a simple example showing how to use a switch to turn on/off an LED.The working principle and use just the same as the \nGrove-Button\n.\n\n\n\n\nConnect the Grove-LED to the Digital 13 of Grove - Basic Shield and connect the Grove -Switch(P) to the Digital 2 of \nGrove-Base Shield\n with two Grove cables.\n\n\nPlug the Grove - Base Shield into Arduino and connect Arduino to PC by using a USB cable.\n\n\nCopy and paste code below to a new Arduino sketch. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n    // constants won't change. They're used here to \n    // set pin numbers:\n    const int switchPin = 2;     // the number of the pushbutton pin\n    const int ledPin =  13;      // the number of the LED pin\n\n    // variables will change:\n    int switchState = 0;         // variable for reading the pushbutton status\n\n    void setup() {\n      // initialize the LED pin as an output:\n      //pinMode(ledPin, OUTPUT);      \n      // initialize the switch pin as an input:\n      Serial.begin(9600);\n      pinMode(switchPin, INPUT);     \n    }\n    void loop(){\n      // read the state of the switch value:\n      switchState = digitalRead(switchPin);\n\n\n      if (switchState == HIGH) {     \n        // turn LED on:    \n       // digitalWrite(ledPin, HIGH);  \n       Serial.println(\"switch high!\");\n      } \n      else {\n        // turn LED off:\n       // digitalWrite(ledPin, LOW); \n       Serial.println(\"switch low\");\n      }\n    }\n\n\n\n\n\nAfter uploading the code, you can see the led will light up when the switch is at \nhigh\n side.\n\n\nResources\n\n\n\n\nGrove - Switch(P) Eagle File\n\n\n\n\nHelp us make it better",
            "title": "Grove Switch P"
        },
        {
            "location": "/Grove-Switch-P/#grove-switchp",
            "text": "",
            "title": "Grove - Switch(P)"
        },
        {
            "location": "/Grove-Switch-P/#introduction",
            "text": "This Grove \u2013 Switch is a mini SPDT slide, great for \u201cON/OFF\u201d situations. It is such a reliable switch of great build quality that we adopt it on many of our boards. You should stock some for your Grove prototyping system.  What does \u201cP\u201d mean? \u201cP\u201d is for \u201cpanel mount\u201d in this product.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Switch-P/#features",
            "text": "Grove Interface  Easy to use  Basic Grove element",
            "title": "Features"
        },
        {
            "location": "/Grove-Switch-P/#usage",
            "text": "Below is a simple example showing how to use a switch to turn on/off an LED.The working principle and use just the same as the  Grove-Button .   Connect the Grove-LED to the Digital 13 of Grove - Basic Shield and connect the Grove -Switch(P) to the Digital 2 of  Grove-Base Shield  with two Grove cables.  Plug the Grove - Base Shield into Arduino and connect Arduino to PC by using a USB cable.  Copy and paste code below to a new Arduino sketch. Please click  here  if you do not know how to upload.   \n    // constants won't change. They're used here to \n    // set pin numbers:\n    const int switchPin = 2;     // the number of the pushbutton pin\n    const int ledPin =  13;      // the number of the LED pin\n\n    // variables will change:\n    int switchState = 0;         // variable for reading the pushbutton status\n\n    void setup() {\n      // initialize the LED pin as an output:\n      //pinMode(ledPin, OUTPUT);      \n      // initialize the switch pin as an input:\n      Serial.begin(9600);\n      pinMode(switchPin, INPUT);     \n    }\n    void loop(){\n      // read the state of the switch value:\n      switchState = digitalRead(switchPin);\n\n\n      if (switchState == HIGH) {     \n        // turn LED on:    \n       // digitalWrite(ledPin, HIGH);  \n       Serial.println(\"switch high!\");\n      } \n      else {\n        // turn LED off:\n       // digitalWrite(ledPin, LOW); \n       Serial.println(\"switch low\");\n      }\n    }  After uploading the code, you can see the led will light up when the switch is at  high  side.",
            "title": "Usage"
        },
        {
            "location": "/Grove-Switch-P/#resources",
            "text": "Grove - Switch(P) Eagle File",
            "title": "Resources"
        },
        {
            "location": "/Grove-Switch-P/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Touch_Sensor/",
            "text": "Grove - Touch Sensor\n\n\n\n\nIntroduction\n\n\nGrove - Touch Sensor enables you to replace press with touch. It can detect the change in capacitance when a finger is near by. That means no matter your finger directly touches the pad or just stays close to the pad, Grove - Touch Sensor would outputs HIGH also.\n\n\n\n\nSpecifications\n\n\n\n\nOperating Voltage: 2.0 - 5.5V\n\n\nOperating Current(Vcc=3V):1.5 - 3.0\u03bcA\n\n\nOperating Current(VDD=3V):3.5 - 7.0\u03bcA\n\n\nOutput Response Time: 60 - 220mS\n\n\nUsed Chipset: TTP223-BA6\n\n\n\n\nOption features\n\n\n\n\n\n\n\n\nAHLB\n\n\nTOG\n\n\nLPMB\n\n\nMOTB\n\n\nSLRFTB\n\n\nRST\n\n\nQ\n\n\nOPDO\n\n\n\n\n\n\n\n\n\n\nOutput Active High / Low\n\n\nToggle mode\n\n\nPower Mode\n\n\nMax. On Time\n\n\nSampling length\n\n\nRESET PIN\n\n\nCMOS Output\n\n\nOpen Drain Mode\n\n\n\n\n\n\nV\n\n\nV\n\n\n0\n\n\n1\n\n\n1\n\n\nX\n\n\nV\n\n\nX\n\n\n\n\n\n\nActive High\n\n\nDisabled\n\n\nLOW\n\n\nInfinite\n\n\n1.6 msec\n\n\nN/A\n\n\nPresent\n\n\nN/A\n\n\n\n\n\n\n\n\nDemonstration\n\n\nWith \nArduino\n\n\n\nThis demo is going to show you how to turn on/off an LED.\n\n\nDemo Code:\n\n\nconst int TouchPin=9;\nconst int ledPin=12;\nvoid setup() {\npinMode(TouchPin, INPUT);\npinMode(ledPin,OUTPUT);\n} \n\u00a0\nvoid loop() {\nint sensorValue = digitalRead(TouchPin);\nif(sensorValue==1)\n{\ndigitalWrite(ledPin,HIGH);\n}\nelse\n{\ndigitalWrite(ledPin,LOW);\n}\n}\n\n\n\n\nWith \nRaspberry Pi\n\n\n\n\nYou should have a raspberry pi and a grovepi or grovepi+.\n\n\nYou should have completed configuring the development environment, otherwise follow \nhere\n.\n\n\n\n\nConnection\n\n\n\n\nPlug the sensor to grovepi socket D4 by using a grove cable.\n\n\n\n\n\n\n\n\nNavigate to the demos' directory:\n\n\n\n\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_touch_sensor.py   # \"Ctrl+x\" to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Touch Sensor to digital port D4\n    # SIG,NC,VCC,GND\n    touch_sensor = 4\n\n    grovepi.pinMode(touch_sensor,\"INPUT\")\n\n    while True:\n        try:\n            print grovepi.digitalRead(touch_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print \"Error\"\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_touch_sensor.py\n\n\n\nResources\n\n\n\n\nEagle Files\n\n\nTTP223pdf\n\n\nhow to upload code\n\n\n\n\nHelp us make it better",
            "title": "Grove Touch Sensor"
        },
        {
            "location": "/Grove-Touch_Sensor/#grove-touch-sensor",
            "text": "",
            "title": "Grove - Touch Sensor"
        },
        {
            "location": "/Grove-Touch_Sensor/#introduction",
            "text": "Grove - Touch Sensor enables you to replace press with touch. It can detect the change in capacitance when a finger is near by. That means no matter your finger directly touches the pad or just stays close to the pad, Grove - Touch Sensor would outputs HIGH also.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Touch_Sensor/#specifications",
            "text": "Operating Voltage: 2.0 - 5.5V  Operating Current(Vcc=3V):1.5 - 3.0\u03bcA  Operating Current(VDD=3V):3.5 - 7.0\u03bcA  Output Response Time: 60 - 220mS  Used Chipset: TTP223-BA6   Option features     AHLB  TOG  LPMB  MOTB  SLRFTB  RST  Q  OPDO      Output Active High / Low  Toggle mode  Power Mode  Max. On Time  Sampling length  RESET PIN  CMOS Output  Open Drain Mode    V  V  0  1  1  X  V  X    Active High  Disabled  LOW  Infinite  1.6 msec  N/A  Present  N/A",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Touch_Sensor/#demonstration",
            "text": "",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-Touch_Sensor/#with-arduino",
            "text": "This demo is going to show you how to turn on/off an LED.  Demo Code:  const int TouchPin=9;\nconst int ledPin=12;\nvoid setup() {\npinMode(TouchPin, INPUT);\npinMode(ledPin,OUTPUT);\n} \n\u00a0\nvoid loop() {\nint sensorValue = digitalRead(TouchPin);\nif(sensorValue==1)\n{\ndigitalWrite(ledPin,HIGH);\n}\nelse\n{\ndigitalWrite(ledPin,LOW);\n}\n}",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-Touch_Sensor/#with-raspberry-pi",
            "text": "You should have a raspberry pi and a grovepi or grovepi+.  You should have completed configuring the development environment, otherwise follow  here .   Connection   Plug the sensor to grovepi socket D4 by using a grove cable.     Navigate to the demos' directory:        cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_touch_sensor.py   # \"Ctrl+x\" to exit #      import time\n    import grovepi\n\n    # Connect the Grove Touch Sensor to digital port D4\n    # SIG,NC,VCC,GND\n    touch_sensor = 4\n\n    grovepi.pinMode(touch_sensor,\"INPUT\")\n\n    while True:\n        try:\n            print grovepi.digitalRead(touch_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print \"Error\"  5.Run the demo.      sudo python grove_touch_sensor.py",
            "title": "With Raspberry Pi"
        },
        {
            "location": "/Grove-Touch_Sensor/#resources",
            "text": "Eagle Files  TTP223pdf  how to upload code",
            "title": "Resources"
        },
        {
            "location": "/Grove-Touch_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Variable_Color_LED/",
            "text": "Grove - Variable Color LED\n\n\n \n\n\nIntroduction\n\n\nThis Grove consists of one 8mm RGB LED. It operates at 5V DC. When SIG pin is logic HIGH, the RGB LED will light up. Perfect for use on Seeeduino digital outputs, or also can be controlled by pulse-width modulation. And it uses three adjustable resistor to change the color of the RGB LED.\n\n\n\n\nFeatures\n\n\n\n\nGrove compatible\n\n\nColor adjustable\n\n\n\n\nApplication Ideas\n\n\n\n\nToys\n\n\nDecoration\n\n\n\n\n\n\nCaution\n\nBe gentle while adjusting the R, G and B adjustable resistances in case of over-turning.\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nOperate Voltage\n\n\n5.0\n\n\nVDC\n\n\n\n\n\n\nWorking Current\n\n\n20\n\n\nmA\n\n\n\n\n\n\nVariable Resistor\n\n\n<1\n\n\nK\u03a9\n\n\n\n\n\n\n\n\nUsage\n\n\nThe three resistances RED, GREEN and BLUE of the module control the R, G and B channels respectively. By adjusting the three adjustable resistances, it can turn out variable color. The thing to notice, however, is that be gentle when turning the adjustable resistances.\n\n\nThe following sketch demonstrates a simple application of controlling its brightness. As the picture on the below indicates, the Variable Color LED is connected to digital port 9 of the \nGrove - Base Shield\n. The hardware installation is as follows:\n\n\n\n\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\nDemo code like:\n\n\nint ledPin = 9;    // LED connected to digital pin 9\n\nvoid setup()  { \n  // nothing happens in setup \n}\n\nvoid loop()  { \n  // fade in from min to max in increments of 5 points:\n  for(int fadeValue = 0\u00a0; fadeValue <= 255; fadeValue +=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  }\n\n  // fade out from max to min in increments of 5 points:\n  for(int fadeValue = 255\u00a0; fadeValue >= 0; fadeValue -=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  } \n}\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n    Adjust the three adjustable resistances, I am sure you will like it. Have a try!\n\n\n\n\nResources\n\n\n\n\nVariable Color LED eagle_file\n\n\n\n\nHelp us make it better",
            "title": "Grove Variable Color LED"
        },
        {
            "location": "/Grove-Variable_Color_LED/#grove-variable-color-led",
            "text": "",
            "title": "Grove - Variable Color LED"
        },
        {
            "location": "/Grove-Variable_Color_LED/#introduction",
            "text": "This Grove consists of one 8mm RGB LED. It operates at 5V DC. When SIG pin is logic HIGH, the RGB LED will light up. Perfect for use on Seeeduino digital outputs, or also can be controlled by pulse-width modulation. And it uses three adjustable resistor to change the color of the RGB LED.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Variable_Color_LED/#features",
            "text": "Grove compatible  Color adjustable",
            "title": "Features"
        },
        {
            "location": "/Grove-Variable_Color_LED/#application-ideas",
            "text": "Toys  Decoration    Caution \nBe gentle while adjusting the R, G and B adjustable resistances in case of over-turning.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Variable_Color_LED/#specifications",
            "text": "Item  Typical  Unit      Operate Voltage  5.0  VDC    Working Current  20  mA    Variable Resistor  <1  K\u03a9",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Variable_Color_LED/#usage",
            "text": "The three resistances RED, GREEN and BLUE of the module control the R, G and B channels respectively. By adjusting the three adjustable resistances, it can turn out variable color. The thing to notice, however, is that be gentle when turning the adjustable resistances.  The following sketch demonstrates a simple application of controlling its brightness. As the picture on the below indicates, the Variable Color LED is connected to digital port 9 of the  Grove - Base Shield . The hardware installation is as follows:    Copy and paste code below to a new Arduino sketch.   Demo code like:  int ledPin = 9;    // LED connected to digital pin 9\n\nvoid setup()  { \n  // nothing happens in setup \n}\n\nvoid loop()  { \n  // fade in from min to max in increments of 5 points:\n  for(int fadeValue = 0\u00a0; fadeValue <= 255; fadeValue +=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  }\n\n  // fade out from max to min in increments of 5 points:\n  for(int fadeValue = 255\u00a0; fadeValue >= 0; fadeValue -=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  } \n}   Upload the code, Please click  here  if you do not know how to upload.\n    Adjust the three adjustable resistances, I am sure you will like it. Have a try!",
            "title": "Usage"
        },
        {
            "location": "/Grove-Variable_Color_LED/#resources",
            "text": "Variable Color LED eagle_file",
            "title": "Resources"
        },
        {
            "location": "/Grove-Variable_Color_LED/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Linkit_Connect_7681/",
            "text": "Linkit Connect 7681\n\n\n\n\nIntroduction\n\n\nThe LinkIt Connect 7681 development board provides easy access to the five GPIO pins and one UART port \u2014 each with an LED \u2014 of the MT7681, to quickly connect peripheral controllers and electronic circuits. The MT7681 is provided on the LinkIt Connect 7681 module, which was co-designed with AcSiP. This module, which is only 15 x 18mm, will also be available separately for direct integration into your product\u2019s PCB.\n\n\n\n\nKey Features\n\n\n\n\nAccess to the five GPIO pins and one UART port provided by MT7681, with attached LEDs\n\n\nWiFi antenna integrated on Linkit 7681 module\n\n\nPower over USB (Micro USB port).\n\n\nOpen source hardware board reference design, including schematic, layouts, and pin details.\n\n\n\n\nSpecifications\n\n\n\n\nChipset Core: MT7681 ANDES N9\n\n\nClock Speed: 80MHz\n\n\nFlash: 1MB\n\n\nRAM: 64KB\n\n\nPower: on-board 1A 3.3V voltage regulator (can be powered from USB connector)\n\n\nConnectors: UART/GPIO/SPI pins are available on connectors(100mil/2.54mm pitch);micro USB connector.\n\n\nGPIO Voltage: 3.3V\n\n\nPWM Output pin Count: 5\n\n\nPWM levels: 0~20\n\n\nUART Voltage: 3.3V\n\n\nWi-Fi Spec: 802.11 b/g/n for Station mode; 802.11 b/g for AP mode\n\n\nDimensions: 50 x 31 mm\n\n\nOther: Onboard reset push-button.\n\n\n\n\nHardware Overview\n\n\n\n\nGetting Started\n\n\nInstall USB Driver\n\n\nConnect LinkIt Connect 7681 development board to PC\u2019s USB port using a USB cable. The driver will be automatically installed.(As shown below in Windows7 OS)\n\n\n\n\n\n\n\n\nNote\n\nIf the driver does not install successfully, you can download and install \nFTDI Driver\n manually.\n\n\n\n\nGetting started with \nMediaTek LinkIt Connect 7681 Developer\u2019s Guide\n\n\nThis document provides you with a detailed introduction to the MediaTek LinkIt Connect 7681 SDK, step-by-step installation guide, and details on how to use it to create and run Wi-Fi applications. It also covers how to use the board upgrade tool provided in the SDK, an overview of the APIs and several how-to guides to undertake common Wi-Fi operations with code example. Details on how to create MediaTek Smart Connection apps for Android and iOS are also included.\n\n\nResources\n\n\n\n\nMediaTek LinkIt Connect 7681 Developer\u2019s Guide\n\n\nMediaTek LinkIt Connect 7681 API Reference\n\n\nLinkIt Connect 7681 Hardware Reference Design\n\n\nMediaTek LinkIt\u2122 Connect 7681 SDK\n\n\n\n\nHelp us make it better",
            "title": "Linkit Connect 7681"
        },
        {
            "location": "/Linkit_Connect_7681/#linkit-connect-7681",
            "text": "",
            "title": "Linkit Connect 7681"
        },
        {
            "location": "/Linkit_Connect_7681/#introduction",
            "text": "The LinkIt Connect 7681 development board provides easy access to the five GPIO pins and one UART port \u2014 each with an LED \u2014 of the MT7681, to quickly connect peripheral controllers and electronic circuits. The MT7681 is provided on the LinkIt Connect 7681 module, which was co-designed with AcSiP. This module, which is only 15 x 18mm, will also be available separately for direct integration into your product\u2019s PCB.",
            "title": "Introduction"
        },
        {
            "location": "/Linkit_Connect_7681/#key-features",
            "text": "Access to the five GPIO pins and one UART port provided by MT7681, with attached LEDs  WiFi antenna integrated on Linkit 7681 module  Power over USB (Micro USB port).  Open source hardware board reference design, including schematic, layouts, and pin details.",
            "title": "Key Features"
        },
        {
            "location": "/Linkit_Connect_7681/#specifications",
            "text": "Chipset Core: MT7681 ANDES N9  Clock Speed: 80MHz  Flash: 1MB  RAM: 64KB  Power: on-board 1A 3.3V voltage regulator (can be powered from USB connector)  Connectors: UART/GPIO/SPI pins are available on connectors(100mil/2.54mm pitch);micro USB connector.  GPIO Voltage: 3.3V  PWM Output pin Count: 5  PWM levels: 0~20  UART Voltage: 3.3V  Wi-Fi Spec: 802.11 b/g/n for Station mode; 802.11 b/g for AP mode  Dimensions: 50 x 31 mm  Other: Onboard reset push-button.",
            "title": "Specifications"
        },
        {
            "location": "/Linkit_Connect_7681/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Linkit_Connect_7681/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/Linkit_Connect_7681/#install-usb-driver",
            "text": "Connect LinkIt Connect 7681 development board to PC\u2019s USB port using a USB cable. The driver will be automatically installed.(As shown below in Windows7 OS)     Note \nIf the driver does not install successfully, you can download and install  FTDI Driver  manually.  Getting started with  MediaTek LinkIt Connect 7681 Developer\u2019s Guide  This document provides you with a detailed introduction to the MediaTek LinkIt Connect 7681 SDK, step-by-step installation guide, and details on how to use it to create and run Wi-Fi applications. It also covers how to use the board upgrade tool provided in the SDK, an overview of the APIs and several how-to guides to undertake common Wi-Fi operations with code example. Details on how to create MediaTek Smart Connection apps for Android and iOS are also included.",
            "title": "Install USB Driver"
        },
        {
            "location": "/Linkit_Connect_7681/#resources",
            "text": "MediaTek LinkIt Connect 7681 Developer\u2019s Guide  MediaTek LinkIt Connect 7681 API Reference  LinkIt Connect 7681 Hardware Reference Design  MediaTek LinkIt\u2122 Connect 7681 SDK",
            "title": "Resources"
        },
        {
            "location": "/Linkit_Connect_7681/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/RS232_Shield/",
            "text": "RS232 Shield\n\n\n\n\nIntroduction\n\n\nRS232 Shield is a standard communication port for industry equipment.This module is base on MAX232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.\n\n\n\n\nSpecifications\n\n\n\n\nMeets or Exceeds TIA/EIA-232-F and ITU\n\n\nOperates Up To 120 kbit/s\n\n\nLow Supply Current\n\n\nLED Indicator\n\n\nDB9 Connectors(female)\n\n\nWelding Areas\n\n\n\n\nInterface Function\n\n\nUsage\n\n\nFirst,we can test it by computer.\n\n\nHardware Installation\n\n\n\n\nSeeeduino v3.0,Mini usb Cable,RS232 Shield,RS232 to USB Cable.\n\n\nMake the connections as below. The jumper hats can be used to select the software serial port from the digital pins. You can set them to D7(232_TX) and D6(232_RX), and modify the code to \"\nSoftwareSerial mySerial(7, 6); // 232_TX, 232_RX\n\"\n\n\n\n\n\n\nSoftware Part\n\n\n\n\n1) Open Arduino IDE, and paste the code below.\n\n\n\n\n\u00a0\n#include <SoftwareSerial.h>\n\u00a0\nSoftwareSerial mySerial(7, 6); //232_TX,232_RX\n\u00a0\nvoid setup()\n{\n    // Open serial communications and wait for port to open:\n    Serial.begin(9600);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for Leonardo only\n    }\n\u00a0\n\u00a0\n    Serial.println(\"Goodnight moon!\");\n\u00a0\n    // set the data rate for the SoftwareSerial port\n    mySerial.begin(9600);\n    mySerial.println(\"Hello, world?\");\n}\n\u00a0\nvoid loop() // run over and over\n{\n    if (mySerial.available())\n    Serial.write(mySerial.read());\n    if (Serial.available())\n    mySerial.write(Serial.read());\n}\n\n\n\n\n\n\n2) Upload the code. Note that you should select the correct board type and COM port.\n\n\n3) Open the Serial Monitor.\n\n\n\n\nYou can see\u00a0:\n\n\n\nResources\n\n\n\n\nRS232 Shield eagle file\n\n\nRS232_Shield_v1.0.pdf\n\n\nDatasheet MAX232D.pdf\n\n\n\n\nHelp us make it better",
            "title": "RS232 Shield"
        },
        {
            "location": "/RS232_Shield/#rs232-shield",
            "text": "",
            "title": "RS232 Shield"
        },
        {
            "location": "/RS232_Shield/#introduction",
            "text": "RS232 Shield is a standard communication port for industry equipment.This module is base on MAX232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.",
            "title": "Introduction"
        },
        {
            "location": "/RS232_Shield/#specifications",
            "text": "Meets or Exceeds TIA/EIA-232-F and ITU  Operates Up To 120 kbit/s  Low Supply Current  LED Indicator  DB9 Connectors(female)  Welding Areas",
            "title": "Specifications"
        },
        {
            "location": "/RS232_Shield/#interface-function",
            "text": "Usage  First,we can test it by computer.",
            "title": "Interface Function"
        },
        {
            "location": "/RS232_Shield/#hardware-installation",
            "text": "Seeeduino v3.0,Mini usb Cable,RS232 Shield,RS232 to USB Cable.  Make the connections as below. The jumper hats can be used to select the software serial port from the digital pins. You can set them to D7(232_TX) and D6(232_RX), and modify the code to \" SoftwareSerial mySerial(7, 6); // 232_TX, 232_RX \"",
            "title": "Hardware Installation"
        },
        {
            "location": "/RS232_Shield/#software-part",
            "text": "1) Open Arduino IDE, and paste the code below.   \u00a0\n#include <SoftwareSerial.h>\n\u00a0\nSoftwareSerial mySerial(7, 6); //232_TX,232_RX\n\u00a0\nvoid setup()\n{\n    // Open serial communications and wait for port to open:\n    Serial.begin(9600);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for Leonardo only\n    }\n\u00a0\n\u00a0\n    Serial.println(\"Goodnight moon!\");\n\u00a0\n    // set the data rate for the SoftwareSerial port\n    mySerial.begin(9600);\n    mySerial.println(\"Hello, world?\");\n}\n\u00a0\nvoid loop() // run over and over\n{\n    if (mySerial.available())\n    Serial.write(mySerial.read());\n    if (Serial.available())\n    mySerial.write(Serial.read());\n}   2) Upload the code. Note that you should select the correct board type and COM port.  3) Open the Serial Monitor.   You can see\u00a0:",
            "title": "Software Part"
        },
        {
            "location": "/RS232_Shield/#resources",
            "text": "RS232 Shield eagle file  RS232_Shield_v1.0.pdf  Datasheet MAX232D.pdf",
            "title": "Resources"
        },
        {
            "location": "/RS232_Shield/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/",
            "text": "Raspberry Pi Breakout Board v1.0\n\n\n\n\nIntroduction\n\n\nRaspberry Pi Breakout Board for Raspberry Pi is a prototype board that you can combine your raspberry pi with other components, modules.\nAs a prototype board, it also provides power, state indicator light, button and universal transistor,such as NPN, PNP, N-MOS, P-MOS.\n\n\n\n\nFeatures\n\n\n\n\nRaspberry pi compatible\n\n\nMicro USB power supply\n\n\nBasic Circuit\u00a0: state indicator light, button and universal transistor\uff08NPN,PNP,N-MOS,P-MOS\uff09\n\n\n3.3 volts, 5 volts and ground power rails are easily available anywhere on the board\n\n\n\n\nHardware Overview\n\n\n\n\nAssembly\n\n\n\n\nYou can design circuit on the Raspberry Pi Breakout Board, then connect to raspberry pi as shown below.\n\n\n\n\n\n\nResources\n\n\n\n\nRaspberry Pi Breakout Board v1.0 sch pcb-.zip\n\n\n\n\nHelp us make it better",
            "title": "Raspberry Pi Breakout Board v1.0"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#raspberry-pi-breakout-board-v10",
            "text": "",
            "title": "Raspberry Pi Breakout Board v1.0"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#introduction",
            "text": "Raspberry Pi Breakout Board for Raspberry Pi is a prototype board that you can combine your raspberry pi with other components, modules.\nAs a prototype board, it also provides power, state indicator light, button and universal transistor,such as NPN, PNP, N-MOS, P-MOS.",
            "title": "Introduction"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#features",
            "text": "Raspberry pi compatible  Micro USB power supply  Basic Circuit\u00a0: state indicator light, button and universal transistor\uff08NPN,PNP,N-MOS,P-MOS\uff09  3.3 volts, 5 volts and ground power rails are easily available anywhere on the board",
            "title": "Features"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#assembly",
            "text": "You can design circuit on the Raspberry Pi Breakout Board, then connect to raspberry pi as shown below.",
            "title": "Assembly"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#resources",
            "text": "Raspberry Pi Breakout Board v1.0 sch pcb-.zip",
            "title": "Resources"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/",
            "text": "Raspberry Pi RS232 Board v1.0\n\n\n\n\nIntroduction\n\n\nRaspberry Pi RS232 Board v1.0 is a standard communication port for industry equipment.This module is base on MAX3232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.\n\n\n\n\nFeatures\n\n\n\n\nLow Supply Current:300\u03bcA\n\n\nGuaranteed Data Rate:120kbps\n\n\nMeets EIA/TIA-232 Specifications Down to 3.0V\n\n\nPin Compatible with Industry-Standard MAX232\n\n\nGuaranteed Slew Rate:6V/\u03bcs\n\n\nLED Indicator\n\n\nDB9 Connectors(female)\n\n\n\n\nSpecifications\n\n\n\n\n\n\n Item\n\n\n\n Min\n\n\n\n Typical\n\n\n\n Max\n\n\n\n Unit\n\n\n\n\n\n Input Voltage Range\n\n\n\n -25\n\n\n\n /\n\n\n\n 25\n\n\n\n V\n\n\n\n\n\n Input Threshold Low(VCC=3.3V/5.0V)\n\n\n\n 0.6 / 0.8\n\n\n\n 1.2 / 1.5\n\n\n\n /\n\n\n\n V\n\n\n\n\n\n Input Threshold High (VCC=3.3V/5.0V)\n\n\n\n /\n\n\n\n 1.5 / 1.8\n\n\n\n 2.4 / 2.4\n\n\n\n V\n\n\n\n\n\n Maximum Data Rate\n\n\n\n 120\n\n\n\n 235\n\n\n\n\n\n\n\n kHz\n\n\n\n\n\n Operating Temperature\n\n\n\n 0\n\n\n\n /\n\n\n\n 70\n\n\n\n \u2103\n\n\n\n\n\n Dimension\n\n\n\n 91.20 * 56.15*32\n\n\n\n mm\n\n\n\n\nHardware Overview\n\n\n\n\nUART Pin must be pup joint if you want to connect to raspberry pi.\n\n\nUsage\n\n\nUsing serial COM ports to Configure system on Raspberry Pi.\n\n\nHardware Installation\n\n\n\n\n\n\nRaspberry Pi&USB to serial COM Port line.\n\n\n\n\n\n\nConnect as in the following picture:\n\n\n\n\n\n\n\n\nFine out which com it is using on you PC's device management.\n\n\n\n\n\n\nRun a serial port assistant, and set it as shown:\n\n\nCOM must be set as what you fine on you PC's device management.Then power on your raspberry pi. You can see the serial port assistant as shown below.\n\n\n\n\n\n\n\n\nHave communication with Raspberry Pi successfully.\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nRaspberry_Pi_RS232_Board_v1.0_sch_pcb\n\n\nMAX3232\n\n\n\n\nHelp us make it better",
            "title": "Raspberry Pi R232 Board v1.0"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#raspberry-pi-rs232-board-v10",
            "text": "",
            "title": "Raspberry Pi RS232 Board v1.0"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#introduction",
            "text": "Raspberry Pi RS232 Board v1.0 is a standard communication port for industry equipment.This module is base on MAX3232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.",
            "title": "Introduction"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#features",
            "text": "Low Supply Current:300\u03bcA  Guaranteed Data Rate:120kbps  Meets EIA/TIA-232 Specifications Down to 3.0V  Pin Compatible with Industry-Standard MAX232  Guaranteed Slew Rate:6V/\u03bcs  LED Indicator  DB9 Connectors(female)",
            "title": "Features"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#specifications",
            "text": "Item   Min   Typical   Max   Unit    Input Voltage Range   -25   /   25   V    Input Threshold Low(VCC=3.3V/5.0V)   0.6 / 0.8   1.2 / 1.5   /   V    Input Threshold High (VCC=3.3V/5.0V)   /   1.5 / 1.8   2.4 / 2.4   V    Maximum Data Rate   120   235     kHz    Operating Temperature   0   /   70   \u2103    Dimension   91.20 * 56.15*32   mm",
            "title": "Specifications"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#hardware-overview",
            "text": "UART Pin must be pup joint if you want to connect to raspberry pi.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#usage",
            "text": "Using serial COM ports to Configure system on Raspberry Pi.",
            "title": "Usage"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#hardware-installation",
            "text": "Raspberry Pi&USB to serial COM Port line.    Connect as in the following picture:     Fine out which com it is using on you PC's device management.    Run a serial port assistant, and set it as shown:  COM must be set as what you fine on you PC's device management.Then power on your raspberry pi. You can see the serial port assistant as shown below.     Have communication with Raspberry Pi successfully.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#resources",
            "text": "Raspberry_Pi_RS232_Board_v1.0_sch_pcb  MAX3232",
            "title": "Resources"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/UartSBee_v5/",
            "text": "UartSBee v5\n\n\n\n\nIntroduction\n\n\nUartSBee v5'\n is FTDI cable compatible \nUSB to Serial\n adapter equipped with BEE socket(20pin 2.0mm). The integrated \nFT232RL\n can be used for programming or communicating with MCUs. On the other hand, you might connect your PC to various wireless applications via a \nBee\n compatible module. UartSBee provides breakouts for the bit-bang mode pins of \nFT232RL\n as well.This Bit-bang mode pins (8 I/O pins) can be used as a replacement for applications involving PC parallel port which is scares now a day.\n\n\n\n\nUartSBee v5 is the Mesh Bee programmer version based on UartSBee v4.\n\n\nPlease refer to \nUartSBee v4's wiki page\n for general help topics. In this wiki we focus on the difference between v4 and v5.\n\n\nAdded Features\n\n\n\n\nMicroUSB interface\n\n\nCan program Mesh Bee\n\n\nAdded SW3 to switch the connection of FT232's UART between the TX1/RX1 pins of BEE socket and the program interface of Mesh Bee\n\n\n\n\nHardware Overview\n\n\n\n\nResources\n\n\n\n\nEagle file for UartSBee v5\n\n\nHow to program Mesh Bee\n\n\n\n\nHelp us make it better",
            "title": "UartSBee v5"
        },
        {
            "location": "/UartSBee_v5/#uartsbee-v5",
            "text": "",
            "title": "UartSBee v5"
        },
        {
            "location": "/UartSBee_v5/#introduction",
            "text": "UartSBee v5'  is FTDI cable compatible  USB to Serial  adapter equipped with BEE socket(20pin 2.0mm). The integrated  FT232RL  can be used for programming or communicating with MCUs. On the other hand, you might connect your PC to various wireless applications via a  Bee  compatible module. UartSBee provides breakouts for the bit-bang mode pins of  FT232RL  as well.This Bit-bang mode pins (8 I/O pins) can be used as a replacement for applications involving PC parallel port which is scares now a day.   UartSBee v5 is the Mesh Bee programmer version based on UartSBee v4.  Please refer to  UartSBee v4's wiki page  for general help topics. In this wiki we focus on the difference between v4 and v5.",
            "title": "Introduction"
        },
        {
            "location": "/UartSBee_v5/#added-features",
            "text": "MicroUSB interface  Can program Mesh Bee  Added SW3 to switch the connection of FT232's UART between the TX1/RX1 pins of BEE socket and the program interface of Mesh Bee",
            "title": "Added Features"
        },
        {
            "location": "/UartSBee_v5/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/UartSBee_v5/#resources",
            "text": "Eagle file for UartSBee v5  How to program Mesh Bee",
            "title": "Resources"
        },
        {
            "location": "/UartSBee_v5/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/",
            "text": "Wio Link Bootcamp Kit\n\n\n\n\nIntroduction\n\n\nIf you have no programming skills, and you want to build some cool gadgets for your life, this kit will be a perfect starter. It contains a relay, a recorder, a strip of LEDs, a buzzer and a servo motor which will perform basic actions required in daily life. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's get started to build some useful stuff.\n\n\n\n\nFeatures\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCompletely easy to make things around you smarter and add fun to daily life.\n\n\nCost-effective\n\n\nWeight: 285 g\n\n\n\n\nParts list\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Relay\n\n\n1PC\n\n\n\n\n\n\nGrove - Recorder\n\n\n1PC\n\n\n\n\n\n\nGrove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter\n\n\n1PC\n\n\n\n\n\n\nGrove - Buzzer\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\nGrove - Servo\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\n\nPlease go to \nRecipe\n for the detailed manual.\n\n\nHelp us make it better",
            "title": "Wio Link Bootcamp Kit"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#wio-link-bootcamp-kit",
            "text": "",
            "title": "Wio Link Bootcamp Kit"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#introduction",
            "text": "If you have no programming skills, and you want to build some cool gadgets for your life, this kit will be a perfect starter. It contains a relay, a recorder, a strip of LEDs, a buzzer and a servo motor which will perform basic actions required in daily life. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's get started to build some useful stuff.",
            "title": "Introduction"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#features",
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Completely easy to make things around you smarter and add fun to daily life.  Cost-effective  Weight: 285 g",
            "title": "Features"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#parts-list",
            "text": "Parts name  Quantity      Grove - Relay  1PC    Grove - Recorder  1PC    Grove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter  1PC    Grove - Buzzer  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC    Grove - Servo  1PC",
            "title": "Parts list"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#a-simple-demo",
            "text": "This demo can used as a compilation result-indicator.",
            "title": "A simple demo"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#preliminary-guide",
            "text": "Travis CI  Wio Link",
            "title": "Preliminary Guide"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#prerequisites",
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light",
            "title": "Prerequisites"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#a-detailed-how-to",
            "text": "Please go to  Recipe  for the detailed manual.",
            "title": "A detailed how-to"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Wio_Link_Environment_Kit/",
            "text": "Wio Link Environment Kit\n\n\n\n\nIntroduction\n\n\nWe are always closely connected with our surrounding environment. So it is important for us to get some details from an environment. This kit is supposed to do this task perfectly, at least at a primary level. In this kit, you can find common functional modules to collect data, such as humidity or light level indoor, from the environment in our house. The most amazing part of this kit is the Wio Link development board which can be utilized for various purposes, without requiring any programming skills. All the actions you want your modules to perform and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet from anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. So let's get an understanding for those conditions you are in.\n\n\n\n\nFeatures\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCost-effective\n\n\nWeight\u00a0: 154 g\n\n\n\n\nParts list\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Moisture Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Temp&Humi Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Digital Light Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Air quality sensor v1.3\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\n\nPlease go to \nRecipe\n for the detailed manual.\n\n\nHelp us make it better",
            "title": "Wio Link Environment Kit"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#wio-link-environment-kit",
            "text": "",
            "title": "Wio Link Environment Kit"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#introduction",
            "text": "We are always closely connected with our surrounding environment. So it is important for us to get some details from an environment. This kit is supposed to do this task perfectly, at least at a primary level. In this kit, you can find common functional modules to collect data, such as humidity or light level indoor, from the environment in our house. The most amazing part of this kit is the Wio Link development board which can be utilized for various purposes, without requiring any programming skills. All the actions you want your modules to perform and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet from anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. So let's get an understanding for those conditions you are in.",
            "title": "Introduction"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#features",
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Cost-effective  Weight\u00a0: 154 g",
            "title": "Features"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#parts-list",
            "text": "Parts name  Quantity      Grove - Moisture Sensor  1PC    Grove - Temp&Humi Sensor  1PC    Grove - Digital Light Sensor  1PC    Grove - Air quality sensor v1.3  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC",
            "title": "Parts list"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#a-simple-demo",
            "text": "This demo can used as a compilation result-indicator.",
            "title": "A simple demo"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#preliminary-guide",
            "text": "Travis CI  Wio Link",
            "title": "Preliminary Guide"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#prerequisites",
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light",
            "title": "Prerequisites"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#a-detailed-how-to",
            "text": "Please go to  Recipe  for the detailed manual.",
            "title": "A detailed how-to"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Wio_Link_Event_Kit/",
            "text": "Wio Link Event Kit\n\n\n\n\nIntroduction\n\n\nWio Link Event Kit is a event-monitoring kit which include some typical event-triggered \nGrove\n functional modules to build smart IoT devices. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over the internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's get familiar with some event-triggered modules included in this Kit.\n\n\n\n\nFeatures\n\n\n\n\nInclude common frequently-used event-monitoring functional modules.\n\n\nCompletely easy to make things around you smarter.\n\n\nGrove port interfaced, more practical function and less work.\n\n\nWeight: 145 g\n\n\n\n\nParts list\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - IR Distance Interrupt\n\n\n1PC\n\n\n\n\n\n\nGrove - Button\n\n\n1PC\n\n\n\n\n\n\nGrove - Magnetic Switch\n\n\n1PC\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\n\nPlease go to \nRecipe\n for the detailed manual:\n\n\nHelp us make it better",
            "title": "Wio Link Event Kit"
        },
        {
            "location": "/Wio_Link_Event_Kit/#wio-link-event-kit",
            "text": "",
            "title": "Wio Link Event Kit"
        },
        {
            "location": "/Wio_Link_Event_Kit/#introduction",
            "text": "Wio Link Event Kit is a event-monitoring kit which include some typical event-triggered  Grove  functional modules to build smart IoT devices. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over the internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's get familiar with some event-triggered modules included in this Kit.",
            "title": "Introduction"
        },
        {
            "location": "/Wio_Link_Event_Kit/#features",
            "text": "Include common frequently-used event-monitoring functional modules.  Completely easy to make things around you smarter.  Grove port interfaced, more practical function and less work.  Weight: 145 g",
            "title": "Features"
        },
        {
            "location": "/Wio_Link_Event_Kit/#parts-list",
            "text": "Parts name  Quantity      Grove - IR Distance Interrupt  1PC    Grove - Button  1PC    Grove - Magnetic Switch  1PC    Grove - 3-Axis Digital Accelerometer(\u00b11.5g)  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC",
            "title": "Parts list"
        },
        {
            "location": "/Wio_Link_Event_Kit/#a-simple-demo",
            "text": "This demo can used as a compilation result-indicator.",
            "title": "A simple demo"
        },
        {
            "location": "/Wio_Link_Event_Kit/#preliminary-guide",
            "text": "Travis CI  Wio Link",
            "title": "Preliminary Guide"
        },
        {
            "location": "/Wio_Link_Event_Kit/#prerequisites",
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light",
            "title": "Prerequisites"
        },
        {
            "location": "/Wio_Link_Event_Kit/#a-detailed-how-to",
            "text": "Please go to  Recipe  for the detailed manual:",
            "title": "A detailed how-to"
        },
        {
            "location": "/Wio_Link_Event_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Wio_Link_Starter_Kit/",
            "text": "Wio Link Starter Kit\n\n\n\n\nIntroduction\n\n\nThis kit is aimed at novices wanting to become a maker. The functional modules included in this kit are selected especially for a beginner which all are frequently required modules, and it is cost-effective. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's enjoy being a maker.\n\n\n\n\nFeatures\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCompletely easy to make things around you smarter and add fun to daily life.\n\n\nCost-effective\n\n\nWeight: 267 g\n\n\n\n\nParts list\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Button\n\n\n1PC\n\n\n\n\n\n\nGrove - Relay\n\n\n1PC\n\n\n\n\n\n\nGrove - Temp&Humi Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Digital Light Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter\n\n\n1PC\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\n\nPlease go to \nRecipe\n for the detailed manual.\n\n\nHelp us make it better",
            "title": "Wio Link Starter Kit"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#wio-link-starter-kit",
            "text": "",
            "title": "Wio Link Starter Kit"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#introduction",
            "text": "This kit is aimed at novices wanting to become a maker. The functional modules included in this kit are selected especially for a beginner which all are frequently required modules, and it is cost-effective. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's enjoy being a maker.",
            "title": "Introduction"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#features",
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Completely easy to make things around you smarter and add fun to daily life.  Cost-effective  Weight: 267 g",
            "title": "Features"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#parts-list",
            "text": "Parts name  Quantity      Grove - Button  1PC    Grove - Relay  1PC    Grove - Temp&Humi Sensor  1PC    Grove - Digital Light Sensor  1PC    Grove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter  1PC    Grove - 3-Axis Digital Accelerometer(\u00b11.5g)  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC",
            "title": "Parts list"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#a-simple-demo",
            "text": "This demo can used as a compilation result-indicator.",
            "title": "A simple demo"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#preliminary-guide",
            "text": "Travis CI  Wio Link",
            "title": "Preliminary Guide"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#prerequisites",
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light",
            "title": "Prerequisites"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#a-detailed-how-to",
            "text": "Please go to  Recipe  for the detailed manual.",
            "title": "A detailed how-to"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        }
    ]
}