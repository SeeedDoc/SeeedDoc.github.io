{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\uf0c1\n\n\nWellcome to Seeed Product Document, here you will get the user manual of all the product that provide by SeeedStudio.\n\n\nThe products include:\n\n\n\n\n\n\nPlatform\n\n\n\n\nArduino\n\n\nRaspberry Pi\n\n\nLinkIt\n\n\nLaunchPad\n\n\nBeagleBone\n\n\nIntel Edison\n\n\nmbed\n\n\nRePhone\n\n\nWio\n\n\n\n\n\n\n\n\nGrove\n\n\n\n\nSensor\n\n\nActuator\n\n\nDisplay\n\n\nCommunication\n\n\n\n\n\n\n\n\nShield\n\n\n\n\nRobot", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Wellcome to Seeed Product Document, here you will get the user manual of all the product that provide by SeeedStudio.  The products include:    Platform   Arduino  Raspberry Pi  LinkIt  LaunchPad  BeagleBone  Intel Edison  mbed  RePhone  Wio     Grove   Sensor  Actuator  Display  Communication     Shield   Robot", 
            "title": "Introduction"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/", 
            "text": "This is a multifunctional Arduino/Seeeduino/Arduino Mega compatible resistive touch screen. It can be used as display device or sketch pad.Compared with the previous version, 2.8``TFT Touch Shield V1.0, we replaced the screen driver with a more professional chip, ILI9341 driver, providing different pin-saving SPI communication without sacrificing the data transmitting speed. Due to the communication method change, programs developed for the original version need modifications before being transplanted to the new version. With a SD card module integrated also on this shield, this shield reserves great room for other expansions to your project.\n\n\n  \n\n\nFeatures\n\uf0c1\n\n\n\n\nBig screen for easy and comfortable experience\n\n\nBacklight controllable via programming\n\n\n65k rich colors display\n\n\nSPI pin-saving communication method\n\n\nFull screen touch active range\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n5 V\n\n\n\n\n\n\nResolution\n\n\n320 x 240\n\n\n\n\n\n\nColors\n\n\n65k\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nGame\n\n\nSensor Hub\n\n\nHuman Machine Interface\n\n\nSmart House\n\n\n\n\nHere are some awesome projects for your reference. If you have project want to add to this chapter, please feel free to contact loovee@seeed.cc. \n\n\n\n\n\n\n\n\nArduino Phone\n\n\nFacebook Monitor\n\n\nInstrucatbles Monitor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it Now!\n\n\nMake it Now!\n\n\nMake it Now!\n\n\n\n\n\n\n\n\nPin Used\n\uf0c1\n\n\n\n\nNote\n\n\nYou can use the NOT USED pins to control the others module. \n\n\n\n\nDigital Pins\n\n\n\n\n\n\n\n\nPin Name\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nD0\n\n\nNOT USED\n\n\n\n\n\n\nD1\n\n\nNOT USED\n\n\n\n\n\n\nD2\n\n\nNOT USED\n\n\n\n\n\n\nD3\n\n\nNOT USED\n\n\n\n\n\n\nD4\n\n\nTF_CS\n\n\n\n\n\n\nD5\n\n\nTFT_CS\n\n\n\n\n\n\nD6\n\n\nTFT_DC\n\n\n\n\n\n\nD7\n\n\nBACKLIGHT(Selectable)\n\n\n\n\n\n\nD8\n\n\nNOT USED\n\n\n\n\n\n\nD9\n\n\nNOT USED\n\n\n\n\n\n\nD10\n\n\nNOT USED\n\n\n\n\n\n\nD11\n\n\nSPI_MOSI\n\n\n\n\n\n\nD12\n\n\nSPI_MISO\n\n\n\n\n\n\nD13\n\n\nSPI_SCK\n\n\n\n\n\n\n\n\nAnalog Pins\n\n\n\n\n\n\n\n\nPin Name\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nA0\n\n\nTOUCH PANEL\n\n\n\n\n\n\nA1\n\n\nTOUCH PANEL\n\n\n\n\n\n\nA2\n\n\nTOUCH PANEL\n\n\n\n\n\n\nA3\n\n\nTOUCH PANEL\n\n\n\n\n\n\nA4\n\n\nNOT USED\n\n\n\n\n\n\nA5\n\n\nNOT USED\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\nNote\n\n\nThis getting started is based on Win10 and Arduino IDE 1.6.9\n\n\n\n\nHere we will show you how this display work, we need thing as below to start. \n\n\n\n\n\n\n\n\nSeeeduino V4\n\n\n2.8 TFT Touch Shield V2\n\n\nMicro USB Cable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\nDownload Arduino Library\n\uf0c1\n\n\nThis library work for:\n\n\n\n\nArduino/Genuino UNO\n\n\nSeeeduino V3/4.0/4.2\n\n\nArduino/Genuino Mega\n\n\nArduino Leonardo\n\n\nSeeeduino Lite/Clio/Lotus\n\n\nLinkIt ONE(Touch panel don\nt work)\n\n\n\n\nClick on the below button to download the library and install it \n(HOW TO INSTALL AN ARDUINO LIBRARY)\n. \n\n\n\n\nThis library include few examples, \n\n\n\n\ndrawCircle\n\n\ndrawLines\n\n\ndrawNumber\n\n\ndrawRectangle\n\n\npaint\n\n\nshapes\n\n\ntext\n\n\ntftbmp\n\n\ntftbmp2\n\n\n\n\nWe use shapes example for this demo.\n\n\nConnection and Upload the code\n\uf0c1\n\n\nInsert the board to Seeeduino, and open your Arduino IDE. Click on \nFile \n Examples \n TFT_Touch_Shield_V2-master \n shapes\n to open the code. \n\n\nSelect the correct COM port and Boards(Seeeduino V4), upload the code to Seeeduino, then it\ns done. If you have any question about how to start the uploading, please put had on \nhere\n to get more details. \n\n\n\n\nBacklight\n\uf0c1\n\n\nThe backlight is default on always, if you want to control the backlight, you need to do some hack in the board. Please look at the back side of the board, there\ns a BACKLIGHT label, and one side named ON the other side named D7. We need to cut the wire at ON side and solder D7 side. As shown below.\n\n\n\n\nThen you can control the backlight via control D7.\n\n\nTo open backlight:\n     digitalWrite(7, HIGH);\n\n\nTo close backlight:\n    digitaWrite(7, LOW);\n\n\n\n\nWarning\n\n\nPlease be careful when use a box cutter and soldering iron.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic in Eagle File\n\n\nLibrary at Github page\n\n\nGithub page of this document", 
            "title": "2.8&#39;&#39; TFT Touch Shield v2.0"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#features", 
            "text": "Big screen for easy and comfortable experience  Backlight controllable via programming  65k rich colors display  SPI pin-saving communication method  Full screen touch active range", 
            "title": "Features"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#specification", 
            "text": "Item  Value      Working Voltage  5 V    Resolution  320 x 240    Colors  65k", 
            "title": "Specification"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#application-ideas", 
            "text": "Game  Sensor Hub  Human Machine Interface  Smart House   Here are some awesome projects for your reference. If you have project want to add to this chapter, please feel free to contact loovee@seeed.cc.      Arduino Phone  Facebook Monitor  Instrucatbles Monitor           Make it Now!  Make it Now!  Make it Now!", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#pin-used", 
            "text": "Note  You can use the NOT USED pins to control the others module.    Digital Pins     Pin Name  Function      D0  NOT USED    D1  NOT USED    D2  NOT USED    D3  NOT USED    D4  TF_CS    D5  TFT_CS    D6  TFT_DC    D7  BACKLIGHT(Selectable)    D8  NOT USED    D9  NOT USED    D10  NOT USED    D11  SPI_MOSI    D12  SPI_MISO    D13  SPI_SCK     Analog Pins     Pin Name  Function      A0  TOUCH PANEL    A1  TOUCH PANEL    A2  TOUCH PANEL    A3  TOUCH PANEL    A4  NOT USED    A5  NOT USED", 
            "title": "Pin Used"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#getting-started", 
            "text": "Note  This getting started is based on Win10 and Arduino IDE 1.6.9   Here we will show you how this display work, we need thing as below to start.      Seeeduino V4  2.8 TFT Touch Shield V2  Micro USB Cable           More Details  More Details  More Details", 
            "title": "Getting Started"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#download-arduino-library", 
            "text": "This library work for:   Arduino/Genuino UNO  Seeeduino V3/4.0/4.2  Arduino/Genuino Mega  Arduino Leonardo  Seeeduino Lite/Clio/Lotus  LinkIt ONE(Touch panel don t work)   Click on the below button to download the library and install it  (HOW TO INSTALL AN ARDUINO LIBRARY) .    This library include few examples,    drawCircle  drawLines  drawNumber  drawRectangle  paint  shapes  text  tftbmp  tftbmp2   We use shapes example for this demo.", 
            "title": "Download Arduino Library"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#connection-and-upload-the-code", 
            "text": "Insert the board to Seeeduino, and open your Arduino IDE. Click on  File   Examples   TFT_Touch_Shield_V2-master   shapes  to open the code.   Select the correct COM port and Boards(Seeeduino V4), upload the code to Seeeduino, then it s done. If you have any question about how to start the uploading, please put had on  here  to get more details.", 
            "title": "Connection and Upload the code"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#backlight", 
            "text": "The backlight is default on always, if you want to control the backlight, you need to do some hack in the board. Please look at the back side of the board, there s a BACKLIGHT label, and one side named ON the other side named D7. We need to cut the wire at ON side and solder D7 side. As shown below.   Then you can control the backlight via control D7.  To open backlight:\n     digitalWrite(7, HIGH);  To close backlight:\n    digitaWrite(7, LOW);   Warning  Please be careful when use a box cutter and soldering iron.", 
            "title": "Backlight"
        }, 
        {
            "location": "/2.8inch_TFT_Touch_Shield_v2.0/#resources", 
            "text": "Schematic in Eagle File  Library at Github page  Github page of this document", 
            "title": "Resources"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/", 
            "text": "Battery Detector with Polymer Lithium Ion 1050mAh 3.8V contains two items: a 1050 mAh lithium-ion battery and a battery power detector to measure the power remain in a li-ion battery.\n\n\nThe li-ion battery is very slim, light and cost effective. It output 3.7 V voltage(nominal). You can also charge it with a specialized charger which has maximum input current 1050 mA and maximum input voltage 4.2V. This battery comes with pre-attached JST 2.0 connector which is handy to click in and out. It also has built-in overcurrent protection to protect against output short circuit. \nAlthough, please still take caution and do not abuse the battery in usage. Never charge or use it unattended.\n\n\nThe battery power detector can detect the input voltage range of 3\u20134.2 volts. There are three JST sockets (JST 1.0, JST 2.0 and JST 2.0) and two battery-soldering pads will adapt to those batteries with a different connector. As you connect a battery to this battery power detector, the on-board four LEDs will indicate remaining power in percentage (0\u201325%, 26\u201350%, 51\u201375%, 76\u2013100%). Another LED will be on if you plug the connector of battery in the wrong way.\n\n\n\n\n\n\nNotes\n\n\n 1. There is only one battery reliable to be tested at the same time.\n\n\n 2. It will damage this battery power detector as the input voltage is above 9 volts.\n\n\n 3. Never use the battery when it is being charged.\n\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nProduct revision\n\n\nRelease date\n\n\nSupport status\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nBattery Detector with Polymer Lithium Ion 1050mAh 3.8V(current version)\n\n\nMay 2016\n\n\nSupported\n\n\nNone\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\nFor battery\n\n\n\n\nFor Pre-attached JST 2.0 connector\n\n\nShort circuit protection for output circuit\n\n\nCost-effective\n\n\n\n\nFor battery power detector\n\n\n\n\nVisual indication on remaining power of a battery\n\n\nDifferent JST sockets for different battery connectors\n\n\n\n\nSpecifications\n\uf0c1\n\n\nFor battery\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nCapacity\n\n\n1050 mAh\n\n\n\n\n\n\nNominal output voltage(DC)\n\n\n3.7 volts\n\n\n\n\n\n\nConnector\n\n\nJST 2.0\n\n\n\n\n\n\nMaximum Charge Current\n\n\n1050 mA\n\n\n\n\n\n\nProtection\n\n\nShort circuit protection for output circuit\n\n\n\n\n\n\nWeight\n\n\n19 g, the whole package weighs 33.5 g.\n\n\n\n\n\n\nDimensions\n\n\n48(width)\u00d74.9(height)\u00d745(depth) mm\n\n\n\n\n\n\n\n\nFor battery power detector\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nInput voltage\n\n\n3 \u2013 4.2V\n\n\n\n\n\n\nOperating current\n\n\n15 mA\n\n\n\n\n\n\nIndication manner\n\n\nFour LEDs (we will detail it later)\n\n\n\n\n\n\nSockets\n\n\nThree sockets for different battery connector and two battery-soldering pads (we will detail it later)\n\n\n\n\n\n\nDimensions\n\n\n30(width)\u00d725(depth) mm\n\n\n\n\n\n\nCN1185\n\n\nDatasheet\n\n\n\n\n\n\nWeight\n\n\n3.2 g\n\n\n\n\n\n\nNotes\n\n\nOnly connect a single battery to this module; The input voltage to this module should be less than 9 volts, or it will damage this module.\n\n\n\n\n\n\n\n\nPlatforms supported(only for battery)\n\uf0c1\n\n\n\n\n\n\n\nPlatform\n\n\n\n\nSeeeduino/Arduino\n\n\n\n\nRasberry Pi\n\n\n\n\nBeaglebone\n\n\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\nSupported status\n\n\n\n\nSupported\n\n\n\n\nNot supported\n\n\n\n\nSupported(only with \nGrove Base Cape for Beaglebone\n)\n\n\n\n\nNot supported\n\n\n\n\n\n\n\n\nNotes\n\n\n\n\nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform.\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\nThis section shows descriptions for components on battery power detector.\n\n\n\n\n\n\nCN1185\n, a voltage monitoring circuit.\n\n\nBattery-soldering pads\n, to solder battery\ns leads on.\n\n\n\n\nPackage includes\n(main parts)\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nLi-ion battery\n\n\n1 piece\n\n\n\n\n\n\nBattery power detector\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nConnect battery and battery power detector as in the following image. You can see LEDs are \nON\n indicates actual power remains.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic(Eagle) file\n\n\nCN1185 Datasheet\n\n\nBattery Usage Datasheet\n\n\nBattery Safety Datasheet and Certificates", 
            "title": "Battery Detector with Polymer Lithium Ion 1050mAh 3.7V"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#version-tracker", 
            "text": "Product revision  Release date  Support status  Notes      Battery Detector with Polymer Lithium Ion 1050mAh 3.8V(current version)  May 2016  Supported  None", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#features", 
            "text": "For battery   For Pre-attached JST 2.0 connector  Short circuit protection for output circuit  Cost-effective   For battery power detector   Visual indication on remaining power of a battery  Different JST sockets for different battery connectors", 
            "title": "Features"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#specifications", 
            "text": "For battery     Parameter  Value      Capacity  1050 mAh    Nominal output voltage(DC)  3.7 volts    Connector  JST 2.0    Maximum Charge Current  1050 mA    Protection  Short circuit protection for output circuit    Weight  19 g, the whole package weighs 33.5 g.    Dimensions  48(width)\u00d74.9(height)\u00d745(depth) mm     For battery power detector     Parameter  Value      Input voltage  3 \u2013 4.2V    Operating current  15 mA    Indication manner  Four LEDs (we will detail it later)    Sockets  Three sockets for different battery connector and two battery-soldering pads (we will detail it later)    Dimensions  30(width)\u00d725(depth) mm    CN1185  Datasheet    Weight  3.2 g    Notes  Only connect a single battery to this module; The input voltage to this module should be less than 9 volts, or it will damage this module.", 
            "title": "Specifications"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#platforms-supportedonly-for-battery", 
            "text": "Platform  \nSeeeduino/Arduino  \nRasberry Pi  \nBeaglebone  \nLinkIt ONE    \nSupported status  \nSupported  \nNot supported  \nSupported(only with  Grove Base Cape for Beaglebone )  \nNot supported    \nNotes  \nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform.", 
            "title": "Platforms supported(only for battery)"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#hardware-overview", 
            "text": "This section shows descriptions for components on battery power detector.    CN1185 , a voltage monitoring circuit.  Battery-soldering pads , to solder battery s leads on.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#package-includesmain-parts", 
            "text": "Parts name  Quantity      Li-ion battery  1 piece    Battery power detector  1 piece", 
            "title": "Package includes(main parts)"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#getting-started", 
            "text": "Connect battery and battery power detector as in the following image. You can see LEDs are  ON  indicates actual power remains.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#resources", 
            "text": "Schematic(Eagle) file  CN1185 Datasheet  Battery Usage Datasheet  Battery Safety Datasheet and Certificates", 
            "title": "Resources"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/", 
            "text": "Battery Detector with Polymer Lithium Ion 5100mAh 3.8V contains two items: a 1050 mAh lithium-ion battery and a battery power detector to measure the power remain in a li-ion battery.\n\n\nThe li-ion battery is very slim, light and cost effective. It output 3.8 V voltage(nominal). You can also charge it with a specialized charger which has maximum input current 5100 mA and maximum input voltage 4.2V. This battery comes with pre-attached JST 2.0 connector which is handy to click in and out. It also has built-in overcurrent protection to protect against output short circuit. \nAlthough, please still take caution and do not abuse the battery in usage. Never charge or use it unattended.\n\n\nThe battery power detector can detect the input voltage range of 3\u20134.2 volts. There are three JST sockets (JST 1.0, JST 2.0 and JST 2.0) and two battery-soldering pads will adapt to those batteries with a different connector. As you connect a battery to this battery power detector, the on-board four LEDs will indicate remaining power in percentage (0\u201325%, 26\u201350%, 51\u201375%, 76\u2013100%). Another LED will be on if you plug the connector of battery in the wrong way.\n\n\n\n\n\n\nNotes\n\n\n 1. There is only one battery reliable to be tested at the same time.\n\n\n 2. It will damage this battery power detector as the input voltage is above 9 volts.\n\n\n 3. Never use the battery when it is being charged.\n\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nProduct revision\n\n\nRelease date\n\n\nSupport status\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nBattery Detector with Polymer Lithium Ion 1050mAh 3.8V(current version)\n\n\nMay 2016\n\n\nSupported\n\n\nNone\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\nFor battery\n\n\n\n\nFor Pre-attached JST 2.0 connector\n\n\nShort circuit protection for output circuit\n\n\nCost-effective\n\n\n\n\nFor battery power detector\n\n\n\n\nVisual indication on remaining power of a battery\n\n\nDifferent JST sockets for different battery connectors\n\n\n\n\nSpecifications\n\uf0c1\n\n\nFor battery\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nCapacity\n\n\n5100 mAh\n\n\n\n\n\n\nNominal output voltage(DC)\n\n\n3.8 volts\n\n\n\n\n\n\nConnector\n\n\nJST 2.0\n\n\n\n\n\n\nMaximum Charge Current\n\n\n2500 mA\n\n\n\n\n\n\nProtection\n\n\nShort circuit protection for output circuit\n\n\n\n\n\n\nWeight\n\n\n76 g, the whole package weighs 91 g.\n\n\n\n\n\n\nDimensions\n\n\n59.8(width)\u00d710.8(height)\u00d759.5(depth) mm\n\n\n\n\n\n\n\n\nFor battery power detector\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nInput voltage\n\n\n3 \u2013 4.2V\n\n\n\n\n\n\nOperating current\n\n\n15 mA\n\n\n\n\n\n\nIndication manner\n\n\nFour LEDs (we will detail it later)\n\n\n\n\n\n\nSockets\n\n\nThree sockets for different battery connector and two battery-soldering pads (we will detail it later)\n\n\n\n\n\n\nDimensions\n\n\n30(width)\u00d725(depth) mm\n\n\n\n\n\n\nCN1185\n\n\nDatasheet\n\n\n\n\n\n\nWeight\n\n\n3.2 g\n\n\n\n\n\n\nNotes\n\n\nOnly connect a single battery to this module; The input voltage to this module should be less than 9 volts, or it will damage this module.\n\n\n\n\n\n\n\n\nPlatforms supported(only for battery)\n\uf0c1\n\n\n\n\n\n\n\nPlatform\n\n\n\n\nSeeeduino/Arduino\n\n\n\n\nRasberry Pi\n\n\n\n\nBeaglebone\n\n\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\nSupported status\n\n\n\n\nSupported\n\n\n\n\nNot supported\n\n\n\n\nSupported(only with \nGrove Base Cape for Beaglebone\n)\n\n\n\n\nNot supported\n\n\n\n\n\n\n\n\nNotes\n\n\n\n\nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform.\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nCN1185\n, a voltage monitoring circuit.\n\n\nBattery-soldering pads\n, to solder battery\ns leads on.\n\n\n\n\nPackage includes\n(main parts)\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nLi-ion battery\n\n\n1 piece\n\n\n\n\n\n\nBattery power detector\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nConnect battery and battery power detector as in the following image. You can see LEDs are \nON\n indicates actual power remains.\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic(Eagle) file\n\n\nCN1185 Datasheet\n\n\nBattery Datasheet\n\n\nCertifications and Test Report for this Battery", 
            "title": "Battery Detector with Polymer Lithium Ion 5100mAh 3.8V"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#version-tracker", 
            "text": "Product revision  Release date  Support status  Notes      Battery Detector with Polymer Lithium Ion 1050mAh 3.8V(current version)  May 2016  Supported  None", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#features", 
            "text": "For battery   For Pre-attached JST 2.0 connector  Short circuit protection for output circuit  Cost-effective   For battery power detector   Visual indication on remaining power of a battery  Different JST sockets for different battery connectors", 
            "title": "Features"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#specifications", 
            "text": "For battery     Parameter  Value      Capacity  5100 mAh    Nominal output voltage(DC)  3.8 volts    Connector  JST 2.0    Maximum Charge Current  2500 mA    Protection  Short circuit protection for output circuit    Weight  76 g, the whole package weighs 91 g.    Dimensions  59.8(width)\u00d710.8(height)\u00d759.5(depth) mm     For battery power detector     Parameter  Value      Input voltage  3 \u2013 4.2V    Operating current  15 mA    Indication manner  Four LEDs (we will detail it later)    Sockets  Three sockets for different battery connector and two battery-soldering pads (we will detail it later)    Dimensions  30(width)\u00d725(depth) mm    CN1185  Datasheet    Weight  3.2 g    Notes  Only connect a single battery to this module; The input voltage to this module should be less than 9 volts, or it will damage this module.", 
            "title": "Specifications"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#platforms-supportedonly-for-battery", 
            "text": "Platform  \nSeeeduino/Arduino  \nRasberry Pi  \nBeaglebone  \nLinkIt ONE    \nSupported status  \nSupported  \nNot supported  \nSupported(only with  Grove Base Cape for Beaglebone )  \nNot supported    \nNotes  \nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform.", 
            "title": "Platforms supported(only for battery)"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#hardware-overview", 
            "text": "CN1185 , a voltage monitoring circuit.  Battery-soldering pads , to solder battery s leads on.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#package-includesmain-parts", 
            "text": "Parts name  Quantity      Li-ion battery  1 piece    Battery power detector  1 piece", 
            "title": "Package includes(main parts)"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#getting-started", 
            "text": "Connect battery and battery power detector as in the following image. You can see LEDs are  ON  indicates actual power remains.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#resources", 
            "text": "Schematic(Eagle) file  CN1185 Datasheet  Battery Datasheet  Certifications and Test Report for this Battery", 
            "title": "Resources"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/", 
            "text": "CAN-BUS\n is a common industrial bus because of its long travel distance, medium communication speed and high reliability. It is commonly found on modern machine tools and as an automotive diagnostic bus. \n\n\nThis CAN-BUS Shield adopts \nMCP2515\n CAN Bus controller with SPI interface and \nMCP2551\n CAN transceiver to give your Arduino/Seeeduino CAN-BUS capability. With an \nOBD-II\n converter cable added on and the OBD-II library imported, you are ready to build an onboard diagnostic device or data logger.\n\n\nVersion\n\uf0c1\n\n\nThis document applies to the following version of products:\n\n\n\n\n\n\n\n\nVersion\n\n\nReleased Date\n\n\nHow to Buy\n\n\n\n\n\n\n\n\n\n\nCAN BUS Shield V1.0\n\n\nOct 14, 2012\n\n\n\n\n\n\n\n\nCAN BUS Shield V1.1\n\n\nAug 10, 2013\n\n\n\n\n\n\n\n\nCAN BUS Shield V1.2\n\n\nJan 5, 2015\n\n\n\n\n\n\n\n\n\n\nWhat\ns new in CAN BUS Shield V1.2\n\uf0c1\n\n\n\n\nPads on the back of PCBA\n\n\nChange terminal resistor to 120 Ohm\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nImplements CAN V2.0B at up to \n1 Mb/s\n\n\nSPI Interface up to \n10 MHz\n\n\nStandard (\n11 bit\n) and extended (\n29 bit\n) data and remote frames\n\n\nTwo receive buffers with prioritized message storage\n\n\nIndustrial standard DB-9 connector\n\n\nLED indicators\n\n\n\n\n\n\nNote\n\n\nCAN BUS Shield Work well with Arduino UNO (ATmega328), Arduino Mega (ATmega1280/2560) as well as Arduino Leonardo (ATmega32U4).\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n\n\nDB9 Interface\n - to connect to OBDII Interface via a DBG-OBD Cable.\n\n\nV_OBD\n - If get power from OBDII Interface (from DB9)\n\n\nLed Indicator\n:\n\n\nPWR\n: power\n\n\nTX\n: blink when the data is sending\n\n\nRX\n: blink when there\ns data coming\n\n\nINT\n: data interrupt\n\n\n\n\n\n\nTerminal\n - CAN_H and CAN_L\n\n\nArduino UNO pin out\n\n\nSerial Grove connector\n\n\nI2C Grove connector\n\n\nICSP pins\n\n\nIC\n - MCP2551, a high-speed can transceiver (\ndatasheet\n)\n\n\nIC\n - MCP2515, stand-alone CAN controller with SPI interface (\ndatasheet\n)\n\n\n\n\n\n\nWarning\n\n\nWhen you use more than two CAN Bus Shield in one net, you should think about the impedance.\nYou can just cut P1 in the PCB with a knife, or just remove R3 on the PCB.\n\n\n\n\nPin map\n\uf0c1\n\n\n\n\n\n\nNote\n\n\nThe pin FREE is available for the others usage. \n\n\n\n\nDB9\nOBDii Interface\n\uf0c1\n\n\n\n\nCS pin\n\uf0c1\n\n\nSPI_CS pin of V1.2 is default to \nD9\n. If you want to change it to \nD10\n. Take a look at the back of the PCBA, you will find a pad named CS. You can cut the wire that at the left of the pad with a box cutter, and the solder the right 2 pads. \n\n\n\n\nWarning\n\n\nBe careful when you are going to change CS pin, it\ns easy to hear yourself or the PCBA.\n\n\n\n\n\n\nSPI pins\n\uf0c1\n\n\nThe SPI pins (SCK, MISO, MOSI) is default to the ICSP pins. But for some Boards, maybe the SPI pins is at D11~D13, if so you need to change something in the PCBA. Take a look that the back of the PCBA, there\nre three pads, MOSI, MISO and SCK, they are default to A. You can change them to B if needed.\n\n\n\n\nNote\n\n\nFor Arduino UNO, Arduino Mega, Arduino Leonardo and any others AVR based Arduino boards, default is working. \n\n\n\n\n\n\nWarning\n\n\nBe careful when you are going to change SPI pins, it\ns easy to hear yourself or the PCBA.\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\nHere\ns a simple demo to show you how CAN-BUS Shield works. In this demo we need 2 piece of CAN-BUS Shield as well as Arduino/Seeeduino.\n\n\n\n\nNote\n\n\nThis demo is built under \nArduino IDE version 1.6.9\n.\n\n\n\n\nSTEP1: What do we need\n\uf0c1\n\n\n\n\n\n\n\n\nName\n\n\nFunction\n\n\nQty\n\n\nLink\n\n\n\n\n\n\n\n\n\n\nCAN-BUS Shield\n\n\nCAN Bus communication\n\n\n2\n\n\nlink\n\n\n\n\n\n\nSeeeduino V4.2\n\n\nController\n\n\n2\n\n\nlink\n\n\n\n\n\n\nJumper Wire\n\n\nconnection\n\n\n2\n\n\nlink\n\n\n\n\n\n\n\n\nSTEP2: Hardware Connection\n\uf0c1\n\n\nInsert each CAN-BUS Shield to Seeeduino V4.2, and connect the 2 CAN-BUS Shield together via 2 jumper wires. Shown as below images. \n\n\n\n\n\n\nNote\n\n\nCAN_H to CAN_H, CAN_L to CAN_L\n\n\n\n\nSTEP3: Software\n\uf0c1\n\n\nClick on the below button to download the library.\n\n\n\n\nInstall the library to your Arduino IDE when it is downloaded. \n\n\nOf of the node (a node means Seeeduino + CAN_BUS Shield) act as master, the other act as slaver. The master will send data to slaver constantly. \n\n\n\n\nNote\n\n\nEach node can act at master before the code is uploaded. \n\n\n\n\nOpen the \nsend\n example (\nFile \n Examples \n CAN_BUS_Shield-master \n send\n) and upload to the \nmaster\n. \n\n\nOpen the \nreceive_check\n example (\nFile \n Examples \n CAN_BUS_Shield-master \n receive_check\n) and upload to the \nslaver\n.\n\n\nSTEP4: View Result\n\uf0c1\n\n\nOpen the Serial Monitor of Arduino IDE(\nslaver\n), you will get the data sent from the master. \n\n\n\n\nAPIs\n\uf0c1\n\n\n\n\n1. Set the Baud rate\n\uf0c1\n\n\nThis function is used to initialize the baud rate of the CAN Bus system.\n\n\nThe available baud rates are listed as follows:\n\n\n#define CAN_5KBPS    1\n#define CAN_10KBPS   2\n#define CAN_20KBPS   3\n#define CAN_25KBPS   4 \n#define CAN_31K25BPS 5\n#define CAN_33KBPS   6\n#define CAN_40KBPS   7\n#define CAN_50KBPS   8\n#define CAN_80KBPS   9\n#define CAN_83K3BPS  10\n#define CAN_95KBPS   11\n#define CAN_100KBPS  12\n#define CAN_125KBPS  13\n#define CAN_200KBPS  14\n#define CAN_250KBPS  15\n#define CAN_500KBPS  16\n#define CAN_666kbps  17\n#define CAN_1000KBPS 18\n\n\n\n2. Set Receive Mask and Filter\n\uf0c1\n\n\nThere are \n2\n receive mask registers and \n5\n filter registers on the controller chip that guarantee you get data from the target device. They are useful especially in a large network consisting of numerous nodes.\n\n\nWe provide two functions for you to utilize these mask and filter registers. They are:\n\n\nMask:\n\n\ninit_Mask(unsigned char num, unsigned char ext, unsigned char ulData);\n\n\n\nFilter:\n\n\ninit_Filt(unsigned char num, unsigned char ext, unsigned char ulData);\n\n\n\n\n\nnum\n represents which register to use. You can fill 0 or 1 for mask and 0 to 5 for filter.\n\n\next\n represents the status of the frame. 0 means it\ns a mask or filter for a standard frame. 1 means it\ns for a extended frame.\n\n\nulData\n represents the content of the mask of filter.\n\n\n\n\n3. Check Receive\n\uf0c1\n\n\nThe MCP2515 can operate in either a polled mode, where the software checks for a received frame, or using additional pins to signal that a frame has been received or transmit completed. \n\n\nUse the following function to poll for received frames.\n\n\nINT8U MCP_CAN::checkReceive(void);\n\n\n\nThe function will return 1 if a frame arrives, and 0 if nothing arrives.\n\n\n4. Get CAN ID\n\uf0c1\n\n\nWhen some data arrive, you can use the following function to get the CAN ID of the \nsend\n node.\n\n\nINT32U MCP_CAN::getCanId(void)\n\n\n\n5. Send Data\n\uf0c1\n\n\nCAN.sendMsgBuf(INT8U id, INT8U ext, INT8U len, data_buf);\n\n\n\nIt is a function to send data onto the bus. In which:\n\n\n\n\nid\n represents where the data come from.\n\n\next\n represents the status of the frame. \n0\n means standard frame. \n1\n means extended frame.\n\n\nlen\n represents the length of this frame.\n\n\ndata_buf\n is the content of this message.\n\n\n\n\nFor example, In the \nsend\n example, we have:\n\n\nunsigned char stmp[8] = {0, 1, 2, 3, 4, 5, 6, 7};\nCAN.sendMsgBuf(0x00, 0, 8, stmp); //send out the message 'stmp' to the bus and tell other devices this is a standard frame from 0x00.\n\n\n\n6. Receive Data\n\uf0c1\n\n\nThe following function is used to receive data on the \nreceive\n node:\n\n\nCAN.readMsgBuf(unsigned char len, unsigned char buf);\n\n\n\nIn conditions that masks and filters have been set. This function can only get frames that meet the requirements of masks and filters.\n\n\n\n\nlen\n represents the data length.\n\n\nbuf\n is where you store the data.\n\n\n\n\nGenerate a New BaudRate\n\uf0c1\n\n\nWe had provided many frequently-used baud rate, as below:\n\n\n#define CAN_5KBPS    1\n#define CAN_10KBPS   2\n#define CAN_20KBPS   3\n#define CAN_25KBPS   4 \n#define CAN_31K25BPS 5\n#define CAN_33KBPS   6\n#define CAN_40KBPS   7\n#define CAN_50KBPS   8\n#define CAN_80KBPS   9\n#define CAN_83K3BPS  10\n#define CAN_95KBPS   11\n#define CAN_100KBPS  12\n#define CAN_125KBPS  13\n#define CAN_200KBPS  14\n#define CAN_250KBPS  15\n#define CAN_500KBPS  16\n#define CAN_666kbps  17\n#define CAN_1000KBPS 18\n\n\n\nYet you may still can\nt find the rate you want. Here we provide a software to help you to calculate the baud rate you need.\n\n\nClick \nhere\n to download the software, it\ns in Chinese, but never mind, it\ns easy to use. \n\n\n\n\n\n\nNote\n\n\nThis software support Windows system only. If you can\nt open it, please free to contact loovee@seeed.cc for help. \n\n\n\n\nOpen the software, what you need to do is set the baud rate you want, and do some simple setting, then click \ncalculate\n.\n\n\nThen you will get some data, cfg1, cfg2 and cfg3.\n\n\nYou need to add some code to the library.\n\n\nOpen \nmcp_can_dfs.h\n, you need to add some code at about line 272:\n\n\n#define MCP_16MHz_xxxkBPS_CFG1 (cfg1)    // xxx is the baud rate you need\n#define MCP_16MHz_xxxkBPS_CFG2 (cfg2)\n#define MCP_16MHz_xxxkBPS_CFG3 (cfg2)\n\n\n\nThen let\ns go to about line 390, add some code:\n\n\n#define CAN_xxxKBPS NUM       // xxx is the baudrate you need, and NUM is a number, you need to get a different from the other rates.\n\n\n\nOpen \nmcp_can.cpp\n, goto the function \nmcp2515_configRate\n(at about line 190), then add some code:\n\n\ncase (CAN_xxxKBPS):\n    cfg1 = MCP_16MHz_xxxkBPS_CFG1;\n    cfg2 = MCP_16MHz_xxxkBPS_CFG2;\n    cfg3 = MCP_16MHz_xxxkBPS_CFG3;\n    break;\n\n\n\nThen you can use the baud rate you need. And please give me a pull request at github when you use a new rate, so I can add it to the library to help the other guys.\n\n\nProjects\n\uf0c1\n\n\n\n\nIf you want to make some awesome projects with CAN-BUS shield, here\ns some projects for reference.\n\n\nVolkswagen CAN BUS Gaming\n\uf0c1\n\n\n\n\nEver wanted to play a car/truck simulator with a real dashboard on your PC? Me too! I\nm trying to control a VW Polo 6R dashboard via CAN Bus with an Arduino Uno and a Seeed CAN Bus Shield. Inspired by Silas Parker. Thanks to Sepp and Is0-Mick for their great support!\n\n\n\n\nHack your vehicle CAN-BUS\n\uf0c1\n\n\n\n\nModern Vehicles all come equipped with a CAN-BUS Controller Area Network, Instead of having a million wires running back and forth from various devices in your car to the battery, its making use of a more clever system.\n\n\nAll electronic functions are connected to the TIPM, (Totally integrated Power Module), such as solenoids/relays to lock the doors or mini motors to wind the windows etc.\n\n\nFrom each node (IE Switch pod that controls your windows or electric door locks) it broadcasts a message across the CAN. When the TIPM detects a valid message it will react accordingly like, lock the doors, switch on lights and so on.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\n\n\n\u3010PDF\u3011\nCAN-BUS Shield V1.2 Schmatics\n\n\n\u3010Eagle\u3011\nSchematic of CAN-BUS Shield V1.2\n \n\n\n\u3010Library\u3011\nArduino Library for CAN-BUS Shield\n\n\n\u3010Datasheet\u3011\nMCP2515 datasheet\n\n\n\u3010Datasheet\u3011\nMCP2551 datasheet\n\n\n\u3010Demo\u3011\nAn OBD Demo\n\n\n\u3010\nTool\u3011\nMCP2515 Baud Rate Tool\n\n\n\n\nFAQ\n\uf0c1\n\n\n\n\nQ1: I can\nt get data from other CAN device.\n\uf0c1\n\n\n\n\nCheck if the connection is right\n\n\nCheck if the baud rate set right\n\n\n\n\nQ2: The serial monitor print Init Fail.\n\uf0c1\n\n\n\n\nCheck if the CS pin set right in the code. For CAN Bus Shield V1.1/1.2, CS pin is default to D9, others default to D10.\n\n\n\n\nQ3. Where can I find technical support if I have some other issue.\n\uf0c1\n\n\n\n\nYou can post a question to \nSeeed Forum\n or send an email to \ntechsupport@seeed.cc\n.", 
            "title": "CAN-BUS Shield V1.2"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#version", 
            "text": "This document applies to the following version of products:     Version  Released Date  How to Buy      CAN BUS Shield V1.0  Oct 14, 2012     CAN BUS Shield V1.1  Aug 10, 2013     CAN BUS Shield V1.2  Jan 5, 2015", 
            "title": "Version"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#whats-new-in-can-bus-shield-v12", 
            "text": "Pads on the back of PCBA  Change terminal resistor to 120 Ohm", 
            "title": "What's new in CAN BUS Shield V1.2"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#features", 
            "text": "Implements CAN V2.0B at up to  1 Mb/s  SPI Interface up to  10 MHz  Standard ( 11 bit ) and extended ( 29 bit ) data and remote frames  Two receive buffers with prioritized message storage  Industrial standard DB-9 connector  LED indicators    Note  CAN BUS Shield Work well with Arduino UNO (ATmega328), Arduino Mega (ATmega1280/2560) as well as Arduino Leonardo (ATmega32U4).", 
            "title": "Features"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#hardware-overview", 
            "text": "DB9 Interface  - to connect to OBDII Interface via a DBG-OBD Cable.  V_OBD  - If get power from OBDII Interface (from DB9)  Led Indicator :  PWR : power  TX : blink when the data is sending  RX : blink when there s data coming  INT : data interrupt    Terminal  - CAN_H and CAN_L  Arduino UNO pin out  Serial Grove connector  I2C Grove connector  ICSP pins  IC  - MCP2551, a high-speed can transceiver ( datasheet )  IC  - MCP2515, stand-alone CAN controller with SPI interface ( datasheet )    Warning  When you use more than two CAN Bus Shield in one net, you should think about the impedance.\nYou can just cut P1 in the PCB with a knife, or just remove R3 on the PCB.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#pin-map", 
            "text": "Note  The pin FREE is available for the others usage.", 
            "title": "Pin map"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#db9obdii-interface", 
            "text": "", 
            "title": "DB9&amp;OBDii Interface"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#cs-pin", 
            "text": "SPI_CS pin of V1.2 is default to  D9 . If you want to change it to  D10 . Take a look at the back of the PCBA, you will find a pad named CS. You can cut the wire that at the left of the pad with a box cutter, and the solder the right 2 pads.    Warning  Be careful when you are going to change CS pin, it s easy to hear yourself or the PCBA.", 
            "title": "CS pin"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#spi-pins", 
            "text": "The SPI pins (SCK, MISO, MOSI) is default to the ICSP pins. But for some Boards, maybe the SPI pins is at D11~D13, if so you need to change something in the PCBA. Take a look that the back of the PCBA, there re three pads, MOSI, MISO and SCK, they are default to A. You can change them to B if needed.   Note  For Arduino UNO, Arduino Mega, Arduino Leonardo and any others AVR based Arduino boards, default is working.     Warning  Be careful when you are going to change SPI pins, it s easy to hear yourself or the PCBA.", 
            "title": "SPI pins"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#getting-started", 
            "text": "Here s a simple demo to show you how CAN-BUS Shield works. In this demo we need 2 piece of CAN-BUS Shield as well as Arduino/Seeeduino.   Note  This demo is built under  Arduino IDE version 1.6.9 .", 
            "title": "Getting Started"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#step1-what-do-we-need", 
            "text": "Name  Function  Qty  Link      CAN-BUS Shield  CAN Bus communication  2  link    Seeeduino V4.2  Controller  2  link    Jumper Wire  connection  2  link", 
            "title": "STEP1: What do we need"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#step2-hardware-connection", 
            "text": "Insert each CAN-BUS Shield to Seeeduino V4.2, and connect the 2 CAN-BUS Shield together via 2 jumper wires. Shown as below images.     Note  CAN_H to CAN_H, CAN_L to CAN_L", 
            "title": "STEP2: Hardware Connection"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#step3-software", 
            "text": "Click on the below button to download the library.   Install the library to your Arduino IDE when it is downloaded.   Of of the node (a node means Seeeduino + CAN_BUS Shield) act as master, the other act as slaver. The master will send data to slaver constantly.    Note  Each node can act at master before the code is uploaded.    Open the  send  example ( File   Examples   CAN_BUS_Shield-master   send ) and upload to the  master .   Open the  receive_check  example ( File   Examples   CAN_BUS_Shield-master   receive_check ) and upload to the  slaver .", 
            "title": "STEP3: Software"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#step4-view-result", 
            "text": "Open the Serial Monitor of Arduino IDE( slaver ), you will get the data sent from the master.", 
            "title": "STEP4: View Result"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#apis", 
            "text": "", 
            "title": "APIs"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#1-set-the-baud-rate", 
            "text": "This function is used to initialize the baud rate of the CAN Bus system.  The available baud rates are listed as follows:  #define CAN_5KBPS    1\n#define CAN_10KBPS   2\n#define CAN_20KBPS   3\n#define CAN_25KBPS   4 \n#define CAN_31K25BPS 5\n#define CAN_33KBPS   6\n#define CAN_40KBPS   7\n#define CAN_50KBPS   8\n#define CAN_80KBPS   9\n#define CAN_83K3BPS  10\n#define CAN_95KBPS   11\n#define CAN_100KBPS  12\n#define CAN_125KBPS  13\n#define CAN_200KBPS  14\n#define CAN_250KBPS  15\n#define CAN_500KBPS  16\n#define CAN_666kbps  17\n#define CAN_1000KBPS 18", 
            "title": "1. Set the Baud rate"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#2-set-receive-mask-and-filter", 
            "text": "There are  2  receive mask registers and  5  filter registers on the controller chip that guarantee you get data from the target device. They are useful especially in a large network consisting of numerous nodes.  We provide two functions for you to utilize these mask and filter registers. They are:  Mask:  init_Mask(unsigned char num, unsigned char ext, unsigned char ulData);  Filter:  init_Filt(unsigned char num, unsigned char ext, unsigned char ulData);   num  represents which register to use. You can fill 0 or 1 for mask and 0 to 5 for filter.  ext  represents the status of the frame. 0 means it s a mask or filter for a standard frame. 1 means it s for a extended frame.  ulData  represents the content of the mask of filter.", 
            "title": "2. Set Receive Mask and Filter"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#3-check-receive", 
            "text": "The MCP2515 can operate in either a polled mode, where the software checks for a received frame, or using additional pins to signal that a frame has been received or transmit completed.   Use the following function to poll for received frames.  INT8U MCP_CAN::checkReceive(void);  The function will return 1 if a frame arrives, and 0 if nothing arrives.", 
            "title": "3. Check Receive"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#4-get-can-id", 
            "text": "When some data arrive, you can use the following function to get the CAN ID of the  send  node.  INT32U MCP_CAN::getCanId(void)", 
            "title": "4. Get CAN ID"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#5-send-data", 
            "text": "CAN.sendMsgBuf(INT8U id, INT8U ext, INT8U len, data_buf);  It is a function to send data onto the bus. In which:   id  represents where the data come from.  ext  represents the status of the frame.  0  means standard frame.  1  means extended frame.  len  represents the length of this frame.  data_buf  is the content of this message.   For example, In the  send  example, we have:  unsigned char stmp[8] = {0, 1, 2, 3, 4, 5, 6, 7};\nCAN.sendMsgBuf(0x00, 0, 8, stmp); //send out the message 'stmp' to the bus and tell other devices this is a standard frame from 0x00.", 
            "title": "5. Send Data"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#6-receive-data", 
            "text": "The following function is used to receive data on the  receive  node:  CAN.readMsgBuf(unsigned char len, unsigned char buf);  In conditions that masks and filters have been set. This function can only get frames that meet the requirements of masks and filters.   len  represents the data length.  buf  is where you store the data.", 
            "title": "6. Receive Data"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#generate-a-new-baudrate", 
            "text": "We had provided many frequently-used baud rate, as below:  #define CAN_5KBPS    1\n#define CAN_10KBPS   2\n#define CAN_20KBPS   3\n#define CAN_25KBPS   4 \n#define CAN_31K25BPS 5\n#define CAN_33KBPS   6\n#define CAN_40KBPS   7\n#define CAN_50KBPS   8\n#define CAN_80KBPS   9\n#define CAN_83K3BPS  10\n#define CAN_95KBPS   11\n#define CAN_100KBPS  12\n#define CAN_125KBPS  13\n#define CAN_200KBPS  14\n#define CAN_250KBPS  15\n#define CAN_500KBPS  16\n#define CAN_666kbps  17\n#define CAN_1000KBPS 18  Yet you may still can t find the rate you want. Here we provide a software to help you to calculate the baud rate you need.  Click  here  to download the software, it s in Chinese, but never mind, it s easy to use.     Note  This software support Windows system only. If you can t open it, please free to contact loovee@seeed.cc for help.    Open the software, what you need to do is set the baud rate you want, and do some simple setting, then click  calculate .  Then you will get some data, cfg1, cfg2 and cfg3.  You need to add some code to the library.  Open  mcp_can_dfs.h , you need to add some code at about line 272:  #define MCP_16MHz_xxxkBPS_CFG1 (cfg1)    // xxx is the baud rate you need\n#define MCP_16MHz_xxxkBPS_CFG2 (cfg2)\n#define MCP_16MHz_xxxkBPS_CFG3 (cfg2)  Then let s go to about line 390, add some code:  #define CAN_xxxKBPS NUM       // xxx is the baudrate you need, and NUM is a number, you need to get a different from the other rates.  Open  mcp_can.cpp , goto the function  mcp2515_configRate (at about line 190), then add some code:  case (CAN_xxxKBPS):\n    cfg1 = MCP_16MHz_xxxkBPS_CFG1;\n    cfg2 = MCP_16MHz_xxxkBPS_CFG2;\n    cfg3 = MCP_16MHz_xxxkBPS_CFG3;\n    break;  Then you can use the baud rate you need. And please give me a pull request at github when you use a new rate, so I can add it to the library to help the other guys.", 
            "title": "Generate a New BaudRate"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#projects", 
            "text": "If you want to make some awesome projects with CAN-BUS shield, here s some projects for reference.", 
            "title": "Projects"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#volkswagen-can-bus-gaming", 
            "text": "Ever wanted to play a car/truck simulator with a real dashboard on your PC? Me too! I m trying to control a VW Polo 6R dashboard via CAN Bus with an Arduino Uno and a Seeed CAN Bus Shield. Inspired by Silas Parker. Thanks to Sepp and Is0-Mick for their great support!", 
            "title": "Volkswagen CAN BUS Gaming"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#hack-your-vehicle-can-bus", 
            "text": "Modern Vehicles all come equipped with a CAN-BUS Controller Area Network, Instead of having a million wires running back and forth from various devices in your car to the battery, its making use of a more clever system.  All electronic functions are connected to the TIPM, (Totally integrated Power Module), such as solenoids/relays to lock the doors or mini motors to wind the windows etc.  From each node (IE Switch pod that controls your windows or electric door locks) it broadcasts a message across the CAN. When the TIPM detects a valid message it will react accordingly like, lock the doors, switch on lights and so on.", 
            "title": "Hack your vehicle CAN-BUS"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#resources", 
            "text": "\u3010PDF\u3011 CAN-BUS Shield V1.2 Schmatics  \u3010Eagle\u3011 Schematic of CAN-BUS Shield V1.2    \u3010Library\u3011 Arduino Library for CAN-BUS Shield  \u3010Datasheet\u3011 MCP2515 datasheet  \u3010Datasheet\u3011 MCP2551 datasheet  \u3010Demo\u3011 An OBD Demo  \u3010 Tool\u3011 MCP2515 Baud Rate Tool", 
            "title": "Resources"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#q1-i-cant-get-data-from-other-can-device", 
            "text": "Check if the connection is right  Check if the baud rate set right", 
            "title": "Q1: I can't get data from other CAN device."
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#q2-the-serial-monitor-print-init-fail", 
            "text": "Check if the CS pin set right in the code. For CAN Bus Shield V1.1/1.2, CS pin is default to D9, others default to D10.", 
            "title": "Q2: The serial monitor print Init Fail."
        }, 
        {
            "location": "/CAN-BUS_Shield_V1.2/#q3-where-can-i-find-technical-support-if-i-have-some-other-issue", 
            "text": "You can post a question to  Seeed Forum  or send an email to  techsupport@seeed.cc .", 
            "title": "Q3. Where can I find technical support if I have some other issue."
        }, 
        {
            "location": "/EL_Shield/", 
            "text": "This shield is used to control EL devices. It can control 4 EL devices simultaneously. The controlling method is as simple as controlling an LED. Driven by PWM, it can create a colorful and florid effect by controlling each EL wire with a simple program. Combined with our EL Inverter, it can drive an EL wire as long as 15m, which provides infinite possibility for your design. Besides, the Shield is covered by Acrylic board, which enhances user\ns safety.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nOperating Voltage: 5V\n\n\nInvertor interface: JST 2.0\n\n\nControl channel interface: 2P - 2.5SM socket\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nDemonstration\n\uf0c1\n\n\nHere is a simple demo involving EL shield, 4 EL tapes and the custom invertor that accompanies EL shield.\nHook all things up as in the picture below.\n\n\n\n\nUpload the code below to your microcontroller.\n\n\n// EL test code \n\u00a0\nvoid setup(){\n for(int i = 4; i\n8; i++)\n { \n  pinMode(i, OUTPUT);\n }\n}\n\u00a0\nvoid setEL(int ch) // set a certain EL on\n{ \n for(int i = 4; i\n8; i++) // all off\n digitalWrite(i, LOW);\n digitalWrite(ch+3, HIGH); // ch on\n} \n\u00a0\nint count = 0; \n\u00a0\nvoid loop()\n{ \n setEL(count%4 + 1);\n delay(200);\n if(count++ == 1000)\n { \n  count = 0;\n } \n}\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nEL Shield eagle file\n\n\nEL Shield Source code file for Arduino 1.0\n\n\nBT134W-600D datasheet\n\n\nMOC 3063 datasheet", 
            "title": "EL Shield"
        }, 
        {
            "location": "/EL_Shield/#specifications", 
            "text": "Operating Voltage: 5V  Invertor interface: JST 2.0  Control channel interface: 2P - 2.5SM socket", 
            "title": "Specifications"
        }, 
        {
            "location": "/EL_Shield/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/EL_Shield/#demonstration", 
            "text": "Here is a simple demo involving EL shield, 4 EL tapes and the custom invertor that accompanies EL shield.\nHook all things up as in the picture below.   Upload the code below to your microcontroller.  // EL test code \n\u00a0\nvoid setup(){\n for(int i = 4; i 8; i++)\n { \n  pinMode(i, OUTPUT);\n }\n}\n\u00a0\nvoid setEL(int ch) // set a certain EL on\n{ \n for(int i = 4; i 8; i++) // all off\n digitalWrite(i, LOW);\n digitalWrite(ch+3, HIGH); // ch on\n} \n\u00a0\nint count = 0; \n\u00a0\nvoid loop()\n{ \n setEL(count%4 + 1);\n delay(200);\n if(count++ == 1000)\n { \n  count = 0;\n } \n}", 
            "title": "Demonstration"
        }, 
        {
            "location": "/EL_Shield/#resources", 
            "text": "EL Shield eagle file  EL Shield Source code file for Arduino 1.0  BT134W-600D datasheet  MOC 3063 datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Energy_Shield/", 
            "text": "Energy Shield is a LiPo battery based power shield that keeps your project alive. It keeps its battery charged whenever an available power source exists. It accepts a wide range of power sources, from common solar cells via JST connector and USB via USB port on microcontroller, to 9V and 12V DC adapters via DC Jack on your Arduino. Meanwhile it can not only provide power for your Arduino project, with a standard USB port populated on the shield, it\u2019s also capable of rescuing your mobile electric devices from dying batteries, such as mobile phone, mp3 and tablet.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nAccept wide range of power inputs\n\n\nOvervoltage protection\n\n\n85%+ high power conversion efficiency\n\n\nComprehensive LEDs indicators for charging and working status\n\n\n\n\nSpecifications\n\uf0c1\n\n\nPower Output Specifications\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nvoltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\ncurrent\n\n\n5\n\n\n/\n\n\n750\n\n\nmA\n\n\n\n\n\n\n\n\nPower Input Specifications via JST Connector\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nEffective Voltage\n\n\n4.5\n\n\n5\n\n\n5.5\n\n\nV\n\n\n\n\n\n\nCurrent\n\n\n1\n\n\n/\n\n\n800\n\n\nmA\n\n\n\n\n\n\nProtection Voltage\n\n\n/\n\n\n/\n\n\n12\n\n\nV\n\n\n\n\n\n\n\n\nWorking Mode Explanation\n\n\nEnergy shield can draw current from three different ports to charge the battery, including JST connector, USB port @ Arduino and DC jack. The voltage ranges vary as below:\n\n\n\n\nWhen input voltage is under 6.6V, you can switch the working mode of Energy Shield between \u201cCharge\u201d and \u201cON\u201d via the working mode select switch. In \u201cCharge\u201d condition, Lipo battery doesn\u2019t output but only pull current from any existing power source. In \u201cON\u201d condition, the battery gets charged as well as supplies power to the whole system.\n\n\nHowever when input voltage exceeds 6.6V, Energy Shield is forced to enter the \u201cCharge\u201d mode regardless of the switch status.\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nHardware Config\n\n\nU1: ISL97516 IC, boost chip;\n\n\nU3: CN3065 IC, charge management chip;\n\n\nU4,U8: LM293D IC, dual differential comparators;\n\n\nCharge Indicator: it lights in charging status;\n\n\nCapacity Indicator: indicate the remaining life of battery;\n\n\nSW2 Button: check the capacity of battery;\n\n\nPins Used on Arduino\n\n\nVin pin: convey power from DC jack to charge battery;\n\n\n5V pin: convey power from USB port to charge battery;\n\n\nOther Interfaces\n\n\nJST socket\uff1aprovided for external power sources that requires JST connector, like solar panel;\n\n\nBattery socket: used to hook up LiPo battery;\n\n\nUSB port: output 5V for other devices;\n\n\nUsage\n\uf0c1\n\n\n1. Charge Examples\n\uf0c1\n\n\nYou can charge the Lipo battery with massive external power sources. Here we show you usages of two common powersources.\u00a0\n\n\n1) Solar Panel\n \u00a0 \u00a0\n\n\nSolar panel is one of the most common green power sources we use. The typical output of one unit is around 5V.\u00a0We provide \nlots of solar panels\n at our store. They are all pre-assembled with JST connencors which can seamlessly match up with Energy Shield.\u00a0\n\n\nPlug solar panel into JST socket on the shield as below.\n\n\n\n\nNote\n\nMake sure there is sufficient light to provide considerable current.\n\n\n\n\n\n\nNow, press down SW2. You will find the \nCharge\n indicator LED lights up. The other indicator \nCapacity\n indicates remaining power of battery. When the remaining power is below 30%, it turns red. When remaining power is between 30% - 80%, it turns yellow. Otherwise it\ns green.\n\n\n\n\n2) 9V Adaptor\n \u00a0 \u00a0\n\n\nIf you are using a DC adaptor to supply power to your project, then 9V adaptor won\nt be unfamiliar to you. By connecting a 9V adapter to DC Jack of Arduino, you can run your project as well as charge the battery simultaneously.\n\n\n\n\n2. Shield power for device\n\uf0c1\n\n\n1) Supply Power For Arduino\n\n\n\n\nSwitch the working mode select switch to \nON\n. Check on the power indicator LED on Arduino to see if it works appropriately.\n\n\n2) Supply Power For Mobile Devices\n\n\n\n\nUse the standard USB port on the shield to supply power to mobile devices.\n\n\n3. Conversion Efficiency\n\uf0c1\n\n\n\n\nThe graph above describes the conversion efficiency of boost circuit of Energy Shield. Boost circuit boosts the voltage of Lipo battery, which is typically 4.2V or 3.7V with the drop of remaining power, to 5V and supplies outward. You can find this conversion efficiency peaks when output current is around 200mA.\n\n\nResources\n\uf0c1\n\n\n\n\nEnergy Shield Eagle File\n\n\nCN3065 Datasheet\n\n\nISL97516 Datasheet\n\n\nLM293D Datasheet", 
            "title": "Energy Shield"
        }, 
        {
            "location": "/Energy_Shield/#features", 
            "text": "Accept wide range of power inputs  Overvoltage protection  85%+ high power conversion efficiency  Comprehensive LEDs indicators for charging and working status", 
            "title": "Features"
        }, 
        {
            "location": "/Energy_Shield/#specifications", 
            "text": "Power Output Specifications     Item  Min  Typical  Max  Unit      voltage  4.9  5  5.1  V    current  5  /  750  mA     Power Input Specifications via JST Connector     Item  Min  Typical  Max  Unit      Effective Voltage  4.5  5  5.5  V    Current  1  /  800  mA    Protection Voltage  /  /  12  V     Working Mode Explanation  Energy shield can draw current from three different ports to charge the battery, including JST connector, USB port @ Arduino and DC jack. The voltage ranges vary as below:   When input voltage is under 6.6V, you can switch the working mode of Energy Shield between \u201cCharge\u201d and \u201cON\u201d via the working mode select switch. In \u201cCharge\u201d condition, Lipo battery doesn\u2019t output but only pull current from any existing power source. In \u201cON\u201d condition, the battery gets charged as well as supplies power to the whole system.  However when input voltage exceeds 6.6V, Energy Shield is forced to enter the \u201cCharge\u201d mode regardless of the switch status.", 
            "title": "Specifications"
        }, 
        {
            "location": "/Energy_Shield/#hardware-overview", 
            "text": "Hardware Config  U1: ISL97516 IC, boost chip;  U3: CN3065 IC, charge management chip;  U4,U8: LM293D IC, dual differential comparators;  Charge Indicator: it lights in charging status;  Capacity Indicator: indicate the remaining life of battery;  SW2 Button: check the capacity of battery;  Pins Used on Arduino  Vin pin: convey power from DC jack to charge battery;  5V pin: convey power from USB port to charge battery;  Other Interfaces  JST socket\uff1aprovided for external power sources that requires JST connector, like solar panel;  Battery socket: used to hook up LiPo battery;  USB port: output 5V for other devices;", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Energy_Shield/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Energy_Shield/#1-charge-examples", 
            "text": "You can charge the Lipo battery with massive external power sources. Here we show you usages of two common powersources.\u00a0  1) Solar Panel  \u00a0 \u00a0  Solar panel is one of the most common green power sources we use. The typical output of one unit is around 5V.\u00a0We provide  lots of solar panels  at our store. They are all pre-assembled with JST connencors which can seamlessly match up with Energy Shield.\u00a0  Plug solar panel into JST socket on the shield as below.   Note \nMake sure there is sufficient light to provide considerable current.   Now, press down SW2. You will find the  Charge  indicator LED lights up. The other indicator  Capacity  indicates remaining power of battery. When the remaining power is below 30%, it turns red. When remaining power is between 30% - 80%, it turns yellow. Otherwise it s green.   2) 9V Adaptor  \u00a0 \u00a0  If you are using a DC adaptor to supply power to your project, then 9V adaptor won t be unfamiliar to you. By connecting a 9V adapter to DC Jack of Arduino, you can run your project as well as charge the battery simultaneously.", 
            "title": "1. Charge Examples"
        }, 
        {
            "location": "/Energy_Shield/#2-shield-power-for-device", 
            "text": "1) Supply Power For Arduino   Switch the working mode select switch to  ON . Check on the power indicator LED on Arduino to see if it works appropriately.  2) Supply Power For Mobile Devices   Use the standard USB port on the shield to supply power to mobile devices.", 
            "title": "2. Shield power for device"
        }, 
        {
            "location": "/Energy_Shield/#3-conversion-efficiency", 
            "text": "The graph above describes the conversion efficiency of boost circuit of Energy Shield. Boost circuit boosts the voltage of Lipo battery, which is typically 4.2V or 3.7V with the drop of remaining power, to 5V and supplies outward. You can find this conversion efficiency peaks when output current is around 200mA.", 
            "title": "3. Conversion Efficiency"
        }, 
        {
            "location": "/Energy_Shield/#resources", 
            "text": "Energy Shield Eagle File  CN3065 Datasheet  ISL97516 Datasheet  LM293D Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Motor_Shield_V2.0/", 
            "text": "Note\n\n\nThis document works for Motor Shield V2.0/2.1/2.2.\n\n\n\n\nThe Motor Shield is a driver module for motors that allows you to use Arduino to control the working speed and direction of the motor. Based on the Dual Full-Bridge Drive Chip L298, it is able to drive two DC motors or a step motor. The Motor Shield can either be powered directly by Arduino or by an external 6V~15V power supply via the terminal input. This module can be used for the development of micro robots and intelligent vehicles, etc\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nStandard Arduino UNO Shield pin out\n\n\nBased on L298 full bridge IC\n\n\nDrive 2 DC Motor or 1 Stepper\n\n\nExternal power input available\n\n\nLed indicator\n\n\nHeat sink for better performance\n\n\nArduino library\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nSpec\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating Voltage\n\n\n5V\n\n\n\n\n\n\nExternal Power\n\n\n6-15V\n\n\n\n\n\n\nOutput Current\n\n\n2.0A Max @ Each Channel\n\n\n\n\n\n\nPWM Range\n\n\n0-100%\n\n\n\n\n\n\nOutput\n\n\n2 Channels, 4 Ports\n\n\n\n\n\n\n\n\nHardware Overivew\n\uf0c1\n\n\n\n\n1\n.Channel 1 indicator, include 3 leds\n\n\n\n\nEB - channel 1 enable, high active\n\n\nIN3 - status of OUT3\n\n\nIN4 - status of OUT4\n\n\n\n\n2\n.Channel 1 Sense - Please connect the left 2 pins together for normal usage.\n\n\nNote\n that it\ns a high level application for sense the current, please refer to datasheet and schematic for more information.\n\n\n3\n.OUTPUT - There\nre 2 channels, each channel has 2 output\n\n\n\n\nChannel 0 - OUT1, OUT2\n\n\nChannel 1 - OUT3, OUT4\n\n\n\n\n4\n.Channel 0 Sense\n\n\n5\n.Channel 0 indicator, include 3 leds\n\n\n\n\nEB - channel 0 enable, high active\n\n\nIN1 - status of OUT1\n\n\nIN2 - status of OUT2\n\n\n\n\n6\n.External Power Input, range 6-15V\n\n\n7\n.Reset indicator - turn red when Reset button is pressed\n\n\n8\n.Reset button - pressed to reset the shield and Arduino\n\n\n9\n.Power indicator - turn green when power in, either internal or external\n\n\nA.\nPower switch\n\n\n\n\nConnect - Get power from Arduino\n\n\nDisconnect - Get power from External sources\n\n\n\n\nB.\nStandard Arduino shield pin out\n\n\nDigital Pin Used\n\uf0c1\n\n\n\n\n\n\n\n\nArduino Pin\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nD0\n\n\nNot Used\n\n\n\n\n\n\nD1\n\n\nNot Used\n\n\n\n\n\n\nD2\n\n\nNot Used\n\n\n\n\n\n\nD3\n\n\nNot Used\n\n\n\n\n\n\nD4\n\n\nNot Used\n\n\n\n\n\n\nD5\n\n\nNot Used\n\n\n\n\n\n\nD6\n\n\nNot Used\n\n\n\n\n\n\nD7\n\n\nNot Used\n\n\n\n\n\n\nD8\n\n\nOUT1\n\n\n\n\n\n\nD9\n\n\nEnable of Channel0\n\n\n\n\n\n\nD10\n\n\nEnable of Chennel1\n\n\n\n\n\n\nD11\n\n\nOUT2\n\n\n\n\n\n\nD12\n\n\nOUT3\n\n\n\n\n\n\nD13\n\n\nOUT4\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nD8~D13 was used by Motor Shield. Please don\nt use those pins to avoid conflict.\n\n\n\n\nAnalog Pin Used\n\uf0c1\n\n\n\n\n\n\n\n\nArduino Pin\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nD0\n\n\nNot Used\n\n\n\n\n\n\nD1\n\n\nNot Used\n\n\n\n\n\n\nD2\n\n\nNot Used\n\n\n\n\n\n\nD3\n\n\nNot Used\n\n\n\n\n\n\nD4\n\n\nNot Used\n\n\n\n\n\n\nD5\n\n\nNot Used\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nNot Used means you can use those pins freely. \n\n\n\n\nGetteing Started\n\uf0c1\n\n\nHere we will show you how to drive a dc motor and a stepper with this shield.\n\n\nWe need a\n Seeeduino V4 \nas the controller, Seeeduino V4 is an Arduino compatible board, and you can use an Arduino as well.\n\n\nAnd you need a dc motor or a stepper for testing.\n\n\nDownload the library\n\uf0c1\n\n\nClick the below button to download the library. If the library you had download include \n-master\n, please remove it.\n\n\n\n\nDrive a DC Motor\n\uf0c1\n\n\nYou can drive 2 DC motor with this shield. Here I will show you how to drive a DC motor.\n\n\n\nYou need to do some preparing first:\n\n\n\n\nSet \nSEN_A\n and \nSEN_B\n, connect the left 2 pins together with a jumper.\n\n\nConnect \nMB_EN\n together with a jumper, as we are no going use an external power.\n\n\nConnect your DC motor to Chanel 0 (OUT1 and OUT2).\n\n\n\n\nThen open \nmotor_dc\n example in the library. Upload the code to Seeeduino V4.2.\n\n\n//  Demo function:The application method to drive the DC motor.\n//  Author:Loovee (luweicong@seeed.cc)\n//  2016-3-11\n\n#include \nMotorDriver.h\n\n\nMotorDriver motor;\n\nvoid setup()\n{\n    // initialize\n    motor.begin();\n}\n\nvoid loop()\n{\n    motor.speed(0, 100);            // set motor0 to speed 100\n    delay(1000);\n    motor.brake(0);                 // brake\n    delay(1000);\n    motor.speed(0, -100);           // set motor0 to speed -100\n    delay(1000);\n    motor.stop(0);                  // stop\n    delay(1000);\n}\n// END FILE\n\n\n\n\nThen you will find your motor move (1s), stop (1s), move back (1s), stop (1s), and loop.\n\n\nIf there\ns nothing happen, please make sure:\n\n\n\n\nYou had uploaded the code successfully\n\n\nYour motor connect right\n\n\nThe led indicators blink right\n\n\n\n\nDrive a Stepper\n\uf0c1\n\n\nYou can drive a 4-wire stepper with this shield. Here I will show you how to drive a \n stepper \n\n\n\n\nYou need to do some preparing first:\n- Set \nSEN_A\n and \nSEN_B\n, connect the left 2 pins together with a jumper.\n- Connect \nMB_EN\n together with a jumper, as we are no going to use an external power.\n\n\nFind the pin definitions of you stepper, and connect it to the OUTPUT of the shield. As below:\n\n\n\n\n\n\n\n\nStepper\n\n\nMotor Shield\n\n\n\n\n\n\n\n\n\n\nA+\n\n\nOUT1\n\n\n\n\n\n\nA-\n\n\nOUT2\n\n\n\n\n\n\nB+\n\n\nOUT3\n\n\n\n\n\n\nB-\n\n\nOUT4\n\n\n\n\n\n\n\n\nThen open \nstepper_test\n example in the library, upload it to Seeeduino V4, then you will find your stepper move.\n\n\n/*\n * Stepper test for Seeed Motor Shield V2\n * loovee @ 15 Mar, 2016\n */\n\n#include \nStepper.h\n\n\n// change this to the number of steps on your motor\n#define STEPS 200\n\n// create an instance of the stepper class, specifying\n// the number of steps of the motor and the pins it's\n// attached to\nStepper stepper(STEPS, 8, 11, 12, 13);\n\n// the previous reading from the analog input\nint previous = 0;\n\nvoid step(int steps)\n{\n    digitalWrite(9, HIGH);\n    digitalWrite(10, HIGH);\n    stepper.step(steps);\n    digitalWrite(9, LOW);\n    digitalWrite(10, LOW);\n}\n\nvoid setup()\n{\n    // set the speed of the motor to 30 RPMs\n    pinMode(9, OUTPUT);\n    pinMode(10, OUTPUT);\n    digitalWrite(9, LOW);\n    digitalWrite(10, LOW);\n    stepper.setSpeed(30);\n}\n\nvoid loop()\n{\n    step(1000);\n    step(-1000);\n}\n\n// END FILE\n\n\n\n\nIf there\ns nothing happen, please double check if you had connected the wire right.\n\n\nLibrary APIs\n\uf0c1\n\n\nbegin\n\uf0c1\n\n\nDescription\n\n\nvoid begin();\n\n\n\n\nspeed\n\uf0c1\n\n\nDescription\n\n\nSet speed, control by PWM.\n\n\nvoid move(int motor_id, int speed);\n\n\n\n\n\n\nmotor_id\n\n\n0 - Chanel 0\n\n\n1 - Chanel 1\n\n\nspeed: -100~100, the larger the faster, 0 for stop\n\n\n\n\nstop\n\n\nvoid stop(unsigned char motor_id);\n\n\n\n\nbrake\n\n\nvoid brake(unsigned char motor_id);\n\n\n\n\nStepper\n\uf0c1\n\n\nNote\n that we use the library provided by Arduino IDE to drive a stepper.\n\n\nThere\ns something need to be modified, please refer the examples.\n\n\nResources\n\uf0c1\n\n\n\n\n Motor Shield V2.0 Eagle File \n\n\nMotor shield V2.1 Eagle File \n\n\nMotor Shield 2.0 schematics\n\n\nMotor Shield 2.1 schematics\n\n\nMotor Shield 2.2 schematics\n\n\nMotor Shield Library\n\n\nL298 Datasheet\n\n\n78M05 Datasheet", 
            "title": "Motor Shield V2.0"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#features", 
            "text": "Standard Arduino UNO Shield pin out  Based on L298 full bridge IC  Drive 2 DC Motor or 1 Stepper  External power input available  Led indicator  Heat sink for better performance  Arduino library", 
            "title": "Features"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#specifications", 
            "text": "Spec  Value      Operating Voltage  5V    External Power  6-15V    Output Current  2.0A Max @ Each Channel    PWM Range  0-100%    Output  2 Channels, 4 Ports", 
            "title": "Specifications"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#hardware-overivew", 
            "text": "1 .Channel 1 indicator, include 3 leds   EB - channel 1 enable, high active  IN3 - status of OUT3  IN4 - status of OUT4   2 .Channel 1 Sense - Please connect the left 2 pins together for normal usage.  Note  that it s a high level application for sense the current, please refer to datasheet and schematic for more information.  3 .OUTPUT - There re 2 channels, each channel has 2 output   Channel 0 - OUT1, OUT2  Channel 1 - OUT3, OUT4   4 .Channel 0 Sense  5 .Channel 0 indicator, include 3 leds   EB - channel 0 enable, high active  IN1 - status of OUT1  IN2 - status of OUT2   6 .External Power Input, range 6-15V  7 .Reset indicator - turn red when Reset button is pressed  8 .Reset button - pressed to reset the shield and Arduino  9 .Power indicator - turn green when power in, either internal or external  A. Power switch   Connect - Get power from Arduino  Disconnect - Get power from External sources   B. Standard Arduino shield pin out", 
            "title": "Hardware Overivew"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#digital-pin-used", 
            "text": "Arduino Pin  Function      D0  Not Used    D1  Not Used    D2  Not Used    D3  Not Used    D4  Not Used    D5  Not Used    D6  Not Used    D7  Not Used    D8  OUT1    D9  Enable of Channel0    D10  Enable of Chennel1    D11  OUT2    D12  OUT3    D13  OUT4      Note  D8~D13 was used by Motor Shield. Please don t use those pins to avoid conflict.", 
            "title": "Digital Pin Used"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#analog-pin-used", 
            "text": "Arduino Pin  Function      D0  Not Used    D1  Not Used    D2  Not Used    D3  Not Used    D4  Not Used    D5  Not Used      Note  Not Used means you can use those pins freely.", 
            "title": "Analog Pin Used"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#getteing-started", 
            "text": "Here we will show you how to drive a dc motor and a stepper with this shield.  We need a  Seeeduino V4  as the controller, Seeeduino V4 is an Arduino compatible board, and you can use an Arduino as well.  And you need a dc motor or a stepper for testing.", 
            "title": "Getteing Started"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#download-the-library", 
            "text": "Click the below button to download the library. If the library you had download include  -master , please remove it.", 
            "title": "Download the library"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#drive-a-dc-motor", 
            "text": "You can drive 2 DC motor with this shield. Here I will show you how to drive a DC motor.  You need to do some preparing first:   Set  SEN_A  and  SEN_B , connect the left 2 pins together with a jumper.  Connect  MB_EN  together with a jumper, as we are no going use an external power.  Connect your DC motor to Chanel 0 (OUT1 and OUT2).   Then open  motor_dc  example in the library. Upload the code to Seeeduino V4.2.  //  Demo function:The application method to drive the DC motor.\n//  Author:Loovee (luweicong@seeed.cc)\n//  2016-3-11\n\n#include  MotorDriver.h \n\nMotorDriver motor;\n\nvoid setup()\n{\n    // initialize\n    motor.begin();\n}\n\nvoid loop()\n{\n    motor.speed(0, 100);            // set motor0 to speed 100\n    delay(1000);\n    motor.brake(0);                 // brake\n    delay(1000);\n    motor.speed(0, -100);           // set motor0 to speed -100\n    delay(1000);\n    motor.stop(0);                  // stop\n    delay(1000);\n}\n// END FILE  Then you will find your motor move (1s), stop (1s), move back (1s), stop (1s), and loop.  If there s nothing happen, please make sure:   You had uploaded the code successfully  Your motor connect right  The led indicators blink right", 
            "title": "Drive a DC Motor"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#drive-a-stepper", 
            "text": "You can drive a 4-wire stepper with this shield. Here I will show you how to drive a   stepper    You need to do some preparing first:\n- Set  SEN_A  and  SEN_B , connect the left 2 pins together with a jumper.\n- Connect  MB_EN  together with a jumper, as we are no going to use an external power.  Find the pin definitions of you stepper, and connect it to the OUTPUT of the shield. As below:     Stepper  Motor Shield      A+  OUT1    A-  OUT2    B+  OUT3    B-  OUT4     Then open  stepper_test  example in the library, upload it to Seeeduino V4, then you will find your stepper move.  /*\n * Stepper test for Seeed Motor Shield V2\n * loovee @ 15 Mar, 2016\n */\n\n#include  Stepper.h \n\n// change this to the number of steps on your motor\n#define STEPS 200\n\n// create an instance of the stepper class, specifying\n// the number of steps of the motor and the pins it's\n// attached to\nStepper stepper(STEPS, 8, 11, 12, 13);\n\n// the previous reading from the analog input\nint previous = 0;\n\nvoid step(int steps)\n{\n    digitalWrite(9, HIGH);\n    digitalWrite(10, HIGH);\n    stepper.step(steps);\n    digitalWrite(9, LOW);\n    digitalWrite(10, LOW);\n}\n\nvoid setup()\n{\n    // set the speed of the motor to 30 RPMs\n    pinMode(9, OUTPUT);\n    pinMode(10, OUTPUT);\n    digitalWrite(9, LOW);\n    digitalWrite(10, LOW);\n    stepper.setSpeed(30);\n}\n\nvoid loop()\n{\n    step(1000);\n    step(-1000);\n}\n\n// END FILE  If there s nothing happen, please double check if you had connected the wire right.", 
            "title": "Drive a Stepper"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#library-apis", 
            "text": "", 
            "title": "Library APIs"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#begin", 
            "text": "Description  void begin();", 
            "title": "begin"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#speed", 
            "text": "Description  Set speed, control by PWM.  void move(int motor_id, int speed);   motor_id  0 - Chanel 0  1 - Chanel 1  speed: -100~100, the larger the faster, 0 for stop   stop  void stop(unsigned char motor_id);  brake  void brake(unsigned char motor_id);", 
            "title": "speed"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#stepper", 
            "text": "Note  that we use the library provided by Arduino IDE to drive a stepper.  There s something need to be modified, please refer the examples.", 
            "title": "Stepper"
        }, 
        {
            "location": "/Motor_Shield_V2.0/#resources", 
            "text": "Motor Shield V2.0 Eagle File   Motor shield V2.1 Eagle File   Motor Shield 2.0 schematics  Motor Shield 2.1 schematics  Motor Shield 2.2 schematics  Motor Shield Library  L298 Datasheet  78M05 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/RS232_Shield/", 
            "text": "RS232 Shield is a standard communication port for industry equipment.This module is base on MAX232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nMeets or Exceeds TIA/EIA-232-F and ITU\n\n\nOperates Up To 120 kbit/s\n\n\nLow Supply Current\n\n\nLED Indicator\n\n\nDB9 Connectors(female)\n\n\nWelding Areas\n\n\n\n\nInterface Function\n\uf0c1\n\n\nUsage\n\n\nFirst,we can test it by computer.\n\n\nHardware Installation\n\uf0c1\n\n\n\n\nSeeeduino v3.0,Mini usb Cable,RS232 Shield,RS232 to USB Cable.\n\n\nMake the connections as below. The jumper hats can be used to select the software serial port from the digital pins. You can set them to D7(232_TX) and D6(232_RX), and modify the code to \nSoftwareSerial mySerial(7, 6); // 232_TX, 232_RX\n\n\n\n\n\n\nSoftware Part\n\uf0c1\n\n\n\n\n1) Open Arduino IDE, and paste the code below.\n\n\n\n\n\u00a0\n#include \nSoftwareSerial.h\n\n\u00a0\nSoftwareSerial mySerial(7, 6); //232_TX,232_RX\n\u00a0\nvoid setup()\n{\n    // Open serial communications and wait for port to open:\n    Serial.begin(9600);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for Leonardo only\n    }\n\u00a0\n\u00a0\n    Serial.println(\nGoodnight moon!\n);\n\u00a0\n    // set the data rate for the SoftwareSerial port\n    mySerial.begin(9600);\n    mySerial.println(\nHello, world?\n);\n}\n\u00a0\nvoid loop() // run over and over\n{\n    if (mySerial.available())\n    Serial.write(mySerial.read());\n    if (Serial.available())\n    mySerial.write(Serial.read());\n}\n\n\n\n\n\n\n2) Upload the code. Note that you should select the correct board type and COM port.\n\n\n3) Open the Serial Monitor.\n\n\n\n\nYou can see\u00a0:\n\n\n\nResources\n\uf0c1\n\n\n\n\nRS232 Shield eagle file\n\n\nRS232_Shield_v1.0.pdf\n\n\nDatasheet MAX232D.pdf", 
            "title": "RS232 Shield"
        }, 
        {
            "location": "/RS232_Shield/#specifications", 
            "text": "Meets or Exceeds TIA/EIA-232-F and ITU  Operates Up To 120 kbit/s  Low Supply Current  LED Indicator  DB9 Connectors(female)  Welding Areas", 
            "title": "Specifications"
        }, 
        {
            "location": "/RS232_Shield/#interface-function", 
            "text": "Usage  First,we can test it by computer.", 
            "title": "Interface Function"
        }, 
        {
            "location": "/RS232_Shield/#hardware-installation", 
            "text": "Seeeduino v3.0,Mini usb Cable,RS232 Shield,RS232 to USB Cable.  Make the connections as below. The jumper hats can be used to select the software serial port from the digital pins. You can set them to D7(232_TX) and D6(232_RX), and modify the code to  SoftwareSerial mySerial(7, 6); // 232_TX, 232_RX", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/RS232_Shield/#software-part", 
            "text": "1) Open Arduino IDE, and paste the code below.   \u00a0\n#include  SoftwareSerial.h \n\u00a0\nSoftwareSerial mySerial(7, 6); //232_TX,232_RX\n\u00a0\nvoid setup()\n{\n    // Open serial communications and wait for port to open:\n    Serial.begin(9600);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for Leonardo only\n    }\n\u00a0\n\u00a0\n    Serial.println( Goodnight moon! );\n\u00a0\n    // set the data rate for the SoftwareSerial port\n    mySerial.begin(9600);\n    mySerial.println( Hello, world? );\n}\n\u00a0\nvoid loop() // run over and over\n{\n    if (mySerial.available())\n    Serial.write(mySerial.read());\n    if (Serial.available())\n    mySerial.write(Serial.read());\n}   2) Upload the code. Note that you should select the correct board type and COM port.  3) Open the Serial Monitor.   You can see\u00a0:", 
            "title": "Software Part"
        }, 
        {
            "location": "/RS232_Shield/#resources", 
            "text": "RS232 Shield eagle file  RS232_Shield_v1.0.pdf  Datasheet MAX232D.pdf", 
            "title": "Resources"
        }, 
        {
            "location": "/Seeeduino_Lotus/", 
            "text": "Seeeduino Lotus is an ATMEGA328 Microcontroller development board. It is a combination of Seeeduino and Base Shield. It uses an Atmel ATMEGA328P-MU and CH340. ATMEGA328P-MU is a high performance, low power AVR 8-Bit Microcontroller. CH340 is a USB bus converter chip that can realize a USB to serial interface. Seeeduino Lotus has 14 digital input/outputs (6 of which can output PWM) and 7 analog input/outputs, a micro USB connection, an ICSP header, 12 Grove connections, a reset button.\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nDIY\n\n\nIoT and Smart Home\n\n\nRobot\n\n\nLearning\n\n\nToy\n\n\n\n\nHere is some funny project for your reference.\n\n\n\n\n\n\n\n\nCar Controlled by Track Ball\n\n\nFM Receiver\n\n\nHCHO Detector\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it Now\n\n\nMake it Now\n\n\nMake it Now\n\n\n\n\n\n\n\n\nFeature\n\uf0c1\n\n\n\n\nFully compatible with Arduino UNO\n\n\nATmega328 microcontroller\n\n\n12 on-board Grove connectors\n\n\n14 Digital I/O Pins (6 PWM outputs)\n\n\n6 Analog Inputs\n\n\nISP Header\n\n\nArduino UNO-R3 Shield Compatible\n\n\nMicro USB programming and power supply\n\n\n5V Operating Voltage\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMicrocontroller\n\n\nATmega328P-MU\n\n\n\n\n\n\nOperating Voltage\n\n\n5V\n\n\n\n\n\n\nDigital I/O Pins\n\n\n14\n\n\n\n\n\n\nPWM Channels\n\n\n6\n\n\n\n\n\n\nAnalog Input Channels\n\n\n7\n\n\n\n\n\n\nDC Current per I/O Pin\n\n\n40 mA\n\n\n\n\n\n\nFlash Memory\n\n\n32 KB\n\n\n\n\n\n\nRAM\n\n\n2 KB\n\n\n\n\n\n\nEEPROM\n\n\n1 KB\n\n\n\n\n\n\nClock Speed\n\n\n16 MHz\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\nThe images below show an overview of Seeeduino Lotus hardware features. The pin-out and alternate functions of various pins of Seeeduino Lotus are shown in the pin-out diagram. This could be used as a quick reference.\n\n\n \n\n\n\n\nLED-D13\n\nAn LED is connected to D13 pin of the board. This can be used as an on-board LED indicator for programs/sketches.\n\n\nUSB Input\n\nUSB Port is used to connect the board to your PC for programming and for powering up. Micro USB is the ubiquitous version of USB, found in most Android phones, and other devices. You probably have dozens of these cables laying around your house.\n\n\nReset\n\nThis button is conveniently placed on the side to allow you to reset the Seeeduino board even when a shield is placed on top. This is not the case in other Arduino boards where the button is placed on top making it hard to access.\n\n\nPower Pins \n Analog Pins\n\nJust like the extra Digital header pads, these extra connections are something we have personally come to realize people need in their projects, especially the power connections if you want to power more than one sensor/device without the use of a breadboard.\n\n\nGrove Connectors\n\nSeeedStudio has a variety of sensors/devices that can make use of this Analog, Digital,I2C and UART connection. In addition, we sell independent Grove connectors to help you make our own sensor connections.\n\n\nICSP\n\nThis is the ICSP connection for the ATmega328P, it is located in the standard ICSP/SPI position for Arduino Uno, Due, Mega, and Leonardo compatible hardware (e.g. shields) that may use this connector. The SPI pins in this port: MISO, SCK, and MOSI, are also connected to digital pins 12, 13, and 11 respectively just like those of the Arduino Uno.\n\n\nUSB 2 Uart\n\nPinout of USB-2-Uart. These pads can be used to interact with other UART devices by putting the on-board ATmega328 in reset mode. This makes Seeeduino Lotus to be used a USB2UART utility board.\n\n\n\n\n\n\nWarning\n\n\nTake gentle care in handling micro USB socket, or you might break the socket off.\n\n\n\n\nInstall the Driver\n\uf0c1\n\n\nFirst of all, you need to:\n\n\n\n\n\n\nGet a Micro-USB cable\n\n\n\n\nYou need a Micro-USB cable first; the data cable of an Android Phone will do fine.\nIf you can\nt find one, you can buy one \nhere\n.\n\n\n\n\n\n\n\n\nConnect the board\n\n\n\n\nConnect the Arduino board to your computer using the USB cable. The green power LED (labelled \nPWR\n) should go on.\n\n\n\n\n\n\n\n\nFor Windows\n\uf0c1\n\n\n\n\nNote\n\n\nThis drive is available for Windows XP, Windows Vista, Windows 7, Windows 8/8.1 and Windows 10.\n\n\n\n\n\n\n\n\nPlug in your board and wait for Windows to begin its driver installation process. After a few moments, the process will fail, despite best efforts.\n\n\nClick on the Start Menu, and open up the Control Panel.\n\n\nWhile in the Control Panel, navigate to System and Security. Next, click on System. Once the System window is up, open the \nDevice Manager\n.\n\n\nLook under Ports (COM \n LPT). You should find an open port named \nSeeeduino Lotus\n. If there is no COM \n LPT section, look under \nOther Devices\n for \nUnknown Device\n.\n\n\nRight click on the \nSeeeduino Lotus\n port and choose the \nUpdate Driver Software\n option.\n\n\nNext, choose the \nBrowse my computer for Driver software\n option.\n\n\nFinally, navigate to and select the driver file named \nSeeeduino Lotus.inf\n\n\nWindows will finish up the driver installation from there.\n\n\n\n\nFor Mac OSX\n\uf0c1\n\n\nYou don\nt need to install any drivers. \n\n\nGetting Started\n\uf0c1\n\n\n\n\nNote\n\n\nThis part is based on Arduino 1.6.9 under Windows 10.\n\n\n\n\nFirst of all, you need to Install an Arduino Software.\n\n\n\n\nLaunch the Arduino application\n\uf0c1\n\n\nDouble-click the Arduino application (arduino.exe) you have previously downloaded. \n\n\n\n\nNote\n\n\nIf the Arduino Software loads in a different language, you can change it in the preferences dialog. See the \nArduino Software (IDE) page\n for details.\n\n\n\n\nOpen the Blink example\n\uf0c1\n\n\nOpen the LED blink example sketch: \nFile \n Examples \n01.Basics \n Blink\n.\n\n\n\n\nAdd Seeeduino to your Arduino IDE\n\uf0c1\n\n\nClick on \nFile \n Preference\n, and fill Additional Boards Manager URLs with below url:\n    \nhttps://raw.githubusercontent.com/Seeed-Studio/Seeeduino-Boards/master/package_seeeduino_index.json\n\n\nClick OK to finish the setting. Then Click on \nTools \n Board \n Boards Manager\n, find \nSeeeduino by Seeed Studio\n, and Install it.\n\n\n\n\nSelect your board\n\uf0c1\n\n\nYou\nll need to select the entry in the \nTools \n Board\n menu that corresponds to your Arduino.\nSelecting a \nSeeeduino Lotus\n.\n\n\n\n\nSelect your serial port\n\uf0c1\n\n\nSelect the serial device of the Arduino board from the Tools | Serial Port menu. This is likely to be COM3 or higher (\nCOM1\n and \nCOM2\n are usually reserved for hardware serial ports). To find out, you can disconnect your Arduino board and re-open the menu; the entry that disappears should be the Arduino board. Reconnect the board and select that serial port.\n\n\n\n\n\n\nNote\n\n\nOn the Mac, this should be something with \n/dev/tty.USBmodem\n.\n\n\n\n\nUpload the program\n\uf0c1\n\n\nNow, simply click the \nUpload\n button in the environment. Wait a few seconds and if the upload is successful, the message \nDone uploading.\n will appear in the status bar.\n\n\n\n\nA few seconds after the upload finishes, you should see the pin 13 (L) LED on the board start to blink (in orange). If it does, congratulations! You\nve gotten Arduino up-and-running. If you have problems, please see the troubleshooting suggestions.\n\n\nGetting Started on Linux\n\uf0c1\n\n\nFor using on Linux, please go to \nInstalling Arduino on Linux\n\n\nResources\n\uf0c1\n\n\n\n\n\n\nSchematic\n\n\n\n\nSeeeduino Lotus Eagle file\n\n\nSeeeduino Lotus PDF file\n\n\n\n\n\n\n\n\nDatasheet\n\n\n\n\nATmega328P\n\n\nATmega16U2\n\n\n\n\n\n\n\n\nBootloader\n    \n\n\n\n\nSeeeduino Lotus Bootloader\n\n\n\n\n\n\n\n\nReferences\n\n\n\n\nGetting Started with Arduino\n\n\nArduino Language Reference\n\n\nDownload the Arduino Software(IDE)\n\n\nArduino FAQ\n\n\nArduino Introduction\n\n\nWikipedia page for Arduino\n\n\n\n\n\n\n\n\nFAQ\n\uf0c1\n\n\nQ1. What\ns the different between Arduino UNO and Seeeduino Lotus\n\uf0c1\n\n\nSeeeduino Lotus is fully compatible with Arduino UNO. And Seeeduino Lotus has 12 Grove connectors, which makes it convenient to create your demo with Seeed Studio Grove Modules. What\ns more, Seeeduino Lotus uses a micro USB to power and program. \n\n\nQ2. I can\nt upload my sketch to Seeeduino Lotus\n\uf0c1\n\n\nPlease check,\n\n\n\n\nIf the Power LED on\n\n\nIf you choose the right Port and Board (Seeeduino Lotus)\n\n\nClose and reopen Arduino IDE and try again\n\n\n\n\nQ3. Where can I find technical support if I have some other issue.\n\uf0c1\n\n\nYou can post a question to \nSeeed Forum\n or send an email to \ntechsupport@seeed.cc\n.\n\n\nHelp us to make it better\n\uf0c1\n\n\nThank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\nve experienced during using the old system.\n\n\nIt is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:\n\n\n\n\nReplace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.  \n\n\nReview and rewrite documents for hundreds of products to make them more understandable.\n\n\nInspected repair all the URL to make sure it can be linked to the right page.\n\n\n\n\nAlthough we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.\n\n\nBy the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Seeeduino Lotus"
        }, 
        {
            "location": "/Seeeduino_Lotus/#application-ideas", 
            "text": "DIY  IoT and Smart Home  Robot  Learning  Toy   Here is some funny project for your reference.     Car Controlled by Track Ball  FM Receiver  HCHO Detector           Make it Now  Make it Now  Make it Now", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Seeeduino_Lotus/#feature", 
            "text": "Fully compatible with Arduino UNO  ATmega328 microcontroller  12 on-board Grove connectors  14 Digital I/O Pins (6 PWM outputs)  6 Analog Inputs  ISP Header  Arduino UNO-R3 Shield Compatible  Micro USB programming and power supply  5V Operating Voltage", 
            "title": "Feature"
        }, 
        {
            "location": "/Seeeduino_Lotus/#specification", 
            "text": "Item  Value      Microcontroller  ATmega328P-MU    Operating Voltage  5V    Digital I/O Pins  14    PWM Channels  6    Analog Input Channels  7    DC Current per I/O Pin  40 mA    Flash Memory  32 KB    RAM  2 KB    EEPROM  1 KB    Clock Speed  16 MHz", 
            "title": "Specification"
        }, 
        {
            "location": "/Seeeduino_Lotus/#hardware-overview", 
            "text": "The images below show an overview of Seeeduino Lotus hardware features. The pin-out and alternate functions of various pins of Seeeduino Lotus are shown in the pin-out diagram. This could be used as a quick reference.      LED-D13 \nAn LED is connected to D13 pin of the board. This can be used as an on-board LED indicator for programs/sketches.  USB Input \nUSB Port is used to connect the board to your PC for programming and for powering up. Micro USB is the ubiquitous version of USB, found in most Android phones, and other devices. You probably have dozens of these cables laying around your house.  Reset \nThis button is conveniently placed on the side to allow you to reset the Seeeduino board even when a shield is placed on top. This is not the case in other Arduino boards where the button is placed on top making it hard to access.  Power Pins   Analog Pins \nJust like the extra Digital header pads, these extra connections are something we have personally come to realize people need in their projects, especially the power connections if you want to power more than one sensor/device without the use of a breadboard.  Grove Connectors \nSeeedStudio has a variety of sensors/devices that can make use of this Analog, Digital,I2C and UART connection. In addition, we sell independent Grove connectors to help you make our own sensor connections.  ICSP \nThis is the ICSP connection for the ATmega328P, it is located in the standard ICSP/SPI position for Arduino Uno, Due, Mega, and Leonardo compatible hardware (e.g. shields) that may use this connector. The SPI pins in this port: MISO, SCK, and MOSI, are also connected to digital pins 12, 13, and 11 respectively just like those of the Arduino Uno.  USB 2 Uart \nPinout of USB-2-Uart. These pads can be used to interact with other UART devices by putting the on-board ATmega328 in reset mode. This makes Seeeduino Lotus to be used a USB2UART utility board.    Warning  Take gentle care in handling micro USB socket, or you might break the socket off.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Seeeduino_Lotus/#install-the-driver", 
            "text": "First of all, you need to:    Get a Micro-USB cable   You need a Micro-USB cable first; the data cable of an Android Phone will do fine.\nIf you can t find one, you can buy one  here .     Connect the board   Connect the Arduino board to your computer using the USB cable. The green power LED (labelled  PWR ) should go on.", 
            "title": "Install the Driver"
        }, 
        {
            "location": "/Seeeduino_Lotus/#for-windows", 
            "text": "Note  This drive is available for Windows XP, Windows Vista, Windows 7, Windows 8/8.1 and Windows 10.     Plug in your board and wait for Windows to begin its driver installation process. After a few moments, the process will fail, despite best efforts.  Click on the Start Menu, and open up the Control Panel.  While in the Control Panel, navigate to System and Security. Next, click on System. Once the System window is up, open the  Device Manager .  Look under Ports (COM   LPT). You should find an open port named  Seeeduino Lotus . If there is no COM   LPT section, look under  Other Devices  for  Unknown Device .  Right click on the  Seeeduino Lotus  port and choose the  Update Driver Software  option.  Next, choose the  Browse my computer for Driver software  option.  Finally, navigate to and select the driver file named  Seeeduino Lotus.inf  Windows will finish up the driver installation from there.", 
            "title": "For Windows"
        }, 
        {
            "location": "/Seeeduino_Lotus/#for-mac-osx", 
            "text": "You don t need to install any drivers.", 
            "title": "For Mac OSX"
        }, 
        {
            "location": "/Seeeduino_Lotus/#getting-started", 
            "text": "Note  This part is based on Arduino 1.6.9 under Windows 10.   First of all, you need to Install an Arduino Software.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Seeeduino_Lotus/#launch-the-arduino-application", 
            "text": "Double-click the Arduino application (arduino.exe) you have previously downloaded.    Note  If the Arduino Software loads in a different language, you can change it in the preferences dialog. See the  Arduino Software (IDE) page  for details.", 
            "title": "Launch the Arduino application"
        }, 
        {
            "location": "/Seeeduino_Lotus/#open-the-blink-example", 
            "text": "Open the LED blink example sketch:  File   Examples  01.Basics   Blink .", 
            "title": "Open the Blink example"
        }, 
        {
            "location": "/Seeeduino_Lotus/#add-seeeduino-to-your-arduino-ide", 
            "text": "Click on  File   Preference , and fill Additional Boards Manager URLs with below url:\n     https://raw.githubusercontent.com/Seeed-Studio/Seeeduino-Boards/master/package_seeeduino_index.json  Click OK to finish the setting. Then Click on  Tools   Board   Boards Manager , find  Seeeduino by Seeed Studio , and Install it.", 
            "title": "Add Seeeduino to your Arduino IDE"
        }, 
        {
            "location": "/Seeeduino_Lotus/#select-your-board", 
            "text": "You ll need to select the entry in the  Tools   Board  menu that corresponds to your Arduino.\nSelecting a  Seeeduino Lotus .", 
            "title": "Select your board"
        }, 
        {
            "location": "/Seeeduino_Lotus/#select-your-serial-port", 
            "text": "Select the serial device of the Arduino board from the Tools | Serial Port menu. This is likely to be COM3 or higher ( COM1  and  COM2  are usually reserved for hardware serial ports). To find out, you can disconnect your Arduino board and re-open the menu; the entry that disappears should be the Arduino board. Reconnect the board and select that serial port.    Note  On the Mac, this should be something with  /dev/tty.USBmodem .", 
            "title": "Select your serial port"
        }, 
        {
            "location": "/Seeeduino_Lotus/#upload-the-program", 
            "text": "Now, simply click the  Upload  button in the environment. Wait a few seconds and if the upload is successful, the message  Done uploading.  will appear in the status bar.   A few seconds after the upload finishes, you should see the pin 13 (L) LED on the board start to blink (in orange). If it does, congratulations! You ve gotten Arduino up-and-running. If you have problems, please see the troubleshooting suggestions.", 
            "title": "Upload the program"
        }, 
        {
            "location": "/Seeeduino_Lotus/#getting-started-on-linux", 
            "text": "For using on Linux, please go to  Installing Arduino on Linux", 
            "title": "Getting Started on Linux"
        }, 
        {
            "location": "/Seeeduino_Lotus/#resources", 
            "text": "Schematic   Seeeduino Lotus Eagle file  Seeeduino Lotus PDF file     Datasheet   ATmega328P  ATmega16U2     Bootloader        Seeeduino Lotus Bootloader     References   Getting Started with Arduino  Arduino Language Reference  Download the Arduino Software(IDE)  Arduino FAQ  Arduino Introduction  Wikipedia page for Arduino", 
            "title": "Resources"
        }, 
        {
            "location": "/Seeeduino_Lotus/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/Seeeduino_Lotus/#q1-whats-the-different-between-arduino-uno-and-seeeduino-lotus", 
            "text": "Seeeduino Lotus is fully compatible with Arduino UNO. And Seeeduino Lotus has 12 Grove connectors, which makes it convenient to create your demo with Seeed Studio Grove Modules. What s more, Seeeduino Lotus uses a micro USB to power and program.", 
            "title": "Q1. What's the different between Arduino UNO and Seeeduino Lotus"
        }, 
        {
            "location": "/Seeeduino_Lotus/#q2-i-cant-upload-my-sketch-to-seeeduino-lotus", 
            "text": "Please check,   If the Power LED on  If you choose the right Port and Board (Seeeduino Lotus)  Close and reopen Arduino IDE and try again", 
            "title": "Q2. I can't upload my sketch to Seeeduino Lotus"
        }, 
        {
            "location": "/Seeeduino_Lotus/#q3-where-can-i-find-technical-support-if-i-have-some-other-issue", 
            "text": "You can post a question to  Seeed Forum  or send an email to  techsupport@seeed.cc .", 
            "title": "Q3. Where can I find technical support if I have some other issue."
        }, 
        {
            "location": "/Seeeduino_Lotus/#help-us-to-make-it-better", 
            "text": "Thank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you ve experienced during using the old system.  It is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:   Replace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.    Review and rewrite documents for hundreds of products to make them more understandable.  Inspected repair all the URL to make sure it can be linked to the right page.   Although we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.  By the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Help us to make it better"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/", 
            "text": "Maybe you are very familiar with the Seeeduino stalker series, or maybe you are totally new to this feature rich Wireless Sensor Network Node. No matter what situation you are in, if you are going to make an outdoor data-logging application, you will find that Seeeduino Stalker is the best board.\n\n\nThe main purpose of creating this series is to create an X-bee carrier board so that users can make outdoor application more conveniently. Ever since the first version be released in 2009, Seeeders has been continuously collecting feedback from users and kept upgrading the board. there are 6 versions ever existed during the past 7 years, this summer we are excited to release the most updated member of the Seeeduino stalker family----Seeeduino Stalker V3.1.\n\n\nSeeeduino Stalker V3.1 is not just a simple update of V3.0.The main surprise you\nll find about the board is impressively low power consumption, in sleep mode, the output current of the whole board will be as low as 100uA,This is an upgrade truly derived from users feedback.(we really care about your opinion).let\ns see how we achieve it.\n\n\n\n\nVersion Track\n\uf0c1\n\n\n\n\n\n\n\n\nVersion\n\n\nReleased Date\n\n\nHow to Buy\n\n\n\n\n\n\n\n\n\n\nSeeeduino Stalker V1.0\n\n\nDec23, 2009\n\n\n\n\n\n\n\n\nSeeeduino Stalker V2.0\n\n\nDec10, 2010\n\n\n\n\n\n\n\n\nSeeeduino Stalker V2.1\n\n\nOct3, 2011\n\n\n\n\n\n\n\n\nSeeeduino Stalker V2.2\n\n\nDec27, 2011\n\n\n\n\n\n\n\n\nSeeeduino Stalker V2.3\n\n\nJan10, 2013\n\n\n\n\n\n\n\n\nSeeeduino Stalker V3.0\n\n\nJun6, 2014\n\n\n\n\n\n\n\n\nSeeeduino Stalker V3.1\n\n\nJul10, 2016\n\n\n\n\n\n\n\n\n\n\nWhat\ns new in Seeeduino Stalker V3.1\n\uf0c1\n\n\nImprove Power Management\n\n\nIn V3.1, when MCU is in sleep mode, all other power supplement, including Bee area port, 3.3v port, VCC can be cut off manually, so that power can really be saved.\n\n\nOther Changes\n\n\nThere is a toggle switch added to X-bee area, which allows you to select either the hardware serial port   or software serial port base on what you want to connect.\n\n\nWe also added 2 toggle switch on RTC circuitry corresponding 2 INT pin of MCU, so that users can easily choose which INT pin to be connected with RTC INT port then activate MCU.\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nArduino UNO compatible pinout with Arduino Fio bootloader\n\n\nLipo battery manager IC and Solar charge input(jst2.0 connector)\n\n\nOnboard Real Time Clock chip \nDS1337S\n (Socket for a CR1220 coin cell, which acts as a backup power source for RTC)\n\n\nSerial interface with DTR for auto reset during programming when operating in standalone mode. \n\n\nmicroSD card socket\n\n\nGrove connector (operation voltage is selectable: 5.0V or 3.3V)\n\n\nReset buttons for both XBee Modules and ATMega328P\n\n\nBee series socket 2*10 pin 2.0mm pitch\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMicro Controller\n\n\nAtmega328P\n\n\n\n\n\n\nClock Speed\n\n\n8 MHz\n\n\n\n\n\n\nI/O Voltage\n\n\n3.3V\n\n\n\n\n\n\nRTC\n\n\nDS1337S\n\n\n\n\n\n\nBoard for Arduino IDE\n\n\nArduino Pro or Pro Mini (3.3v , 8 MHz)w/ATmega328\n\n\n\n\n\n\nPower Supply\n\n\n3.7v LiPo Battery, Use 5VDC solar panel for charging the battery\n\n\n\n\n\n\nPower Connector\n\n\n2 pin JST/ USB\n\n\n\n\n\n\nConnectivity\n\n\nI2C, UART, SPI\n\n\n\n\n\n\nSD Card\n\n\nmicro SD card\n\n\n\n\n\n\nOpen Circuit Current\n\n\n6 mA max\n\n\n\n\n\n\nCharging Current\n\n\n300mA\n\n\n\n\n\n\nMaximum Current on 3.3v port\n\n\n800mA\n\n\n\n\n\n\nSize of PCB\n\n\n86.74mm x 60.96mm\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\n\n\nWireless Sensor Network (using \nXBee\n bought separately)\n\n\nGPS Logging (using \nGPSBee\n bought separately)\n\n\nData Acquisition System capable of communicating with an App running on iPhone/Android Phone (using \nBluetoothBee\n bought separately).\n\n\nRF Remote Control (using \nRFBee\n bought separately).\n\n\nAs a simple standalone Arduino compatible physical computing platform.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nOverview\n\uf0c1\n\n\nSeeeduino Stalker V3.1 is an application board with rich function. RTC, Lipo battery connector, Bee socket and SD card socket etc. The below overview image will introduce each part of the board to help you to know the board better. \n\n\n\n\n\n\n\n\n\n\nNAME\n\n\nFUNCTION\n\n\n\n\n\n\n\n\n\n\nRTC BATTERY\n\n\nCell battery to power DS1337S\n\n\n\n\n\n\nRTC_INT\n\n\nRTC interrupt switch\n\n\n\n\n\n\nBee Serial Select\n\n\nBee RX/TX pin select, you can select D0/D1 or D6/D7\n\n\n\n\n\n\nBee Socket\n\n\nInsert a Bee\n\n\n\n\n\n\nCHARGE STATUS LED\n\n\nOK\n: a green led, on while charge done. \nCH\n: a red led, on while charging\n\n\n\n\n\n\nBEE RST\n\n\nReset the Bee\n\n\n\n\n\n\nSOLAR\n\n\nSolar input to charge the battery, input 4.5~6V\n\n\n\n\n\n\nLIPO\n\n\nlipo battery input, 3.7V\n\n\n\n\n\n\nL\n\n\nA LED connected to D13, can be acted as a monitor\n\n\n\n\n\n\nGROVE2\n\n\nGrove port, connect to I2C\n\n\n\n\n\n\nGROVE1\n\n\nGrove port, connect to D7/8\n\n\n\n\n\n\nPROGRAM\n\n\nProgramming port, connect to a UartSBee here\n\n\n\n\n\n\nRST\n\n\nReset the Atmega328P\n\n\n\n\n\n\nSD CARD\n\n\nA micro SD Card socket\n\n\n\n\n\n\n\n\nPinmap\n\uf0c1\n\n\nSeeeduino Stalker V3.1 is compatible with Arduino, there\nre many Analog pins, Digital Pin as well as Serial pins available to make your own application. Below pin map image will help you to decided which pin are free or not as well as the pin used. \n\n\n\n\nGet Started\n\uf0c1\n\n\n\n\nIf this is your first time to program with a Seeeduino Stalker. You can follow the below steps to getting started. Before we start, make sure you have the below things on hand:\n\n\n\n\n\n\n\n\nSeeeduino Stalker V3.1\n\n\nUartSBee V4\n\n\nMini USB Cable\n\n\n6pin Cable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nUartSBee V4, Mini USB Cable and 6pin cable are not included. \n\n\n\n\nSTEP1: Connection\n\uf0c1\n\n\nFirstly connect Staler to UartSBee via the 6pin jumper wire, then connect UartSBee to a PC via the mini USB cable. \n\n\n\n\n\n\n\n\nSeeeduino Stalker\n\n\nUartSBee V4\n\n\n\n\n\n\n\n\n\n\nDTR\n\n\nDTR\n\n\n\n\n\n\nTXD\n\n\nRXD\n\n\n\n\n\n\nRXD\n\n\nTXD\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nThe power switch on UartSBee V4 put to 5V    \n\n\n\n\nSTEP2: UartSBee and the Driver\n\uf0c1\n\n\nUartSBee is a USB to Serial UART interface which is based on FT232RL from FDTI. Click to download the \ndriver\n for the board.\n\n\nIn our case, it will perform three functions: \n\n\n\n\nTo program the Seeeduino Stalker.\n\n\nTo communicate with Seeeduino Stalker.\n\n\nProvide power (from USB power of PC) to Seeeduino Stalker (including any peripherals connected to it).\n\n\n\n\nSTEP3: Arduino IDE\n\uf0c1\n\n\nSeeeduino Stalker is an Arduino compatible board that with rich function. If you don\nt have an Arduino IDE, you need to download the latest Arduino software to program the board. \n\n\n\n\nSTEP4: Blink\n\uf0c1\n\n\nHere we will update a simple code to Stalker. Open your Arduino IDE, open \nFile \n Examples \n Basics \n Blink\n\n\n\n\nThen click on the Upload button, seconds later after the uploading is done, check \nL\n on the board, it will blink at the frequency of 1s.\n\n\nSketchbook for Stalker V3.1\n\uf0c1\n\n\nThere\ns a sketchbook for Seeeduino Stalker V3.1, which is consist of:\n\n\n\n\nExample of reading the voltage of battery\n\n\nExample of reading the status of charging\n\n\nExample of data log\n\n\nRTC library and some examples\n\n\nSleep related function\n\n\n\n\n\n\nDownload the sketch and put at anywhere, open Arduino IDE, \nFile \n Reference\n, and copy the location path to \nSketchbook location\n, then click on OK. Reopen Arduino IDE, then the sketchbook is set. \n\n\n\n\nRTC\n\uf0c1\n\n\nThere\ns a on-board  DS1307S with a 3V cell battery, which can hold the time for more that 3 years even there\ns no power supply to the board. The library of DS1307S is included at the sketch of Stalker. \n\n\nAdjust Date/Time\n\uf0c1\n\n\nOpen Arduino IDE, then \nFile \n Sketchbook \n RTC \n Adjust\n, then set the current date/time using the DateTime Class object \ndt\n in the example:\n\n\nDateTime dt(year, month, date, hour, min, sec, week-day(starts from 0 and goes to 6));\nEx:- DateTime dt(2015, 10, 1, 11, 43, 0, 4);\n\n\n\nCompile and upload to Stalker, then time is set.\n\n\nGet Current Date/Time\n\uf0c1\n\n\nOpen Arduino IDE, then \nFile \n Sketchbook \n RTC \n Now\n, The current date/time is read from DS1337 using \nRTC.now()\n function. \n\n\nEx:- DateTime now = RTC.now();\n\n\n\nCompile and upload to Stalker, and open the Serial monitor, you will get the date and time display:\n\n\n\n\nDS1337 Interrupts Example\n\uf0c1\n\n\nThis example is a demonstration of interrupt detection from DS1337 INT output. This feature is useful for data-logger functionality where the MCU is put to sleep mode when not in use and DS1337 INT wakes up the CPU periodically. This extends battery power. The complete operation is documented in the code.\n\n\nThere\nre 2 INT output from DS1337, INTA (connect to \nD2\n) and INTB (connect to \nD3\n). There\ns a switch to connect INTA/INTB and D2/D3, if you don\nt need the interrupt, you can just close the switch and save 1 or 2 I/O. Switch as below:\n\n\n\n\nOpen Arduino IDE, then \nFile \n Sketchbook \n RTC \n interrupts\n, this example will generate an interrupt every minutes. If you need other type of alarm, please refer to the code.\n\n\nSD Card\n\uf0c1\n\n\nThere\ns a micro SD card socket which you can insert a micro SD card to store some data. Stalker read/write the SD card via SPI interface. There\nre enough examples to operate a SD by using the SD library inside Arduino IDE.\nOpen your Arduino IDE, \nFile \n Examples \n SD\n, you will get many examples. \n\n\n\n\n\n\nNote\n\n\nThe CS pin is connected to D10 of Stalker, so you need to change the CS pin into D10 at the examples. \n\n\n\n\nPower Manager\n\uf0c1\n\n\nThere\ns Lipo battery manage circuit built in Stalker. There are two useful function supply at the sketch.\n\n\nRead the voltage of Lipo Battery:\n\uf0c1\n\n\nOpen Arduino IDE, \nFile \n Sketchbook \n ReadBattery\n to open the example. \n\n\nThe voltage of the battery is related to the battery capacity. Below is a reference, but please know that it\ns not for every battery, for a certain battery, the data may a little different. \n\n\n\n\n\n\n\n\nCapacity(%)\n\n\n100%\n\n\n80%\n\n\n60%\n\n\n40%\n\n\n20%\n\n\n0%\n\n\n\n\n\n\n\n\n\n\nVoltage(V)\n\n\n4.20\n\n\n4.00\n\n\n3.87\n\n\n3.79\n\n\n3.73\n\n\n3.00\n\n\n\n\n\n\n\n\nGET Charge Status\n\uf0c1\n\n\nOpen Arduino IdE, \nFile \n Sketchbook \n ReadChageStatus\n to open the examples. This function will return 3 status:\n\n\n0: No batter insert\n1: Charging\n2: Charge done\n\n\n\nBees\n\uf0c1\n\n\nBees are a series of modules that consist of rich function. Such as Wi-Fi, BLE, GPS as well as RF etc. With an XBee, Stalker can act as a node that with communication. A Stalker talk to another Stalker is no longer impossible. If you need more details about the Bees, below is some reference.\n\n\n\n\n\n\n\n\nBluetooth Bee\n\n\nXBee Wi-Fi PCB Antenna\n\n\nRFbee V1.1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBluetooth Bee - Standalone\n\n\nGPS Bee kit\n\n\nMesh Bee\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nYou need to select the Serial pin for a Bee, D0/D1 and D5/D6 is available. Please refer to Hardware Overview get more info. \n\n\nD9 is controlling the power of Vcc of Bee socket, if you need power to a Bee, you should make D9 HIGH: digitalWrite(9, HIGH), and don\nt forget to pinMode(9, OUTPUT) in the Setup.\n\n\n\n\n\n\nData Logger Example\n\uf0c1\n\n\n\n\nThe principal application of Seeeduino Stalker v3.0 is data-logging of sensor signal like battery voltage, etc. along with the time-stamp. This sketch puts the MCU in sleep mode when not performing data sampling / logging operation. The complete implementation is documented very well in the code. \n\n\nOpen Arduino IDE, \nFile \n Sketchbook \n StalkerV30_DataLogger_10Sec\n to open the example.\n- This sketch logs battery voltage data to SD card configured by RTC.enableInterrupts(h, m, s) function.\n- The periodicity is provided using h, m and s. Once an interrupt is detected, the next interrupt time is updated by advancing the h, m and s value. The DateTime Class comes handy for this.\n- ex:- interruptTime = DateTime (interruptTime.get() + interruptInterval); //decide the time for next interrupt\n- This sketch also produces verbose output i.e the various events happening inside MCU are displayed in serial terminal.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\n\n\nSchematic\n\n\nSchematic in \nEagle\n\n\nSchematic in \nPDF\n\n\nDatasheet\n\n\nDS1307\n\n\nCN3065\n\n\nETA3406\n\n\nSketchbook\n\n\n\n\nFAQ\n\uf0c1\n\n\n\n\nHere are some questions that we usually received from new users. If you have any other issues when you are using Seeeduino Stalker V3.1, welcome to the \nCommunity of Arduino\n where there are many professional users waiting to give you advices and also many advanced users providing plenty of ideas on how to use this products! \n\n\nQ1:\n The RTC is reset to the original time when power off and on again.\n\n\n\n\nThere\ns a cell battery to power the RTC when there\ns no power from the system. The cell battery is supposed to last at least 3 years. You can check if the cell battery run off.\n\n\n\n\nQ2:\n I can\nt upload sketch to Stalker V3.1\n\n\n\n\nFirstly, check if your USB-UART connected to Stalker right, then check if you select the right port number and board(\nArduino Fio\n or \nArduino Arduino Pro or Pro Mini (3.3v , 8 MHz)w/ATmega328\n). Finaly, if you had inserted a Bee on the socket and the RX/TX is selected to D0/D1, you should take the bee off when uploading the skteck. \n\n\n\n\nQ3:\n The RTC interrupt demo is not work, I can\nt get any interrupt.\n\n\n\n\nFirstly, check if you set the alarm time right, and don\nt forget to put the RTC_INT switch to the right side. \n\n\n\n\nQ4:\n The solar panel can\nt charge the lipo battery.\n\n\n\n\nMake sure your solar panel is able to supple 4.5~6V voltage.", 
            "title": "Seeeduino Stalker V3.1"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#version-track", 
            "text": "Version  Released Date  How to Buy      Seeeduino Stalker V1.0  Dec23, 2009     Seeeduino Stalker V2.0  Dec10, 2010     Seeeduino Stalker V2.1  Oct3, 2011     Seeeduino Stalker V2.2  Dec27, 2011     Seeeduino Stalker V2.3  Jan10, 2013     Seeeduino Stalker V3.0  Jun6, 2014     Seeeduino Stalker V3.1  Jul10, 2016", 
            "title": "Version Track"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#whats-new-in-seeeduino-stalker-v31", 
            "text": "Improve Power Management  In V3.1, when MCU is in sleep mode, all other power supplement, including Bee area port, 3.3v port, VCC can be cut off manually, so that power can really be saved.  Other Changes  There is a toggle switch added to X-bee area, which allows you to select either the hardware serial port   or software serial port base on what you want to connect.  We also added 2 toggle switch on RTC circuitry corresponding 2 INT pin of MCU, so that users can easily choose which INT pin to be connected with RTC INT port then activate MCU.", 
            "title": "What's new in Seeeduino Stalker V3.1"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#features", 
            "text": "Arduino UNO compatible pinout with Arduino Fio bootloader  Lipo battery manager IC and Solar charge input(jst2.0 connector)  Onboard Real Time Clock chip  DS1337S  (Socket for a CR1220 coin cell, which acts as a backup power source for RTC)  Serial interface with DTR for auto reset during programming when operating in standalone mode.   microSD card socket  Grove connector (operation voltage is selectable: 5.0V or 3.3V)  Reset buttons for both XBee Modules and ATMega328P  Bee series socket 2*10 pin 2.0mm pitch", 
            "title": "Features"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#specification", 
            "text": "Parameter  Value      Micro Controller  Atmega328P    Clock Speed  8 MHz    I/O Voltage  3.3V    RTC  DS1337S    Board for Arduino IDE  Arduino Pro or Pro Mini (3.3v , 8 MHz)w/ATmega328    Power Supply  3.7v LiPo Battery, Use 5VDC solar panel for charging the battery    Power Connector  2 pin JST/ USB    Connectivity  I2C, UART, SPI    SD Card  micro SD card    Open Circuit Current  6 mA max    Charging Current  300mA    Maximum Current on 3.3v port  800mA    Size of PCB  86.74mm x 60.96mm", 
            "title": "Specification"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#application-ideas", 
            "text": "Wireless Sensor Network (using  XBee  bought separately)  GPS Logging (using  GPSBee  bought separately)  Data Acquisition System capable of communicating with an App running on iPhone/Android Phone (using  BluetoothBee  bought separately).  RF Remote Control (using  RFBee  bought separately).  As a simple standalone Arduino compatible physical computing platform.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#overview", 
            "text": "Seeeduino Stalker V3.1 is an application board with rich function. RTC, Lipo battery connector, Bee socket and SD card socket etc. The below overview image will introduce each part of the board to help you to know the board better.       NAME  FUNCTION      RTC BATTERY  Cell battery to power DS1337S    RTC_INT  RTC interrupt switch    Bee Serial Select  Bee RX/TX pin select, you can select D0/D1 or D6/D7    Bee Socket  Insert a Bee    CHARGE STATUS LED  OK : a green led, on while charge done.  CH : a red led, on while charging    BEE RST  Reset the Bee    SOLAR  Solar input to charge the battery, input 4.5~6V    LIPO  lipo battery input, 3.7V    L  A LED connected to D13, can be acted as a monitor    GROVE2  Grove port, connect to I2C    GROVE1  Grove port, connect to D7/8    PROGRAM  Programming port, connect to a UartSBee here    RST  Reset the Atmega328P    SD CARD  A micro SD Card socket", 
            "title": "Overview"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#pinmap", 
            "text": "Seeeduino Stalker V3.1 is compatible with Arduino, there re many Analog pins, Digital Pin as well as Serial pins available to make your own application. Below pin map image will help you to decided which pin are free or not as well as the pin used.", 
            "title": "Pinmap"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#get-started", 
            "text": "If this is your first time to program with a Seeeduino Stalker. You can follow the below steps to getting started. Before we start, make sure you have the below things on hand:     Seeeduino Stalker V3.1  UartSBee V4  Mini USB Cable  6pin Cable            GET ONE NOW  GET ONE NOW  GET ONE NOW  GET ONE NOW      Note  UartSBee V4, Mini USB Cable and 6pin cable are not included.", 
            "title": "Get Started"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#step1-connection", 
            "text": "Firstly connect Staler to UartSBee via the 6pin jumper wire, then connect UartSBee to a PC via the mini USB cable.      Seeeduino Stalker  UartSBee V4      DTR  DTR    TXD  RXD    RXD  TXD    5V  VCC    GND  GND      Note  The power switch on UartSBee V4 put to 5V", 
            "title": "STEP1: Connection"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#step2-uartsbee-and-the-driver", 
            "text": "UartSBee is a USB to Serial UART interface which is based on FT232RL from FDTI. Click to download the  driver  for the board.  In our case, it will perform three functions:    To program the Seeeduino Stalker.  To communicate with Seeeduino Stalker.  Provide power (from USB power of PC) to Seeeduino Stalker (including any peripherals connected to it).", 
            "title": "STEP2: UartSBee and the Driver"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#step3-arduino-ide", 
            "text": "Seeeduino Stalker is an Arduino compatible board that with rich function. If you don t have an Arduino IDE, you need to download the latest Arduino software to program the board.", 
            "title": "STEP3: Arduino IDE"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#step4-blink", 
            "text": "Here we will update a simple code to Stalker. Open your Arduino IDE, open  File   Examples   Basics   Blink   Then click on the Upload button, seconds later after the uploading is done, check  L  on the board, it will blink at the frequency of 1s.", 
            "title": "STEP4: Blink"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#sketchbook-for-stalker-v31", 
            "text": "There s a sketchbook for Seeeduino Stalker V3.1, which is consist of:   Example of reading the voltage of battery  Example of reading the status of charging  Example of data log  RTC library and some examples  Sleep related function    Download the sketch and put at anywhere, open Arduino IDE,  File   Reference , and copy the location path to  Sketchbook location , then click on OK. Reopen Arduino IDE, then the sketchbook is set.", 
            "title": "Sketchbook for Stalker V3.1"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#rtc", 
            "text": "There s a on-board  DS1307S with a 3V cell battery, which can hold the time for more that 3 years even there s no power supply to the board. The library of DS1307S is included at the sketch of Stalker.", 
            "title": "RTC"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#adjust-datetime", 
            "text": "Open Arduino IDE, then  File   Sketchbook   RTC   Adjust , then set the current date/time using the DateTime Class object  dt  in the example:  DateTime dt(year, month, date, hour, min, sec, week-day(starts from 0 and goes to 6));\nEx:- DateTime dt(2015, 10, 1, 11, 43, 0, 4);  Compile and upload to Stalker, then time is set.", 
            "title": "Adjust Date/Time"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#get-current-datetime", 
            "text": "Open Arduino IDE, then  File   Sketchbook   RTC   Now , The current date/time is read from DS1337 using  RTC.now()  function.   Ex:- DateTime now = RTC.now();  Compile and upload to Stalker, and open the Serial monitor, you will get the date and time display:", 
            "title": "Get Current Date/Time"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#ds1337-interrupts-example", 
            "text": "This example is a demonstration of interrupt detection from DS1337 INT output. This feature is useful for data-logger functionality where the MCU is put to sleep mode when not in use and DS1337 INT wakes up the CPU periodically. This extends battery power. The complete operation is documented in the code.  There re 2 INT output from DS1337, INTA (connect to  D2 ) and INTB (connect to  D3 ). There s a switch to connect INTA/INTB and D2/D3, if you don t need the interrupt, you can just close the switch and save 1 or 2 I/O. Switch as below:   Open Arduino IDE, then  File   Sketchbook   RTC   interrupts , this example will generate an interrupt every minutes. If you need other type of alarm, please refer to the code.", 
            "title": "DS1337 Interrupts Example"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#sd-card", 
            "text": "There s a micro SD card socket which you can insert a micro SD card to store some data. Stalker read/write the SD card via SPI interface. There re enough examples to operate a SD by using the SD library inside Arduino IDE.\nOpen your Arduino IDE,  File   Examples   SD , you will get many examples.     Note  The CS pin is connected to D10 of Stalker, so you need to change the CS pin into D10 at the examples.", 
            "title": "SD Card"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#power-manager", 
            "text": "There s Lipo battery manage circuit built in Stalker. There are two useful function supply at the sketch.", 
            "title": "Power Manager"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#read-the-voltage-of-lipo-battery", 
            "text": "Open Arduino IDE,  File   Sketchbook   ReadBattery  to open the example.   The voltage of the battery is related to the battery capacity. Below is a reference, but please know that it s not for every battery, for a certain battery, the data may a little different.      Capacity(%)  100%  80%  60%  40%  20%  0%      Voltage(V)  4.20  4.00  3.87  3.79  3.73  3.00", 
            "title": "Read the voltage of Lipo Battery:"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#get-charge-status", 
            "text": "Open Arduino IdE,  File   Sketchbook   ReadChageStatus  to open the examples. This function will return 3 status:  0: No batter insert\n1: Charging\n2: Charge done", 
            "title": "GET Charge Status"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#bees", 
            "text": "Bees are a series of modules that consist of rich function. Such as Wi-Fi, BLE, GPS as well as RF etc. With an XBee, Stalker can act as a node that with communication. A Stalker talk to another Stalker is no longer impossible. If you need more details about the Bees, below is some reference.     Bluetooth Bee  XBee Wi-Fi PCB Antenna  RFbee V1.1           GET ONE NOW  GET ONE NOW  GET ONE NOW        Bluetooth Bee - Standalone  GPS Bee kit  Mesh Bee           GET ONE NOW  GET ONE NOW  GET ONE NOW      Note   You need to select the Serial pin for a Bee, D0/D1 and D5/D6 is available. Please refer to Hardware Overview get more info.   D9 is controlling the power of Vcc of Bee socket, if you need power to a Bee, you should make D9 HIGH: digitalWrite(9, HIGH), and don t forget to pinMode(9, OUTPUT) in the Setup.", 
            "title": "Bees"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#data-logger-example", 
            "text": "The principal application of Seeeduino Stalker v3.0 is data-logging of sensor signal like battery voltage, etc. along with the time-stamp. This sketch puts the MCU in sleep mode when not performing data sampling / logging operation. The complete implementation is documented very well in the code.   Open Arduino IDE,  File   Sketchbook   StalkerV30_DataLogger_10Sec  to open the example.\n- This sketch logs battery voltage data to SD card configured by RTC.enableInterrupts(h, m, s) function.\n- The periodicity is provided using h, m and s. Once an interrupt is detected, the next interrupt time is updated by advancing the h, m and s value. The DateTime Class comes handy for this.\n- ex:- interruptTime = DateTime (interruptTime.get() + interruptInterval); //decide the time for next interrupt\n- This sketch also produces verbose output i.e the various events happening inside MCU are displayed in serial terminal.", 
            "title": "Data Logger Example"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#resources", 
            "text": "Schematic  Schematic in  Eagle  Schematic in  PDF  Datasheet  DS1307  CN3065  ETA3406  Sketchbook", 
            "title": "Resources"
        }, 
        {
            "location": "/Seeeduino_Stalker_V3.1/#faq", 
            "text": "Here are some questions that we usually received from new users. If you have any other issues when you are using Seeeduino Stalker V3.1, welcome to the  Community of Arduino  where there are many professional users waiting to give you advices and also many advanced users providing plenty of ideas on how to use this products!   Q1:  The RTC is reset to the original time when power off and on again.   There s a cell battery to power the RTC when there s no power from the system. The cell battery is supposed to last at least 3 years. You can check if the cell battery run off.   Q2:  I can t upload sketch to Stalker V3.1   Firstly, check if your USB-UART connected to Stalker right, then check if you select the right port number and board( Arduino Fio  or  Arduino Arduino Pro or Pro Mini (3.3v , 8 MHz)w/ATmega328 ). Finaly, if you had inserted a Bee on the socket and the RX/TX is selected to D0/D1, you should take the bee off when uploading the skteck.    Q3:  The RTC interrupt demo is not work, I can t get any interrupt.   Firstly, check if you set the alarm time right, and don t forget to put the RTC_INT switch to the right side.    Q4:  The solar panel can t charge the lipo battery.   Make sure your solar panel is able to supple 4.5~6V voltage.", 
            "title": "FAQ"
        }, 
        {
            "location": "/Seeeduino_v4.2/", 
            "text": "Seeeduino v4 is an Open Source, Arduino-compatible ATmega328 MCU development board. We think Seeeduino v4 is one of the best Arduino derivatives/compatibles available. Seeeduino v4 is feature rich, much more stable, easy-to-use and even good looking.\n\n\nSeeeduino v4 is based the Arduino UNO bootloader, an ATmega16U2 as a UART-to-USB converter (basically work like an FTDI USB2UART chip). The board comes with an additional set of through-hole pads for all pins. These pads are aligned to 0.1\n grid. This makes it easy to solder additional pin-headers to plug into breadboard or create your own attachment/shield with 0.1\n dot-matrix general purpose PCBs.\n\n\nYou can program the board via a micro-USB cable. Also, you can power the board via a DC Jack input (7 to 15V DC) is acceptable. There is a switch to choose the system\ns supply voltage either 3.3V or 5V, which is very useful if you want to set the system to 3.3V to interact with low voltage sensors.\n\n\nFinally, the three on-board Grove interfaces can make your board connect to Grove modules easily. Want to make something awesome, maybe just a Seeeduino v4.2 and some Groves is enough.\n\n\nVersion\n\uf0c1\n\n\nThis document applies to the following version of products:\n\n\n\n\n\n\n\n\nVersion\n\n\nReleased Date\n\n\nHow to Buy\n\n\n\n\n\n\n\n\n\n\nSeeeduino V4.0\n\n\nAug 15, 2014\n\n\n\n\n\n\n\n\nSeeeduino V4.2\n\n\nAug 24, 2015\n\n\n\n\n\n\n\n\n\n\nWhat\ns New in Seeeduino V4.2\n\uf0c1\n\n\nThere\nre many updates from V4.0 to V4.2. Listed below:\n\n\n\n\nCancel some pad on the top left corner.\n\n\nChange the usb location to middle\n\n\nImprove DCDC circuit to get a better performance\n\n\nAdd an I2C Grove connector\n\n\nChange some silkscreen and part location\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nDIY\n\n\nIoT and Smart Home\n\n\nRobot\n\n\nLearning\n\n\n\n\nHere is some funny project for your reference.\n\n\n\n\n\n\n\n\nPaper Man\n\n\nFingerprint Lock\n\n\nMonitor Stand\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it Now\n\n\nMake it Now\n\n\nMake it Now\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDesk Promo\n\n\nTiger Machine\n\n\nColorful Pyramid\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it Now\n\n\nMake it Now\n\n\nMake it Now\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nFully compatible with Arduino UNO\n\n\nATmega328 microcontroller\n\n\n14 Digital I/O Pins (6 PWM outputs)\n\n\n6 Analog Inputs\n\n\nISP Header\n\n\nArduino UNO-R3 Shield Compatible\n\n\nMicro USB programming and power supply\n\n\nOn-board Grove connectors\n\n\n3.3/5V system operation power switch\n\n\nAdditional pads aligned to 0.1\n grid\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nDC Jack Input\n\n\n7-12V\n\n\n\n\n\n\nDC Output Current\n\n\n\n\n\n\n\n\n5V Pin\n\n\nWith Micro USB    500mA Max\n\n\n\n\n\n\n5V Pin\n\n\nWith DC Jack Power    2000mA Max\n\n\n\n\n\n\n3V3 Pin\n\n\n500mA Max\n\n\n\n\n\n\nDC Current per I/O Pin\n\n\n40mA\n\n\n\n\n\n\nFlash Memory\n\n\n32 KB\n\n\n\n\n\n\nRAM\n\n\n2 KB\n\n\n\n\n\n\nEEPROM\n\n\n1 KB\n\n\n\n\n\n\nClock Speed\n\n\n16 MHz\n\n\n\n\n\n\nDimension\n\n\n68.6mm x 53.4mm\n\n\n\n\n\n\nWeight\n\n\n26g\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nNote\n\n\nThis part is based on Seeeduino V4.2\n\n\n\n\nThe images below show an overview of Seeeduino v4.2 hardware features. The pin-out and alternate functions of various pins of Seeeduino v4.2 are shown in the pin-out diagram. This could be used as a quick reference.\n\n\n\n\n\n\nLED-D13\n\nAn LED is connected to D13 pin of the board. This can be used as an on-board LED indicator for programs/sketches.\n\n\nUSB Input\n\nUSB Port is used to connect the board to your PC for programming and for powering up. Micro USB is the ubiquitous version of USB, found in most Android phones, and other devices. You probably have dozens of these cables laying around your house.\n\n\nRX/TX Indicator\n\nThe TX and RX LED indicators are connected to TX and RX of USB-to-UART chip. They work automatically, they let you know when the board is sending or receiving data respectively.\n\n\nSystem Power Switch\n\nSlide switch is used to change the logic level and operating voltage of the board to either 5V or 3.3V. Nowadays, many new and great sensors are being developed to work only with 3.3V, with other Arduino boards you would need to place a logic level converter between the board and these sensor(s). With the Seeeduino V4 board all you have to do is slide the switch!\n\n\nDC Input\n\nThe DC power jack allows your Seeeduino board to be powered from a wall adapter so that you can supply more power to your project if needed. For example, when using DC motors or other high power devices. The DC input can be 7V-15V.\n\n\nReset\n\nThis button is conveniently placed on the side to allow you to reset the Seeeduino board even when a shield is placed on top. This is not the case in other Arduino boards where the button is placed on top making it hard to access.\n\n\nPower Pins \n Analog Pins\n\nJust like the extra Digital header pads, these extra connections are something we have personally come to realize people need in their projects, especially the power connections if you want to power more than one sensor/device without the use of a breadboard.\n\n\nGrove Connectors\n\nSeeedStudio has a variety of sensors/devices that can make use of this I2C or UART connection. In addition, we sell independent Grove connectors to help you make our own sensor connections. The I2C Grove connector is also connected to analog pin A4 and A5 for SDA and SCL respectively if you would like to use those pins instead. The UART Grove connector is connected to digital pins 0 and 1 for RX and TX respectively.\n\n\nICSP\n\nThis is the ICSP connection for the ATmega328P, it is located in the standard ICSP/SPI position for Arduino Uno, Due, Mega, and Leonardo compatible hardware (e.g. shields) that may use this connector. The SPI pins in this port: MISO, SCK, and MOSI, are also connected to digital pins 12, 13, and 11 respectively just like those of the Arduino Uno.\n\n\nUSB 2 Uart\n\nPinout of USB-2-Uart. These pads can be used to interact with other UART devices by putting the on-board ATmega328 in reset mode. This makes Seeeduino V4.2 to be used a USB2UART utility board.\n\n\nAdditional 0.1\n Grid aligned header Pads\n\nSometimes it is very convenient to connect a sensor/device to your board directly instead of going through a breadboard, or perhaps you want to solder the sensor directly to the board once you\nve completed your project, or maybe you want to monitor the output of the pins while they\nre been used by other devices. In any cases we have added these extra pads to help you along the way. These pads are aligned in 0.1\n grid and can conveniently work with general purpose dot-matrix PCBs.\n\n\n\n\n\n\nWarning\n\n\nTake gentle care in handling micro USB socket, or you might break the socket off.\n\n\n\n\nInstall the Driver\n\uf0c1\n\n\nFirst of all, you need to:\n\n\n\n\n\n\nGet a Micro-USB cable\n\n\n\n\nYou need a Micro-USB cable first; the data cable of an Android Phone will do fine.\nIf you can\nt find one, you can buy one \nhere\n.\n\n\n\n\n\n\n\n\nConnect the board\n\n\n\n\nThe Seeeduino V4.2 automatically draw power from either the USB connection to the computer or an external power supply. Connect the Arduino board to your computer using the USB cable. The green power LED (labelled \nPWR\n) should go on.\n\n\n\n\n\n\n\n\nFor Windows\n\uf0c1\n\n\n\n\nNote\n\n\nThis drive is available for Windows XP, Windows Vista, Windows 7, Windows 8/8.1 and Windows 10.\n\n\n\n\n\n\n\n\nPlug in your board and wait for Windows to begin its driver installation process. After a few moments, the process will fail, despite best efforts.\n\n\nClick on the Start Menu, and open up the Control Panel.\n\n\nWhile in the Control Panel, navigate to System and Security. Next, click on System. Once the System window is up, open the \nDevice Manager\n.\n\n\nLook under Ports (COM \n LPT). You should find an open port named \nSeeeduino v4\n. If there is no COM \n LPT section, look under \nOther Devices\n for \nUnknown Device\n.\n\n\nRight click on the \nSeeeduino v4\n port and choose the \nUpdate Driver Software\n option.\n\n\nNext, choose the \nBrowse my computer for Driver software\n option.\n\n\nFinally, navigate to and select the driver file named \nSeeeduinoV4.inf\n\n\nWindows will finish up the driver installation from there.\n\n\n\n\nFor Mac OSX\n\uf0c1\n\n\nYou don\nt need to install any drivers. \n\n\nGetting Started\n\uf0c1\n\n\n\n\nNote\n\n\nThis part is based on Arduino 1.6.9 under Windows 10.\n\n\n\n\nFirst of all, you need to Install an Arduino Software.\n\n\n\n\nLaunch the Arduino application\n\uf0c1\n\n\nDouble-click the Arduino application (arduino.exe) you have previously downloaded. \n\n\n\n\nNote\n\n\nIf the Arduino Software loads in a different language, you can change it in the preferences dialog. See the \nArduino Software (IDE) page\n for details.\n\n\n\n\nOpen the Blink example\n\uf0c1\n\n\nOpen the LED blink example sketch: \nFile \n Examples \n01.Basics \n Blink\n.\n\n\n\n\nAdd Seeeduino to your Arduino IDE\n\uf0c1\n\n\nClick on \nFile \n Preference\n, and fill Additional Boards Manager URLs with below url:\n    \nhttps://raw.githubusercontent.com/Seeed-Studio/Seeeduino-Boards/master/package_seeeduino_index.json\n\n\nClick OK to finish the setting. Then Click on \nTools \n Board \n Boards Manager\n, find \nSeeeduino by Seeed Studio\n, and Install it.\n\n\n\n\nSelect your board\n\uf0c1\n\n\nYou\nll need to select the entry in the \nTools \n Board\n menu that corresponds to your Arduino.\nSelecting a \nSeeeduino V4\n.\n\n\n\n\nSelect your serial port\n\uf0c1\n\n\nSelect the serial device of the Arduino board from the Tools | Serial Port menu. This is likely to be COM3 or higher (\nCOM1\n and \nCOM2\n are usually reserved for hardware serial ports). To find out, you can disconnect your Arduino board and re-open the menu; the entry that disappears should be the Arduino board. Reconnect the board and select that serial port.\n\n\n\n\n\n\nNote\n\n\nOn the Mac, this should be something with \n/dev/tty.USBmodem\n.\n\n\n\n\nUpload the program\n\uf0c1\n\n\nNow, simply click the \nUpload\n button in the environment. Wait a few seconds - you should see the RX and TX LED indicators on the board flashing. If the upload is successful, the message \nDone uploading.\n will appear in the status bar.\n\n\n\n\nA few seconds after the upload finishes, you should see the pin 13 (L) LED on the board start to blink (in orange). If it does, congratulations! You\nve gotten Arduino up-and-running. If you have problems, please see the troubleshooting suggestions.\n\n\n\n\nGetting Started on Linux\n\uf0c1\n\n\nFor using on Linux, please go to \nInstalling Arduino on Linux\n\n\nResources\n\uf0c1\n\n\n\n\n\n\nSchematic\n\n\n\n\nSeeeduino V4.2 in EAGLE file\n\n\nSeeeduino V4.2 in PDF\n\n\nSeeeduino V4.0 in EAGLE file\n\n\nSeeeduino V4.0 in PDF\n\n\n\n\n\n\n\n\nDatasheet\n\n\n\n\nATmega328P\n\n\nATmega16U2\n\n\n\n\n\n\n\n\nDownload above all\n\n\n\n\n\n\nReferences\n\n\n\n\nGetting Started with Arduino\n\n\nArduino Language Reference\n\n\nDownload the Arduino Software(IDE)\n\n\nArduino FAQ\n\n\nArduino Introduction\n\n\nWikipedia page for Arduino\n\n\n\n\n\n\n\n\nFAQ\n\uf0c1\n\n\nQ1. What\ns the different between Arduino UNO and Seeeduino V4\n\uf0c1\n\n\nSeeeduino V4 is fully compatible with Arduino UNO. The mainly difference list below:\n\n\n\n\nUse a micro USB to power and program the board\n\n\n3 on-board Grove connector\n\n\n3.3/5V system power switch\n\n\nDCDC circuit instead of LDO, more efficiency\n\n\nOthers circuit improve\n\n\n\n\nQ2. I can\nt upload my sketch to Seeeduino V4\n\uf0c1\n\n\nPlease check,\n\n\n\n\nIf the Power LED on\n\n\nIf you choose the right Port and Board (Seeeduino V4)\n\n\nClose and reopen Arduino IDE and try again\n\n\n\n\nQ3. Where can I find technical support if I have some other issue.\n\uf0c1\n\n\nYou can post a question to \nSeeed Forum\n or send an email to \ntechsupport@seeed.cc\n.\n\n\nHelp us to make it better\n\uf0c1\n\n\nThank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.\n\n\nIt is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:\n\n\n\n\nReplace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.  \n\n\nReview and rewrite documents for hundreds of products to make them more understandable.\n\n\nInspected repair all the URL to make sure it can be linked to the right page.\n\n\n\n\nAlthough we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\nt forget to leave your email address if you need our reply, we will reply to you as soon as we can.\n\n\nBy the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Seeeduino v4.2"
        }, 
        {
            "location": "/Seeeduino_v4.2/#version", 
            "text": "This document applies to the following version of products:     Version  Released Date  How to Buy      Seeeduino V4.0  Aug 15, 2014     Seeeduino V4.2  Aug 24, 2015", 
            "title": "Version"
        }, 
        {
            "location": "/Seeeduino_v4.2/#whats-new-in-seeeduino-v42", 
            "text": "There re many updates from V4.0 to V4.2. Listed below:   Cancel some pad on the top left corner.  Change the usb location to middle  Improve DCDC circuit to get a better performance  Add an I2C Grove connector  Change some silkscreen and part location", 
            "title": "What's New in Seeeduino V4.2"
        }, 
        {
            "location": "/Seeeduino_v4.2/#application-ideas", 
            "text": "DIY  IoT and Smart Home  Robot  Learning   Here is some funny project for your reference.     Paper Man  Fingerprint Lock  Monitor Stand           Make it Now  Make it Now  Make it Now        Desk Promo  Tiger Machine  Colorful Pyramid           Make it Now  Make it Now  Make it Now", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Seeeduino_v4.2/#features", 
            "text": "Fully compatible with Arduino UNO  ATmega328 microcontroller  14 Digital I/O Pins (6 PWM outputs)  6 Analog Inputs  ISP Header  Arduino UNO-R3 Shield Compatible  Micro USB programming and power supply  On-board Grove connectors  3.3/5V system operation power switch  Additional pads aligned to 0.1  grid", 
            "title": "Features"
        }, 
        {
            "location": "/Seeeduino_v4.2/#specification", 
            "text": "Item  Value      DC Jack Input  7-12V    DC Output Current     5V Pin  With Micro USB    500mA Max    5V Pin  With DC Jack Power    2000mA Max    3V3 Pin  500mA Max    DC Current per I/O Pin  40mA    Flash Memory  32 KB    RAM  2 KB    EEPROM  1 KB    Clock Speed  16 MHz    Dimension  68.6mm x 53.4mm    Weight  26g", 
            "title": "Specification"
        }, 
        {
            "location": "/Seeeduino_v4.2/#hardware-overview", 
            "text": "Note  This part is based on Seeeduino V4.2   The images below show an overview of Seeeduino v4.2 hardware features. The pin-out and alternate functions of various pins of Seeeduino v4.2 are shown in the pin-out diagram. This could be used as a quick reference.    LED-D13 \nAn LED is connected to D13 pin of the board. This can be used as an on-board LED indicator for programs/sketches.  USB Input \nUSB Port is used to connect the board to your PC for programming and for powering up. Micro USB is the ubiquitous version of USB, found in most Android phones, and other devices. You probably have dozens of these cables laying around your house.  RX/TX Indicator \nThe TX and RX LED indicators are connected to TX and RX of USB-to-UART chip. They work automatically, they let you know when the board is sending or receiving data respectively.  System Power Switch \nSlide switch is used to change the logic level and operating voltage of the board to either 5V or 3.3V. Nowadays, many new and great sensors are being developed to work only with 3.3V, with other Arduino boards you would need to place a logic level converter between the board and these sensor(s). With the Seeeduino V4 board all you have to do is slide the switch!  DC Input \nThe DC power jack allows your Seeeduino board to be powered from a wall adapter so that you can supply more power to your project if needed. For example, when using DC motors or other high power devices. The DC input can be 7V-15V.  Reset \nThis button is conveniently placed on the side to allow you to reset the Seeeduino board even when a shield is placed on top. This is not the case in other Arduino boards where the button is placed on top making it hard to access.  Power Pins   Analog Pins \nJust like the extra Digital header pads, these extra connections are something we have personally come to realize people need in their projects, especially the power connections if you want to power more than one sensor/device without the use of a breadboard.  Grove Connectors \nSeeedStudio has a variety of sensors/devices that can make use of this I2C or UART connection. In addition, we sell independent Grove connectors to help you make our own sensor connections. The I2C Grove connector is also connected to analog pin A4 and A5 for SDA and SCL respectively if you would like to use those pins instead. The UART Grove connector is connected to digital pins 0 and 1 for RX and TX respectively.  ICSP \nThis is the ICSP connection for the ATmega328P, it is located in the standard ICSP/SPI position for Arduino Uno, Due, Mega, and Leonardo compatible hardware (e.g. shields) that may use this connector. The SPI pins in this port: MISO, SCK, and MOSI, are also connected to digital pins 12, 13, and 11 respectively just like those of the Arduino Uno.  USB 2 Uart \nPinout of USB-2-Uart. These pads can be used to interact with other UART devices by putting the on-board ATmega328 in reset mode. This makes Seeeduino V4.2 to be used a USB2UART utility board.  Additional 0.1  Grid aligned header Pads \nSometimes it is very convenient to connect a sensor/device to your board directly instead of going through a breadboard, or perhaps you want to solder the sensor directly to the board once you ve completed your project, or maybe you want to monitor the output of the pins while they re been used by other devices. In any cases we have added these extra pads to help you along the way. These pads are aligned in 0.1  grid and can conveniently work with general purpose dot-matrix PCBs.    Warning  Take gentle care in handling micro USB socket, or you might break the socket off.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Seeeduino_v4.2/#install-the-driver", 
            "text": "First of all, you need to:    Get a Micro-USB cable   You need a Micro-USB cable first; the data cable of an Android Phone will do fine.\nIf you can t find one, you can buy one  here .     Connect the board   The Seeeduino V4.2 automatically draw power from either the USB connection to the computer or an external power supply. Connect the Arduino board to your computer using the USB cable. The green power LED (labelled  PWR ) should go on.", 
            "title": "Install the Driver"
        }, 
        {
            "location": "/Seeeduino_v4.2/#for-windows", 
            "text": "Note  This drive is available for Windows XP, Windows Vista, Windows 7, Windows 8/8.1 and Windows 10.     Plug in your board and wait for Windows to begin its driver installation process. After a few moments, the process will fail, despite best efforts.  Click on the Start Menu, and open up the Control Panel.  While in the Control Panel, navigate to System and Security. Next, click on System. Once the System window is up, open the  Device Manager .  Look under Ports (COM   LPT). You should find an open port named  Seeeduino v4 . If there is no COM   LPT section, look under  Other Devices  for  Unknown Device .  Right click on the  Seeeduino v4  port and choose the  Update Driver Software  option.  Next, choose the  Browse my computer for Driver software  option.  Finally, navigate to and select the driver file named  SeeeduinoV4.inf  Windows will finish up the driver installation from there.", 
            "title": "For Windows"
        }, 
        {
            "location": "/Seeeduino_v4.2/#for-mac-osx", 
            "text": "You don t need to install any drivers.", 
            "title": "For Mac OSX"
        }, 
        {
            "location": "/Seeeduino_v4.2/#getting-started", 
            "text": "Note  This part is based on Arduino 1.6.9 under Windows 10.   First of all, you need to Install an Arduino Software.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Seeeduino_v4.2/#launch-the-arduino-application", 
            "text": "Double-click the Arduino application (arduino.exe) you have previously downloaded.    Note  If the Arduino Software loads in a different language, you can change it in the preferences dialog. See the  Arduino Software (IDE) page  for details.", 
            "title": "Launch the Arduino application"
        }, 
        {
            "location": "/Seeeduino_v4.2/#open-the-blink-example", 
            "text": "Open the LED blink example sketch:  File   Examples  01.Basics   Blink .", 
            "title": "Open the Blink example"
        }, 
        {
            "location": "/Seeeduino_v4.2/#add-seeeduino-to-your-arduino-ide", 
            "text": "Click on  File   Preference , and fill Additional Boards Manager URLs with below url:\n     https://raw.githubusercontent.com/Seeed-Studio/Seeeduino-Boards/master/package_seeeduino_index.json  Click OK to finish the setting. Then Click on  Tools   Board   Boards Manager , find  Seeeduino by Seeed Studio , and Install it.", 
            "title": "Add Seeeduino to your Arduino IDE"
        }, 
        {
            "location": "/Seeeduino_v4.2/#select-your-board", 
            "text": "You ll need to select the entry in the  Tools   Board  menu that corresponds to your Arduino.\nSelecting a  Seeeduino V4 .", 
            "title": "Select your board"
        }, 
        {
            "location": "/Seeeduino_v4.2/#select-your-serial-port", 
            "text": "Select the serial device of the Arduino board from the Tools | Serial Port menu. This is likely to be COM3 or higher ( COM1  and  COM2  are usually reserved for hardware serial ports). To find out, you can disconnect your Arduino board and re-open the menu; the entry that disappears should be the Arduino board. Reconnect the board and select that serial port.    Note  On the Mac, this should be something with  /dev/tty.USBmodem .", 
            "title": "Select your serial port"
        }, 
        {
            "location": "/Seeeduino_v4.2/#upload-the-program", 
            "text": "Now, simply click the  Upload  button in the environment. Wait a few seconds - you should see the RX and TX LED indicators on the board flashing. If the upload is successful, the message  Done uploading.  will appear in the status bar.   A few seconds after the upload finishes, you should see the pin 13 (L) LED on the board start to blink (in orange). If it does, congratulations! You ve gotten Arduino up-and-running. If you have problems, please see the troubleshooting suggestions.", 
            "title": "Upload the program"
        }, 
        {
            "location": "/Seeeduino_v4.2/#getting-started-on-linux", 
            "text": "For using on Linux, please go to  Installing Arduino on Linux", 
            "title": "Getting Started on Linux"
        }, 
        {
            "location": "/Seeeduino_v4.2/#resources", 
            "text": "Schematic   Seeeduino V4.2 in EAGLE file  Seeeduino V4.2 in PDF  Seeeduino V4.0 in EAGLE file  Seeeduino V4.0 in PDF     Datasheet   ATmega328P  ATmega16U2     Download above all    References   Getting Started with Arduino  Arduino Language Reference  Download the Arduino Software(IDE)  Arduino FAQ  Arduino Introduction  Wikipedia page for Arduino", 
            "title": "Resources"
        }, 
        {
            "location": "/Seeeduino_v4.2/#faq", 
            "text": "", 
            "title": "FAQ"
        }, 
        {
            "location": "/Seeeduino_v4.2/#q1-whats-the-different-between-arduino-uno-and-seeeduino-v4", 
            "text": "Seeeduino V4 is fully compatible with Arduino UNO. The mainly difference list below:   Use a micro USB to power and program the board  3 on-board Grove connector  3.3/5V system power switch  DCDC circuit instead of LDO, more efficiency  Others circuit improve", 
            "title": "Q1. What's the different between Arduino UNO and Seeeduino V4"
        }, 
        {
            "location": "/Seeeduino_v4.2/#q2-i-cant-upload-my-sketch-to-seeeduino-v4", 
            "text": "Please check,   If the Power LED on  If you choose the right Port and Board (Seeeduino V4)  Close and reopen Arduino IDE and try again", 
            "title": "Q2. I can't upload my sketch to Seeeduino V4"
        }, 
        {
            "location": "/Seeeduino_v4.2/#q3-where-can-i-find-technical-support-if-i-have-some-other-issue", 
            "text": "You can post a question to  Seeed Forum  or send an email to  techsupport@seeed.cc .", 
            "title": "Q3. Where can I find technical support if I have some other issue."
        }, 
        {
            "location": "/Seeeduino_v4.2/#help-us-to-make-it-better", 
            "text": "Thank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.  It is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:   Replace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.    Review and rewrite documents for hundreds of products to make them more understandable.  Inspected repair all the URL to make sure it can be linked to the right page.   Although we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don t forget to leave your email address if you need our reply, we will reply to you as soon as we can.  By the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Help us to make it better"
        }, 
        {
            "location": "/UartSBee_v5/", 
            "text": "UartSBee v5\n is FTDI cable compatible \nUSB to Serial\n adapter equipped with BEE socket(20pin 2.0mm). The integrated \nFT232RL\n can be used for programming or communicating with MCUs. On the other hand, you might connect your PC to various wireless applications via a \nBee\n compatible module. UartSBee provides breakouts for the bit-bang mode pins of \nFT232RL\n as well.This Bit-bang mode pins (8 I/O pins) can be used as a replacement for applications involving PC parallel port which is scares now a day.\n\n\n\n\nUartSBee v5 is the Mesh Bee programmer version based on UartSBee v4.\n\n\nPlease refer to \nUartSBee v4\ns wiki page\n for general help topics. In this wiki we focus on the difference between v4 and v5.\n\n\nAdded Features\n\uf0c1\n\n\n\n\nMicroUSB interface\n\n\nCan program Mesh Bee\n\n\nAdded SW3 to switch the connection of FT232\ns UART between the TX1/RX1 pins of BEE socket and the program interface of Mesh Bee\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nEagle file for UartSBee v5\n\n\nHow to program Mesh Bee", 
            "title": "UartSBee v5"
        }, 
        {
            "location": "/UartSBee_v5/#added-features", 
            "text": "MicroUSB interface  Can program Mesh Bee  Added SW3 to switch the connection of FT232 s UART between the TX1/RX1 pins of BEE socket and the program interface of Mesh Bee", 
            "title": "Added Features"
        }, 
        {
            "location": "/UartSBee_v5/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/UartSBee_v5/#resources", 
            "text": "Eagle file for UartSBee v5  How to program Mesh Bee", 
            "title": "Resources"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/", 
            "text": "Main articles: Start here \nGrove IoT Starter Kits Powered by AWS\n , \nBeaglebone Green\n\n\nBeagleBone Green\n (BBG) is a joint effort by BeagleBoard.org and Seeed Studio. It is based on the open-source hardware design of \nBeagleBone Black\n and has added two Grove connectors. The kit contains the new BBG, 10 Grove modules as well as step-by-step tutorials to hook them up quickly. The Grove IoT Starter Kit includes most frequently used sensors and actuators to turn your ideas into tangible applications with AWS Cloud computing.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nOut-of-box, plug and play, no breadboard or soldering\n\n\nFully compliant with AWS Services and AWS best practices\n\n\nStep-by-step tutorials for developers and makers to get started quickly\n\n\n\n\nIncluded in the Box\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nBoard/Part\n\n\nQty\n\n\nDocumentation\n\n\n\n\n\n\n\n\n\n\nBeagleBone Green\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - I2C ADC\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - I2C Hub\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Relay\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Buzzer\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - OLED Display 0.96\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Button\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Temperature Sensor\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Sound Sensor\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b116g)\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Chainable RGB LED\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1\n\n\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nConfigure Your AWS IoT Service\n\uf0c1\n\n\nAt the very beginning, we need to get an AWS IoT service account, and do some configuring.\n\n\n\n\nCreate an \nAWS Account\n\n\n\n\nGo to \nAWS IoT Console\n and open the AWS IoT Dashboard\n\n\n1.Click the \nServices\n on the top-left corner, and then click on AWS IoT, as shown in the image below.\n\n\n\n\n\n\n2.Click \nGet started\n button.\n\n\n\n\n3.Click on \nCreate a Resource\n and then click \nCreat a thing\n.\n\n\n\n\n\n\n\n\n4.Enter a name, whatever you like, here we name it temperature.\n\n\n\n\n5.Click \nCreate\n to complete it and then click on \nView thing\n to get information of the thing you create.\n\n\n\n\n6.Click on \nConnect a device\n.\n\n\n\n\n7.Choose Node JS and Click on \nGenerate certificate and policy\n.\n\n\n\n\n8.You will find 3 files. Download the file, we need them later. And click on \nConfirm \n start connecting\n.\n\n\n\n\n9.Then we should download the AWS IoT Node.js SDK and click on \nReturn to Thing Detail\n.\n\n\n\n\n\n\n\n\nNow, this step is done. Let\ns move to the next step.\n\n\nSetup your BeagleBone Green\n\uf0c1\n\n\nConnect BBG to your PC via micro USB cable, and let BBG access the Internet. If this is your first time to use BBG/BBB, maybe you can follow \nhere\n to get started.\n\n\nConnect Grove modules to BBG as the picture below shows.\n\n\n\n\nSoftware Works\n\uf0c1\n\n\nUpload SDK and keys file to Cloud9 examples folder\n\uf0c1\n\n\n1.Do you still remember the 3 key files and Node JS SDK that you have already download before.\n\n\n\n\n2.Now, upload the SDK and keys file to your Cloud9 examples folder.\n\n\n\n\n\n\nOpen a new terminal\n\uf0c1\n\n\nWe need unzip the SDK and move the keys to right place.\n\n\n\n\n# cd examples\n\n\n\n\nAnd unzip the SDK file.\n\n\n# unzip aws-iot-device-sdk-js-latest.zip\n\n\n\n\nThen entering the unziped folder.\n\n\n#cd aws-iot-device-sdk-js\n\n\n\n\nInstall the dependent packages.\n\n\n# npm install\n\n\n\n\n\n\nCreate a new folder named awsCerts.\n\n\n# mkdir awsCerts \n cd awsCerts\n\n\n\n\nAnd then move the 3 key files to the new folder.\n\n\n# mv ../../31f2fd2680-* .\n\n\n\n\nPlease note that 31f2fd2680 should be replaced by your own key files number.\n\n\nAnd rename the key files\n\n\n# mv 31f2fd2680-certificate.pem.crt.txt  certificate.pem.crt\n# mv 31f2fd2680-private.pem.key   private.pem.key\n\n\n\n\nDownload a file from the internet.\n\n\n# wget https://www.symantec.com/content/en/us/enterprise/verisign/roots/VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem\n\n\n\n\nAnd rename the downloaded file as root-CA.crt.\n\n\n#mv VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem root-CA.crt\n\n\n\n\n\n\nProgramming on BBG\n\uf0c1\n\n\nEnter the examples folder.\n\n\n# cd .. \n cd examples/\n\n\n\n\n\nCreate a new file named grove_temperature_sensor.py.\n\n\n# vim grove_temperature_sensor.py\n\n\n\nAnd copy the following code to the file.\n\n\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\u00a0\nimport time\nimport math\nimport Adafruit_BBIO.GPIO as GPIO\nfrom Adafruit_I2C import Adafruit_I2C\nBUZZER = \nP9_22\n            # GPIO P9_22\nGPIO.setup(BUZZER, GPIO.OUT)\n\u00a0\n# The threshold to turn the buzzer on 28 Celsius\nTHRESHOLD_TEMPERATURE = 28\nADDR_ADC121 = 0x50\n\u00a0\nREG_ADDR_RESULT = 0x00\nREG_ADDR_ALERT = 0x01\nREG_ADDR_CONFIG = 0x02\nREG_ADDR_LIMITL = 0x03\nREG_ADDR_LIMITH = 0x04\nREG_ADDR_HYST = 0x05\nREG_ADDR_CONVL = 0x06\nREG_ADDR_CONVH = 0x07\n\u00a0\ni2c = Adafruit_I2C(ADDR_ADC121)           \n\u00a0\nclass I2cAdc:\n    def __init__(self):\n        i2c.write8(REG_ADDR_CONFIG, 0x20)\n\u00a0\n    def read_adc(self):\n        \nRead ADC data 0-4095.\n\n        data_list = i2c.readList(REG_ADDR_RESULT, 2)\n        #print 'data list', data_list\n        data = ((data_list[0] \n 0x0f) \n 8 | data_list[1]) \n 0xfff\n        return data\nadc = I2cAdc()\n\u00a0\n#   The argument in the read_temperature() method defines which Grove board(Grove Temperature Sensor) version you have connected.\n#   Defaults to 'v1.2'. eg.\n#       temp = read_temperature('v1.0')          # B value = 3975\n#       temp = read_temperature('v1.1')          # B value = 4250\n#       temp = read_temperature('v1.2')          # B value = 4250\ndef read_temperature(model = 'v1.2'):\n    \nRead temperature values in Celsius from Grove Temperature Sensor\n\n    # each of the sensor revisions use different thermistors, each with their own B value constant\n    if model == 'v1.2':\n        bValue = 4250  # sensor v1.2 uses thermistor\u00a0??? (assuming NCP18WF104F03RC until SeeedStudio clarifies)\n    elif model == 'v1.1':\n        bValue = 4250  # sensor v1.1 uses thermistor NCP18WF104F03RC\n    else:\n        bValue = 3975  # sensor v1.0 uses thermistor TTC3A103*39H\n\u00a0\n    total_value = 0\n    for index in range(20):\n        sensor_value = adc.read_adc()\n        total_value += sensor_value\n        time.sleep(0.05)\n    average_value = float(total_value / 20)\n\u00a0\n    # Transform the ADC data into the data of Arduino platform.\n    sensor_value_tmp = (float)(average_value / 4095 * 2.95 * 2 / 3.3 * 1023)\n    resistance = (float)(1023 - sensor_value_tmp) * 10000 / sensor_value_tmp\n    temperature = round((float)(1 / (math.log(resistance / 10000) / bValue + 1 / 298.15) - 273.15), 2)\n    return temperature\n\u00a0\n# Function: If the temperature sensor senses the temperature that is up to the threshold you set in the code, the buzzer is ringing for 1s.\n# Hardware: Grove - I2C ADC, Grove - Temperature Sensor, Grove - Buzzer\n# Note: Use P9_22(UART2_RXD) as GPIO.\n# Connect the Grove Buzzer to UART Grove port of Beaglebone Green.\n# Connect the Grove - I2C ADC to I2C Grove port of Beaglebone Green, and then connect the Grove - Temperature Sensor to Grove - I2C ADC.\nif __name__ == '__main__':\n\u00a0\n    while True:\n        try:\n            # Read temperature values in Celsius from Grove Temperature Sensor\n            temperature = read_temperature('v1.2')\n\u00a0\n            # When the temperature reached predetermined value, buzzer is ringing.\n            if temperature \n THRESHOLD_TEMPERATURE:\n                # Send HIGH to switch on BUZZER\n                GPIO.output(BUZZER, GPIO.HIGH)\n            else:\n                # Send LOW to switch off BUZZER\n                GPIO.output(BUZZER, GPIO.LOW)\n\u00a0\n            print \ntemperature = \n, temperature\n\u00a0\n        except KeyboardInterrupt:\n            GPIO.output(BUZZER, GPIO.LOW)\n            break\n\u00a0\n        except IOError:\n            print \nError\n\n\n\n\n\nCreate a new file named python_sensor.py.\n\n\n#vim  python_sensor.py\n\n\n\nCopy the following code to the new file.\n\n\nimport socket\nimport grove_temperature_sensor\nif __name__ == \n__main__\n:\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('127.0.0.1', 7000))\n\u00a0\n    while True:\n        temperature = grove_temperature_sensor.read_temperature('v1.2')\n    print temperature\n        client.sendall(str('%.2f'%temperature))\n    data = client.recv(1024)\n    print data\n    client.close()\n\u00a0\n    print 'Received', repr(data)\n\n\n\n\nCreate a new file named rgbled.js.\n\n\n#vim rgbled.js\n\n\n\nAnd copy the following code to the new file.\n\n\nvar exec = require('child_process').exec; \nvar value = 0;\n\u00a0\nexports.initpins = function(){\n    exec(\necho 3 \n /sys/class/gpio/export\n,function(error,stdout,stderr){\n        if(error) \n                console.info('stderr\u00a0: '+stderr);\n    });\n    exec(\necho out \n /sys/class/gpio/gpio3/direction\n,function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n    exec(\necho 2 \n /sys/class/gpio/export\n,function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n    exec(\necho out \n /sys/class/gpio/gpio2/direction\n,function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n}\ndigitalwrite = function(pin,state){\n    exec(\necho \n+state.toString()+\n \n /sys/class/gpio/gpio\n+pin.toString()+\n/value\n,\n        function(error,stdout,stderr){\n                    if(error) \n                            console.log('stderr\u00a0: '+stderr);\n        });\n\u00a0\n}\nsleep = function(sleepTime) {\n    for(var start = +new Date; +new Date - start \n= sleepTime; ) { }\n}\nclk = function(){\n        digitalwrite(2,0);\n        sleep(2);\n                digitalwrite(2,1);\n        sleep(2);\n}\nsendByte = function(b){\n    for(var i = 0 ; i \n 8 ;i++){\n        if((b \n 0x80) != 0)\n            digitalwrite(3,1);\n        else\n            digitalwrite(3,0);\n        clk();\n        b = b \n 1; \n    }\n}\nsetColor = function(red,green,blue){\n    var prefix = 0xc0;\n    if((blue \n 0x80) == 0)\n        prefix |= 0x20;\n    if((blue \n 0x40) == 0)\n        prefix |= 0x10;\n    if((green \n 0x80) == 0)\n        prefix |= 0x08;\n    if((green \n 0x40) == 0)\n        prefix |= 0x04;\n    if((red \n 0x80) == 0)\n        prefix |= 0x02;\n    if((red \n 0x40) == 0)\n        prefix |= 0x01;\n    sendByte(prefix);\n    sendByte(blue);\n    sendByte(green);\n    sendByte(red);\n}\nexports.setColorRGB = function(led,red,green,blue){\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    for(var i = 0; i \n led; i++ ){\n        setColor(red,green,blue);\n    }\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    console.log(\nset rgb\n);\n}\ntest = function(){\n    initpins();\n    while(1){\n    console.log(\nloop\n);\n        setColorRGB(1, 255, 0, 0)\n        setColorRGB(1, 0, 255, 0)\n        setColorRGB(1, 0, 0, 255)\n        setColorRGB(1, 0, 255, 255)\n        setColorRGB(1, 255, 0, 255)\n        setColorRGB(1, 255, 255, 0)\n        setColorRGB(1, 255, 255, 255)\n    }\n}\n\n\n\n\nCreate a new file named shadow.js.\n\n\n#vim shadow.js\n\n\n\nCopy the following code to the new file.\n\n\nvar awsIot = require('..');\nvar net = require('net');\nvar rgbled = require('./rgbled.js');\nvar exec = require('child_process').exec;    \nvar myThingName = 'temperature';\nvar thingShadows = awsIot.thingShadow({\n   keyPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/private.pem.key',\n  certPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/certificate.pem.crt',\n    caPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/root-CA.crt',\n  clientId: 'myAwsClientId',\n    region: 'us-west-2'\n});\nvar HOST = '127.0.0.1';\nvar PORT = 7000;\nvar temperature = 25;\nvar red = 0;\nvar green = 0;\nvar blue = 0;\n// Create a server instance, and chain the listen function to it\nnet.createServer(function(socket) {\n    console.log('CONNECTED: ' + socket.remoteAddress +':'+ socket.remotePort);\n            // Add a 'data' event handler to this instance of socket\n    socket.on('data', function(data) {\n        console.log('DATA ' + socket.remoteAddress + ': ' + data);\n        temperature = data.toString().substr(0,5);\n        socket.write('This is your request: \n' + data + '\n');\n    });\n    // Add a 'close' event handler to this instance of socket\n    socket.on('close', function(data) {\n        console.log('Socket connection closed... ');\n    });\n}).listen(PORT, HOST);\n//\n// Thing shadow state\n//\nvar rgbLedLampState = {\nstate\n:{\ndesired\n:{\nred\n:187,\ngreen\n:114,\nblue\n:222,value:25}}};\n\u00a0\n//\n// Client token value returned from thingShadows.update() operation\n//\nvar clientTokenUpdate;\n\u00a0\nthingShadows.on('connect', function() {\n//\n// After connecting to the AWS IoT platform, register interest in the\n// Thing Shadow named 'RGBLedLamp'.\n//\n    thingShadows.register( myThingName );\n//\n// 2 seconds after registering, update the Thing Shadow named \n// 'RGBLedLamp' with the latest device state and save the clientToken\n// so that we can correlate it with status or timeout events.\n//\n// Note that the delay is not required for subsequent updates; only\n// the first update after a Thing Shadow registration using default\n// parameters requires a delay.  See API documentation for the update\n// method for more details.\n//\n    exec('python python_sensor.py',function(error,stdout,stderr){\n            if(stdout.length \n1){\n                console.log('you offer args:',stdout);\n            }else {\n                console.log('you don\\'t offer args');\n            }\n            if(error) {\n                console.info('stderr\u00a0: '+stderr);\n            }});\n    rgbled.initpins();\n    setTimeout( function() {\n       clientTokenUpdate = thingShadows.update(myThingName, rgbLedLampState );\n       }, 2000 );\n    });\nsetInterval(function(){\n        new_data = {\nstate\n:{\ndesired\n:{\nred\n:187,\ngreen\n:114,\nblue\n:222,value:temperature.toString()}}};\n        //new_data = {\nstate\n:{\ndesired\n:{\nvalue\n:temperature.toString()}}};\n        console.log(new_data);\n       clientTokenUpdate = thingShadows.update(myThingName, new_data )\n},2000);\nthingShadows.on('status', \n    function(thingName, stat, clientToken, stateObject) {\n       console.log('received '+stat+' on '+thingName+': '+\n                   JSON.stringify(stateObject));\n    });\n\u00a0\nthingShadows.on('delta', \n    function(thingName, stateObject) {\n       console.log('received delta '+' on '+thingName+': '+\n                   JSON.stringify(stateObject));\n        //console.log(stateObject[\nstate\n]);\n    if(stateObject[\nstate\n][\nred\n]      != red ||\n       stateObject[\nstate\n][\ngreen\n]  != green||\n      stateObject[\nstate\n][\nblue\n]    != blue)\n            rgbled.setColorRGB(1,stateObject[\nstate\n][\nred\n],\n                        stateObject[\nstate\n][\ngreen\n],\n                        stateObject[\nstate\n][\nblue\n]);\n\u00a0\n    red = stateObject[\nstate\n][\nred\n];\n    green = stateObject[\nstate\n][\ngreen\n];\n    blue = stateObject[\nstate\n][\nblue\n];\n    });\n\u00a0\nthingShadows.on('timeout',\n    function(thingName, clientToken) {\n       console.log('received timeout '+' on '+thingName+': '+\n                   clientToken);\n    });\n\n\n\n\nPlease note that, the value of \nmyThingName\n in the 5 line should be the same as your Thing name that you have already create before in your AWS account.\n\n\nRun the Code\n\uf0c1\n\n\nWhen the BBG reboot done, run the code.\n\n\n# cd examples/aws-iot-device-sdk-js/examples/\n# node shadow.js\n\n\n\n\n\nView Result\n\uf0c1\n\n\nThen let\ns open \nAWS IoT\n website, sign in to your account. And click the thing you created minutes ago. Now you can see the temperature was upload to website.\n\n\n\n\nIf you want change the grove chainable led color. You can update the shadow value. eg:\n\n\n\n\nYou can see the BBG get the new RGB value.\n\n\n\n\nAnd the Grove - Chainable RGB LED alse turned into green.\n\n\n\n\nPut hand on \nAWS IoT Services Getting Started Guide\n to get more information about AWS IoT.\n\n\nTroubleshoot\n\uf0c1\n\n\nCan\nt open 192.168.7.2\n\uf0c1\n\n\nPlease update the latest software if you can\nt open 192.168.7.2.\n\n\nStep #1: Download the latest software image.\n\n\nUpdated time: 11/15/15\n\n\nDownload the latest image from \ngoogle drive\n\n\n\n\nStep #2: Install compression utility\n\n\nDownload and install \n7-zip\n.\n\n\n\n\nStep #3: Decompress the image\n\n\nUse 7-zip to decompress the .img file on the desktop or other folder.\n\n\nStep #4: Install SD card programming utility\n\n\nDownload and install \nImage Writer for Windows\n. Be sure to download the binary distribution.\n\n\n\n\nStep #5: Connect SD card to your computer\n\n\nUse an 8G microSD card at least to SD adapter or a USB adapter to connect the SD card to your computer.\n\n\nStep #6: Write the image to your SD card\n\n\nUse either the Ubuntu Image Writer or instructions on its page to write the decompressed image to your SD card.\n\n\n\n\n\n\nNotes\n\n\n 1. You may see a warning about damaging your device. This is fine to accept as long as you are pointing to your SD card for writing.\n\n\n 2. You should not have your BeagleBone connected to your computer at this time.\n\n\n\n\n\nStep #7: Eject the SD card\n\n\nEject the newly programmed SD card.\n\n\nStep #8: Boot your board off of the SD card\n\n\nInsert SD card into your (powered-down) board and apply power, either by the USB cable or 5V adapter. You\nll see flash led if getting started, and this reboot will take up to 10 minutes. The latest Debian flasher images automatically power down the board upon completion. Power-down your board, remove the SD card and apply power again to be complete.\n\n\nGood Luck.\n\n\nTech Support\n\uf0c1\n\n\nPlease post any question on the \nforum\n.\n\n\nFirmware update\n\uf0c1\n\n\nUpdated by 11/15/15\n:\n\n\n\n\nFix the problem of not being able to access 192.168.7.2\n\n\nWin 10 supported now\n\n\n\n\nResources\n\uf0c1\n\n\n\n\n\u3010PDF\u3011AWS IoT Developer Guide\n\n\n\u3010PDF\u3011AWS User Guide for BBG\n\n\n\u3010Wiki\u3011Main Page for Grove IoT Starter Kits Powered by AWS\n\n\n\u3010Github\u3011AWS SDK for BeagleBone Green kit\n\n\n\u3010Github\u3011Libraries for BeagleBone Green kit\n\n\nWiki:BeagleBone Green\n\n\nMain page of Beagleboard\n\n\nWiki:Grove - I2C ADC\n\n\nWiki:Grove - I2C Hub\n\n\nWiki:Grove - Relay\n\n\nWiki:Grove - Buzzer\n\n\nWiki:Grove - OLED Display 96*96\n\n\nWiki:Grove - Button\n\n\nWiki:Grove - Temperature sensor v1.2\n\n\nWiki:Grove - Sound sensor\n\n\nWiki:Grove - 3-Axis Digital Accelerometer ADXL345\n\n\nWiki:Grove - Chainable RGB LED", 
            "title": "Beagle Bone Green and Grove IoT Starter Kit Powered by AWS"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#features", 
            "text": "Out-of-box, plug and play, no breadboard or soldering  Fully compliant with AWS Services and AWS best practices  Step-by-step tutorials for developers and makers to get started quickly", 
            "title": "Features"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#included-in-the-box", 
            "text": "Board/Part  Qty  Documentation      BeagleBone Green  1  Read Here    Grove - I2C ADC  1  Read Here    Grove - I2C Hub  1  Read Here    Grove - Relay  1  Read Here    Grove - Buzzer  1  Read Here    Grove - OLED Display 0.96  1  Read Here    Grove - Button  1  Read Here    Grove - Temperature Sensor  1  Read Here    Grove - Sound Sensor  1  Read Here    Grove - 3-Axis Digital Accelerometer(\u00b116g)  1  Read Here    Grove - Chainable RGB LED  1  Read Here    Micro USB Cable - 48cm  1", 
            "title": "Included in the Box"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#configure-your-aws-iot-service", 
            "text": "At the very beginning, we need to get an AWS IoT service account, and do some configuring.   Create an  AWS Account   Go to  AWS IoT Console  and open the AWS IoT Dashboard  1.Click the  Services  on the top-left corner, and then click on AWS IoT, as shown in the image below.    2.Click  Get started  button.   3.Click on  Create a Resource  and then click  Creat a thing .     4.Enter a name, whatever you like, here we name it temperature.   5.Click  Create  to complete it and then click on  View thing  to get information of the thing you create.   6.Click on  Connect a device .   7.Choose Node JS and Click on  Generate certificate and policy .   8.You will find 3 files. Download the file, we need them later. And click on  Confirm   start connecting .   9.Then we should download the AWS IoT Node.js SDK and click on  Return to Thing Detail .     Now, this step is done. Let s move to the next step.", 
            "title": "Configure Your AWS IoT Service"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#setup-your-beaglebone-green", 
            "text": "Connect BBG to your PC via micro USB cable, and let BBG access the Internet. If this is your first time to use BBG/BBB, maybe you can follow  here  to get started.  Connect Grove modules to BBG as the picture below shows.", 
            "title": "Setup your BeagleBone Green"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#software-works", 
            "text": "", 
            "title": "Software Works"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#upload-sdk-and-keys-file-to-cloud9-examples-folder", 
            "text": "1.Do you still remember the 3 key files and Node JS SDK that you have already download before.   2.Now, upload the SDK and keys file to your Cloud9 examples folder.", 
            "title": "Upload SDK and keys file to Cloud9 examples folder"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#open-a-new-terminal", 
            "text": "We need unzip the SDK and move the keys to right place.   # cd examples  And unzip the SDK file.  # unzip aws-iot-device-sdk-js-latest.zip  Then entering the unziped folder.  #cd aws-iot-device-sdk-js  Install the dependent packages.  # npm install   Create a new folder named awsCerts.  # mkdir awsCerts   cd awsCerts  And then move the 3 key files to the new folder.  # mv ../../31f2fd2680-* .  Please note that 31f2fd2680 should be replaced by your own key files number.  And rename the key files  # mv 31f2fd2680-certificate.pem.crt.txt  certificate.pem.crt\n# mv 31f2fd2680-private.pem.key   private.pem.key  Download a file from the internet.  # wget https://www.symantec.com/content/en/us/enterprise/verisign/roots/VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem  And rename the downloaded file as root-CA.crt.  #mv VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem root-CA.crt", 
            "title": "Open a new terminal"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#programming-on-bbg", 
            "text": "Enter the examples folder.  # cd ..   cd examples/   Create a new file named grove_temperature_sensor.py.  # vim grove_temperature_sensor.py  And copy the following code to the file.  #!/usr/bin/python\n# -*- coding: utf-8 -*-\n\u00a0\nimport time\nimport math\nimport Adafruit_BBIO.GPIO as GPIO\nfrom Adafruit_I2C import Adafruit_I2C\nBUZZER =  P9_22             # GPIO P9_22\nGPIO.setup(BUZZER, GPIO.OUT)\n\u00a0\n# The threshold to turn the buzzer on 28 Celsius\nTHRESHOLD_TEMPERATURE = 28\nADDR_ADC121 = 0x50\n\u00a0\nREG_ADDR_RESULT = 0x00\nREG_ADDR_ALERT = 0x01\nREG_ADDR_CONFIG = 0x02\nREG_ADDR_LIMITL = 0x03\nREG_ADDR_LIMITH = 0x04\nREG_ADDR_HYST = 0x05\nREG_ADDR_CONVL = 0x06\nREG_ADDR_CONVH = 0x07\n\u00a0\ni2c = Adafruit_I2C(ADDR_ADC121)           \n\u00a0\nclass I2cAdc:\n    def __init__(self):\n        i2c.write8(REG_ADDR_CONFIG, 0x20)\n\u00a0\n    def read_adc(self):\n         Read ADC data 0-4095. \n        data_list = i2c.readList(REG_ADDR_RESULT, 2)\n        #print 'data list', data_list\n        data = ((data_list[0]   0x0f)   8 | data_list[1])   0xfff\n        return data\nadc = I2cAdc()\n\u00a0\n#   The argument in the read_temperature() method defines which Grove board(Grove Temperature Sensor) version you have connected.\n#   Defaults to 'v1.2'. eg.\n#       temp = read_temperature('v1.0')          # B value = 3975\n#       temp = read_temperature('v1.1')          # B value = 4250\n#       temp = read_temperature('v1.2')          # B value = 4250\ndef read_temperature(model = 'v1.2'):\n     Read temperature values in Celsius from Grove Temperature Sensor \n    # each of the sensor revisions use different thermistors, each with their own B value constant\n    if model == 'v1.2':\n        bValue = 4250  # sensor v1.2 uses thermistor\u00a0??? (assuming NCP18WF104F03RC until SeeedStudio clarifies)\n    elif model == 'v1.1':\n        bValue = 4250  # sensor v1.1 uses thermistor NCP18WF104F03RC\n    else:\n        bValue = 3975  # sensor v1.0 uses thermistor TTC3A103*39H\n\u00a0\n    total_value = 0\n    for index in range(20):\n        sensor_value = adc.read_adc()\n        total_value += sensor_value\n        time.sleep(0.05)\n    average_value = float(total_value / 20)\n\u00a0\n    # Transform the ADC data into the data of Arduino platform.\n    sensor_value_tmp = (float)(average_value / 4095 * 2.95 * 2 / 3.3 * 1023)\n    resistance = (float)(1023 - sensor_value_tmp) * 10000 / sensor_value_tmp\n    temperature = round((float)(1 / (math.log(resistance / 10000) / bValue + 1 / 298.15) - 273.15), 2)\n    return temperature\n\u00a0\n# Function: If the temperature sensor senses the temperature that is up to the threshold you set in the code, the buzzer is ringing for 1s.\n# Hardware: Grove - I2C ADC, Grove - Temperature Sensor, Grove - Buzzer\n# Note: Use P9_22(UART2_RXD) as GPIO.\n# Connect the Grove Buzzer to UART Grove port of Beaglebone Green.\n# Connect the Grove - I2C ADC to I2C Grove port of Beaglebone Green, and then connect the Grove - Temperature Sensor to Grove - I2C ADC.\nif __name__ == '__main__':\n\u00a0\n    while True:\n        try:\n            # Read temperature values in Celsius from Grove Temperature Sensor\n            temperature = read_temperature('v1.2')\n\u00a0\n            # When the temperature reached predetermined value, buzzer is ringing.\n            if temperature   THRESHOLD_TEMPERATURE:\n                # Send HIGH to switch on BUZZER\n                GPIO.output(BUZZER, GPIO.HIGH)\n            else:\n                # Send LOW to switch off BUZZER\n                GPIO.output(BUZZER, GPIO.LOW)\n\u00a0\n            print  temperature =  , temperature\n\u00a0\n        except KeyboardInterrupt:\n            GPIO.output(BUZZER, GPIO.LOW)\n            break\n\u00a0\n        except IOError:\n            print  Error   Create a new file named python_sensor.py.  #vim  python_sensor.py  Copy the following code to the new file.  import socket\nimport grove_temperature_sensor\nif __name__ ==  __main__ :\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('127.0.0.1', 7000))\n\u00a0\n    while True:\n        temperature = grove_temperature_sensor.read_temperature('v1.2')\n    print temperature\n        client.sendall(str('%.2f'%temperature))\n    data = client.recv(1024)\n    print data\n    client.close()\n\u00a0\n    print 'Received', repr(data)  Create a new file named rgbled.js.  #vim rgbled.js  And copy the following code to the new file.  var exec = require('child_process').exec; \nvar value = 0;\n\u00a0\nexports.initpins = function(){\n    exec( echo 3   /sys/class/gpio/export ,function(error,stdout,stderr){\n        if(error) \n                console.info('stderr\u00a0: '+stderr);\n    });\n    exec( echo out   /sys/class/gpio/gpio3/direction ,function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n    exec( echo 2   /sys/class/gpio/export ,function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n    exec( echo out   /sys/class/gpio/gpio2/direction ,function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n}\ndigitalwrite = function(pin,state){\n    exec( echo  +state.toString()+    /sys/class/gpio/gpio +pin.toString()+ /value ,\n        function(error,stdout,stderr){\n                    if(error) \n                            console.log('stderr\u00a0: '+stderr);\n        });\n\u00a0\n}\nsleep = function(sleepTime) {\n    for(var start = +new Date; +new Date - start  = sleepTime; ) { }\n}\nclk = function(){\n        digitalwrite(2,0);\n        sleep(2);\n                digitalwrite(2,1);\n        sleep(2);\n}\nsendByte = function(b){\n    for(var i = 0 ; i   8 ;i++){\n        if((b   0x80) != 0)\n            digitalwrite(3,1);\n        else\n            digitalwrite(3,0);\n        clk();\n        b = b   1; \n    }\n}\nsetColor = function(red,green,blue){\n    var prefix = 0xc0;\n    if((blue   0x80) == 0)\n        prefix |= 0x20;\n    if((blue   0x40) == 0)\n        prefix |= 0x10;\n    if((green   0x80) == 0)\n        prefix |= 0x08;\n    if((green   0x40) == 0)\n        prefix |= 0x04;\n    if((red   0x80) == 0)\n        prefix |= 0x02;\n    if((red   0x40) == 0)\n        prefix |= 0x01;\n    sendByte(prefix);\n    sendByte(blue);\n    sendByte(green);\n    sendByte(red);\n}\nexports.setColorRGB = function(led,red,green,blue){\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    for(var i = 0; i   led; i++ ){\n        setColor(red,green,blue);\n    }\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    console.log( set rgb );\n}\ntest = function(){\n    initpins();\n    while(1){\n    console.log( loop );\n        setColorRGB(1, 255, 0, 0)\n        setColorRGB(1, 0, 255, 0)\n        setColorRGB(1, 0, 0, 255)\n        setColorRGB(1, 0, 255, 255)\n        setColorRGB(1, 255, 0, 255)\n        setColorRGB(1, 255, 255, 0)\n        setColorRGB(1, 255, 255, 255)\n    }\n}  Create a new file named shadow.js.  #vim shadow.js  Copy the following code to the new file.  var awsIot = require('..');\nvar net = require('net');\nvar rgbled = require('./rgbled.js');\nvar exec = require('child_process').exec;    \nvar myThingName = 'temperature';\nvar thingShadows = awsIot.thingShadow({\n   keyPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/private.pem.key',\n  certPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/certificate.pem.crt',\n    caPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/root-CA.crt',\n  clientId: 'myAwsClientId',\n    region: 'us-west-2'\n});\nvar HOST = '127.0.0.1';\nvar PORT = 7000;\nvar temperature = 25;\nvar red = 0;\nvar green = 0;\nvar blue = 0;\n// Create a server instance, and chain the listen function to it\nnet.createServer(function(socket) {\n    console.log('CONNECTED: ' + socket.remoteAddress +':'+ socket.remotePort);\n            // Add a 'data' event handler to this instance of socket\n    socket.on('data', function(data) {\n        console.log('DATA ' + socket.remoteAddress + ': ' + data);\n        temperature = data.toString().substr(0,5);\n        socket.write('This is your request:  ' + data + ' ');\n    });\n    // Add a 'close' event handler to this instance of socket\n    socket.on('close', function(data) {\n        console.log('Socket connection closed... ');\n    });\n}).listen(PORT, HOST);\n//\n// Thing shadow state\n//\nvar rgbLedLampState = { state :{ desired :{ red :187, green :114, blue :222,value:25}}};\n\u00a0\n//\n// Client token value returned from thingShadows.update() operation\n//\nvar clientTokenUpdate;\n\u00a0\nthingShadows.on('connect', function() {\n//\n// After connecting to the AWS IoT platform, register interest in the\n// Thing Shadow named 'RGBLedLamp'.\n//\n    thingShadows.register( myThingName );\n//\n// 2 seconds after registering, update the Thing Shadow named \n// 'RGBLedLamp' with the latest device state and save the clientToken\n// so that we can correlate it with status or timeout events.\n//\n// Note that the delay is not required for subsequent updates; only\n// the first update after a Thing Shadow registration using default\n// parameters requires a delay.  See API documentation for the update\n// method for more details.\n//\n    exec('python python_sensor.py',function(error,stdout,stderr){\n            if(stdout.length  1){\n                console.log('you offer args:',stdout);\n            }else {\n                console.log('you don\\'t offer args');\n            }\n            if(error) {\n                console.info('stderr\u00a0: '+stderr);\n            }});\n    rgbled.initpins();\n    setTimeout( function() {\n       clientTokenUpdate = thingShadows.update(myThingName, rgbLedLampState );\n       }, 2000 );\n    });\nsetInterval(function(){\n        new_data = { state :{ desired :{ red :187, green :114, blue :222,value:temperature.toString()}}};\n        //new_data = { state :{ desired :{ value :temperature.toString()}}};\n        console.log(new_data);\n       clientTokenUpdate = thingShadows.update(myThingName, new_data )\n},2000);\nthingShadows.on('status', \n    function(thingName, stat, clientToken, stateObject) {\n       console.log('received '+stat+' on '+thingName+': '+\n                   JSON.stringify(stateObject));\n    });\n\u00a0\nthingShadows.on('delta', \n    function(thingName, stateObject) {\n       console.log('received delta '+' on '+thingName+': '+\n                   JSON.stringify(stateObject));\n        //console.log(stateObject[ state ]);\n    if(stateObject[ state ][ red ]      != red ||\n       stateObject[ state ][ green ]  != green||\n      stateObject[ state ][ blue ]    != blue)\n            rgbled.setColorRGB(1,stateObject[ state ][ red ],\n                        stateObject[ state ][ green ],\n                        stateObject[ state ][ blue ]);\n\u00a0\n    red = stateObject[ state ][ red ];\n    green = stateObject[ state ][ green ];\n    blue = stateObject[ state ][ blue ];\n    });\n\u00a0\nthingShadows.on('timeout',\n    function(thingName, clientToken) {\n       console.log('received timeout '+' on '+thingName+': '+\n                   clientToken);\n    });  Please note that, the value of  myThingName  in the 5 line should be the same as your Thing name that you have already create before in your AWS account.", 
            "title": "Programming on BBG"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#run-the-code", 
            "text": "When the BBG reboot done, run the code.  # cd examples/aws-iot-device-sdk-js/examples/\n# node shadow.js", 
            "title": "Run the Code"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#view-result", 
            "text": "Then let s open  AWS IoT  website, sign in to your account. And click the thing you created minutes ago. Now you can see the temperature was upload to website.   If you want change the grove chainable led color. You can update the shadow value. eg:   You can see the BBG get the new RGB value.   And the Grove - Chainable RGB LED alse turned into green.   Put hand on  AWS IoT Services Getting Started Guide  to get more information about AWS IoT.", 
            "title": "View Result"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#troubleshoot", 
            "text": "", 
            "title": "Troubleshoot"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#cant-open-19216872", 
            "text": "Please update the latest software if you can t open 192.168.7.2.  Step #1: Download the latest software image.  Updated time: 11/15/15  Download the latest image from  google drive   Step #2: Install compression utility  Download and install  7-zip .   Step #3: Decompress the image  Use 7-zip to decompress the .img file on the desktop or other folder.  Step #4: Install SD card programming utility  Download and install  Image Writer for Windows . Be sure to download the binary distribution.   Step #5: Connect SD card to your computer  Use an 8G microSD card at least to SD adapter or a USB adapter to connect the SD card to your computer.  Step #6: Write the image to your SD card  Use either the Ubuntu Image Writer or instructions on its page to write the decompressed image to your SD card.    Notes   1. You may see a warning about damaging your device. This is fine to accept as long as you are pointing to your SD card for writing.   2. You should not have your BeagleBone connected to your computer at this time.   Step #7: Eject the SD card  Eject the newly programmed SD card.  Step #8: Boot your board off of the SD card  Insert SD card into your (powered-down) board and apply power, either by the USB cable or 5V adapter. You ll see flash led if getting started, and this reboot will take up to 10 minutes. The latest Debian flasher images automatically power down the board upon completion. Power-down your board, remove the SD card and apply power again to be complete.  Good Luck.", 
            "title": "Can't open 192.168.7.2"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#tech-support", 
            "text": "Please post any question on the  forum .", 
            "title": "Tech Support"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#firmware-update", 
            "text": "Updated by 11/15/15 :   Fix the problem of not being able to access 192.168.7.2  Win 10 supported now", 
            "title": "Firmware update"
        }, 
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#resources", 
            "text": "\u3010PDF\u3011AWS IoT Developer Guide  \u3010PDF\u3011AWS User Guide for BBG  \u3010Wiki\u3011Main Page for Grove IoT Starter Kits Powered by AWS  \u3010Github\u3011AWS SDK for BeagleBone Green kit  \u3010Github\u3011Libraries for BeagleBone Green kit  Wiki:BeagleBone Green  Main page of Beagleboard  Wiki:Grove - I2C ADC  Wiki:Grove - I2C Hub  Wiki:Grove - Relay  Wiki:Grove - Buzzer  Wiki:Grove - OLED Display 96*96  Wiki:Grove - Button  Wiki:Grove - Temperature sensor v1.2  Wiki:Grove - Sound sensor  Wiki:Grove - 3-Axis Digital Accelerometer ADXL345  Wiki:Grove - Chainable RGB LED", 
            "title": "Resources"
        }, 
        {
            "location": "/BeagleBone_Green/", 
            "text": "SeeedStudio BeagleBone Green (BBG) is a low cost, open-source, community supported development platform for developers and hobbyists. It is a joint effort by \nBeagleBoard.org\n and Seeed Studio. It is based on the classical open-source hardware design of \nBeagleBone Black\n and developed into this differentiated version. The BBG includes two Grove connectors, making it easier to connect to the large family of Grove sensors. The on-board HDMI is removed to make room for these Grove connectors.\n\n\nBoot Linux in under 10 seconds and get started on development in less than 5 minutes with just a single USB cable.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nFully Compatible with BeagleBone Black\n\n\nProcessor: AM335x 1GHz ARMR Cortex-A8\n\n\n512MB DDR3 RAM\n\n\n4GB 8-bit eMMC on-board flash storage\n\n\n3D graphics accelerator\n\n\nNEON floating-point accelerator\n\n\n2x PRU 32-bit microcontrollers\n\n\n\n\n\n\nConnectivity\n\n\nUSB client for power \n communications\n\n\nUSB host\n\n\nEthernet\n\n\n2x 46 pin headers\n\n\n2x Grove connectors (I2C and UART)\n\n\n\n\n\n\nSoftware Compatibility\n\n\nDebian\n\n\nAndroid\n\n\nUbuntu\n\n\nCloud9 IDE on Node.js w/ BoneScript library\n\n\nplus much more\n\n\n\n\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nProcessor\n\n\nAM335x 1GHz ARMR Cortex-A8\n\n\n\n\n\n\nRAM\n\n\n512MB DDR3\n\n\n\n\n\n\non-board Flash Storage\n\n\n4GB eMMC\n\n\n\n\n\n\nCPU Supports\n\n\nNEON floating-point \n 3D graphics accelerator\n\n\n\n\n\n\nMicro USB  Supports\n\n\npowering \n communications\n\n\n\n\n\n\nUSB\n\n\nHost  1\n\n\n\n\n\n\nGrove Connectors\n\n\n2 (One I2C and One UART)\n\n\n\n\n\n\nGPIO\n\n\n2 x 46 pin headers\n\n\n\n\n\n\nEthernet\n\n\n1\n\n\n\n\n\n\nOperating Temperature\n\n\n0 ~ 75\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nInternet of Things\n\n\nSmart House\n\n\nIndustrial\n\n\nAutomation \n Process Control\n\n\nHuman Machine Interface\n\n\nSensor Hub\n\n\nRobot\n\n\n\n\nHere are some funny projects for your reference.\n\n\n\n\n\n\n\n\nHome Center\n\n\nRetro Lamp\n\n\nDrive a Motor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBBG Acrylic Case\n\n\nGPIO Control\n\n\nSmart Light\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nUSB Host\n - USB Host\n\n\nDC Power and USB Client\n - Power the board and act as client\n\n\nLEDs\n\n\nD2\n is configured at boot to blink in a heartbeat pattern\n\n\nD3\n is configured at boot to light during microSD card accesses\n\n\nD4\n is configured at boot to light during CPU activity\n\n\nD5\n is configured at boot to light during eMMC accesses\n\n\n\n\n\n\nBoot button\n\n\nWhen there\ns a SD card insert, the system will boot from SD card first, if you want to boot from eMMC, press this button and then power on. \n\n\nUse as a normal button after boot, connect to \nGPIO_72\n\n\n\n\n\n\nI2C Grove Interface\n - Connected to \nI2C2\n\n\nUart Grove Interface\n - Connected to \nUART2\n\n\nSerial Debug\n - Connect to \nUART0\n, PIN1~PIN6: GND, NC, NC, RX, TX, NC, note that pin1 is near to the USB.\n\n\n\n\nPin map\n\uf0c1\n\n\nEach digital I/O pin has 8 different modes that can be selected, including GPIO.\n\n\n65 Possible Digital I/Os\n\uf0c1\n\n\n\n\nNote\n\n\nIn GPIO mode, each digital I/O can produce interrupts.\n\n\n\n\n\n\nPWMs and Timers\n\uf0c1\n\n\n\n\nNote\n\n\nUp to 8 digital I/O pins can be configured with pulse-width modulators (PWM) to produce signals to control motors or create pseudo analog voltage levels, without taking up any extra CPU cycles.\n\n\n\n\n\n\nAnalog Inputs\n\uf0c1\n\n\n\n\nNote\n\n\nMake sure you don\nt input more than 1.8V to the analog input pins. This is a single 12-bit analog-to-digital converter with 8 channels, 7 of which are made available on the headers.\n\n\n\n\n\n\nUART\n\uf0c1\n\n\n\n\nNote\n\n\nThere is a dedicated header for getting to the UART0 pins and connecting a debug cable. Five additional serial ports are brought to the expansion headers, but one of them only has a single direction brought to the headers.\n\n\n\n\n\n\nI2C\n\uf0c1\n\n\n\n\nNote\n\n\nThe first I2C bus is utilized for reading EEPROMS on cape add-on boards and can\nt be used for other digital I/O operations without interfering with that function, but you can still use it to add other I2C devices at available addresses. The second I2C bus is available for you to configure and use.\n\n\n\n\n\n\nSPI\n\uf0c1\n\n\n\n\nNote\n\n\nFor shifting out data fast, you might consider using one of the SPI ports.\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\n\n\nNote\n\n\nThis chapter is writing under Win10. The steps are familiar for the other operate systems.\n\n\n\n\nSTEP1. Plug in your BBG via USB\n\uf0c1\n\n\nUse the provided micro USB cable to plug your BBG into your computer. This will both power the board and provide a development interface. BBG will boot Linux from the on-board 2GB or 4GB eMMC. \n\n\nBBG will operate as a flash drive providing you with a local copy of the documentation and drivers. Note that this interface may not be used to re-configure the microSD card with a new image, but may be used to update the boot parameters using the uEnv.txt file.\n\n\nYou\nll see the PWR LED lit steadily. Within 10 seconds, you should see the other LEDs blinking in their default configurations.\n\n\n\n\nD2 is configured at boot to blink in a heartbeat pattern\n\n\nD3 is configured at boot to light during microSD card accesses\n\n\nD4 is configured at boot to light during CPU activity\n\n\nD5 is configured at boot to light during eMMC accesses\n\n\n\n\nSTEP2. Install Drivers\n\uf0c1\n\n\nInstall the drivers for your operating system to give you network-over-USB access to your Beagle. Additional drivers give you serial access to your board.\n\n\n\n\n\n\n\n\nOperating System\n\n\nUSB Drivers\n\n\nComments\n\n\n\n\n\n\n\n\n\n\nWindows (64-bit)\n\n\n64-bit installer\n\n\n\n\n\n\n\n\nWindows (32-bit)\n\n\n32-bit installer\n\n\n\n\n\n\n\n\nMac OS X\n\n\nNetwork\n \nSerial\n\n\nInstall both sets of drivers.\n\n\n\n\n\n\nLinux\n\n\nmkudevrule.sh\n\n\nDriver installation isn\nt required, but you might find a few udev rules helpful.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nFor window system, please note that:\n\n\n\n\nWindows Driver Certification warning may pop up two or three times. Click \nIgnore\n, \nInstall\n or \nRun\n\n\nTo check if you\nre running 32 or 64-bit Windows see \nthis\n.\n\n\nOn systems without the latest service release, you may get an error (0xc000007b). In that case, please \ninstall\n and retry: \n\n\nYou may need to reboot Windows.\n\n\nThese drivers have been tested to work up to Windows 10\n\n\n\n\n\n\n\n\nNote\n\n\nAdditional FTDI USB to serial/JTAG information and drivers are available from \nhttps://www.ftdichip.com/Drivers/VCP.htm\n.\n\n\n\n\n\n\nNote\n\n\nAdditional USB to virtual Ethernet information and drivers are available from \nhttps://www.linux-usb.org/gadget/\n and \nhttps://joshuawise.com/horndis\n.\n\n\n\n\nSTEP3. Browse to your Beagle\n\uf0c1\n\n\nUsing either Chrome or Firefox (Internet Explorer will NOT work), browse to the web server running on your board. It will load a presentation showing you the capabilities of the board. Use the arrow keys on your keyboard to navigate the presentation.\n\n\nClick \nhttp://192.168.7.2\n to launch to your BBG.\nOlder software images require you to EJECT the BEAGLE_BONE drive to start the network. With the latest software image, that step is no longer required.\n\n\n\n\nSTEP4. Cloud9 IDE\n\uf0c1\n\n\nTo begin editing programs that live on your board, you can use the Cloud9 IDE by click\n\n\n\n\nUpdate to latest software\n\uf0c1\n\n\n\n\nYou need to update the board to latest software to keep a better performance, here we will show you how to make it step by step. \n\n\nSTEP1. Download the latest software image\n\uf0c1\n\n\nFirst of all, you have to download the suitable image here. \n\n\n\n\n\n\nNote\n\n\nDue to sizing necessities, this download may take about 30 minutes or more. \n\n\n\n\nThe file you download will have an \n.img.xz\n extension. This is a compressed sector-by-sector image of the SD card. \n\n\nSTEP2. Install compression utility and decompress the image\n\uf0c1\n\n\nDownload and install \n7-zip.\n \n\n\n\n\nNote\n\n\nChoose a version that suitable for your system.\n\n\n\n\nUse 7-zip to decompress the SD card \n.img file\n\n\nSTEP3. Install SD card programming utility\n\uf0c1\n\n\nDownload and install \nImage Writer for Windows\n. Be sure to download the binary distribution.\n\n\nSTEP4. Write the image to your SD card\n\uf0c1\n\n\nYou need a SD adapter to connect your microSD card to your computer at the first. Then use the software Image Write for Windows to write the decompressed image to your SD card.\n\n\n\n\nClick on \nWrite\n button, then the process is started. \n\n\n\n\n\n\nNote\n\n\n\n\nYou may see a warning about damaging your device. This is fine to accept as long as you are pointing to your SD card for writing.\n\n\nYou should not have your BeagleBone connected to your computer at this time.\n\n\nThis process may need up to 10 minutes.\n\n\n\n\n\n\nSTEP5. Boot your board off of the SD card\n\uf0c1\n\n\nInsert SD card into your (powered-down first) board. Then the board will boot from the SD card.\n\n\n\n\nNote\n\n\nIf you don\nt need to write the image to your on-board eMMC, you don\nt need to read the last of this chapter.  Otherwise pleas go ahead.\n\n\n\n\nIf you desire to write the image to your on-board eMMC, you need to launch to the board, and modify a file. \n\n\nIn \n/boot/uEnv.txt\n:\n\n\n##enable BBB: eMMC Flasher:\n#cmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh\n\n\n\nChange to:\n\n\n##enable BBB: eMMC Flasher:\ncmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh\n\n\n\nThen you will find the 4 user led light as below\n\n\n\n\n\n\nNote\n\n\nIf you don\nt find the upper tracing light, please press the RESET button to reset the board. \n\n\n\n\nWhen the flashing is complete, all 4 USRx LEDs will be \noff\n. The latest Debian flasher images automatically power down the board upon completion. This can take up to \n10 minutes\n. Power-down your board, remove the SD card and apply power again to be complete.\n\n\nGrove for BBG\n\uf0c1\n\n\n\n\nGrove is a modular, standardized connecter prototyping system. Grove takes a building block approach to assembling electronics. Compared to the jumper or solder based system, it is easier to connect, experiment and build and simplifies the learning system, but not to the point where it becomes dumbed down.  Some of the other prototype systems out there takes the level down to building blocks.   Good stuff to be learned that way, but the Grove system allows you to build real systems.   It requires some learning and expertise to hook things up.\n\n\nBelow listed the Grove modules that work well with BBG.\n\n\n\n\n\n\n\n\nSKU\n\n\nName\n\n\nInterface\n\n\nlink\n\n\n\n\n\n\n\n\n\n\n101020054\n\n\nGrove - 3-Axis Digital Accelerometer(+16g)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020071\n\n\nGrove - 3-Axis Digital Accelerometer(+400g)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020034\n\n\nGrove - 3-Axis Digital Compass\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020050\n\n\nGrove - 3-Axis Digital Gyro\n\n\nAnalog\n\n\nlink\n\n\n\n\n\n\n101020081\n\n\nGrove - 6-Axis Accelerometer\nCompass v2.0\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020072\n\n\nGrove - Barometer Sensor(BMP180)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n104030010\n\n\nGrove - Blue LED\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n101020003\n\n\nGrove - Button\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n111020000\n\n\nGrove - Button(P)\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n107020000\n\n\nGrove - Buzzer\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n104030006\n\n\nGrove - Chainable RGB LED\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020030\n\n\nGrove - Digital Light Sensor\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n103020024\n\n\nGrove - Finger-clip Heart Rate Sensor\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020082\n\n\nGrove - Finger-clip Heart Rate Sensor with shell\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n113020003\n\n\nGrove - GPS\n\n\nUART\n\n\nlink\n\n\n\n\n\n\n104030007\n\n\nGrove - Green LED\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n103020013\n\n\nGrove - I2C ADC\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n103020006\n\n\nGrove - I2C Hub\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020079\n\n\nGrove - IMU 10DOF\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020080\n\n\nGrove - IMU 9DOF v2.0\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020040\n\n\nGrove - IR Distance Interrupter\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n104030011\n\n\nGrove - OLED Display 0.96\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n104030008\n\n\nGrove - OLED Display 1.12\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n104030005\n\n\nGrove - Red LED\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n103020005\n\n\nGrove - Relay\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n316010005\n\n\nGrove - Servo\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n101020023\n\n\nGrove - Sound Sensor\n\n\nAnalog\n\n\nlink\n\n\n\n\n\n\n101020004\n\n\nGrove - Switch(P)\n\n\nI/O\n\n\nlink\n\n\n\n\n\n\n101020015\n\n\nGrove - Temperature Sensor\n\n\nAnalog\n\n\nlink\n\n\n\n\n\n\n101020019\n\n\nGrove - Temperature\nHumidity Sensor Pro\n\n\nAnalog\n\n\nlink\n\n\n\n\n\n\n\n\nCape for BBG\n\uf0c1\n\n\n\n\nYou will need some expansion board when you start a project. There\nre many cape for BBG already, they include LCD display, motor driver as well as HDMI expansion etc. Below is some of them recommend.\n\n\n\n\n\n\n\n\nGrove Cape\n\n\nMotor Bridge Cape\n\n\nHDMI Cape\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGET ONE NOW!\n\n\nGET ONE NOW!\n\n\nGET ONE NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrove Cape\n\n\n5 Inch LCD\n\n\n7 Inch LCD\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGET ONE NOW!\n\n\nGET ONE NOW!\n\n\nGET ONE NOW!\n\n\n\n\n\n\n\n\nReferences and Resources\n\uf0c1\n\n\nReferences\n\uf0c1\n\n\nThere\nre many references to help you to get more information about the board. \n\n\n\n\nBeagleBoard Main Page\n\n\nBeagleBone Green info at BeagleBoard page\n\n\nBeagleBoard Getting Started\n\n\nTroubleshooting\n\n\nHardware documentation\n\n\nProjects of BeagleBoard\n\n\n\n\nResources\n\uf0c1\n\n\n\n\n\n\nBEAGLEBONE_GREEN SRM(v1a)(pdf)\n\n\nBEAGLEBONE_GREEN Schematic(pdf)\n\n\nBEAGLEBONE_GREEN Schematic(OrCAD)\n\n\nBEAGLEBONE_GREEN PCB(OrCAD)", 
            "title": "BeagleBone Green"
        }, 
        {
            "location": "/BeagleBone_Green/#features", 
            "text": "Fully Compatible with BeagleBone Black  Processor: AM335x 1GHz ARMR Cortex-A8  512MB DDR3 RAM  4GB 8-bit eMMC on-board flash storage  3D graphics accelerator  NEON floating-point accelerator  2x PRU 32-bit microcontrollers    Connectivity  USB client for power   communications  USB host  Ethernet  2x 46 pin headers  2x Grove connectors (I2C and UART)    Software Compatibility  Debian  Android  Ubuntu  Cloud9 IDE on Node.js w/ BoneScript library  plus much more", 
            "title": "Features"
        }, 
        {
            "location": "/BeagleBone_Green/#specification", 
            "text": "Item  Value      Processor  AM335x 1GHz ARMR Cortex-A8    RAM  512MB DDR3    on-board Flash Storage  4GB eMMC    CPU Supports  NEON floating-point   3D graphics accelerator    Micro USB  Supports  powering   communications    USB  Host  1    Grove Connectors  2 (One I2C and One UART)    GPIO  2 x 46 pin headers    Ethernet  1    Operating Temperature  0 ~ 75", 
            "title": "Specification"
        }, 
        {
            "location": "/BeagleBone_Green/#application-ideas", 
            "text": "Internet of Things  Smart House  Industrial  Automation   Process Control  Human Machine Interface  Sensor Hub  Robot   Here are some funny projects for your reference.     Home Center  Retro Lamp  Drive a Motor           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!        BBG Acrylic Case  GPIO Control  Smart Light           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/BeagleBone_Green/#hardware-overview", 
            "text": "USB Host  - USB Host  DC Power and USB Client  - Power the board and act as client  LEDs  D2  is configured at boot to blink in a heartbeat pattern  D3  is configured at boot to light during microSD card accesses  D4  is configured at boot to light during CPU activity  D5  is configured at boot to light during eMMC accesses    Boot button  When there s a SD card insert, the system will boot from SD card first, if you want to boot from eMMC, press this button and then power on.   Use as a normal button after boot, connect to  GPIO_72    I2C Grove Interface  - Connected to  I2C2  Uart Grove Interface  - Connected to  UART2  Serial Debug  - Connect to  UART0 , PIN1~PIN6: GND, NC, NC, RX, TX, NC, note that pin1 is near to the USB.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/BeagleBone_Green/#pin-map", 
            "text": "Each digital I/O pin has 8 different modes that can be selected, including GPIO.", 
            "title": "Pin map"
        }, 
        {
            "location": "/BeagleBone_Green/#65-possible-digital-ios", 
            "text": "Note  In GPIO mode, each digital I/O can produce interrupts.", 
            "title": "65 Possible Digital I/Os"
        }, 
        {
            "location": "/BeagleBone_Green/#pwms-and-timers", 
            "text": "Note  Up to 8 digital I/O pins can be configured with pulse-width modulators (PWM) to produce signals to control motors or create pseudo analog voltage levels, without taking up any extra CPU cycles.", 
            "title": "PWMs and Timers"
        }, 
        {
            "location": "/BeagleBone_Green/#analog-inputs", 
            "text": "Note  Make sure you don t input more than 1.8V to the analog input pins. This is a single 12-bit analog-to-digital converter with 8 channels, 7 of which are made available on the headers.", 
            "title": "Analog Inputs"
        }, 
        {
            "location": "/BeagleBone_Green/#uart", 
            "text": "Note  There is a dedicated header for getting to the UART0 pins and connecting a debug cable. Five additional serial ports are brought to the expansion headers, but one of them only has a single direction brought to the headers.", 
            "title": "UART"
        }, 
        {
            "location": "/BeagleBone_Green/#i2c", 
            "text": "Note  The first I2C bus is utilized for reading EEPROMS on cape add-on boards and can t be used for other digital I/O operations without interfering with that function, but you can still use it to add other I2C devices at available addresses. The second I2C bus is available for you to configure and use.", 
            "title": "I2C"
        }, 
        {
            "location": "/BeagleBone_Green/#spi", 
            "text": "Note  For shifting out data fast, you might consider using one of the SPI ports.", 
            "title": "SPI"
        }, 
        {
            "location": "/BeagleBone_Green/#getting-started", 
            "text": "Note  This chapter is writing under Win10. The steps are familiar for the other operate systems.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/BeagleBone_Green/#step1-plug-in-your-bbg-via-usb", 
            "text": "Use the provided micro USB cable to plug your BBG into your computer. This will both power the board and provide a development interface. BBG will boot Linux from the on-board 2GB or 4GB eMMC.   BBG will operate as a flash drive providing you with a local copy of the documentation and drivers. Note that this interface may not be used to re-configure the microSD card with a new image, but may be used to update the boot parameters using the uEnv.txt file.  You ll see the PWR LED lit steadily. Within 10 seconds, you should see the other LEDs blinking in their default configurations.   D2 is configured at boot to blink in a heartbeat pattern  D3 is configured at boot to light during microSD card accesses  D4 is configured at boot to light during CPU activity  D5 is configured at boot to light during eMMC accesses", 
            "title": "STEP1. Plug in your BBG via USB"
        }, 
        {
            "location": "/BeagleBone_Green/#step2-install-drivers", 
            "text": "Install the drivers for your operating system to give you network-over-USB access to your Beagle. Additional drivers give you serial access to your board.     Operating System  USB Drivers  Comments      Windows (64-bit)  64-bit installer     Windows (32-bit)  32-bit installer     Mac OS X  Network   Serial  Install both sets of drivers.    Linux  mkudevrule.sh  Driver installation isn t required, but you might find a few udev rules helpful.      Note  For window system, please note that:   Windows Driver Certification warning may pop up two or three times. Click  Ignore ,  Install  or  Run  To check if you re running 32 or 64-bit Windows see  this .  On systems without the latest service release, you may get an error (0xc000007b). In that case, please  install  and retry:   You may need to reboot Windows.  These drivers have been tested to work up to Windows 10     Note  Additional FTDI USB to serial/JTAG information and drivers are available from  https://www.ftdichip.com/Drivers/VCP.htm .    Note  Additional USB to virtual Ethernet information and drivers are available from  https://www.linux-usb.org/gadget/  and  https://joshuawise.com/horndis .", 
            "title": "STEP2. Install Drivers"
        }, 
        {
            "location": "/BeagleBone_Green/#step3-browse-to-your-beagle", 
            "text": "Using either Chrome or Firefox (Internet Explorer will NOT work), browse to the web server running on your board. It will load a presentation showing you the capabilities of the board. Use the arrow keys on your keyboard to navigate the presentation.  Click  http://192.168.7.2  to launch to your BBG.\nOlder software images require you to EJECT the BEAGLE_BONE drive to start the network. With the latest software image, that step is no longer required.", 
            "title": "STEP3. Browse to your Beagle"
        }, 
        {
            "location": "/BeagleBone_Green/#step4-cloud9-ide", 
            "text": "To begin editing programs that live on your board, you can use the Cloud9 IDE by click", 
            "title": "STEP4. Cloud9 IDE"
        }, 
        {
            "location": "/BeagleBone_Green/#update-to-latest-software", 
            "text": "You need to update the board to latest software to keep a better performance, here we will show you how to make it step by step.", 
            "title": "Update to latest software"
        }, 
        {
            "location": "/BeagleBone_Green/#step1-download-the-latest-software-image", 
            "text": "First of all, you have to download the suitable image here.     Note  Due to sizing necessities, this download may take about 30 minutes or more.    The file you download will have an  .img.xz  extension. This is a compressed sector-by-sector image of the SD card.", 
            "title": "STEP1. Download the latest software image"
        }, 
        {
            "location": "/BeagleBone_Green/#step2-install-compression-utility-and-decompress-the-image", 
            "text": "Download and install  7-zip.     Note  Choose a version that suitable for your system.   Use 7-zip to decompress the SD card  .img file", 
            "title": "STEP2. Install compression utility and decompress the image"
        }, 
        {
            "location": "/BeagleBone_Green/#step3-install-sd-card-programming-utility", 
            "text": "Download and install  Image Writer for Windows . Be sure to download the binary distribution.", 
            "title": "STEP3. Install SD card programming utility"
        }, 
        {
            "location": "/BeagleBone_Green/#step4-write-the-image-to-your-sd-card", 
            "text": "You need a SD adapter to connect your microSD card to your computer at the first. Then use the software Image Write for Windows to write the decompressed image to your SD card.   Click on  Write  button, then the process is started.     Note   You may see a warning about damaging your device. This is fine to accept as long as you are pointing to your SD card for writing.  You should not have your BeagleBone connected to your computer at this time.  This process may need up to 10 minutes.", 
            "title": "STEP4. Write the image to your SD card"
        }, 
        {
            "location": "/BeagleBone_Green/#step5-boot-your-board-off-of-the-sd-card", 
            "text": "Insert SD card into your (powered-down first) board. Then the board will boot from the SD card.   Note  If you don t need to write the image to your on-board eMMC, you don t need to read the last of this chapter.  Otherwise pleas go ahead.   If you desire to write the image to your on-board eMMC, you need to launch to the board, and modify a file.   In  /boot/uEnv.txt :  ##enable BBB: eMMC Flasher:\n#cmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh  Change to:  ##enable BBB: eMMC Flasher:\ncmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh  Then you will find the 4 user led light as below    Note  If you don t find the upper tracing light, please press the RESET button to reset the board.    When the flashing is complete, all 4 USRx LEDs will be  off . The latest Debian flasher images automatically power down the board upon completion. This can take up to  10 minutes . Power-down your board, remove the SD card and apply power again to be complete.", 
            "title": "STEP5. Boot your board off of the SD card"
        }, 
        {
            "location": "/BeagleBone_Green/#grove-for-bbg", 
            "text": "Grove is a modular, standardized connecter prototyping system. Grove takes a building block approach to assembling electronics. Compared to the jumper or solder based system, it is easier to connect, experiment and build and simplifies the learning system, but not to the point where it becomes dumbed down.  Some of the other prototype systems out there takes the level down to building blocks.   Good stuff to be learned that way, but the Grove system allows you to build real systems.   It requires some learning and expertise to hook things up.  Below listed the Grove modules that work well with BBG.     SKU  Name  Interface  link      101020054  Grove - 3-Axis Digital Accelerometer(+16g)  I2C  link    101020071  Grove - 3-Axis Digital Accelerometer(+400g)  I2C  link    101020034  Grove - 3-Axis Digital Compass  I2C  link    101020050  Grove - 3-Axis Digital Gyro  Analog  link    101020081  Grove - 6-Axis Accelerometer Compass v2.0  I2C  link    101020072  Grove - Barometer Sensor(BMP180)  I2C  link    104030010  Grove - Blue LED  I/O  link    101020003  Grove - Button  I/O  link    111020000  Grove - Button(P)  I/O  link    107020000  Grove - Buzzer  I/O  link    104030006  Grove - Chainable RGB LED  I2C  link    101020030  Grove - Digital Light Sensor  I2C  link    103020024  Grove - Finger-clip Heart Rate Sensor  I2C  link    101020082  Grove - Finger-clip Heart Rate Sensor with shell  I2C  link    113020003  Grove - GPS  UART  link    104030007  Grove - Green LED  I/O  link    103020013  Grove - I2C ADC  I2C  link    103020006  Grove - I2C Hub  I2C  link    101020079  Grove - IMU 10DOF  I2C  link    101020080  Grove - IMU 9DOF v2.0  I2C  link    101020040  Grove - IR Distance Interrupter  I/O  link    104030011  Grove - OLED Display 0.96  I2C  link    104030008  Grove - OLED Display 1.12  I2C  link    104030005  Grove - Red LED  I/O  link    103020005  Grove - Relay  I/O  link    316010005  Grove - Servo  I/O  link    101020023  Grove - Sound Sensor  Analog  link    101020004  Grove - Switch(P)  I/O  link    101020015  Grove - Temperature Sensor  Analog  link    101020019  Grove - Temperature Humidity Sensor Pro  Analog  link", 
            "title": "Grove for BBG"
        }, 
        {
            "location": "/BeagleBone_Green/#cape-for-bbg", 
            "text": "You will need some expansion board when you start a project. There re many cape for BBG already, they include LCD display, motor driver as well as HDMI expansion etc. Below is some of them recommend.     Grove Cape  Motor Bridge Cape  HDMI Cape           GET ONE NOW!  GET ONE NOW!  GET ONE NOW!        Grove Cape  5 Inch LCD  7 Inch LCD           GET ONE NOW!  GET ONE NOW!  GET ONE NOW!", 
            "title": "Cape for BBG"
        }, 
        {
            "location": "/BeagleBone_Green/#references-and-resources", 
            "text": "", 
            "title": "References and Resources"
        }, 
        {
            "location": "/BeagleBone_Green/#references", 
            "text": "There re many references to help you to get more information about the board.    BeagleBoard Main Page  BeagleBone Green info at BeagleBoard page  BeagleBoard Getting Started  Troubleshooting  Hardware documentation  Projects of BeagleBoard", 
            "title": "References"
        }, 
        {
            "location": "/BeagleBone_Green/#resources", 
            "text": "BEAGLEBONE_GREEN SRM(v1a)(pdf)  BEAGLEBONE_GREEN Schematic(pdf)  BEAGLEBONE_GREEN Schematic(OrCAD)  BEAGLEBONE_GREEN PCB(OrCAD)", 
            "title": "Resources"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/", 
            "text": "BeagleBone Green HDMI Cape\n is a general integrated HDMI connector for expanding your BeagleBone to a rich variety of peripherals such as computer monitor, video projector, digital television, or digital audio device. This board features a standard HDMI receptacle that can be connected to a monitor with a standard HDMI-to-HDMI cable. All HD signals are supported, and the output resolution is 1280\u00d7720. It also can be used to transmit audio information. This product will make your applications based on BeagleBone board more versatile for different circumstances.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nPlug and play.\n\n\nAdapter to different input signal.\n\n\n720P(1280\u00d7720) output resolution.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nInput voltage\n\n\n5V/3.3V\n\n\n\n\n\n\nMaxium operating current\n\n\n80 mA\n\n\n\n\n\n\nHDMI version\n\n\nVersion 1.2\n\n\n\n\n\n\nMaxium Output resolution\n\n\n1280x720 @60Hz\n\n\n\n\n\n\nAudio transmission\n\n\nAvailable\n\n\n\n\n\n\nChip\n\n\nIT66121 HDMI Framer(\nDatasheet\n)\n\n\n\n\n\n\n\n\nPlatforms supported\n\uf0c1\n\n\n\n\n\n\n\n\nPlatoform\n\n\nSupport\n\n\n\n\n\n\n\n\n\n\nPlatform\n\n\nSupported status\n\n\n\n\n\n\nBeagleBone\n\n\nSupported\n\n\n\n\n\n\n\n\nApplication ideas\n\uf0c1\n\n\nYou can expand your BeagleBone to more multimedia peripherals such computer monitor, video projector, digital television, or digital audio device.\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nIT66121 HDMI Framer\n\n\n\n\nHDMI Transmitter\n\n\n\n\nCape I2C address Switch\n\n\n\n\nTo switch between different cape address identifier.\n\n\n\n\nCape EEPROM\n\n\n\n\nEEPROM memory for this cape.\n\n\n\n\nHDMI Connector\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\nBeagleBone Green HDMI Cape\n\n\n1\n\n\n\n\n\n\n\n\nGet started\n\uf0c1\n\n\nThis part will show you how to start with this product in a few steps.\n\n\nPreparations\n\uf0c1\n\n\n\n\nBeagleBone Green board(with OS \nInstalled first\n) \u00d7 1.\n\n\nUSB cable (type A to micro type B) \u00d7 1.\n\n\nStandard HDMI cable(type A to type A) \u00d7 1.\n\n\n\n\nHardware Connection\n\uf0c1\n\n\n\n\n\n\nNote\n\nWe use Windows 7 in this case. After connection work is done, plug a computer mouse into USB interface on BeagleBone Green board.\n\n\n\n\nPlug USB cable(type C end) to your PC, you will find that a BeagleBone desktop is shown on your computer monitor.\n\n\nThen you can use BeagleBone like a PC or a Mac.\n\n\n\n\nTrouble shooting\n\uf0c1\n\n\n\n\n\n\nNo BeagleBone desktop operation system is shown on the computer monitor? Try one of following steps.\n\n\n\n\nPower down the monitor and restart it.\n\n\nPress RESET button on BeagleBone Green board.\n\n\nPress POWER button on BeagleBone Green board and then press it again.\n\n\n\n\n\n\n\n\n\n\nThe computer mouse does not work(not powered)?\n\n\n\n\nPress RESET button on BeagleBone Green board and wait it to launch.\n\n\n\n\n\n\n\n\nHow disassemble BeagleBone Green HDMI Cape quickly?\n\n\n\n\nPull(with your hand) the end with HDMI receptacle out first, then pull the other end out. Repeat previous two steps again if it is necessary.\n\n\n\n\n\n\n\n\nDemo\n\uf0c1\n\n\nThis \nvideo\n shows how to use BeagleBone Green HDMI Cape to surfing Internet and play audio.\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic files", 
            "title": "BeagleBone Green HDMI Cape"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#features", 
            "text": "Plug and play.  Adapter to different input signal.  720P(1280\u00d7720) output resolution.", 
            "title": "Features"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#specifications", 
            "text": "Parameter  Value      Input voltage  5V/3.3V    Maxium operating current  80 mA    HDMI version  Version 1.2    Maxium Output resolution  1280x720 @60Hz    Audio transmission  Available    Chip  IT66121 HDMI Framer( Datasheet )", 
            "title": "Specifications"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#platforms-supported", 
            "text": "Platoform  Support      Platform  Supported status    BeagleBone  Supported", 
            "title": "Platforms supported"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#application-ideas", 
            "text": "You can expand your BeagleBone to more multimedia peripherals such computer monitor, video projector, digital television, or digital audio device.", 
            "title": "Application ideas"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#hardware-overview", 
            "text": "IT66121 HDMI Framer   HDMI Transmitter   Cape I2C address Switch   To switch between different cape address identifier.   Cape EEPROM   EEPROM memory for this cape.   HDMI Connector", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#parts-list", 
            "text": "Parts name  Quantity    BeagleBone Green HDMI Cape  1", 
            "title": "Parts list"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#get-started", 
            "text": "This part will show you how to start with this product in a few steps.", 
            "title": "Get started"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#preparations", 
            "text": "BeagleBone Green board(with OS  Installed first ) \u00d7 1.  USB cable (type A to micro type B) \u00d7 1.  Standard HDMI cable(type A to type A) \u00d7 1.", 
            "title": "Preparations"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#hardware-connection", 
            "text": "Note \nWe use Windows 7 in this case. After connection work is done, plug a computer mouse into USB interface on BeagleBone Green board.  Plug USB cable(type C end) to your PC, you will find that a BeagleBone desktop is shown on your computer monitor.  Then you can use BeagleBone like a PC or a Mac.", 
            "title": "Hardware Connection"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#trouble-shooting", 
            "text": "No BeagleBone desktop operation system is shown on the computer monitor? Try one of following steps.   Power down the monitor and restart it.  Press RESET button on BeagleBone Green board.  Press POWER button on BeagleBone Green board and then press it again.      The computer mouse does not work(not powered)?   Press RESET button on BeagleBone Green board and wait it to launch.     How disassemble BeagleBone Green HDMI Cape quickly?   Pull(with your hand) the end with HDMI receptacle out first, then pull the other end out. Repeat previous two steps again if it is necessary.", 
            "title": "Trouble shooting"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#demo", 
            "text": "This  video  shows how to use BeagleBone Green HDMI Cape to surfing Internet and play audio.", 
            "title": "Demo"
        }, 
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#resources", 
            "text": "Schematic files", 
            "title": "Resources"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/", 
            "text": "SeeedStudio BeagleBone Green Wireless (BBGW) is a joint effort by \nBeagleBoard.org\n and Seeed Studio. It is based on the open-source hardware design of\u00a0\nBeagleBone Black\n\u00a0and developed into this differentiated version. SeeedStudio BeagleBone Green Wireless has included a high-performance flexible WiFi/Bluetooth interface and two Grove connectors, making it easier to connect to the large family of Grove sensors. The on-board HDMI and Ethernet are removed to make room for these wireless features and Grove connectors.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nFully Compatiable with BeagleBone Black\n\n\n\n\nProcessor:\u00a0AM335x 1GHz ARM\u00ae Cortex-A8\n\n\n\n\n512MB DDR3 RAM\n\n\n4GB 8-bit eMMC on-board flash storage\n\n\n3D graphics accelerator\n\n\nNEON floating-point accelerator\n\n\n2x PRU 32-bit microcontrollers\n\n\n\n\n\n\n\n\nConnectivity\n\n\n\n\nUSB client for power \n communications\n\n\nUSB host with 4-port hub\n\n\nWiFi 802.11 b/g/n 2.4GHz\n\n\nBluetooth 4.1 with BLE\n\n\n2x 46 pin headers\n\n\n2x Grove connectors (I2C and UART)\n\n\n\n\n\n\n\n\nSoftware Compatibility\n\n\n\n\nDebian\n\n\nAndroid\n\n\nUbuntu\n\n\nCloud9 IDE on Node.js w/ BoneScript library\n\n\nplus much more\n\n\n\n\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nProcessor\n\n\nAM335x 1GHz ARMR Cortex-A8\n\n\n\n\n\n\nRAM\n\n\n512MB DDR3\n\n\n\n\n\n\non-board Flash Storage\n\n\n4GB eMMC\n\n\n\n\n\n\nCPU Supports\n\n\nNEON floating-point \n 3D graphics accelerator\n\n\n\n\n\n\nMicro USB  Supports\n\n\npowering \n communications\n\n\n\n\n\n\nUSB\n\n\nUSB2.0 Host   *4\n\n\n\n\n\n\nGrove Connectors\n\n\n2 (One I2C and One UART)\n\n\n\n\n\n\nGPIO\n\n\n2 x 46 pin headers\n\n\n\n\n\n\nEthernet\n\n\nWi-Fi 802.11b/g/n 2.4GHz and Bluetooth 4.1 LE\n\n\n\n\n\n\nOperating Temperature\n\n\n0 ~ 75\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nInternet of Things\n\n\nSmart House\n\n\nIndustrial\n\n\nAutomation \n Process Control\n\n\nHuman Machine Interface\n\n\nSensor Hub\n\n\nRobot\n\n\n\n\nBBGW Starter Tutorial #1-#6\n\uf0c1\n\n\nHere are some tutorials for the starters to use some Grove modules to realize their interesting ideas with BeagleBone Green Wireless(BBGW). The tutorials are based on Python and mraa/upm library.  \n\n\n\n\n\n\n\n\n#1 The Breath LED\n\n\n#2 Storm on your table\n\n\n#3 Speak Louuuuuudly\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#4 How hot is it today?\n\n\n#5 Where are you?\n\n\n#6 My Little alarm clock\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\nFunny Projects\n\uf0c1\n\n\n\n\n\n\n\n\nBluetooth Device Detection\n\n\nHome Control Center\n\n\nSAP HCP IoT Service\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nPin map\n\uf0c1\n\n\nEach digital I/O pin has 8 different modes that can be selected, including GPIO.\n\n\n65 Possible Digital I/Os\n\uf0c1\n\n\n\n\nNote\n\n\nIn GPIO mode, each digital I/O can produce interrupts.\n\n\n\n\n\n\nPWMs and Timers\n\uf0c1\n\n\n\n\nNote\n\n\nUp to 8 digital I/O pins can be configured with pulse-width modulators (PWM) to produce signals to control motors or create pseudo analog voltage levels, without taking up any extra CPU cycles.\n\n\n\n\n\n\nAnalog Inputs\n\uf0c1\n\n\n\n\nNote\n\n\nMake sure you don\nt input more than 1.8V to the analog input pins. This is a single 12-bit analog-to-digital converter with 8 channels, 7 of which are made available on the headers.\n\n\n\n\n\n\nUART\n\uf0c1\n\n\n\n\nNote\n\n\nThere is a dedicated header for getting to the UART0 pins and connecting a debug cable. Five additional serial ports are brought to the expansion headers, but one of them only has a single direction brought to the headers.\n\n\n\n\n\n\nI2C\n\uf0c1\n\n\n\n\nNote\n\n\nThe first I2C bus is utilized for reading EEPROMS on cape add-on boards and can\nt be used for other digital I/O operations without interfering with that function, but you can still use it to add other I2C devices at available addresses. The second I2C bus is available for you to configure and use.\n\n\n\n\n\n\nSPI\n\uf0c1\n\n\n\n\nNote\n\n\nFor shifting out data fast, you might consider using one of the SPI ports.\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\n\n\nNote\n\n\nThis chapter is writing under Win10. The steps are familiar for the other operate systems.\n\n\n\n\nSTEP1. Plug in your BBGW via USB\n\uf0c1\n\n\nUse the provided micro USB cable to plug your BBGW into your computer. This will both power the board and provide a development interface. BBGW will boot Linux from the \non-board 2GB\n or 4GB eMMC.\n\n\nBBGW will operate as a flash drive providing you with a local copy of the documentation and drivers. Note that this interface may not be used to re-configure the microSD card with a new image, but may be used to update the boot parameters using the uEnv.txt file.\n\n\nYou\u2019ll see the PWR LED lit steadily. Within 10 seconds, you should see the other LEDs blinking in their default configurations.\n\n\n\n\nD2 is configured at boot to blink in a heartbeat pattern\n\n\nD3 is configured at boot to light during microSD card accesses\n\n\nD4 is configured at boot to light during CPU activity\n\n\nD5 is configured at boot to light during eMMC accesses\n\n\n\n\nSTEP2. Install Drivers\n\uf0c1\n\n\nInstall the drivers for your operating system to give you network-over-USB access to your Beagle. Additional drivers give you serial access to your board.\n\n\n\n\n\n\n\n\nOperating System\n\n\nUSB Drivers\n\n\nComments\n\n\n\n\n\n\n\n\n\n\nWindows (64-bit)\n\n\n64-bit installer\n\n\n\n\n\n\n\n\nWindows (32-bit)\n\n\n32-bit installer\n\n\n\n\n\n\n\n\nMac OS X\n\n\nNetwork\n \nSerial\n\n\nInstall both sets of drivers.\n\n\n\n\n\n\nLinux\n\n\nmkudevrule.sh\n\n\nDriver installation isn\nt required, but you might find a few udev rules helpful.\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nFor window system, please note that:\n\n\n\n\nWindows Driver Certification warning may pop up two or three times. Click \nIgnore\n, \nInstall\n or \nRun\n\n\nTo check if you\nre running 32 or 64-bit Windows see \nthis\n.\n\n\nOn systems without the latest service release, you may get an error (0xc000007b). In that case, please \ninstall\n and retry: \n\n\nYou may need to reboot Windows.\n\n\nThese drivers have been tested to work up to Windows 10\n\n\n\n\n\n\n\n\nNote\n\n\nAdditional FTDI USB to serial/JTAG information and drivers are available from \nhttps://www.ftdichip.com/Drivers/VCP.htm\n.\n\n\n\n\n\n\nNote\n\n\nAdditional USB to virtual Ethernet information and drivers are available from \nhttps://www.linux-usb.org/gadget/\n and \nhttps://joshuawise.com/horndis\n.\n\n\n\n\nSTEP3. Browse to your Beagle\n\uf0c1\n\n\nUsing either Chrome or Firefox (Internet Explorer will NOT work), browse to the web server running on your board. It will load a presentation showing you the capabilities of the board. Use the arrow keys on your keyboard to navigate the presentation.\n\n\nClick \nhttp://192.168.7.2\n to launch to your BBGW.\nOlder software images require you to EJECT the BEAGLE_BONE drive to start the network. With the latest software image, that step is no longer required.\n\n\n\n\nSTEP4. Cloud9 IDE\n\uf0c1\n\n\nTo begin editing programs that live on your board, you can use the Cloud9 IDE by click\n\n\n\n\nSTEP5. Connect your BBGW to Wi-Fi\n\uf0c1\n\n\nUsing your smart phone or computer to scan local Wi-Fi network and connect to the AP named \nBeagleBone XXX\n\n\n\n\nAfter connection success, it will head to the login page automatically. Select the SSID of your Wi-Fi and enter the passwd, click OK.\n\n\n\n\nNow your BBGW is connected to Wi-Fi.\n\n\n\n\nSTEP6. Connect your BBGW to your Bluetooth Device\n\uf0c1\n\n\nConnect to Cloud9 IDE and start a new terminal.\nStart the bluetooth config with the command: \n\n\nbb-wl18x-bluetooth\nbluetoothctl\n\n\n\n\n\n\nType \nscan on\n to scan local bluetooth devices. My device named \njy\n is found. \n\n\n\n\nCopy the device mac address, then contect to the device  with the command:\n\n\npair 0C:xx:xx:xx:xx:0B\ntrust 0C:xx:xx:xx:xx:0B\nconnect 0C:xx:xx:xx:xx:0B\n\n\n\n\n\n\nNow your BBGW is connected to your bluetooth device. Type \nquit\n back to the terminal.\nPlay music on BBGW, then you will hear music on your bluetooth speaker device.\n\n\nUpdate to latest software\n\uf0c1\n\n\n\n\nYou need to update the board to latest software to keep a better performance, here we will show you how to make it step by step. \n\n\nSTEP1. Download the latest software image\n\uf0c1\n\n\nFirst of all, you have to download the suitable image here. \n\n\n\n\n\n\nNote\n\n\nDue to sizing necessities, this download may take about 30 minutes or more. \n\n\n\n\nThe file you download will have an \n.img.xz\n extension. This is a compressed sector-by-sector image of the SD card. \n\n\nSTEP2. Install compression utility and decompress the image\n\uf0c1\n\n\nDownload and install \n7-zip.\n \n\n\n\n\nNote\n\n\nChoose a version that suitable for your system.\n\n\n\n\nUse 7-zip to decompress the SD card \n.img file\n\n\nSTEP3. Install SD card programming utility\n\uf0c1\n\n\nDownload and install \nImage Writer for Windows\n. Be sure to download the binary distribution.\n\n\nSTEP4. Write the image to your SD card\n\uf0c1\n\n\nYou need a SD adapter to connect your microSD card to your computer at the first. Then use the software Image Write for Windows to write the decompressed image to your SD card.\n\n\n\n\nClick on \nWrite\n button, then the process is started. \n\n\n\n\n\n\nNote\n\n\n\n\nYou may see a warning about damaging your device. This is fine to accept as long as you are pointing to your SD card for writing.\n\n\nYou should not have your BeagleBone connected to your computer at this time.\n\n\nThis process may need up to 10 minutes.\n\n\n\n\n\n\nSTEP5. Boot your board off of the SD card\n\uf0c1\n\n\nInsert SD card into your (powered-down first) board. Then the board will boot from the SD card.\n\n\n\n\nNote\n\n\nIf you don\nt need to write the image to your on-board eMMC, you don\nt need to read the last of this chapter.  Otherwise pleas go ahead.\n\n\n\n\nIf you desire to write the image to your on-board eMMC, you need to launch to the board, and modify a file. \n\n\nIn \n/boot/uEnv.txt\n:\n\n\n##enable BBB: eMMC Flasher:\n#cmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh\n\n\n\nChange to:\n\n\n##enable BBB: eMMC Flasher:\ncmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh\n\n\n\nThen you will find the 4 user led light as below\n\n\n\n\n\n\nNote\n\n\nIf you don\nt find the upper tracing light, please press the RESET button to reset the board. \n\n\n\n\nWhen the flashing is complete, all 4 USRx LEDs will be \noff\n. The latest Debian flasher images automatically power down the board upon completion. This can take up to \n10 minutes\n. Power-down your board, remove the SD card and apply power again to be complete.\n\n\nProgram Grove Module with Mraa and UPM\n\uf0c1\n\n\nWe have provided Mraa library and UPM library to make it easy for developers and sensor manufacturers to map their sensors \n actuators on top of supported hardware and to allow control of low level communication protocol by high level languages \n constructs.\n\n\nWhat are Mraa and UPM?\n\uf0c1\n\n\nMraa is a C/C++ library with bindings to Python, Javascript and Java to interface with the I/O on BBG, BBGW and other platforms, with a structured and sane API where port names/numbering matches the board that you are on. Use of Mraa does not tie you to specific hardware with board detection done at runtime you can create portable code that will work across the supported platforms.\nUPM is a high level repository for sensors that use MRAA. Each sensor links to MRAA and are not meant to be interlinked although some groups of sensors may be. Each sensor contains a header which allows to interface with it. Typically a sensor is represented as a class and instantiated.The constructor is expected to initialise the sensor and parameters may be used to provide identification/pin location on the board.\n\n\nInstall and update\n\uf0c1\n\n\nMraa\u00a0and UPM are\u00a0already installed in the system image of BBGW, so \nyou don\nt need to install it.\n However if you want to update the library, or want to upgrade the library, use\u00a0\napt-get update\n\u00a0and \napt-get upgrade\n\u00a0please. Refer to \nhttps://github.com/intel-iot-devkit/mraa\n\u00a0and \nhttps://github.com/intel-iot-devkit/upm\n\u00a0for more information.\n\n\nMraa Example\n\uf0c1\n\n\n\n\nlight a led\n\n\n\n\nimport mraa\nimport time\n#mraa.gpio60 = P9_14 = GPIO_50\nled = mraa.Gpio(60)\nled.dir(mraa.DIR_OUT)\n\nwhile True:\n    led.write(1)\n    time.sleep(1)\n    led.write(0)\n    time.sleep(1)\n\n\n\n\n\n\n\nGrove - PIR Sensor\n\n\n\n\nimport mraa\nimport time\n#mraa.gpio73 = P9_27 = GPIO_115\npir = mraa.Gpio(73)\npir.dir(mraa.DIR_IN)\n\nwhile True:\n    print (pir.read())\n    time.sleep(1)\n\n\n\n\n\n\nGrove - Rotary Angle Sensor\n\n\n\n\nimport mraa\nimport time\n#mraa.aio1 = AIN0\nrotary = mraa.Aio(1)\n\nwhile True:\n    print(rotary.read())\n    time.sleep(1)\n\n\n\n\n\n\nMore Tutorials\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b116g)\n Grove - Variable Color LED\n\n\nGrove - Mini Fan\nGrove - PIR Motion Sensor\nGrove - Rotary Angle Sensor\n\n\n\nGrove - Relay\nGrove - Sound Sensor\n\n\n\nGrove - OLED Display 0.96\u201d\nGrove - Light Sensor \nGrove - Temperature Sensor\n\n\n\nGrove - GPS\nGrove - Button(P)\nGrove - Buzzer\nGrove - RTC v2.0\n\n\n\nMraa Map for BBGW\n\uf0c1\n\n\n\n\n\n\n\n\n\n\n\n\nReferences and Resources\n\uf0c1\n\n\nReferences\n\uf0c1\n\n\n\n\nThere\nre many references to help you to get more information about the board. \n\n\n\n\nBeagleBoard Main Page\n\n\nBeagleBone Green Wireless info at BeagleBoard page\n\n\nBeagleBoard Getting Started\n\n\nTroubleshooting\n\n\nHardware documentation\n\n\nProjects of BeagleBoard\n\n\n\n\nResources\n\uf0c1\n\n\n\n\n\n\nBeagleBone_Green_Wireless Schematic(pdf)", 
            "title": "SeeedStudio BeagleBone Green Wireless"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#features", 
            "text": "Fully Compatiable with BeagleBone Black   Processor:\u00a0AM335x 1GHz ARM\u00ae Cortex-A8   512MB DDR3 RAM  4GB 8-bit eMMC on-board flash storage  3D graphics accelerator  NEON floating-point accelerator  2x PRU 32-bit microcontrollers     Connectivity   USB client for power   communications  USB host with 4-port hub  WiFi 802.11 b/g/n 2.4GHz  Bluetooth 4.1 with BLE  2x 46 pin headers  2x Grove connectors (I2C and UART)     Software Compatibility   Debian  Android  Ubuntu  Cloud9 IDE on Node.js w/ BoneScript library  plus much more", 
            "title": "Features"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#specification", 
            "text": "Item  Value      Processor  AM335x 1GHz ARMR Cortex-A8    RAM  512MB DDR3    on-board Flash Storage  4GB eMMC    CPU Supports  NEON floating-point   3D graphics accelerator    Micro USB  Supports  powering   communications    USB  USB2.0 Host   *4    Grove Connectors  2 (One I2C and One UART)    GPIO  2 x 46 pin headers    Ethernet  Wi-Fi 802.11b/g/n 2.4GHz and Bluetooth 4.1 LE    Operating Temperature  0 ~ 75", 
            "title": "Specification"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#application-ideas", 
            "text": "Internet of Things  Smart House  Industrial  Automation   Process Control  Human Machine Interface  Sensor Hub  Robot", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#bbgw-starter-tutorial-1-6", 
            "text": "Here are some tutorials for the starters to use some Grove modules to realize their interesting ideas with BeagleBone Green Wireless(BBGW). The tutorials are based on Python and mraa/upm library.       #1 The Breath LED  #2 Storm on your table  #3 Speak Louuuuuudly           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!        #4 How hot is it today?  #5 Where are you?  #6 My Little alarm clock           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!", 
            "title": "BBGW Starter Tutorial #1-#6"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#funny-projects", 
            "text": "Bluetooth Device Detection  Home Control Center  SAP HCP IoT Service           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!", 
            "title": "Funny Projects"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#pin-map", 
            "text": "Each digital I/O pin has 8 different modes that can be selected, including GPIO.", 
            "title": "Pin map"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#65-possible-digital-ios", 
            "text": "Note  In GPIO mode, each digital I/O can produce interrupts.", 
            "title": "65 Possible Digital I/Os"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#pwms-and-timers", 
            "text": "Note  Up to 8 digital I/O pins can be configured with pulse-width modulators (PWM) to produce signals to control motors or create pseudo analog voltage levels, without taking up any extra CPU cycles.", 
            "title": "PWMs and Timers"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#analog-inputs", 
            "text": "Note  Make sure you don t input more than 1.8V to the analog input pins. This is a single 12-bit analog-to-digital converter with 8 channels, 7 of which are made available on the headers.", 
            "title": "Analog Inputs"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#uart", 
            "text": "Note  There is a dedicated header for getting to the UART0 pins and connecting a debug cable. Five additional serial ports are brought to the expansion headers, but one of them only has a single direction brought to the headers.", 
            "title": "UART"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#i2c", 
            "text": "Note  The first I2C bus is utilized for reading EEPROMS on cape add-on boards and can t be used for other digital I/O operations without interfering with that function, but you can still use it to add other I2C devices at available addresses. The second I2C bus is available for you to configure and use.", 
            "title": "I2C"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#spi", 
            "text": "Note  For shifting out data fast, you might consider using one of the SPI ports.", 
            "title": "SPI"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#getting-started", 
            "text": "Note  This chapter is writing under Win10. The steps are familiar for the other operate systems.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step1-plug-in-your-bbgw-via-usb", 
            "text": "Use the provided micro USB cable to plug your BBGW into your computer. This will both power the board and provide a development interface. BBGW will boot Linux from the  on-board 2GB  or 4GB eMMC.  BBGW will operate as a flash drive providing you with a local copy of the documentation and drivers. Note that this interface may not be used to re-configure the microSD card with a new image, but may be used to update the boot parameters using the uEnv.txt file.  You\u2019ll see the PWR LED lit steadily. Within 10 seconds, you should see the other LEDs blinking in their default configurations.   D2 is configured at boot to blink in a heartbeat pattern  D3 is configured at boot to light during microSD card accesses  D4 is configured at boot to light during CPU activity  D5 is configured at boot to light during eMMC accesses", 
            "title": "STEP1. Plug in your BBGW via USB"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step2-install-drivers", 
            "text": "Install the drivers for your operating system to give you network-over-USB access to your Beagle. Additional drivers give you serial access to your board.     Operating System  USB Drivers  Comments      Windows (64-bit)  64-bit installer     Windows (32-bit)  32-bit installer     Mac OS X  Network   Serial  Install both sets of drivers.    Linux  mkudevrule.sh  Driver installation isn t required, but you might find a few udev rules helpful.      Note  For window system, please note that:   Windows Driver Certification warning may pop up two or three times. Click  Ignore ,  Install  or  Run  To check if you re running 32 or 64-bit Windows see  this .  On systems without the latest service release, you may get an error (0xc000007b). In that case, please  install  and retry:   You may need to reboot Windows.  These drivers have been tested to work up to Windows 10     Note  Additional FTDI USB to serial/JTAG information and drivers are available from  https://www.ftdichip.com/Drivers/VCP.htm .    Note  Additional USB to virtual Ethernet information and drivers are available from  https://www.linux-usb.org/gadget/  and  https://joshuawise.com/horndis .", 
            "title": "STEP2. Install Drivers"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step3-browse-to-your-beagle", 
            "text": "Using either Chrome or Firefox (Internet Explorer will NOT work), browse to the web server running on your board. It will load a presentation showing you the capabilities of the board. Use the arrow keys on your keyboard to navigate the presentation.  Click  http://192.168.7.2  to launch to your BBGW.\nOlder software images require you to EJECT the BEAGLE_BONE drive to start the network. With the latest software image, that step is no longer required.", 
            "title": "STEP3. Browse to your Beagle"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step4-cloud9-ide", 
            "text": "To begin editing programs that live on your board, you can use the Cloud9 IDE by click", 
            "title": "STEP4. Cloud9 IDE"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step5-connect-your-bbgw-to-wi-fi", 
            "text": "Using your smart phone or computer to scan local Wi-Fi network and connect to the AP named  BeagleBone XXX   After connection success, it will head to the login page automatically. Select the SSID of your Wi-Fi and enter the passwd, click OK.   Now your BBGW is connected to Wi-Fi.", 
            "title": "STEP5. Connect your BBGW to Wi-Fi"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step6-connect-your-bbgw-to-your-bluetooth-device", 
            "text": "Connect to Cloud9 IDE and start a new terminal.\nStart the bluetooth config with the command:   bb-wl18x-bluetooth\nbluetoothctl   Type  scan on  to scan local bluetooth devices. My device named  jy  is found.    Copy the device mac address, then contect to the device  with the command:  pair 0C:xx:xx:xx:xx:0B\ntrust 0C:xx:xx:xx:xx:0B\nconnect 0C:xx:xx:xx:xx:0B   Now your BBGW is connected to your bluetooth device. Type  quit  back to the terminal.\nPlay music on BBGW, then you will hear music on your bluetooth speaker device.", 
            "title": "STEP6. Connect your BBGW to your Bluetooth Device"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#update-to-latest-software", 
            "text": "You need to update the board to latest software to keep a better performance, here we will show you how to make it step by step.", 
            "title": "Update to latest software"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step1-download-the-latest-software-image", 
            "text": "First of all, you have to download the suitable image here.     Note  Due to sizing necessities, this download may take about 30 minutes or more.    The file you download will have an  .img.xz  extension. This is a compressed sector-by-sector image of the SD card.", 
            "title": "STEP1. Download the latest software image"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step2-install-compression-utility-and-decompress-the-image", 
            "text": "Download and install  7-zip.     Note  Choose a version that suitable for your system.   Use 7-zip to decompress the SD card  .img file", 
            "title": "STEP2. Install compression utility and decompress the image"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step3-install-sd-card-programming-utility", 
            "text": "Download and install  Image Writer for Windows . Be sure to download the binary distribution.", 
            "title": "STEP3. Install SD card programming utility"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step4-write-the-image-to-your-sd-card", 
            "text": "You need a SD adapter to connect your microSD card to your computer at the first. Then use the software Image Write for Windows to write the decompressed image to your SD card.   Click on  Write  button, then the process is started.     Note   You may see a warning about damaging your device. This is fine to accept as long as you are pointing to your SD card for writing.  You should not have your BeagleBone connected to your computer at this time.  This process may need up to 10 minutes.", 
            "title": "STEP4. Write the image to your SD card"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#step5-boot-your-board-off-of-the-sd-card", 
            "text": "Insert SD card into your (powered-down first) board. Then the board will boot from the SD card.   Note  If you don t need to write the image to your on-board eMMC, you don t need to read the last of this chapter.  Otherwise pleas go ahead.   If you desire to write the image to your on-board eMMC, you need to launch to the board, and modify a file.   In  /boot/uEnv.txt :  ##enable BBB: eMMC Flasher:\n#cmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh  Change to:  ##enable BBB: eMMC Flasher:\ncmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh  Then you will find the 4 user led light as below    Note  If you don t find the upper tracing light, please press the RESET button to reset the board.    When the flashing is complete, all 4 USRx LEDs will be  off . The latest Debian flasher images automatically power down the board upon completion. This can take up to  10 minutes . Power-down your board, remove the SD card and apply power again to be complete.", 
            "title": "STEP5. Boot your board off of the SD card"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#program-grove-module-with-mraa-and-upm", 
            "text": "We have provided Mraa library and UPM library to make it easy for developers and sensor manufacturers to map their sensors   actuators on top of supported hardware and to allow control of low level communication protocol by high level languages   constructs.", 
            "title": "Program Grove Module with Mraa and UPM"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#what-are-mraa-and-upm", 
            "text": "Mraa is a C/C++ library with bindings to Python, Javascript and Java to interface with the I/O on BBG, BBGW and other platforms, with a structured and sane API where port names/numbering matches the board that you are on. Use of Mraa does not tie you to specific hardware with board detection done at runtime you can create portable code that will work across the supported platforms.\nUPM is a high level repository for sensors that use MRAA. Each sensor links to MRAA and are not meant to be interlinked although some groups of sensors may be. Each sensor contains a header which allows to interface with it. Typically a sensor is represented as a class and instantiated.The constructor is expected to initialise the sensor and parameters may be used to provide identification/pin location on the board.", 
            "title": "What are Mraa and UPM?"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#install-and-update", 
            "text": "Mraa\u00a0and UPM are\u00a0already installed in the system image of BBGW, so  you don t need to install it.  However if you want to update the library, or want to upgrade the library, use\u00a0 apt-get update \u00a0and  apt-get upgrade \u00a0please. Refer to  https://github.com/intel-iot-devkit/mraa \u00a0and  https://github.com/intel-iot-devkit/upm \u00a0for more information.", 
            "title": "Install and update"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#mraa-example", 
            "text": "light a led   import mraa\nimport time\n#mraa.gpio60 = P9_14 = GPIO_50\nled = mraa.Gpio(60)\nled.dir(mraa.DIR_OUT)\n\nwhile True:\n    led.write(1)\n    time.sleep(1)\n    led.write(0)\n    time.sleep(1)   Grove - PIR Sensor   import mraa\nimport time\n#mraa.gpio73 = P9_27 = GPIO_115\npir = mraa.Gpio(73)\npir.dir(mraa.DIR_IN)\n\nwhile True:\n    print (pir.read())\n    time.sleep(1)   Grove - Rotary Angle Sensor   import mraa\nimport time\n#mraa.aio1 = AIN0\nrotary = mraa.Aio(1)\n\nwhile True:\n    print(rotary.read())\n    time.sleep(1)   More Tutorials   Grove - 3-Axis Digital Accelerometer(\u00b116g)\n Grove - Variable Color LED  Grove - Mini Fan\nGrove - PIR Motion Sensor\nGrove - Rotary Angle Sensor  Grove - Relay\nGrove - Sound Sensor  Grove - OLED Display 0.96\u201d\nGrove - Light Sensor \nGrove - Temperature Sensor  Grove - GPS\nGrove - Button(P)\nGrove - Buzzer\nGrove - RTC v2.0", 
            "title": "Mraa Example"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#mraa-map-for-bbgw", 
            "text": "", 
            "title": "Mraa Map for BBGW"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#references-and-resources", 
            "text": "", 
            "title": "References and Resources"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#references", 
            "text": "There re many references to help you to get more information about the board.    BeagleBoard Main Page  BeagleBone Green Wireless info at BeagleBoard page  BeagleBoard Getting Started  Troubleshooting  Hardware documentation  Projects of BeagleBoard", 
            "title": "References"
        }, 
        {
            "location": "/SeeedStudio_BeagleBone_Green_Wireless/#resources", 
            "text": "BeagleBone_Green_Wireless Schematic(pdf)", 
            "title": "Resources"
        }, 
        {
            "location": "/Raspberry_Pi/", 
            "text": "// to be continued", 
            "title": "Raspberry Pi"
        }, 
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/", 
            "text": "Raspberry Pi Breakout Board for Raspberry Pi is a prototype board that you can combine your raspberry pi with other components, modules.\nAs a prototype board, it also provides power, state indicator light, button and universal transistor,such as NPN, PNP, N-MOS, P-MOS.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nRaspberry pi compatible\n\n\nMicro USB power supply\n\n\nBasic Circuit\u00a0: state indicator light, button and universal transistor\uff08NPN,PNP,N-MOS,P-MOS\uff09\n\n\n3.3 volts, 5 volts and ground power rails are easily available anywhere on the board\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nAssembly\n\uf0c1\n\n\n\n\nYou can design circuit on the Raspberry Pi Breakout Board, then connect to raspberry pi as shown below.\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nRaspberry Pi Breakout Board v1.0 sch pcb-.zip", 
            "title": "Raspberry Pi Breakout Board v1.0"
        }, 
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#features", 
            "text": "Raspberry pi compatible  Micro USB power supply  Basic Circuit\u00a0: state indicator light, button and universal transistor\uff08NPN,PNP,N-MOS,P-MOS\uff09  3.3 volts, 5 volts and ground power rails are easily available anywhere on the board", 
            "title": "Features"
        }, 
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#assembly", 
            "text": "You can design circuit on the Raspberry Pi Breakout Board, then connect to raspberry pi as shown below.", 
            "title": "Assembly"
        }, 
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#resources", 
            "text": "Raspberry Pi Breakout Board v1.0 sch pcb-.zip", 
            "title": "Resources"
        }, 
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/", 
            "text": "Raspberry Pi RS232 Board v1.0 is a standard communication port for industry equipment.This module is base on MAX3232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nLow Supply Current:300\u03bcA\n\n\nGuaranteed Data Rate:120kbps\n\n\nMeets EIA/TIA-232 Specifications Down to 3.0V\n\n\nPin Compatible with Industry-Standard MAX232\n\n\nGuaranteed Slew Rate:6V/\u03bcs\n\n\nLED Indicator\n\n\nDB9 Connectors(female)\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n Item\n\n\n\n Min\n\n\n\n Typical\n\n\n\n Max\n\n\n\n Unit\n\n\n\n\n\n Input Voltage Range\n\n\n\n -25\n\n\n\n /\n\n\n\n 25\n\n\n\n V\n\n\n\n\n\n Input Threshold Low(VCC=3.3V/5.0V)\n\n\n\n 0.6 / 0.8\n\n\n\n 1.2 / 1.5\n\n\n\n /\n\n\n\n V\n\n\n\n\n\n Input Threshold High (VCC=3.3V/5.0V)\n\n\n\n /\n\n\n\n 1.5 / 1.8\n\n\n\n 2.4 / 2.4\n\n\n\n V\n\n\n\n\n\n Maximum Data Rate\n\n\n\n 120\n\n\n\n 235\n\n\n\n\n\n\n\n kHz\n\n\n\n\n\n Operating Temperature\n\n\n\n 0\n\n\n\n /\n\n\n\n 70\n\n\n\n \u2103\n\n\n\n\n\n Dimension\n\n\n\n 91.20 * 56.15*32\n\n\n\n mm\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nUART Pin must be pup joint if you want to connect to raspberry pi.\n\n\nUsage\n\uf0c1\n\n\nUsing serial COM ports to Configure system on Raspberry Pi.\n\n\nHardware Installation\n\uf0c1\n\n\n\n\n\n\nRaspberry Pi\nUSB to serial COM Port line.\n\n\n\n\n\n\nConnect as in the following picture:\n\n\n\n\n\n\n\n\nFine out which com it is using on you PC\ns device management.\n\n\n\n\n\n\nRun a serial port assistant, and set it as shown:\n\n\nCOM must be set as what you fine on you PC\ns device management.Then power on your raspberry pi. You can see the serial port assistant as shown below.\n\n\n\n\n\n\n\n\nHave communication with Raspberry Pi successfully.\n\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nRaspberry_Pi_RS232_Board_v1.0_sch_pcb\n\n\nMAX3232", 
            "title": "Raspberry Pi RS232 Board v1.0"
        }, 
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#features", 
            "text": "Low Supply Current:300\u03bcA  Guaranteed Data Rate:120kbps  Meets EIA/TIA-232 Specifications Down to 3.0V  Pin Compatible with Industry-Standard MAX232  Guaranteed Slew Rate:6V/\u03bcs  LED Indicator  DB9 Connectors(female)", 
            "title": "Features"
        }, 
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#specifications", 
            "text": "Item   Min   Typical   Max   Unit    Input Voltage Range   -25   /   25   V    Input Threshold Low(VCC=3.3V/5.0V)   0.6 / 0.8   1.2 / 1.5   /   V    Input Threshold High (VCC=3.3V/5.0V)   /   1.5 / 1.8   2.4 / 2.4   V    Maximum Data Rate   120   235     kHz    Operating Temperature   0   /   70   \u2103    Dimension   91.20 * 56.15*32   mm", 
            "title": "Specifications"
        }, 
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#hardware-overview", 
            "text": "UART Pin must be pup joint if you want to connect to raspberry pi.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#usage", 
            "text": "Using serial COM ports to Configure system on Raspberry Pi.", 
            "title": "Usage"
        }, 
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#hardware-installation", 
            "text": "Raspberry Pi USB to serial COM Port line.    Connect as in the following picture:     Fine out which com it is using on you PC s device management.    Run a serial port assistant, and set it as shown:  COM must be set as what you fine on you PC s device management.Then power on your raspberry pi. You can see the serial port assistant as shown below.     Have communication with Raspberry Pi successfully.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#resources", 
            "text": "Raspberry_Pi_RS232_Board_v1.0_sch_pcb  MAX3232", 
            "title": "Resources"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/", 
            "text": "Arduino Breakout for LinkIt Smart 7688 Duo\n is an expansion board for LinkIt Smart 7688 Duo. Just like other breakout board produced by Seeed, this board has integrated copiously 12 grove ports that allows you to connect more grove modules easily. By using this board, beginners are able to get started quickly because wiring, which is usually not a happy process for most people, is simplified. What\ns more, the board shares the same MUC as Arduino, that means you can not only use the features of LinkIt Smart 7688, but also from Arduino Y\u00fan, which allows you to build rich IoT applications based on various, robust and compiled Arduino sketches. On the board, there are reserved pins for LinkIt Smart 7688 Duo to easily access, apart from that, it also supports serial buses like I2C, UART and comes with USB and Ethernet.\n\n\n\n\nLinkIt Smart 7688 Duo is an open development board based on the OpenWrt Linux distribution, MT7688 and ATmega32u4. The board is designed especially to enable the prototyping of Rich Application IoT devices for Smart-Home. If you want to know more about LinkIt Smart 7688 Duo, please click \nHERE\n.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nArduino Shield Compatible\n\n\nEthernet to connect internet\n\n\nUSB 2.0 for more peripherals\n\n\nGrove interfaces: I2C \u00d7 2, Analog \u00d7 3, Digital\u00d7 6, UART \u00d7 1\n\n\n4-pin debug port \u00d7 1, ICSP \u00d7 1\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nIoT/Gateway Device.\n\n\nRobotics\n\n\nSmart multimedia devices\n\n\nTeaching and learning\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nInput voltage\n :5.0V (With USB Power port)\n\n\nOperating voltage\n :3.3V\n\n\n\n\n\n\nNote\n\n\nDebug pins connect with MT7688, Other pins connect with ATmega32U4.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nItem\n\n\nQty\n\n\nItem\n\n\nQty\n\n\n\n\n\n\n\n\n\n\nArduino Shield\n\n\n1\n\n\nUSE Port(Type-A)\n\n\n1\n\n\n\n\n\n\nMT7688 UART2\n\n\n1\n\n\nUSB Port(Micro type-B)\n\n\n1\n\n\n\n\n\n\nICSP port\n\n\n1\n\n\nEthernet Port\n\n\n1\n\n\n\n\n\n\nReset Button(ATmega32u4)\n\n\n1\n\n\nPort to be plugged with LinkIt Smart 7688 Duo\n\n\n1\n\n\n\n\n\n\n\n\nGet Started\n\uf0c1\n\n\nIn this simple application, you are going to make a buzzer to buzz different sounds. Before getting started, Apart from Arduino Breakout for LinkIt Smart 7688 Duo, please check if you have below materials on hand. You can get them from our Bazzar.\n\n\n\n\n\n\n\n\nLinkIt Smart 7688 Duo\n\n\nUSB cable (type A to micro type-B)\n\n\nUARTBee\n\n\nJumper wires x 3\n\n\nGrove - Buzzer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet One Now\n\n\nGet One Now\n\n\nGet One Now\n\n\nGet One Now\n\n\nGet One Now\n\n\n\n\n\n\n\n\n\n\nStep1 Refer this to connect your LinkIt Smart 7688 Duo to internet.\n\n\n\n\n\n\nNote\n\n\n\n\nYou can find Pin 8, Pin 9 and Pin GND close to the port to be connected LinkIt Smart 7688.\n\n\nYou can plug jumper wires into MT7688 UART2 port instead of soldering them to Pin 8, Pin 9 and Pin GND.\n\n\n\n\n\n\n\n\nStep2. Open a console after connecting an USB to Serial adapter to LinkIt Smart 7688 Duo.\n\n\nStep3 Connect all parts as shown below:\n\n\n\n\n\n\n\n\n\n\nStep4\uff1aPlug Grove - Buzzer into port D4.\n\n\n\n\n\n\nStep5: This step is to build the Arduino environment for LinkIt Smart 7688 Duo platform on host computer. Since the tutorial has been written in the Wiki of LinkIt Smart 7688, please refer to \nHere\n.\n\n\n\n\nStep6: Download firmata.\n\n\nStep7: Refer to \nHere\n to install Arduino IDE for LinkIt Smart 7688 platform, and flash the file firmata to development board.\n\n\n\n\n\n\nNote\n\n\nFollowing steps should be carried out on embedded OS(OpenWRT). Please make sure you have Python in your system and installed pip.\n\n\n\n\n\n\nStep8: Type pip install pyfirmata into console and press Enter to install python library pyfirmata.\n\n\nStep9: Create a file named \nbuzzer.py\n with typing \nvi buzzer.py\n in console, copy the code below into it.\n\n\n\n\nfrom pyfirmata import Arduino, util\nfrom time import sleep\nboard = Arduino('/dev/ttyS0')\nprint \nStart blinking D4\n\nwhile True:\n  board.digital[4].write(1)\n  sleep(0.5)\n  board.digital[4].write(0)\n  sleep(0.5)\n\n\n\n\n\n\nStep10: Save \nbuzzer.py\n and type \npython buzzer.py\n to run the example code.\n\n\nStep11: Now you will hear the buzzing sound.\n\n\n\n\nMake It Now\n\uf0c1\n\n\nHave you successfully make the buzzer to buzz? Here are 2 more awesome projects that use LinkIt Smart 7688 Duo. Let\ns make them now!\n\n\n\n\n\n\n\n\nSmart router with WiFi Connection Visualization\n\n\nFacebook Like Monitor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic files\n\n\nWiki link for LinkIt Smart 7688 Duo\n\n\nOpenWrt\n\n\n\n\nHelp us to make it better\n\uf0c1\n\n\n\n\nThank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.\n\n\nIt is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:\n\n\n\n\nReplace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.\n\n\nReview and rewrite documents for hundreds of products to make them more understandable.\n\n\nInspect and repair all the URL to make sure it can be linked to the right page.\n\n\n\n\nAlthough we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.\n\n\nBy the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Arduino Breakout for LinkIt Smart 7688 Duo"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/#features", 
            "text": "Arduino Shield Compatible  Ethernet to connect internet  USB 2.0 for more peripherals  Grove interfaces: I2C \u00d7 2, Analog \u00d7 3, Digital\u00d7 6, UART \u00d7 1  4-pin debug port \u00d7 1, ICSP \u00d7 1", 
            "title": "Features"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/#application-ideas", 
            "text": "IoT/Gateway Device.  Robotics  Smart multimedia devices  Teaching and learning", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/#specifications", 
            "text": "Input voltage  :5.0V (With USB Power port)  Operating voltage  :3.3V    Note  Debug pins connect with MT7688, Other pins connect with ATmega32U4.", 
            "title": "Specifications"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/#hardware-overview", 
            "text": "Item  Qty  Item  Qty      Arduino Shield  1  USE Port(Type-A)  1    MT7688 UART2  1  USB Port(Micro type-B)  1    ICSP port  1  Ethernet Port  1    Reset Button(ATmega32u4)  1  Port to be plugged with LinkIt Smart 7688 Duo  1", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/#get-started", 
            "text": "In this simple application, you are going to make a buzzer to buzz different sounds. Before getting started, Apart from Arduino Breakout for LinkIt Smart 7688 Duo, please check if you have below materials on hand. You can get them from our Bazzar.     LinkIt Smart 7688 Duo  USB cable (type A to micro type-B)  UARTBee  Jumper wires x 3  Grove - Buzzer             Get One Now  Get One Now  Get One Now  Get One Now  Get One Now      Step1 Refer this to connect your LinkIt Smart 7688 Duo to internet.    Note   You can find Pin 8, Pin 9 and Pin GND close to the port to be connected LinkIt Smart 7688.  You can plug jumper wires into MT7688 UART2 port instead of soldering them to Pin 8, Pin 9 and Pin GND.     Step2. Open a console after connecting an USB to Serial adapter to LinkIt Smart 7688 Duo.  Step3 Connect all parts as shown below:      Step4\uff1aPlug Grove - Buzzer into port D4.    Step5: This step is to build the Arduino environment for LinkIt Smart 7688 Duo platform on host computer. Since the tutorial has been written in the Wiki of LinkIt Smart 7688, please refer to  Here .   Step6: Download firmata.  Step7: Refer to  Here  to install Arduino IDE for LinkIt Smart 7688 platform, and flash the file firmata to development board.    Note  Following steps should be carried out on embedded OS(OpenWRT). Please make sure you have Python in your system and installed pip.    Step8: Type pip install pyfirmata into console and press Enter to install python library pyfirmata.  Step9: Create a file named  buzzer.py  with typing  vi buzzer.py  in console, copy the code below into it.   from pyfirmata import Arduino, util\nfrom time import sleep\nboard = Arduino('/dev/ttyS0')\nprint  Start blinking D4 \nwhile True:\n  board.digital[4].write(1)\n  sleep(0.5)\n  board.digital[4].write(0)\n  sleep(0.5)   Step10: Save  buzzer.py  and type  python buzzer.py  to run the example code.  Step11: Now you will hear the buzzing sound.", 
            "title": "Get Started"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/#make-it-now", 
            "text": "Have you successfully make the buzzer to buzz? Here are 2 more awesome projects that use LinkIt Smart 7688 Duo. Let s make them now!     Smart router with WiFi Connection Visualization  Facebook Like Monitor", 
            "title": "Make It Now"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/#resources", 
            "text": "Schematic files  Wiki link for LinkIt Smart 7688 Duo  OpenWrt", 
            "title": "Resources"
        }, 
        {
            "location": "/Arduino_Breakout_for_LinkIt_Smart_7688_Duo/#help-us-to-make-it-better", 
            "text": "Thank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.  It is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:   Replace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.  Review and rewrite documents for hundreds of products to make them more understandable.  Inspect and repair all the URL to make sure it can be linked to the right page.   Although we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.  By the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Help us to make it better"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/", 
            "text": "Breakout for LinkIt Smart 7688 v2.0\n is a Grove port integrated expansion board for LinkItTM Smart 7688 development board. This breakout board will save a lot of work and makes prototyping easier through simplified wiring. It will assist a beginner to get started fast. It supports serial buses like I2C, UART. It comes with USB, Ethernet, and 3.5mm Audio ports.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nProduct reversion\n\n\nRelease date\n\n\nSupport status\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nVersion 1.0\n\n\nNovember 2015\n\n\nSupported\n\n\nNone\n\n\n\n\n\n\nVersion 2.0\n\n\nApril 2016\n\n\nSupported\n\n\nRefer to New Features\n\n\n\n\n\n\n\n\nNew features:\n\uf0c1\n\n\n\n\nSupport recording functionality\n\n\nFor 3.5 mm phone connector (audio jack), it supports the protocol OMTP and CTIA. You can use either protocol by switching a switch. About how to switch protocol, we will describe it later.\nGet One Now Banner.png\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove interface makes wiring easier and allows expansions with Grove modules.\n\n\nUSB host\n\n\nAudio Output\n\n\nEthernet port\n\n\nCost-effective\n\n\n\n\nApplication ideas\n\uf0c1\n\n\n\n\nIoT/Gateway Device.\n\n\nRobotics\n\n\nSmart multimedia devices\n\n\nTeaching and learning\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nInput voltage\n\n\n5.0V(With USB Power port)\n\n\n\n\n\n\n\n\n\n\nOperating voltage\n\n\n3.3V\n\n\n\n\n\n\nDebug port\n\n\n1(Quantity)\n\n\n\n\n\n\nEthernet port\n\n\n1(Quantity)\n\n\n\n\n\n\nUSB type-A\n\n\n1(Quantity)\n\n\n\n\n\n\nHeadset port\n\n\n1(Quantity)\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nDebug pins, Ethernet pins and USB type-A host pins connect with MT7688, other pins connect with ATmega32U4.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nGrove interface\n\uf0c1\n\n\nConnect rich \nGrove\n interfaced functional modules. With this kind of ports, you never need jumper wire or soldering work, and you can make more powerful applications with those functional modules.\n\n\nTo switch phone connector protocol between OMTP and CTIA\n\n\n\n\nIn preceded figure, you can notice that there are six pins and two jumper caps on bottom-right corner. These pins are used to switch phone connector protocol. As you set tiny jumper(both) to left-four pin, protocol OMTP is used. As you set tiny jumper(both) to right-four pin (as preceded figure shows), protocol CTIA is used. As following figures show:\nBreakout for LinkIt Smart 7688 v2.0 CTIA OMTP Switch Manner.JPG\nNote that to use the recording functionality, you need to update on-board firmware to Breakout for LinkIt Smart 7688 firmware(above version v0.9.2).\n\n\n\n\n\n\nNote\n\n\nWe recommend you use external storage device, because the Write/Read speed of on-board flash memory is limited.\n\n\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nBreakout for LinkIt Smart 7688 v2.0\n\n\n1PCS\n\n\n\n\n\n\n\n\nGet started\n\uf0c1\n\n\nMaterial required\n\uf0c1\n\n\n\n\nLinkIt Smart 7688 \u00d7 1\n\n\nUSB cable (type A to micro type-B) \u00d7 2\n\n\nUSB to Serial adapter \u00d7 1\n\n\nJumper wires \u00d7 3\n\n\nStereo (with 3.5 mm audio cable) \u00d7 1\n\n\nUSB flash driver (with audio file of MP3 format inside) \u00d7 1\n\n\n\n\nPlay music\n\uf0c1\n\n\nStep1:\n Refer \nhere\n to connect your LinkIt Smart 7688 to Internet.\n\n\n\n\nNote\n\n\nYou can plug jumper wires to MT7688 UART2 port instead soldering them to Pin 8, Pin 9 and Pin GND.\n\n\n\n\n\n\nNote\n\n\nIn rare cases, you might not connect to Internet successfully, reboot the embedded OS.\n\n\n\n\nStep2:\n Open a console with USB to Serial adapter.\n\n\nStep3:\n Connect all parts like follows:\n\n\n\n\n\n\nNote\n\n\nThis is a figure of Breakout for LinkIt Smart 7688(v1.0).\n\n\n\n\nStep4:\n Enter folder of USB by type \ncd /Media/USB-A1\n in console.\n\n\nStep5:\n Play music with utility \nMadplay\n(installed on OpenWRT) by typing \nmadplay filename.mp3\n into console.\n\n\nStep6:\n Now you will hear the music.\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic files\n\n\nLinkIt smart 7688\n\n\nOpenWrt\n\n\nLink to buy a LinkIt Smart 7688", 
            "title": "Breakout for LinkIt Smart 7688 v2.0"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#version-tracker", 
            "text": "Product reversion  Release date  Support status  Notes      Version 1.0  November 2015  Supported  None    Version 2.0  April 2016  Supported  Refer to New Features", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#new-features", 
            "text": "Support recording functionality  For 3.5 mm phone connector (audio jack), it supports the protocol OMTP and CTIA. You can use either protocol by switching a switch. About how to switch protocol, we will describe it later.\nGet One Now Banner.png", 
            "title": "New features:"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#features", 
            "text": "Grove interface makes wiring easier and allows expansions with Grove modules.  USB host  Audio Output  Ethernet port  Cost-effective", 
            "title": "Features"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#application-ideas", 
            "text": "IoT/Gateway Device.  Robotics  Smart multimedia devices  Teaching and learning", 
            "title": "Application ideas"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#specification", 
            "text": "Input voltage  5.0V(With USB Power port)      Operating voltage  3.3V    Debug port  1(Quantity)    Ethernet port  1(Quantity)    USB type-A  1(Quantity)    Headset port  1(Quantity)      Note  Debug pins, Ethernet pins and USB type-A host pins connect with MT7688, other pins connect with ATmega32U4.", 
            "title": "Specification"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#grove-interface", 
            "text": "Connect rich  Grove  interfaced functional modules. With this kind of ports, you never need jumper wire or soldering work, and you can make more powerful applications with those functional modules.  To switch phone connector protocol between OMTP and CTIA   In preceded figure, you can notice that there are six pins and two jumper caps on bottom-right corner. These pins are used to switch phone connector protocol. As you set tiny jumper(both) to left-four pin, protocol OMTP is used. As you set tiny jumper(both) to right-four pin (as preceded figure shows), protocol CTIA is used. As following figures show:\nBreakout for LinkIt Smart 7688 v2.0 CTIA OMTP Switch Manner.JPG\nNote that to use the recording functionality, you need to update on-board firmware to Breakout for LinkIt Smart 7688 firmware(above version v0.9.2).    Note  We recommend you use external storage device, because the Write/Read speed of on-board flash memory is limited.", 
            "title": "Grove interface"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#parts-list", 
            "text": "Parts name  Quantity      Breakout for LinkIt Smart 7688 v2.0  1PCS", 
            "title": "Parts list"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#get-started", 
            "text": "", 
            "title": "Get started"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#material-required", 
            "text": "LinkIt Smart 7688 \u00d7 1  USB cable (type A to micro type-B) \u00d7 2  USB to Serial adapter \u00d7 1  Jumper wires \u00d7 3  Stereo (with 3.5 mm audio cable) \u00d7 1  USB flash driver (with audio file of MP3 format inside) \u00d7 1", 
            "title": "Material required"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#play-music", 
            "text": "Step1:  Refer  here  to connect your LinkIt Smart 7688 to Internet.   Note  You can plug jumper wires to MT7688 UART2 port instead soldering them to Pin 8, Pin 9 and Pin GND.    Note  In rare cases, you might not connect to Internet successfully, reboot the embedded OS.   Step2:  Open a console with USB to Serial adapter.  Step3:  Connect all parts like follows:    Note  This is a figure of Breakout for LinkIt Smart 7688(v1.0).   Step4:  Enter folder of USB by type  cd /Media/USB-A1  in console.  Step5:  Play music with utility  Madplay (installed on OpenWRT) by typing  madplay filename.mp3  into console.  Step6:  Now you will hear the music.", 
            "title": "Play music"
        }, 
        {
            "location": "/Breakout_for_LinkIt_Smart_7688_v2.0/#resources", 
            "text": "Schematic files  LinkIt smart 7688  OpenWrt  Link to buy a LinkIt Smart 7688", 
            "title": "Resources"
        }, 
        {
            "location": "/LinkIt_ONE/", 
            "text": "The LinkIt ONE development platform is an open source, high performance board for prototyping Wearables and IoT devices. It is based on the world\ns leading SoC for Wearables, MediaTek Aster (\nMT2502\n) combined with high performance Wi-Fi (\nMT5931\n) and GPS (\nMT3332\n) chipsets to provide you with access to all the features of MediaTek LinkIt. It also provides similar pin-out features to Arduino boards, making it easy to connect various sensors, peripherals, and Arduino shields.\n\n\nLinkIt One is an all-in-one prototyping board for IoT/wearables devices. Integrating GSM, GPRS, Wi-Fi, GPS, Bluetooth features into a basic Arduino form factor.LinkIt ONE is a co-design product by \nSeeed Studio\n and \n MediaTek\n. It brings together both parties\n technology in open hardware and industrial leading reference designs for Wearables and IoT devices to create a powerful development board.\n\n\n\n\n\n\nNote\n\n\nLinkIt ONE board comes with a lot of features and its SDK(Software Development Kit) is quite comprehensive. Read this document throughly once before using the board. Being a co-design product basic level Technical Support for hardware is provided at \n Seeedstudio LinkIt One Forum\n.Advanced Technical support is available at  \n  MediaTek LinkIt One Forums\n.These forums have a good number of FAQs about this board.Please search solutions for your requirements/issues first before posting questions for saving your time. \n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nIncludes ARM7 EJ-S\u2122, GSM, GPRS, Wi-Fi, Bluetooth BR/EDR/BLE, GPS, Audio codec, and SD card connector on a single development board.\n\n\nPin-out similar to Arduino boards, including Digital I/O, Analog I/O, PWM, I2C, SPI, UART and power supply, compatible with Arduino.\n\n\nProvides various interfaces for connecting to most sensors, peripherals, Groves, and other widgets.\n\n\nYou are what you wear. Using LinkIt ONE together with MediaTek LinkIt SDK (for Arduino) you will be able to easily turn your ideas into practical prototypes and make them a reality with the Seeed productization and agile manufacturing service.\n\n\n\n\nspecifications\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nChipset\n\n\nMT2502A (Aster, ARM7 EJ-S (TM) )\n\n\n\n\n\n\nClock Speed\n\n\n260MHz\n\n\n\n\n\n\nDimensions\n\n\n3.3x2.1 inches\n\n\n\n\n\n\nFlash\n\n\n16MB\n\n\n\n\n\n\nRAM\n\n\n4MB\n\n\n\n\n\n\nDC Current Per I/O Pin\n\n\n1mA\n\n\n\n\n\n\nAnalog Pins\n\n\n3\n\n\n\n\n\n\nDigital Output\n\n\n3.3V\n\n\n\n\n\n\nAnalog Input\n\n\n5V\n\n\n\n\n\n\nUART\n\n\nSoftware based(\nSerial\n) ,also known as USB Modem Port and Hardware Serial(\nSerial1\n, D0\nD1)\n\n\n\n\n\n\nSD Card\n\n\nUp to 32GB(Class 10)\n\n\n\n\n\n\nPositioning\n\n\nGPS(MT3332)\n\n\n\n\n\n\nGSM\n\n\n850/900/1800/1900 MHz\n\n\n\n\n\n\nGPRS\n\n\nClass 12\n\n\n\n\n\n\nWi-Fi\n\n\n802.11 b/g/n\n\n\n\n\n\n\nBluetooth\n\n\nBR/EDR/BLE(Dual Mode)\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\n\n\nInternet of Things\n\n\nSmart House\n\n\nWearable Designe\n\n\nIndustrial\n\n\nSensor Hub\n\n\nAutomation \n Transportation\n\n\n\n\nHere are some projects for your reference. More awesome project at \nRecipe\n and \nInstructables\n.\n\n\n\n\n\n\n\n\nFacebook Like Monitor\n\n\nTexting Door Alarm\n\n\nSmart Bed Alarm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it NOW!\n\n\nMake it NOW!\n\n\nMake it NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAWS IoT Tutorial\n\n\nInstructables Indicator\n\n\nDIY an Acrylic Case\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it NOW!\n\n\nMake it NOW!\n\n\nMake it NOW!\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nConfiguration Switches\n\uf0c1\n\n\nThere are 3 slide switches on LinkIt ONE which are used to configure the function/working mode :\n\n\n\n\n\n\n\n\n\n\nSwitch No.\n\n\nFunctionality\n\n\nPosition 1 - Functionality\n\n\nPosition 2 - Functionality\n\n\n\n\n\n\n\n\n\n\n1\n\n\nProgram Mode\n\n\nMS\n\uff1a In this position, when connected to PC, LinkIt One board will be shown as 10MB USB drive. The program will not execute in this mode. Any file that is copied to this drive can be read via the code.\n\n\nUART\uff1aThis position is used to set the board to program mode. Firmware can be uploaded in this mode.\n\n\n\n\n\n\n2\n\n\nPower\n\n\nBAT\n\uff1a Board powered by Li-ion Battery. To charge battery, set the switch to this position and connect the board to PC.\n\n\nUSB\n\uff1aBoard powered by USB port. Set the switch to this position when there is no battery connected to program the board.\n\n\n\n\n\n\n3\n\n\nSD/SPI\n\n\nSPI\n\uff1aThis position allows access of external SPI pins (D10 - D13)\n\n\nSD\n\uff1aThis position allows the code to access SD card. This mode also disables access of SPI pins (D10-D13).\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nDO take care as you handle USB micro type-B socket, or you might break the socket off.\n\n\n\n\nGetting started\n\uf0c1\n\n\nProcedure Overview\n\uf0c1\n\n\n\n\n\n\n\n\nNo.\n\n\nStep\n\n\nRead more\n\n\n\n\n\n\n\n\n\n\n1\n\n\nInstall Arduino IDE 1.5.7 Beta (Windows or MAC OS X version)\n\n\n here\n\n\n\n\n\n\n2\n\n\n Register on MediaTek Labs\n.\n\n\n\n\n\n\n\n\n3\n\n\nDownload \n Linkit Developer\ns Guide\n and read.\n\n\n\n\n\n\n\n\n4\n\n\nInstall \n LinkIt SDK\n for Arduino IDE (Windows or MAC OS X).\n\n\n here\n\n\n\n\n\n\n5\n\n\nInstall LinkIt ONE drivers.\n\n\n here\n\n\n\n\n\n\n6\n\n\nUpdate the on-board firmware version.\n\n\n here\n\n\n\n\n\n\n7\n\n\nOpen Arduino IDE, Select LinkIt ONE board and start coding.\n\n\n here\n\n\n\n\n\n\n8\n\n\nConnect GSM, GPS and WiFi/BT antennae to LinkIt One board\n\n\n here\n\n\n\n\n\n\n9\n\n\nInsert SIM and Micro SD Card\n\n\n here\n\n\n\n\n\n\n10\n\n\nExplore examples and Happy making!\n\n\n\n\n\n\n\n\n\n\nInstalling Arduino IDE\n\uf0c1\n\n\n Download latest Arduino IDE\n .For more advanced topics, follow MediaTekTM\n  instructions\n.\n\n\nInstalling Mediatek LinkIt ONE SDK\n\uf0c1\n\n\n\n\nDownload \n  LinkIt SDK for Arduin\n.At the time of writing this guide, \nv1.1.11\n Windows SDK (Beta) was used. Read the video guide for Windows OS and MAC OS X platforms  \n here\n\n\nExtract the downloaded files to Arduino IDE folder.\n\n\nDouble-Click the .EXE file and install.\n\n\nWith the installation of LinkIt ONE SDK, Arduino IDE works a LinkIt ONE IDE.\n\n\n\n\nInstalling Drivers\n\uf0c1\n\n\n\n\nDisable \nDriver Signature Enforcement\n if you are using Windows 8/8.1 OS. Read[instructions]\n\n\n(http://www.seeedstudio.com/wiki/Download_Arduino_and_install_Arduino_driver#Installing_drivers_for_the_Seeeduino_with_window8)\n\n\n\n\nPut the MS/UART slide switch to UART position and connect LinkIt ONE to PC.\n\n\nOpen Device Manager, the following COM ports will be displayed.\n\n\n\n\n\n\n\n\nInstall driver from ..\\LinkIt_ONE_IDE\\drivers\\mtk folder.\n\n\nAfter installing drivers, Device Manger should display the following two ports:\n\n\n\n\nMTK USB Debug Port\n used for uploading code.\n\n\nMTK USB Modem Port\n used for printing message, such as Serial.println()\n\n\n  \n\n\n\n\nNote\n\n\nThere is no official Windows 10 driver yet. Windows 10 users can manually select the Windows 7 driver files from \n\\LinkIt_ONE_IDE\\drivers\\mtk\n from \nDevice Manager\n. This is known to work on few PCs.\n\n\n\n\nUpdating Firmware\n\uf0c1\n\n\nThe firmware of LinkIt ONE board needs to be updated once in a while. Latest LinkIt ONE SDK comes with a version of firmware.\n\n\n\n\nBefore starting the firmware update, make sure the slide switches are in proper position ( \nMS/UART\n should be in \nMS\n position. \nUSB/BAT\n in \nUSB\n position):\n\n\n\n\n  \n\n\n\n\nRun FirmwareUpdater.exe application from ..\n\\LinkIt_ONE_IDE\\hardware\\tools\\mtk\n folder.\n\n\n\n\n  \n\n\n\n\nClick the button and then connect LinkIt ONE to PC. Wait for 1 minutes for the update to complete successfully.\n\n\n\n\n  \n\n\nUploading Code (Blinky)\n\uf0c1\n\n\n\n\nThe slide switches should be configured for firmware upload (i.e Put MS/UART in UART position and Power switch in USB position).\n\n\n\n\n \n\n\n\n\nOpen \nFile\n -\n \nExamples\n -\n \nBasics\n -\n \nBlink\n in LinkIt ONE IDE.\n\n\nSelect the COM Port number corresponding to \nMTK USB Debug port\n in \nTools\n -\n \nPort\n.\n\n\nCompile and upload the code.\n\n\nLED marked \nL\n should blink.\n\n\n\n\nConnecting Antennae\n\uf0c1\n\n\nThere are three antennae provided with LinkIt ONE. They are used for:\n\n\n\n\nGSM/GPRS\n\n\nWi-Fi/BT\n\n\nGPS\n\n\n\n\nConnect the antenna as the following image.\n\n\n \n\n\n\n\nNote\n\n\n\n\nWhile pulling the antenna from board, do it with care. Please Do not use brute force.\n\n\nTry to use the force perpendicular to the direction of the board, otherwise you might damage the antenna pad.\n\n\n\n\n\n\nInserting SIM Card and SD Card\n\uf0c1\n\n\nLinkIt ONE accepts standard size SIM Card and Micro SD Card. Insert them as per the following image:\n\n\n \n\n\nExploring LinkIt ONE SDK Examples\n\uf0c1\n\n\nLinkIt ONE SDK comes with many examples / sample code to use peripherals like GSM, GPRS, WiFi, BT, Audio, GPS etc. Explore them first and read about API documentation. API documentation are available in \n  User Guide \n and \n  API References site \n\n\nCompatible Groves and Shields for LinkIt ONE\n\uf0c1\n\n\n\n\nWe manufacture hundreds of Groves and Shields, including sensors, actuators, displays and other modules.\n\n\nYou can implement your ideas with those Groves and Shields easily.\n\n\nBut, LinkIt ONE does not support all of them.\n\n\nWe prepared a list of compatible Groves and Shields:\n\n\n\n\n\n\nTutorial of Sidekick Basic Kit for LinkIt ONE\n\uf0c1\n\n\n\n\nThe Sidekick Basic Kit for LinkIt ONE is designed to be used with your LinkIt ONE board. This kit will help you quickly get along well with the platform of LinkIt. It includes many of the most popular accessories for DIY projects : like Breadboard, Jumper wires, Color LEDs, Resistors, Buzzer, etc. All these come in a handy box, which is easy to transport and mimimises clutter. The kit includes a complete guide that will familiarize you with a wide range of electronic components while you create small, simple, and easy-to-assemble circuits. There are 10 different courses outlined that will offer a best way for beginner to get familiar with LinkIt ONE.\n\n\n\n\n\n\nThe Basics\n\n\nHello World\n\n\nPush Button\n\n\nMarquee\n\n\nColorful World\n\n\nAnalog Interface\n\n\nMini Servo\n\n\nLight Sensor\n\n\nSMS Control the LED\n\n\n\n\nGet Temperature with Webpage\n\n\n\n\n\n\nGithub Repo for Sidekick Basic Kit for LinkIt ONE\n\n\n\n\n\n\nResources\n\uf0c1\n\n\nSchematic / Design Files:\n\n\n\n\nLinkIt ONE V1.0 Eagle File\n\n\nLinkIt ONE V1.0 Schematic in PDF\n\n\n\n\nSoftware:\n\n\n\n\nMediaTek_LinkIt_SDK_for_Ardunio\n\n\n\n\nDatasheets and User Guides:\n\n\n\n\nLinkIt_ONE_Hardware_Reference_Design_v1_0\n\n\nLinkIt ONE_Pinout Diagram_v1.0\u3010PDF\u3011\n\n\nMediaTek_LinkIt_Developers_Guide_v1_0\u3010PDF\u3011\n\n\nMediaTek_MT2502A_SOC_Data_Sheet_v1_0\u3010PDF\u3011\n\n\nMediaTek_MT5931_Wi-Fi_Data_Sheet_v1_0\u3010PDF\u3011\n\n\nMediaTek_MT3332_GPS_Data_Sheet_v1_0\u3010PDF\u3011\n\n\n\n\nGetting Help\n\n\n\n\nSeeedstudio LinkIt ONE Forum\n\n\nMediaTek LinkIt ONE Forums\n\n\n\n\nMore\n\n\n\n\nSee Also: Sidekick Base Kit for LinkIt ONE", 
            "title": "LinkIt ONE"
        }, 
        {
            "location": "/LinkIt_ONE/#features", 
            "text": "Includes ARM7 EJ-S\u2122, GSM, GPRS, Wi-Fi, Bluetooth BR/EDR/BLE, GPS, Audio codec, and SD card connector on a single development board.  Pin-out similar to Arduino boards, including Digital I/O, Analog I/O, PWM, I2C, SPI, UART and power supply, compatible with Arduino.  Provides various interfaces for connecting to most sensors, peripherals, Groves, and other widgets.  You are what you wear. Using LinkIt ONE together with MediaTek LinkIt SDK (for Arduino) you will be able to easily turn your ideas into practical prototypes and make them a reality with the Seeed productization and agile manufacturing service.", 
            "title": "Features"
        }, 
        {
            "location": "/LinkIt_ONE/#specifications", 
            "text": "Parameter  Value      Chipset  MT2502A (Aster, ARM7 EJ-S (TM) )    Clock Speed  260MHz    Dimensions  3.3x2.1 inches    Flash  16MB    RAM  4MB    DC Current Per I/O Pin  1mA    Analog Pins  3    Digital Output  3.3V    Analog Input  5V    UART  Software based( Serial ) ,also known as USB Modem Port and Hardware Serial( Serial1 , D0 D1)    SD Card  Up to 32GB(Class 10)    Positioning  GPS(MT3332)    GSM  850/900/1800/1900 MHz    GPRS  Class 12    Wi-Fi  802.11 b/g/n    Bluetooth  BR/EDR/BLE(Dual Mode)", 
            "title": "specifications"
        }, 
        {
            "location": "/LinkIt_ONE/#application-ideas", 
            "text": "Internet of Things  Smart House  Wearable Designe  Industrial  Sensor Hub  Automation   Transportation   Here are some projects for your reference. More awesome project at  Recipe  and  Instructables .     Facebook Like Monitor  Texting Door Alarm  Smart Bed Alarm           Make it NOW!  Make it NOW!  Make it NOW!        AWS IoT Tutorial  Instructables Indicator  DIY an Acrylic Case           Make it NOW!  Make it NOW!  Make it NOW!", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/LinkIt_ONE/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/LinkIt_ONE/#configuration-switches", 
            "text": "There are 3 slide switches on LinkIt ONE which are used to configure the function/working mode :      Switch No.  Functionality  Position 1 - Functionality  Position 2 - Functionality      1  Program Mode  MS \uff1a In this position, when connected to PC, LinkIt One board will be shown as 10MB USB drive. The program will not execute in this mode. Any file that is copied to this drive can be read via the code.  UART\uff1aThis position is used to set the board to program mode. Firmware can be uploaded in this mode.    2  Power  BAT \uff1a Board powered by Li-ion Battery. To charge battery, set the switch to this position and connect the board to PC.  USB \uff1aBoard powered by USB port. Set the switch to this position when there is no battery connected to program the board.    3  SD/SPI  SPI \uff1aThis position allows access of external SPI pins (D10 - D13)  SD \uff1aThis position allows the code to access SD card. This mode also disables access of SPI pins (D10-D13).      Note  DO take care as you handle USB micro type-B socket, or you might break the socket off.", 
            "title": "Configuration Switches"
        }, 
        {
            "location": "/LinkIt_ONE/#getting-started", 
            "text": "", 
            "title": "Getting started"
        }, 
        {
            "location": "/LinkIt_ONE/#procedure-overview", 
            "text": "No.  Step  Read more      1  Install Arduino IDE 1.5.7 Beta (Windows or MAC OS X version)   here    2   Register on MediaTek Labs .     3  Download   Linkit Developer s Guide  and read.     4  Install   LinkIt SDK  for Arduino IDE (Windows or MAC OS X).   here    5  Install LinkIt ONE drivers.   here    6  Update the on-board firmware version.   here    7  Open Arduino IDE, Select LinkIt ONE board and start coding.   here    8  Connect GSM, GPS and WiFi/BT antennae to LinkIt One board   here    9  Insert SIM and Micro SD Card   here    10  Explore examples and Happy making!", 
            "title": "Procedure Overview"
        }, 
        {
            "location": "/LinkIt_ONE/#installing-arduino-ide", 
            "text": "Download latest Arduino IDE  .For more advanced topics, follow MediaTekTM   instructions .", 
            "title": "Installing Arduino IDE"
        }, 
        {
            "location": "/LinkIt_ONE/#installing-mediatek-linkit-one-sdk", 
            "text": "Download    LinkIt SDK for Arduin .At the time of writing this guide,  v1.1.11  Windows SDK (Beta) was used. Read the video guide for Windows OS and MAC OS X platforms    here  Extract the downloaded files to Arduino IDE folder.  Double-Click the .EXE file and install.  With the installation of LinkIt ONE SDK, Arduino IDE works a LinkIt ONE IDE.", 
            "title": "Installing Mediatek LinkIt ONE SDK"
        }, 
        {
            "location": "/LinkIt_ONE/#installing-drivers", 
            "text": "Disable  Driver Signature Enforcement  if you are using Windows 8/8.1 OS. Read[instructions]  (http://www.seeedstudio.com/wiki/Download_Arduino_and_install_Arduino_driver#Installing_drivers_for_the_Seeeduino_with_window8)   Put the MS/UART slide switch to UART position and connect LinkIt ONE to PC.  Open Device Manager, the following COM ports will be displayed.     Install driver from ..\\LinkIt_ONE_IDE\\drivers\\mtk folder.  After installing drivers, Device Manger should display the following two ports:   MTK USB Debug Port  used for uploading code.  MTK USB Modem Port  used for printing message, such as Serial.println()       Note  There is no official Windows 10 driver yet. Windows 10 users can manually select the Windows 7 driver files from  \\LinkIt_ONE_IDE\\drivers\\mtk  from  Device Manager . This is known to work on few PCs.", 
            "title": "Installing Drivers"
        }, 
        {
            "location": "/LinkIt_ONE/#updating-firmware", 
            "text": "The firmware of LinkIt ONE board needs to be updated once in a while. Latest LinkIt ONE SDK comes with a version of firmware.   Before starting the firmware update, make sure the slide switches are in proper position (  MS/UART  should be in  MS  position.  USB/BAT  in  USB  position):        Run FirmwareUpdater.exe application from .. \\LinkIt_ONE_IDE\\hardware\\tools\\mtk  folder.        Click the button and then connect LinkIt ONE to PC. Wait for 1 minutes for the update to complete successfully.", 
            "title": "Updating Firmware"
        }, 
        {
            "location": "/LinkIt_ONE/#uploading-code-blinky", 
            "text": "The slide switches should be configured for firmware upload (i.e Put MS/UART in UART position and Power switch in USB position).       Open  File  -   Examples  -   Basics  -   Blink  in LinkIt ONE IDE.  Select the COM Port number corresponding to  MTK USB Debug port  in  Tools  -   Port .  Compile and upload the code.  LED marked  L  should blink.", 
            "title": "Uploading Code (Blinky)"
        }, 
        {
            "location": "/LinkIt_ONE/#connecting-antennae", 
            "text": "There are three antennae provided with LinkIt ONE. They are used for:   GSM/GPRS  Wi-Fi/BT  GPS   Connect the antenna as the following image.      Note   While pulling the antenna from board, do it with care. Please Do not use brute force.  Try to use the force perpendicular to the direction of the board, otherwise you might damage the antenna pad.", 
            "title": "Connecting Antennae"
        }, 
        {
            "location": "/LinkIt_ONE/#inserting-sim-card-and-sd-card", 
            "text": "LinkIt ONE accepts standard size SIM Card and Micro SD Card. Insert them as per the following image:", 
            "title": "Inserting SIM Card and SD Card"
        }, 
        {
            "location": "/LinkIt_ONE/#exploring-linkit-one-sdk-examples", 
            "text": "LinkIt ONE SDK comes with many examples / sample code to use peripherals like GSM, GPRS, WiFi, BT, Audio, GPS etc. Explore them first and read about API documentation. API documentation are available in    User Guide   and    API References site", 
            "title": "Exploring LinkIt ONE SDK Examples"
        }, 
        {
            "location": "/LinkIt_ONE/#compatible-groves-and-shields-for-linkit-one", 
            "text": "We manufacture hundreds of Groves and Shields, including sensors, actuators, displays and other modules.  You can implement your ideas with those Groves and Shields easily.  But, LinkIt ONE does not support all of them.  We prepared a list of compatible Groves and Shields:", 
            "title": "Compatible Groves and Shields for LinkIt ONE"
        }, 
        {
            "location": "/LinkIt_ONE/#tutorial-of-sidekick-basic-kit-for-linkit-one", 
            "text": "The Sidekick Basic Kit for LinkIt ONE is designed to be used with your LinkIt ONE board. This kit will help you quickly get along well with the platform of LinkIt. It includes many of the most popular accessories for DIY projects : like Breadboard, Jumper wires, Color LEDs, Resistors, Buzzer, etc. All these come in a handy box, which is easy to transport and mimimises clutter. The kit includes a complete guide that will familiarize you with a wide range of electronic components while you create small, simple, and easy-to-assemble circuits. There are 10 different courses outlined that will offer a best way for beginner to get familiar with LinkIt ONE.    The Basics  Hello World  Push Button  Marquee  Colorful World  Analog Interface  Mini Servo  Light Sensor  SMS Control the LED   Get Temperature with Webpage    Github Repo for Sidekick Basic Kit for LinkIt ONE", 
            "title": "Tutorial of Sidekick Basic Kit for LinkIt ONE"
        }, 
        {
            "location": "/LinkIt_ONE/#resources", 
            "text": "Schematic / Design Files:   LinkIt ONE V1.0 Eagle File  LinkIt ONE V1.0 Schematic in PDF   Software:   MediaTek_LinkIt_SDK_for_Ardunio   Datasheets and User Guides:   LinkIt_ONE_Hardware_Reference_Design_v1_0  LinkIt ONE_Pinout Diagram_v1.0\u3010PDF\u3011  MediaTek_LinkIt_Developers_Guide_v1_0\u3010PDF\u3011  MediaTek_MT2502A_SOC_Data_Sheet_v1_0\u3010PDF\u3011  MediaTek_MT5931_Wi-Fi_Data_Sheet_v1_0\u3010PDF\u3011  MediaTek_MT3332_GPS_Data_Sheet_v1_0\u3010PDF\u3011   Getting Help   Seeedstudio LinkIt ONE Forum  MediaTek LinkIt ONE Forums   More   See Also: Sidekick Base Kit for LinkIt ONE", 
            "title": "Resources"
        }, 
        {
            "location": "/Linkit_Connect_7681/", 
            "text": "The LinkIt Connect 7681 development board provides easy access to the five GPIO pins and one UART port \u2014 each with an LED \u2014 of the MT7681, to quickly connect peripheral controllers and electronic circuits. The MT7681 is provided on the LinkIt Connect 7681 module, which was co-designed with AcSiP. This module, which is only 15 x 18mm, will also be available separately for direct integration into your product\u2019s PCB.\n\n\n\n\nKey Features\n\uf0c1\n\n\n\n\nAccess to the five GPIO pins and one UART port provided by MT7681, with attached LEDs\n\n\nWiFi antenna integrated on Linkit 7681 module\n\n\nPower over USB (Micro USB port).\n\n\nOpen source hardware board reference design, including schematic, layouts, and pin details.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nChipset Core: MT7681 ANDES N9\n\n\nClock Speed: 80MHz\n\n\nFlash: 1MB\n\n\nRAM: 64KB\n\n\nPower: on-board 1A 3.3V voltage regulator (can be powered from USB connector)\n\n\nConnectors: UART/GPIO/SPI pins are available on connectors(100mil/2.54mm pitch);micro USB connector.\n\n\nGPIO Voltage: 3.3V\n\n\nPWM Output pin Count: 5\n\n\nPWM levels: 0~20\n\n\nUART Voltage: 3.3V\n\n\nWi-Fi Spec: 802.11 b/g/n for Station mode; 802.11 b/g for AP mode\n\n\nDimensions: 50 x 31 mm\n\n\nOther: Onboard reset push-button.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nGetting Started\n\uf0c1\n\n\nInstall USB Driver\n\uf0c1\n\n\nConnect LinkIt Connect 7681 development board to PC\u2019s USB port using a USB cable. The driver will be automatically installed.(As shown below in Windows7 OS)\n\n\n\n\n\n\n\n\nNote\n\nIf the driver does not install successfully, you can download and install \nFTDI Driver\n manually.\n\n\n\n\nGetting started with \nMediaTek LinkIt Connect 7681 Developer\u2019s Guide\n\n\nThis document provides you with a detailed introduction to the MediaTek LinkIt Connect 7681 SDK, step-by-step installation guide, and details on how to use it to create and run Wi-Fi applications. It also covers how to use the board upgrade tool provided in the SDK, an overview of the APIs and several how-to guides to undertake common Wi-Fi operations with code example. Details on how to create MediaTek Smart Connection apps for Android and iOS are also included.\n\n\nResources\n\uf0c1\n\n\n\n\nMediaTek LinkIt Connect 7681 Developer\u2019s Guide\n\n\nMediaTek LinkIt Connect 7681 API Reference\n\n\nLinkIt Connect 7681 Hardware Reference Design\n\n\nMediaTek LinkIt\u2122 Connect 7681 SDK", 
            "title": "Linkit Connect 7681"
        }, 
        {
            "location": "/Linkit_Connect_7681/#key-features", 
            "text": "Access to the five GPIO pins and one UART port provided by MT7681, with attached LEDs  WiFi antenna integrated on Linkit 7681 module  Power over USB (Micro USB port).  Open source hardware board reference design, including schematic, layouts, and pin details.", 
            "title": "Key Features"
        }, 
        {
            "location": "/Linkit_Connect_7681/#specifications", 
            "text": "Chipset Core: MT7681 ANDES N9  Clock Speed: 80MHz  Flash: 1MB  RAM: 64KB  Power: on-board 1A 3.3V voltage regulator (can be powered from USB connector)  Connectors: UART/GPIO/SPI pins are available on connectors(100mil/2.54mm pitch);micro USB connector.  GPIO Voltage: 3.3V  PWM Output pin Count: 5  PWM levels: 0~20  UART Voltage: 3.3V  Wi-Fi Spec: 802.11 b/g/n for Station mode; 802.11 b/g for AP mode  Dimensions: 50 x 31 mm  Other: Onboard reset push-button.", 
            "title": "Specifications"
        }, 
        {
            "location": "/Linkit_Connect_7681/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Linkit_Connect_7681/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Linkit_Connect_7681/#install-usb-driver", 
            "text": "Connect LinkIt Connect 7681 development board to PC\u2019s USB port using a USB cable. The driver will be automatically installed.(As shown below in Windows7 OS)     Note \nIf the driver does not install successfully, you can download and install  FTDI Driver  manually.  Getting started with  MediaTek LinkIt Connect 7681 Developer\u2019s Guide  This document provides you with a detailed introduction to the MediaTek LinkIt Connect 7681 SDK, step-by-step installation guide, and details on how to use it to create and run Wi-Fi applications. It also covers how to use the board upgrade tool provided in the SDK, an overview of the APIs and several how-to guides to undertake common Wi-Fi operations with code example. Details on how to create MediaTek Smart Connection apps for Android and iOS are also included.", 
            "title": "Install USB Driver"
        }, 
        {
            "location": "/Linkit_Connect_7681/#resources", 
            "text": "MediaTek LinkIt Connect 7681 Developer\u2019s Guide  MediaTek LinkIt Connect 7681 API Reference  LinkIt Connect 7681 Hardware Reference Design  MediaTek LinkIt\u2122 Connect 7681 SDK", 
            "title": "Resources"
        }, 
        {
            "location": "/Arch_BLE/", 
            "text": "Arch BLE is an mbed enabled development board based on Nordic nRF51822. With Arduino form factor and Grove connectors, it is extremely easy to create a Bluetooth Low Energy(BLE) device.\n\n\nThe nRF51822 is a powerful multi-protocol single chip solution for ULP wireless applications. It incorporates Nordic\u2019s latest best-in-class performance radio transceiver, an ARM Cortex M0 MCU and 256kB flash + 16kB RAM memory. The nRF51822 supports Bluetooth\u00ae low energy and 2.4 GHz protocol stacks.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nmbed enabled\n\n\nOnline IDE\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\nCMSIS DAP based on LPC11U35\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS DAP standard\n\n\nUSB virtual serial for communication\n\n\n\n\n\n\nArduino form factor with Grove connectors\n\n\nNordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC\n\n\nARM Cortex M0 processor\n\n\n256kB flash/16kB RAM\n\n\nConfigurable I/O mapping for digital I/O\n\n\n\n\n\n\nUSB Micro B connector\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nGet Started\n\uf0c1\n\n\n\n\n\n\nClick \nthis link\n to \nlogin or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download the compiled hex file.\n\n\nDrag-n-drop the downloaded hex file into the MBED disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1s\n\n\n    #include \nmbed.h\n\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\n\n\nNote\n\nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.\n\n\n\n\nApplications\n\uf0c1\n\n\n\n\n\n\nColor Pixels, a colorful LED strip, can be controlled by mobile phone.\n\n\n\n\nHardware\n\n\nArch BLE\n\n\nDigital RGB LED Strip\n\n\nAndroid device with BLE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it run\n\n\n\n\nDownload \nBLE_Color_Pixels_Arch_BLE.hex\n\n\nCopy the hex file to the MBED disk of your Arch BLE\n\n\nDownload \nthe Color Pixels Android app\n\n\n\n\n\n\n\n\n\n\n\n\nIf you want to change the program, click \nthis link\n to import the Color Pixels program to mbed online IDE.\n\n\nIf the BLE device is disconnecting frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (in main.cpp), Min Interval and Max Interval (in nRF51822/projectconfig.h)\n\n\n#define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**\n Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**\n Maximum acceptable connection interval */\n\n\n\n\n\n\n\n\nA Toy car controlled by mobile phone.\n\n\n\n\n\n\nHardware\n\n\n\n\nArch BLE\n\n\nShield Bot\n\n\n\n\n\n\n\n\nMake it run\n\n\n\n\nRead recipe/instructions \nhere\n\n\n\n\n\n\n\n\n\n\n\n\nUpdate or Restore Firmware\n\uf0c1\n\n\nThe latest firmware version for the Arch BLE is v0221 built on March 02 2015. To check your firmware version and built date, open the MBED.HTM file of your MBED disk in a text editor.\n\n\nChange log:\n\n\n\n\n2014-06-26: First version\n\n\n2014-08-25: Support to drag-n-drop hex file generated by gcc toolchain and without softdevice\n\n\n2014-10-08: Use USB EJECT INSET instead of reconnecting USB, increase intel hex data line buffer (from 64 bytes to 128 bytes)\n\n\n2015-02-03: Fix Mac OS X 10.10 Yosemite read only file system bug\n\n\n\n\nKnown issues:\n\n\n\n\nIssues when \ndirectly\n downloading the hex file into the MBED disk with the Chrome browser. The reason is Chrome creates a temporary file while downloading. If you are using Chrome, please save the hex file to a different location and \nthen\n copy it to the MBED disk.\n\n\n\n\nFirmware:\n\n\n\n\nThe firmware v0221 2015-02-03 for Arch BLE\n\n\nThe firmware v0203 2014-10-08 for Arch BLE\n\n\nThe firmware v0203 2014-08-25 for Arch BLE\n\n\n\n\nTo flash a new firmware:\n\n\n\n\nHold the Arch BLE\ns button and power it ON.\n\n\nA CRP DISABLD disk will pop up.\n\n\nOn Windows, replace firmware.bin with the above firmware.\n\n\nOn Linux/Mac, use command: \ndd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nArch BLE mbed developer platform page\n\n\nSchematic in PDF format\n\n\nSchematic and board files in EAGLE format\n\n\nLPC11U35 Firmware\n\n\nSeeed BLE Color Pixels App for Android\n\n\nSources of BLE Color Pixels App", 
            "title": "Arch BLE"
        }, 
        {
            "location": "/Arch_BLE/#features", 
            "text": "mbed enabled  Online IDE  Easy to use C/C++ SDK  Handy libraries    CMSIS DAP based on LPC11U35  Drag-n-drop programming  Debug using CMSIS DAP standard  USB virtual serial for communication    Arduino form factor with Grove connectors  Nordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC  ARM Cortex M0 processor  256kB flash/16kB RAM  Configurable I/O mapping for digital I/O    USB Micro B connector", 
            "title": "Features"
        }, 
        {
            "location": "/Arch_BLE/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Arch_BLE/#get-started", 
            "text": "Click  this link  to  login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download the compiled hex file.  Drag-n-drop the downloaded hex file into the MBED disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1s      #include  mbed.h \n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }   Note \nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.", 
            "title": "Get Started"
        }, 
        {
            "location": "/Arch_BLE/#applications", 
            "text": "Color Pixels, a colorful LED strip, can be controlled by mobile phone.   Hardware  Arch BLE  Digital RGB LED Strip  Android device with BLE         Make it run   Download  BLE_Color_Pixels_Arch_BLE.hex  Copy the hex file to the MBED disk of your Arch BLE  Download  the Color Pixels Android app       If you want to change the program, click  this link  to import the Color Pixels program to mbed online IDE.  If the BLE device is disconnecting frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (in main.cpp), Min Interval and Max Interval (in nRF51822/projectconfig.h)  #define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**  Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**  Maximum acceptable connection interval */    A Toy car controlled by mobile phone.    Hardware   Arch BLE  Shield Bot     Make it run   Read recipe/instructions  here", 
            "title": "Applications"
        }, 
        {
            "location": "/Arch_BLE/#update-or-restore-firmware", 
            "text": "The latest firmware version for the Arch BLE is v0221 built on March 02 2015. To check your firmware version and built date, open the MBED.HTM file of your MBED disk in a text editor.  Change log:   2014-06-26: First version  2014-08-25: Support to drag-n-drop hex file generated by gcc toolchain and without softdevice  2014-10-08: Use USB EJECT INSET instead of reconnecting USB, increase intel hex data line buffer (from 64 bytes to 128 bytes)  2015-02-03: Fix Mac OS X 10.10 Yosemite read only file system bug   Known issues:   Issues when  directly  downloading the hex file into the MBED disk with the Chrome browser. The reason is Chrome creates a temporary file while downloading. If you are using Chrome, please save the hex file to a different location and  then  copy it to the MBED disk.   Firmware:   The firmware v0221 2015-02-03 for Arch BLE  The firmware v0203 2014-10-08 for Arch BLE  The firmware v0203 2014-08-25 for Arch BLE   To flash a new firmware:   Hold the Arch BLE s button and power it ON.  A CRP DISABLD disk will pop up.  On Windows, replace firmware.bin with the above firmware.  On Linux/Mac, use command:  dd if={new_firmware.bin} of={firmware.bin} conv=notrunc", 
            "title": "Update or Restore Firmware"
        }, 
        {
            "location": "/Arch_BLE/#resources", 
            "text": "Arch BLE mbed developer platform page  Schematic in PDF format  Schematic and board files in EAGLE format  LPC11U35 Firmware  Seeed BLE Color Pixels App for Android  Sources of BLE Color Pixels App", 
            "title": "Resources"
        }, 
        {
            "location": "/Arch_GPRS_V2/", 
            "text": "Arch GPRS V2\n is the new and improved version of the \nArch GPRS\n development board from \nSeeed Studio\n. Like the original \nArch GPRS\n, it is also an \nmbed\n enabled development board that houses a cellular networking module along with a microcontroller. Arch GPRS V2 uses the LPC11U37 Microcontroller instead of the LPC11U24 used in the \nArch GPRS\n. You can use the mbed C/C++ SDK, libraries and optimizing online development tools to rapidly build your Arch GPRS V2 based prototype. The cellular networking module on the Arch GPRS is based on the SIM900 Quad-band GSM/GRPS engine from SIMCom. With this, data collection functions can be performed easily using the 2G GSM/GPRS based cellular network.\nArch GPRS V2 has a standard Arduino interface as well as \nGrove\n connectors on board. It is convenient to connect existing Shields and \nGrove\n products to Arch GPRS V2. You can even connect a solar panel directly to the board to allow the battery to charge from it. A low-power design guarantees easy charging and long hour operations when outdoors!\n\n\n\n\n\n\nNote\n\nArch GPRS V2 does not come with \nan mbed interface\n. To output debug messages, please try \nUSBSerial\n.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nOnline development tools\n\n\nEasy to use C/C++ SDK\n\n\nLots of published libraries, projects\n\n\n\n\n\n\n\n\nNXP LPC11U37 Controller\n\n\n\n\nLow power ARM Cortex-M0 Core\n\n\nOn chip 128KB Flash, 12KB SRAM, 4KB EEPROM\n\n\nUSB Device, UART, I2C\n\n\n\n\n\n\n\n\nSIM900 Module\n\n\n\n\nQuad-band (850/900/1800/1900MHz) GSM/GPRS support\n\n\nSupports external SIM card\uff1a 1.8V/3V\n\n\nControl with standard AT Commands\n\n\n\n\n\n\n\n\nSelect automatically USB5V or Solar panel to charge a battery\n\n\n\n\n\n\nArch GPRS V2 vs Arch GPRS\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nArch GPRS V2\n\n\nArch GPRS\n\n\n\n\n\n\n\n\n\n\nMCU\n\n\nLPC11U27\n\n\nLPC11U24\n\n\n\n\n\n\nGSM/GPRS Module\n\n\nSIM900\n\n\nEG-10\n\n\n\n\n\n\nMicroSD Card\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\n\n\nLogin into the mbed environment from \nhere\n\n\nImport the \nmbed_blinky\n program\n\n\nVerify that the code imported in main.cpp in the mbed_blinky folder in the mbed online Compiler environment is as indicated in the figure above under Step 3. Ensure that the platform selected for compiling the code for is the Seeeduino-Arch. Now go ahead and compile the code. When asked to save the resultant binary file (.bin), save it to a designated folder on your PC.\n\n\nNow connect your Arch board to your PC and long press the reset button. A removable USB drive named CRP DISABLD should automatically appear on your PC. Go to the CRP DISABLD drive, delete the existing firmware file that you see in the folder and copy the downloaded binary file to CRP DISABLD. Quick press the reset button to run the new binary.\n\n\nVerify that your code is running successfully by looking at the Arch GPRS V2 board. If the right-most LED from the Pinout shown above is blinking and the other 3 LEDs next to it are all ON, this implies that your code is working.\n\n\n\n\nYou can change the code to the following and see what happens:\n\n\n\n    #include \nmbed.h\n\n\n    DigitalOut myled1(LED2); //left most LED if board is held as shown in Pinout diagram above\n    DigitalOut myled2(LED3); //2nd from left\n    DigitalOut myled3(LED4); //3rd from left\n    DigitalOut myled4(LED1); //4th from left (right most)\n\n    int main() {\n        while(1) {\n\n            myled1 = 1; //left most LED turns ON, rest off\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1); //1 sec wait time\n            myled1 = 0;\n            myled2 = 1; //2nd from left LED turns ON, rest off\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 1; //3rd from left LED turns ON, rest off\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 1; //4th from left (right most) LED turns ON, rest off\n\n            wait(1);\n        }\n    }\n\n\n\n\nWhen you Compile and Run the above code on the Arch GPRS V2 board, you should see that the LEDs blink in sequence.\n\n\nIf you get through the above steps successfully, this means that:\n\n\n\n\nYour Arch GPRS V2 is powering up correctly.\n\n\nYour code is being downloaded and run by the Arch GPRS V2 module correctly.\n\n\nYou are ready to take on more complex projects now!\n\n\n\n\nProgramming Arch on Windows, Linux or Mac\n\uf0c1\n\n\nArch does not have an mbed interface. It uses USB In-System-Programming (ISP) to upgrade the firmware.\n\n\nTo enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \nCRP DISABLD\n will appear.\n\n\n\n\n\n\nOn windows\n\n\n\n\ndelete firmware.bin in the \nCRP DISABLD\n disk.\n\n\ncopy a new firmware into the disk.\n\n\n\n\n\n\n\n\nOn linux\n\n\n\n\nif the disk is not mounted, mount the disk at \n{mnt_dir}\n\n\ndd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nOn mac you\nll need to use Terminal to run the following script to copy you\nre .bin file to your Arch\n\n\n\n\ndd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nIf you are so inclined, you can also create an \nAutomator\n application to support drag-and-drop of the file to your board. Just create a \nRun Shell Script\n with the following command:\n\n\ndd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nYou will also need to change the \n\"Pass Input\"\n option from \n\"to stdin\"\n to \n\"as arguments\"\nwithout this you will get an error \n\"The action 'Run Shell Script' encountered an error\"\n or \n\"dd: no value specified for if (1)\"\n in the log.\n\n\nAlso, an improved form of the script is:\n\ndd if=\n${1}\n of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nWhich should handle spaces in the file path and only uses the first file supplied.\nQuick press the button to run the new firmware.\n\n\nResources\n\uf0c1\n\n\n\n\nArch GPRS V2.0 mbed developer platform page\n\n\n\n\nDesign Files\n\n\n\n\nSchematic and Board files in EAGLE format\n\n\nSchematic in PDF format\n\n\n\n\nApplications and Library\n\n\n\n\nGPRS library\n\n\nUse Seeeduino Arch as a debug adapter to debug another Seeeduino Arch\n\n\nSense environment\n\n\nPlay with Grove RTC\n\n\nPlay with Grove - Ultrasonic ranger\n\n\n\n\nSee also\n\n\n\n\nSIM900 GPRS Module Information", 
            "title": "Arch GPRS V2"
        }, 
        {
            "location": "/Arch_GPRS_V2/#features", 
            "text": "mbed enabled   Online development tools  Easy to use C/C++ SDK  Lots of published libraries, projects     NXP LPC11U37 Controller   Low power ARM Cortex-M0 Core  On chip 128KB Flash, 12KB SRAM, 4KB EEPROM  USB Device, UART, I2C     SIM900 Module   Quad-band (850/900/1800/1900MHz) GSM/GPRS support  Supports external SIM card\uff1a 1.8V/3V  Control with standard AT Commands     Select automatically USB5V or Solar panel to charge a battery", 
            "title": "Features"
        }, 
        {
            "location": "/Arch_GPRS_V2/#arch-gprs-v2-vs-arch-gprs", 
            "text": "Parameter  Arch GPRS V2  Arch GPRS      MCU  LPC11U27  LPC11U24    GSM/GPRS Module  SIM900  EG-10    MicroSD Card  Yes  No", 
            "title": "Arch GPRS V2 vs Arch GPRS"
        }, 
        {
            "location": "/Arch_GPRS_V2/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Arch_GPRS_V2/#getting-started", 
            "text": "Login into the mbed environment from  here  Import the  mbed_blinky  program  Verify that the code imported in main.cpp in the mbed_blinky folder in the mbed online Compiler environment is as indicated in the figure above under Step 3. Ensure that the platform selected for compiling the code for is the Seeeduino-Arch. Now go ahead and compile the code. When asked to save the resultant binary file (.bin), save it to a designated folder on your PC.  Now connect your Arch board to your PC and long press the reset button. A removable USB drive named CRP DISABLD should automatically appear on your PC. Go to the CRP DISABLD drive, delete the existing firmware file that you see in the folder and copy the downloaded binary file to CRP DISABLD. Quick press the reset button to run the new binary.  Verify that your code is running successfully by looking at the Arch GPRS V2 board. If the right-most LED from the Pinout shown above is blinking and the other 3 LEDs next to it are all ON, this implies that your code is working.   You can change the code to the following and see what happens:  \n    #include  mbed.h \n\n    DigitalOut myled1(LED2); //left most LED if board is held as shown in Pinout diagram above\n    DigitalOut myled2(LED3); //2nd from left\n    DigitalOut myled3(LED4); //3rd from left\n    DigitalOut myled4(LED1); //4th from left (right most)\n\n    int main() {\n        while(1) {\n\n            myled1 = 1; //left most LED turns ON, rest off\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1); //1 sec wait time\n            myled1 = 0;\n            myled2 = 1; //2nd from left LED turns ON, rest off\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 1; //3rd from left LED turns ON, rest off\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 1; //4th from left (right most) LED turns ON, rest off\n\n            wait(1);\n        }\n    }  When you Compile and Run the above code on the Arch GPRS V2 board, you should see that the LEDs blink in sequence.  If you get through the above steps successfully, this means that:   Your Arch GPRS V2 is powering up correctly.  Your code is being downloaded and run by the Arch GPRS V2 module correctly.  You are ready to take on more complex projects now!", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Arch_GPRS_V2/#programming-arch-on-windows-linux-or-mac", 
            "text": "Arch does not have an mbed interface. It uses USB In-System-Programming (ISP) to upgrade the firmware.  To enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named  CRP DISABLD  will appear.    On windows   delete firmware.bin in the  CRP DISABLD  disk.  copy a new firmware into the disk.     On linux   if the disk is not mounted, mount the disk at  {mnt_dir}  dd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc     On mac you ll need to use Terminal to run the following script to copy you re .bin file to your Arch   dd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc     If you are so inclined, you can also create an  Automator  application to support drag-and-drop of the file to your board. Just create a  Run Shell Script  with the following command:  dd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  You will also need to change the  \"Pass Input\"  option from  \"to stdin\"  to  \"as arguments\" without this you will get an error  \"The action 'Run Shell Script' encountered an error\"  or  \"dd: no value specified for if (1)\"  in the log.  Also, an improved form of the script is: dd if= ${1}  of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  Which should handle spaces in the file path and only uses the first file supplied.\nQuick press the button to run the new firmware.", 
            "title": "Programming Arch on Windows, Linux or Mac"
        }, 
        {
            "location": "/Arch_GPRS_V2/#resources", 
            "text": "Arch GPRS V2.0 mbed developer platform page   Design Files   Schematic and Board files in EAGLE format  Schematic in PDF format   Applications and Library   GPRS library  Use Seeeduino Arch as a debug adapter to debug another Seeeduino Arch  Sense environment  Play with Grove RTC  Play with Grove - Ultrasonic ranger   See also   SIM900 GPRS Module Information", 
            "title": "Resources"
        }, 
        {
            "location": "/Arch_Link/", 
            "text": "Arch Link\n is an mbed enabled development board based on Nordic nRF51822 and WIZnet W5500 ethernet interface. With Arduino form factor, Grove connectors and micro SD interface, it is extremely easy to create a bluetooth low energy device.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nmbed enabled\n\n\nOnline IDE\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\nCMSIS DAP based on LPC11U35\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS DAP standard\n\n\nUSB virtual serial for communication\n\n\n\n\n\n\nArduino form factor with Grove connectors\n\n\nI2C and UART connecter on board\n\n\n\n\n\n\nNordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC\n\n\nARM Cortex M0 processor\n\n\n256kB flash/16kB RAM\n\n\nConfigurable I/O mapping for digital I/O\n\n\n\n\n\n\nWIZnet W5500 Ethernet\n\n\nSupports following Hardwired TCP/IP Protocols\u00a0: TCP, UDP, ICMP, IPv4, ARP, IGMP, PPPoE\n\n\nSupports Power down mode\n\n\nSupports Wake on LAN over UDP\n\n\nSupports High Speed Serial Peripheral Interface(SPI MODE 0, 3)\n\n\nInternal 32Kbytes Memory for Tx/Rx Buffers\n\n\n10BaseT/100BaseTX Ethernet PHY embedded\n\n\nwith RJ45 connector\n\n\n\n\n\n\nUSB Micro B connector\n\n\nMicro SD Card connector\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nGet Started\n\uf0c1\n\n\n\n\n\n\nClick \nthis link\n to \nlogin or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download a compiled hex file.\n\n\nDrag-n-drop the downloaded hex file into the MBED disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1s\n\n\n    #include \nmbed.h\n\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\n\n\nNote\n\nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.\n\n\n\n\nApplications\n\uf0c1\n\n\n\n\n\n\nColor Pixels, a colorful LED strip, can be controlled by mobile phone.\n\n\n\n\nHardware\n\n\nArch Link\n\n\nDigital RGB LED Strip\n\n\nAndroid device with BLE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it run\n\n\n\n\nDownload \nBLE_Color_Pixels_Arch_BLE.hex\n\n\nCopy the hex file to the MBED disk of your Arch BLE\n\n\nDownload \nthe Color Pixels Android app\n\n\n\n\n\n\n\n\nIf you want to change the program, click \nthis link\n to import the Color Pixels program to mbed online IDE.\n\n\nIf the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)\n\n\n#define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**\n Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**\n Maximum acceptable connection interval */\n\n\n\n\n\n\n\nYou can use the Arch Link as a web dashboard.\n\n\n\n\n\n\n\n\nYou can also use the Arch Link as a Mobile APP dashboard.\n\n\n\n\n\n\n\n\nUpdate or Restore Firmware\n\uf0c1\n\n\nThe latest firmware version for the Arch Link is v0203 built at Jun 4 2015. To check your firmware version and built date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.\n\n\nChangelog:\n\n\n\n\n2015-06-4 first version\n\n\n\n\nFirmware:\n\n\nThe firmware v0203 2015-06-04 for Arch Link\nTo flash a new firmware:\n\n\n\n\nHold the Arch Link\ns button and power it ON\n\n\nA CRP DISABLD disk will show up\n\n\nOn Windows, replace firmware.bin with the above firmware\n\n\nOn Linux/Mac, use command: dd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nArch Link mbed developer platform page\n\n\nSchematic in PDF format\n\n\nSchematic and board files in EAGLE format\n\n\nLPC11U35 Firmware\n\n\nSeeed BLE color pixels App for android\n\n\nSources of BLE color pixels App\n\n\n\n\nSee Also\n\uf0c1\n\n\n\n\nArch BLE\n\n\nW5500 Ethernet Shield", 
            "title": "Arch Link"
        }, 
        {
            "location": "/Arch_Link/#features", 
            "text": "mbed enabled  Online IDE  Easy to use C/C++ SDK  Handy libraries    CMSIS DAP based on LPC11U35  Drag-n-drop programming  Debug using CMSIS DAP standard  USB virtual serial for communication    Arduino form factor with Grove connectors  I2C and UART connecter on board    Nordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC  ARM Cortex M0 processor  256kB flash/16kB RAM  Configurable I/O mapping for digital I/O    WIZnet W5500 Ethernet  Supports following Hardwired TCP/IP Protocols\u00a0: TCP, UDP, ICMP, IPv4, ARP, IGMP, PPPoE  Supports Power down mode  Supports Wake on LAN over UDP  Supports High Speed Serial Peripheral Interface(SPI MODE 0, 3)  Internal 32Kbytes Memory for Tx/Rx Buffers  10BaseT/100BaseTX Ethernet PHY embedded  with RJ45 connector    USB Micro B connector  Micro SD Card connector", 
            "title": "Features"
        }, 
        {
            "location": "/Arch_Link/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Arch_Link/#get-started", 
            "text": "Click  this link  to  login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download a compiled hex file.  Drag-n-drop the downloaded hex file into the MBED disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1s      #include  mbed.h \n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }   Note \nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.", 
            "title": "Get Started"
        }, 
        {
            "location": "/Arch_Link/#applications", 
            "text": "Color Pixels, a colorful LED strip, can be controlled by mobile phone.   Hardware  Arch Link  Digital RGB LED Strip  Android device with BLE         Make it run   Download  BLE_Color_Pixels_Arch_BLE.hex  Copy the hex file to the MBED disk of your Arch BLE  Download  the Color Pixels Android app     If you want to change the program, click  this link  to import the Color Pixels program to mbed online IDE.  If the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)  #define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**  Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**  Maximum acceptable connection interval */    You can use the Arch Link as a web dashboard.     You can also use the Arch Link as a Mobile APP dashboard.", 
            "title": "Applications"
        }, 
        {
            "location": "/Arch_Link/#update-or-restore-firmware", 
            "text": "The latest firmware version for the Arch Link is v0203 built at Jun 4 2015. To check your firmware version and built date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.  Changelog:   2015-06-4 first version   Firmware:  The firmware v0203 2015-06-04 for Arch Link\nTo flash a new firmware:   Hold the Arch Link s button and power it ON  A CRP DISABLD disk will show up  On Windows, replace firmware.bin with the above firmware  On Linux/Mac, use command: dd if={new_firmware.bin} of={firmware.bin} conv=notrunc", 
            "title": "Update or Restore Firmware"
        }, 
        {
            "location": "/Arch_Link/#resources", 
            "text": "Arch Link mbed developer platform page  Schematic in PDF format  Schematic and board files in EAGLE format  LPC11U35 Firmware  Seeed BLE color pixels App for android  Sources of BLE color pixels App", 
            "title": "Resources"
        }, 
        {
            "location": "/Arch_Link/#see-also", 
            "text": "Arch BLE  W5500 Ethernet Shield", 
            "title": "See Also"
        }, 
        {
            "location": "/Arch_Max_v1.1/", 
            "text": "The Arch Max is a mbed enabled development board for rapid prototyping. It is based on an STM32F407VET6 microcontroller with an ARM Cortex-M4F core running at 168MHz. It provides \nSerial Wire Debug\n(SWD) debug, drag-and-drop programming and USB serial communication.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nName\n\n\nVersion\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nArch Max v1.0\n\n\nv1.0\n\n\n5V cannot be powered by USB, user should connect to ext-power\n\n\n\n\n\n\nArch Max v1.1\n\n\nv1.1\n\n\n5V cannot be powered by USB\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nmbed enabled\n\n\nOnline development tools(include IDE)\n\n\nComplete and straightforward C/C++ SDK\n\n\nMassive examples and tutorials\n\n\n\n\n\n\nHigh-performance STM32F407VET6\n\n\nARM Cortex-M4 MCU with FPU of 168MHz\n\n\n512 KB Flash memory, 192 KB RAM\n\n\n\n\n\n\nOn-board programming and debug\n\n\nDrag-and-drop programming\n\n\nUSB serial communication\n\n\nSWD debug with GDB+ pyOCD/OpenOCD, Keil or IAR\n\n\n\n\n\n\nArduino form factor, compatible with lots of shields\n\n\nBuilt-in Ethernet port, USB and SD card slot for Internet connectivity and data exchange\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter/Item\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nWork Voltage\n\n\n5V\n\n\n\n\n\n\nMicrocontroller\n\n\nSTM32F407VET6\n\n\n\n\n\n\nFlash Memory\n\n\n512KB\n\n\n\n\n\n\nRAM\n\n\n192KB\n\n\n\n\n\n\nUART\n\n\n4\n\n\n\n\n\n\nI2C\n\n\n3\n\n\n\n\n\n\nSPI\n\n\n3\n\n\n\n\n\n\nCAN\n\n\n2\n\n\n\n\n\n\nSDIO\n\n\n1\n\n\n\n\n\n\nCamera interface\n\n\n1\n\n\n\n\n\n\nEth\n\n\n1\n\n\n\n\n\n\nADC Channels\n\n\n8\n\n\n\n\n\n\nI/O pins\n\n\n40\n\n\n\n\n\n\nDigital I/O Max Input Voltage\n\n\n5.0V\n\n\n\n\n\n\nDiameter\n\n\n90mm x 44mm\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nUsage\n\uf0c1\n\n\n\n\n\n\nClick \nhere\n to login or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download a compiled hex file.\n\n\nDrag-n-drop the downloaded bin file into the mbed disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1 second\n\n\n    #include \nmbed.h\n\n\n    DigitalOut led(LED1);          // on-board led is connected to D13\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\nDebug\n\uf0c1\n\n\nTo enable SWD debug or to get debug message through USB Virtual serial, please install \na driver from mbed\n.\n\n\nUpdate or Restore Firmware\n\uf0c1\n\n\nThe latest firmware version for the Arch Max is v0203 built at Oct 8, 2014. To check your firmware version and built date, open the mbed.HTM file of your mbed disk in a text editor.\n\n\nThe firmware v0203 2014-10-08 for Arch Max\n\n\n\n\nPress and hold the Arch Max\ns button to power it on.\n\n\nA CRP DISABLD disk will show\n\n\nOn Windows, replace firmware.bin with the above firmware\n\n\nOn Linux/Mac, enter command: \ndd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematics Eagle file for ARCH Max\n\n\nSchematics PDF file for ARCH Max\n\n\nSTM32F407 datasheet", 
            "title": "Arch Max v1.1"
        }, 
        {
            "location": "/Arch_Max_v1.1/#version-tracker", 
            "text": "Name  Version  Note      Arch Max v1.0  v1.0  5V cannot be powered by USB, user should connect to ext-power    Arch Max v1.1  v1.1  5V cannot be powered by USB", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Arch_Max_v1.1/#features", 
            "text": "mbed enabled  Online development tools(include IDE)  Complete and straightforward C/C++ SDK  Massive examples and tutorials    High-performance STM32F407VET6  ARM Cortex-M4 MCU with FPU of 168MHz  512 KB Flash memory, 192 KB RAM    On-board programming and debug  Drag-and-drop programming  USB serial communication  SWD debug with GDB+ pyOCD/OpenOCD, Keil or IAR    Arduino form factor, compatible with lots of shields  Built-in Ethernet port, USB and SD card slot for Internet connectivity and data exchange", 
            "title": "Features"
        }, 
        {
            "location": "/Arch_Max_v1.1/#specifications", 
            "text": "Parameter/Item  Value      Work Voltage  5V    Microcontroller  STM32F407VET6    Flash Memory  512KB    RAM  192KB    UART  4    I2C  3    SPI  3    CAN  2    SDIO  1    Camera interface  1    Eth  1    ADC Channels  8    I/O pins  40    Digital I/O Max Input Voltage  5.0V    Diameter  90mm x 44mm", 
            "title": "Specifications"
        }, 
        {
            "location": "/Arch_Max_v1.1/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Arch_Max_v1.1/#usage", 
            "text": "Click  here  to login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download a compiled hex file.  Drag-n-drop the downloaded bin file into the mbed disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1 second      #include  mbed.h \n\n    DigitalOut led(LED1);          // on-board led is connected to D13\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }", 
            "title": "Usage"
        }, 
        {
            "location": "/Arch_Max_v1.1/#debug", 
            "text": "To enable SWD debug or to get debug message through USB Virtual serial, please install  a driver from mbed .", 
            "title": "Debug"
        }, 
        {
            "location": "/Arch_Max_v1.1/#update-or-restore-firmware", 
            "text": "The latest firmware version for the Arch Max is v0203 built at Oct 8, 2014. To check your firmware version and built date, open the mbed.HTM file of your mbed disk in a text editor.  The firmware v0203 2014-10-08 for Arch Max   Press and hold the Arch Max s button to power it on.  A CRP DISABLD disk will show  On Windows, replace firmware.bin with the above firmware  On Linux/Mac, enter command:  dd if={new_firmware.bin} of={firmware.bin} conv=notrunc", 
            "title": "Update or Restore Firmware"
        }, 
        {
            "location": "/Arch_Max_v1.1/#resources", 
            "text": "Schematics Eagle file for ARCH Max  Schematics PDF file for ARCH Max  STM32F407 datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Arch_Pro/", 
            "text": "Arch Pro is an mbed enabled development board for rapid prototyping. It is a variant of mbed LPC1768 with built-in Ethernet, USB Host/Device, Grove connectors and Arduino form factor. With a variety of Shield and Grove modules and lots of software libraries for Arch Pro, you can implement Ethernet, USB Host/Device and NFC applications rapidly and easily.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nOnline development tools\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\n\n\nArduino form factor with two Grove connectors\n\n\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS-DAP\n\n\nUSB virtual serial for communication\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue/Availability\n\n\n\n\n\n\n\n\n\n\nMCU\n\n\nNXP LPC1768 variant (with ARM Cortex-M3 core)\n\n\n\n\n\n\nClock Speed\n\n\n100 MHz\n\n\n\n\n\n\nFlash\n\n\n512 KB\n\n\n\n\n\n\nRAM\n\n\n64KB\n\n\n\n\n\n\nUART\n\n\n4 No.s\n\n\n\n\n\n\nI2C\n\n\n3 No.s\n\n\n\n\n\n\nSPI\n\n\n2 No.s\n\n\n\n\n\n\nEthernet\n\n\nYes\n\n\n\n\n\n\nUSB Host/Device\n\n\nYes\n\n\n\n\n\n\n\n\nPlatforms Supported\n\uf0c1\n\n\n\n\nmbed.\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nEthernet\n\n\nUSB Host\n or \nDevice\n\n\nNFC\n\n\nRTOS\n\n\nLua\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nThere is \na monochrome version\n for you to print.\n\n\n\n\nNote\n\nThe Arch Pro silkscreen for the Grove connectors is labeled 3V3 on top of the PCB and 5V on the underside. Grove Vcc is by default 3V3, but can be changed to 5V by moving R50 to R51. SPI Vcc pin can be set by populating R52 (3V3) or R53 (5V) with 0R - neither populated by default.\n\n\n\n\nGetting Started\n\uf0c1\n\n\nAs the Arch Pro is compatible with mbed LPC1768, one can use the mbed C/C++ SDK, libraries and online development tools to rapidly build a prototype.\nHere we show how to light up an LED. This can be done in less than 10 minutes.\n\n\nStep one\uff1a Sign up for an mbed account.\n\n\n\n\nOpen \nmbed.org\n, click Login or signup. If you have already registered, please click login directly.\n\n\n\n\nStep two\uff1a Enter online development tools.\n\n\n\n\nClick Compiler\uff0c it opens the online mbed IDE. Before programming, it is better to read the mbed Complier \nGetting started\n.\n\n\n\n\n\n\nStep three\uff1aEdit code.\n\n\n\n\nClick \nNew\n in the left top corner to create a Program and edit a blink program in main.cpp file.\n\n\n\n\n#include \nmbed.h\n\n\u00a0\nDigitalOut  led1(LED1);\n\u00a0\nint main() {\n    while(1) {\n        led1 = !led1; \n        wait(0.5); \n    }\n}\n\n\n\n\nStep four\uff1a Add a device.\n\n\n\n\nClick \u201dNo device selected\u201d in the top right corner, then click \u201dAdd a device\u201d button in the bottom left as seen in the picture below.\n\n\n\n\n\n\nNote\n\nIf you have already used an mbed device, it will be seen in the top right corner instead of \u201dNo device selected\u201d.\n\n\n\n\n\n\n\n\nA pop-up page appears with a list of devices as shown below. Select \u201dmbed LPC1768\u201d.\n\n\n\n\n\n\n\n\nEnter mbed LPC1768 page and click \u201dAdd to mbed Compiler\u201d. Now you have successfully added Mbed LPU1768. Return to mbed compiler page and click \u201dNo device selected\u201d. After you click \nLPC1768\n in the bottom left corner, a screen appears as shown below.\n\n\n\n\n\n\n\n\nYou can see the selected board in mbed online compiler after clicking \u201dSelect Platform\u201d.\n\n\n\n\nStep five\uff1a Compile, download.\n\n\n\n\nClick \nCompile\n. On successful compilation, the mbed IDE generates a bin file. Save the bin file on your PC.\n\n\n\n\nStep six\uff1a Update firmware.\n\n\n\n\nConnect the USB interface (next to \nBUTTON\n) of Arch Pro to your PC using a USB Micro B cable; It automatically appears as a USB device named MBED.\n\n\nCopy the generated bin file to MBED device (on your PC). Now the USB device disappears and reappears.\n\n\nPress BUTTON of Arch Pro, you will see an LED flashing.\n\n\n\n\nDebug\n\uf0c1\n\n\nTo enable SWD debug or to get debug message through USB Virtual serial, please install \nthe driver from mbed\n.\n\n\nUpdate or Restore Firmware\n\uf0c1\n\n\nThe latest firmware version for the Arch Pro is v0221 built on Jan 28 2015. To check your firmware version and build date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.\n\n\n\n\n[\nFirmware v221 2015-01-28 for Arch Pro\n] Fix Mac OS X 10.10 Yosemite read only file system bug\n\n\n[\nFirmware v0203 2014-09-02 for Arch Pro\n]\n\n\n\n\nTo update:\n\n\n\n\nA Windows or Linux computer is needed.\n\n\nDownload the latest firmware.\n\n\nPress and hold the Arch Pro\ns BUTTON and power it ON.\n\n\nA disk named MBED LOADER will appear.\n\n\nDrag-n-drop the downloaded firmware into the disk.\n\n\n\n\n\n\nNotes\n\n\n 1. LocalFileSystem does not work:\nAs the Arch Pro does not have external flash to store files, the LocalFileSystem is not available for this board.\n\n\n\n 2. P0\\_27 \n&\n P0\\_28 do not work with DigitalOut:\nP0\\_28 \n&\n P0\\_27 are open-drain digital I/O for compatible with I2C. External pull-up resistors are needed to provide output functionality.\n\n\n\n 3. USB Serial Communication:\nIn Windows, install the mbed Windows serial port driver to use USB Serial Communication. Have a look at [Windows Serial Configuration](https://developer.mbed.org/handbook/Windows-serial-configuration)\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nArch Pro V1.0 Schematic PDF\n\n\nArch Pro V1.0 EAGLE Files\n\n\nLPC1768 datasheet\n\n\nLPC17xx User Manual", 
            "title": "Arch Pro"
        }, 
        {
            "location": "/Arch_Pro/#features", 
            "text": "mbed enabled   Online development tools  Easy to use C/C++ SDK  Handy libraries     Arduino form factor with two Grove connectors   Drag-n-drop programming  Debug using CMSIS-DAP  USB virtual serial for communication", 
            "title": "Features"
        }, 
        {
            "location": "/Arch_Pro/#specifications", 
            "text": "Parameter  Value/Availability      MCU  NXP LPC1768 variant (with ARM Cortex-M3 core)    Clock Speed  100 MHz    Flash  512 KB    RAM  64KB    UART  4 No.s    I2C  3 No.s    SPI  2 No.s    Ethernet  Yes    USB Host/Device  Yes", 
            "title": "Specifications"
        }, 
        {
            "location": "/Arch_Pro/#platforms-supported", 
            "text": "mbed.", 
            "title": "Platforms Supported"
        }, 
        {
            "location": "/Arch_Pro/#application-ideas", 
            "text": "Ethernet  USB Host  or  Device  NFC  RTOS  Lua", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Arch_Pro/#hardware-overview", 
            "text": "There is  a monochrome version  for you to print.   Note \nThe Arch Pro silkscreen for the Grove connectors is labeled 3V3 on top of the PCB and 5V on the underside. Grove Vcc is by default 3V3, but can be changed to 5V by moving R50 to R51. SPI Vcc pin can be set by populating R52 (3V3) or R53 (5V) with 0R - neither populated by default.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Arch_Pro/#getting-started", 
            "text": "As the Arch Pro is compatible with mbed LPC1768, one can use the mbed C/C++ SDK, libraries and online development tools to rapidly build a prototype.\nHere we show how to light up an LED. This can be done in less than 10 minutes.  Step one\uff1a Sign up for an mbed account.   Open  mbed.org , click Login or signup. If you have already registered, please click login directly.   Step two\uff1a Enter online development tools.   Click Compiler\uff0c it opens the online mbed IDE. Before programming, it is better to read the mbed Complier  Getting started .    Step three\uff1aEdit code.   Click  New  in the left top corner to create a Program and edit a blink program in main.cpp file.   #include  mbed.h \n\u00a0\nDigitalOut  led1(LED1);\n\u00a0\nint main() {\n    while(1) {\n        led1 = !led1; \n        wait(0.5); \n    }\n}  Step four\uff1a Add a device.   Click \u201dNo device selected\u201d in the top right corner, then click \u201dAdd a device\u201d button in the bottom left as seen in the picture below.    Note \nIf you have already used an mbed device, it will be seen in the top right corner instead of \u201dNo device selected\u201d.    A pop-up page appears with a list of devices as shown below. Select \u201dmbed LPC1768\u201d.     Enter mbed LPC1768 page and click \u201dAdd to mbed Compiler\u201d. Now you have successfully added Mbed LPU1768. Return to mbed compiler page and click \u201dNo device selected\u201d. After you click  LPC1768  in the bottom left corner, a screen appears as shown below.     You can see the selected board in mbed online compiler after clicking \u201dSelect Platform\u201d.   Step five\uff1a Compile, download.   Click  Compile . On successful compilation, the mbed IDE generates a bin file. Save the bin file on your PC.   Step six\uff1a Update firmware.   Connect the USB interface (next to  BUTTON ) of Arch Pro to your PC using a USB Micro B cable; It automatically appears as a USB device named MBED.  Copy the generated bin file to MBED device (on your PC). Now the USB device disappears and reappears.  Press BUTTON of Arch Pro, you will see an LED flashing.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Arch_Pro/#debug", 
            "text": "To enable SWD debug or to get debug message through USB Virtual serial, please install  the driver from mbed .", 
            "title": "Debug"
        }, 
        {
            "location": "/Arch_Pro/#update-or-restore-firmware", 
            "text": "The latest firmware version for the Arch Pro is v0221 built on Jan 28 2015. To check your firmware version and build date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.   [ Firmware v221 2015-01-28 for Arch Pro ] Fix Mac OS X 10.10 Yosemite read only file system bug  [ Firmware v0203 2014-09-02 for Arch Pro ]   To update:   A Windows or Linux computer is needed.  Download the latest firmware.  Press and hold the Arch Pro s BUTTON and power it ON.  A disk named MBED LOADER will appear.  Drag-n-drop the downloaded firmware into the disk.    Notes   1. LocalFileSystem does not work:\nAs the Arch Pro does not have external flash to store files, the LocalFileSystem is not available for this board.   2. P0\\_27  &  P0\\_28 do not work with DigitalOut:\nP0\\_28  &  P0\\_27 are open-drain digital I/O for compatible with I2C. External pull-up resistors are needed to provide output functionality.   3. USB Serial Communication:\nIn Windows, install the mbed Windows serial port driver to use USB Serial Communication. Have a look at [Windows Serial Configuration](https://developer.mbed.org/handbook/Windows-serial-configuration)", 
            "title": "Update or Restore Firmware"
        }, 
        {
            "location": "/Arch_Pro/#resources", 
            "text": "Arch Pro V1.0 Schematic PDF  Arch Pro V1.0 EAGLE Files  LPC1768 datasheet  LPC17xx User Manual", 
            "title": "Resources"
        }, 
        {
            "location": "/Arch_V1.1/", 
            "text": "Arch V1.1 is an mbed enabled development board with Arduino form factor and Grove connectors for rapid prototyping. With a variety of Shield and Grove modules, mbed SDK and lots of software libraries, you can rapidly build a prototype.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRevision\n\n\nDescription\n\n\nRelease Date\n\n\n\n\n\n\n\n\n\n\nSeeeduino Arch V1.0\n\n\n\n\nInitial public release\n\n\n\n\n2013-6-17\n\n\n\n\n\n\nArch V1.1\n\n\n\n\nChange name from Seeeduino Arch to Arch\n\n\nSwitch D13 and D11\n\n\nAdd one Grove connector\n\n\nRemove dual diode\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nonline development tools\n\n\neasy to use C/C++ SDK\n\n\nlots of published libraries, projects\n\n\n\n\n\n\n\n\nArduino form factor, three Grove connectors\n\n\n\n\navailable with 3.3V compatible shields\n\n\na large number of grove modules\n\n\n\n\n\n\nDrag-n-drop programming\n\n\nNXP LPC11U24 MCU\n\n\nLow power ARM Cortex-M0 Core\n\n\n48MHz, 32KB Flash, 8KB RAM, 4KB EEPROM\n\n\nUSB Device, 2xSPI, UART, I2C\n\n\n\n\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\n\n\n\n\n\n\n\n\nWork Voltage\n\n\n7 ~ 12V\n\n\n\n\n\n\nMicrocontroller\n\n\nLPC11U24\n\n\n\n\n\n\nFlash Memory\n\n\n32KB\n\n\n\n\n\n\nEEPROM\n\n\n4KB\n\n\n\n\n\n\nRAM\n\n\n8KB\n\n\n\n\n\n\nUART\n\n\n1\n\n\n\n\n\n\nI2C\n\n\n1\n\n\n\n\n\n\nADC Channels\n\n\n8\n\n\n\n\n\n\nI/O pins\n\n\n40\n\n\n\n\n\n\nDigital I/O Max input voltage\n\n\n5.0V\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nThere is \na monochrome version\n for you to print.\n\n\nGet Started\n\uf0c1\n\n\n\n\n\n\nClick \nthis link\n to login or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nCoding! Then you can compile the code and download the output binary.\n\n\nNow connect your Arch board to your pc and long press the reset button, it will automatically appear as a USB driver named CRP DISABLD. Go to the CRP DISABLD, delete the firmware file and copy the download binary file to CRP DISABLD. Quick press the reset button to run the new binary.\n\n\n\n\nYou can change the code as following and try again.\n\n\n    #include \nmbed.h\n\n\n    BusOut leds(LED1, LED2, LED3, LED4);\n\n    int main() {\n        uint8_t count = 0;\n        while(1) {\n            leds = count++;\n            wait(1);\n        }\n    }\n\n\n\n\nProgramming Arch on Windows, Linux or Mac\n\uf0c1\n\n\nArch does not have an mbed interface. It uses USB In-System-Programming(ISP) to upgrade the firmware.\n\n\nTo enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \nCRP DISABLD\n will appear.\n\n\n\n\n\n\nOn Windows\n\n\n\n\ndelete firmware.bin in the \nCRP DISABLD\n disk.\n\n\ncopy a new firmware into the disk.\n\n\n\n\n\n\n\n\nOn Linux\n\n\n\n\nif the disk is not mounted, mount the disk at \n{mnt_dir}\n\n\ndd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nOn Mac you will need to use Terminal to run the following script to copy you\nre .bin file to your Arch\n\n\n\n\ndd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nIf you are so inclined, you can also create an \nAutomator\n application to support drag-and-drop of the file to your board. Just create a \nRun Shell Script\n with the following command:\n\n\ndd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nYou will also need to change the \n\"Pass Input\"\n option from \n\"to stdin\"\n to \n\"as arguments\"\nwithout this you will get an error \n\"The action 'Run Shell Script' encountered an error\"\n or \n\"dd: no value specified for if (1)\"\n in the log.\n\n\nAlso, an improved form of the script is:\n\n\ndd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nWhich should handle spaces in the file path and only uses the first file supplied.\n\n\nQuick press the button to run the new firmware.\n\n\nApplications\n\uf0c1\n\n\n\n\nUse Seeeduino Arch as a debug adapter to debug another Seeeduino Arch\n\n\nSense environment\n\n\nPlay with Grove RTC\n\n\nPlay with Grove - Ultrasonic ranger\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematics of Arch V1.1", 
            "title": "Arch V1.1"
        }, 
        {
            "location": "/Arch_V1.1/#version-tracker", 
            "text": "Revision  Description  Release Date      Seeeduino Arch V1.0   Initial public release   2013-6-17    Arch V1.1   Change name from Seeeduino Arch to Arch  Switch D13 and D11  Add one Grove connector  Remove dual diode", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Arch_V1.1/#features", 
            "text": "mbed enabled   online development tools  easy to use C/C++ SDK  lots of published libraries, projects     Arduino form factor, three Grove connectors   available with 3.3V compatible shields  a large number of grove modules    Drag-n-drop programming  NXP LPC11U24 MCU  Low power ARM Cortex-M0 Core  48MHz, 32KB Flash, 8KB RAM, 4KB EEPROM  USB Device, 2xSPI, UART, I2C", 
            "title": "Features"
        }, 
        {
            "location": "/Arch_V1.1/#specifications", 
            "text": "Item  Typical      Work Voltage  7 ~ 12V    Microcontroller  LPC11U24    Flash Memory  32KB    EEPROM  4KB    RAM  8KB    UART  1    I2C  1    ADC Channels  8    I/O pins  40    Digital I/O Max input voltage  5.0V", 
            "title": "Specifications"
        }, 
        {
            "location": "/Arch_V1.1/#hardware-overview", 
            "text": "There is  a monochrome version  for you to print.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Arch_V1.1/#get-started", 
            "text": "Click  this link  to login or signup to mbed  Import the mbed_blinky program  Coding! Then you can compile the code and download the output binary.  Now connect your Arch board to your pc and long press the reset button, it will automatically appear as a USB driver named CRP DISABLD. Go to the CRP DISABLD, delete the firmware file and copy the download binary file to CRP DISABLD. Quick press the reset button to run the new binary.   You can change the code as following and try again.      #include  mbed.h \n\n    BusOut leds(LED1, LED2, LED3, LED4);\n\n    int main() {\n        uint8_t count = 0;\n        while(1) {\n            leds = count++;\n            wait(1);\n        }\n    }", 
            "title": "Get Started"
        }, 
        {
            "location": "/Arch_V1.1/#programming-arch-on-windows-linux-or-mac", 
            "text": "Arch does not have an mbed interface. It uses USB In-System-Programming(ISP) to upgrade the firmware.  To enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named  CRP DISABLD  will appear.    On Windows   delete firmware.bin in the  CRP DISABLD  disk.  copy a new firmware into the disk.     On Linux   if the disk is not mounted, mount the disk at  {mnt_dir}  dd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc     On Mac you will need to use Terminal to run the following script to copy you re .bin file to your Arch   dd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc     If you are so inclined, you can also create an  Automator  application to support drag-and-drop of the file to your board. Just create a  Run Shell Script  with the following command:  dd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  You will also need to change the  \"Pass Input\"  option from  \"to stdin\"  to  \"as arguments\" without this you will get an error  \"The action 'Run Shell Script' encountered an error\"  or  \"dd: no value specified for if (1)\"  in the log.  Also, an improved form of the script is:  dd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  Which should handle spaces in the file path and only uses the first file supplied.  Quick press the button to run the new firmware.", 
            "title": "Programming Arch on Windows, Linux or Mac"
        }, 
        {
            "location": "/Arch_V1.1/#applications", 
            "text": "Use Seeeduino Arch as a debug adapter to debug another Seeeduino Arch  Sense environment  Play with Grove RTC  Play with Grove - Ultrasonic ranger", 
            "title": "Applications"
        }, 
        {
            "location": "/Arch_V1.1/#resources", 
            "text": "Schematics of Arch V1.1", 
            "title": "Resources"
        }, 
        {
            "location": "/Xadow_Basic_Sensors/", 
            "text": "Xadow Basic Sensors integrates three different sensors on one single board:\n- 3-Axis Accelerometer for motion detection, activity monitoring and speed tracking\n- Dual diode Digital Light Sensor that can separately measure infrared, full-spectrum or human-visible light\n- Temperature Sensor for temperature monitoring.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nThree-in-one sensor board\n\n\nPlug-and-play if connected with RePhone Kit Create\n\n\nOpen source and modular design\n\n\nSlim and small\n\n\nBuilt-in 11 PIN Xadow Connectors for fully flexible connection with other Xadow Modules\n\n\nStackable, chain-able and sew-able with other Xadow Modules.\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\nOverview\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nMicrocontroller\n\n\nSTM32F030F4\n\n\n\n\n\n\nCore\n\n\nARM\u00ae 32-bit Cortex\u00ae -M0 CPU\n\n\n\n\n\n\nPower Supply\n\n\n3.3 ~ 6 V (via breakout pins)\n\n\n\n\n\n\nFlash\n\n\n16 KB\n\n\n\n\n\n\nSRAM\n\n\n4 KB\n\n\n\n\n\n\nClock Speed\n\n\n48 MHz\n\n\n\n\n\n\nOperating Temperature Range\n\n\n-30\u00b0C to 70\u00b0C\n\n\n\n\n\n\nInterfaces\n\n\nInterface with Xadow GSM+BLE through I2C (7-bit address 0x03)\n\n\n\n\n\n\nDimension\n\n\n25.37mm \u00d7 20.30mm / 1\u201d \u00d7 0.8\u201d\n\n\n\n\n\n\n\n\n3-Axis Accelerometer (ADXL345)\n\n\n\n\n\n\n\n\nItem\n\n\nvalue\n\n\n\n\n\n\n\n\n\n\nTest g Range\n\n\n\u00b12g (default), \u00b14g, \u00b18g, or \u00b116g\n\n\n\n\n\n\nResolution\n\n\nIncrease with g range, up to 13-bit resolution at \u00b116g\n\n\n\n\n\n\n\n\nDigital Light Sensor (TSL2561) \n Approximates Human Eye Response\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nDynamic Range (Lux)\n\n\n0.1 to 40,000 Lux\n\n\n\n\n\n\nDual Photodiodes\n\n\nInfrared and full spectrum\n\n\n\n\n\n\n\n\nTemperature Sensor (LM75ADP)\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nTemperature Range\n\n\n-55\u00b0C to 125 \u00b0C\n\n\n\n\n\n\nAccuracy\n\n\n\u00b1 2\u00b0C for temperature range from -25\u00b0C to 100\u00b0C\n\u00b1 3\u00b0C for temperature range from -55\u00b0C to 25\u00b0C and from 100 \u00b0C to 125\u00b0C\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nUse it with RePhone Kit Create\n\uf0c1\n\n\n\n\nObtain the Sensor Data\n\n\nWithout any programming, you can connect it to the Core Module (Xadow GSM+BLE) of your \u2018RePhone Kit Create\n to read all the data from the sensors.\n\n\n\nSet \nIf This Then That\n\n\nYou can also set the sensor data as a condition to trigger a series of actuators like audio, LED matrix and LED strip, or trigger actions like making a call and sending a message.\n\n\n\nRePhone Community\n\uf0c1\n\n\n\n\n\n\nWe\u2019ve been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the \nRePhone Community\n.\n\n\nNow join us in the \nRePhone Community\n! Together we seek answers, make interesting stuff, care about each other, and share our experiences.\n\n\nFrequently Asked Questions\n\n\nSome frequently asked questions in \nRePhone Community\n are collected and answered to the topic \nFrequently Asked Questions of RePhone (FAQ)\n , the topic will be kept updating whenever a new FAQ comes out.\n\n\nResources\n\uf0c1\n\n\n\n\nWe will be keep updating the source code on our github page:\n- \nSource Code for Xadow Basic Sensors\n\n\nThe schematic diagram of Xadow Basic Sensors is provided in the following link:\n- \nXadow Duino Schematic Files\n\n\nCheck more info about the datasheet for each sensors:\n- ADXL345 - 3_Axis Acceserometer\n- LM75A NXP - Temperature Sensor\n- TSL2561 - Light Sensor\n\n\nAnd the MCU STM32F030F4:\n- STM32F030F4\n\n\nHelp us to make it better\n\uf0c1\n\n\n\n\nThank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.\n\n\nIt is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:\n\n\n\n\nReplace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.\n\n\nReview and rewrite documents for hundreds of products to make them more understandable.\n\n\nInspect and repair all the URL to make sure it can be linked to the right page.\n\n\n\n\nAlthough we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.\n\n\nBy the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Xadow - Basic Sensors"
        }, 
        {
            "location": "/Xadow_Basic_Sensors/#features", 
            "text": "Three-in-one sensor board  Plug-and-play if connected with RePhone Kit Create  Open source and modular design  Slim and small  Built-in 11 PIN Xadow Connectors for fully flexible connection with other Xadow Modules  Stackable, chain-able and sew-able with other Xadow Modules.", 
            "title": "Features"
        }, 
        {
            "location": "/Xadow_Basic_Sensors/#specification", 
            "text": "Overview     Item  Value      Microcontroller  STM32F030F4    Core  ARM\u00ae 32-bit Cortex\u00ae -M0 CPU    Power Supply  3.3 ~ 6 V (via breakout pins)    Flash  16 KB    SRAM  4 KB    Clock Speed  48 MHz    Operating Temperature Range  -30\u00b0C to 70\u00b0C    Interfaces  Interface with Xadow GSM+BLE through I2C (7-bit address 0x03)    Dimension  25.37mm \u00d7 20.30mm / 1\u201d \u00d7 0.8\u201d     3-Axis Accelerometer (ADXL345)     Item  value      Test g Range  \u00b12g (default), \u00b14g, \u00b18g, or \u00b116g    Resolution  Increase with g range, up to 13-bit resolution at \u00b116g     Digital Light Sensor (TSL2561)   Approximates Human Eye Response     Item  Value      Dynamic Range (Lux)  0.1 to 40,000 Lux    Dual Photodiodes  Infrared and full spectrum     Temperature Sensor (LM75ADP)     Item  Value      Temperature Range  -55\u00b0C to 125 \u00b0C    Accuracy  \u00b1 2\u00b0C for temperature range from -25\u00b0C to 100\u00b0C \u00b1 3\u00b0C for temperature range from -55\u00b0C to 25\u00b0C and from 100 \u00b0C to 125\u00b0C", 
            "title": "Specification"
        }, 
        {
            "location": "/Xadow_Basic_Sensors/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Xadow_Basic_Sensors/#use-it-with-rephone-kit-create", 
            "text": "Obtain the Sensor Data  Without any programming, you can connect it to the Core Module (Xadow GSM+BLE) of your \u2018RePhone Kit Create  to read all the data from the sensors.  Set  If This Then That  You can also set the sensor data as a condition to trigger a series of actuators like audio, LED matrix and LED strip, or trigger actions like making a call and sending a message.", 
            "title": "Use it with RePhone Kit Create"
        }, 
        {
            "location": "/Xadow_Basic_Sensors/#rephone-community", 
            "text": "We\u2019ve been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the  RePhone Community .  Now join us in the  RePhone Community ! Together we seek answers, make interesting stuff, care about each other, and share our experiences.  Frequently Asked Questions  Some frequently asked questions in  RePhone Community  are collected and answered to the topic  Frequently Asked Questions of RePhone (FAQ)  , the topic will be kept updating whenever a new FAQ comes out.", 
            "title": "RePhone Community"
        }, 
        {
            "location": "/Xadow_Basic_Sensors/#resources", 
            "text": "We will be keep updating the source code on our github page:\n-  Source Code for Xadow Basic Sensors  The schematic diagram of Xadow Basic Sensors is provided in the following link:\n-  Xadow Duino Schematic Files  Check more info about the datasheet for each sensors:\n- ADXL345 - 3_Axis Acceserometer\n- LM75A NXP - Temperature Sensor\n- TSL2561 - Light Sensor  And the MCU STM32F030F4:\n- STM32F030F4", 
            "title": "Resources"
        }, 
        {
            "location": "/Xadow_Basic_Sensors/#help-us-to-make-it-better", 
            "text": "Thank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.  It is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:   Replace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.  Review and rewrite documents for hundreds of products to make them more understandable.  Inspect and repair all the URL to make sure it can be linked to the right page.   Although we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.  By the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Help us to make it better"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/", 
            "text": "Whether making and receiving telephone calls over a radio link using external speakers and microphone or exchanging data in short distances with Bluetooth, you can do it with Xadow GSM+BLE.\n\n\nAs the heart of RePhone kit Create, the Xadow GSM+BLE is built around the powerful System-On-Chip (SOC) MT2502, offering a rich range of communication protocols - GSM, GPRS and Bluetooth (v4.0 and 2.1 dual mode). It supports quad-band 850/900/1800/1900MHz that covers any GSM network in the world. Just insert a 2G Nano SIM card, and then you can enchant things with cellular connectivity.\n\n\n  \n\n\nFeatures\n\uf0c1\n\n\n\n\nBased on the smallest commercial System-on-Chip  \n\n\n(5.4mm x 6.2mm) currently on the market  \n\n\nOpen source and modular design  \n\n\nSlim and small  \n\n\nBuilt-in Xadow Connectors for easy pluggable FPC cables  \n\n\nStackable, chain-able and sew-able with other Xadow Modules  \n\n\nCore module for most of RePhone Kits  \n\n\nPerfect choice for long distance and short-range communication  \n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nMicrocontroller\n\n\nMT2502\n\n\n\n\n\n\n\n\n\n\nMCU Core\n\n\n32-bit ARM7EJ-STM RISC processor\n\n\n\n\n\n\nRAM\n\n\n4 MB\n\n\n\n\n\n\nFlash Memory\n\n\n16 MB\n\n\n\n\n\n\nPower Supply\n\n\n3.3 ~ 4.2V(no SIM)/3.5 ~ 4.2V(with SIM)\n\n\n\n\n\n\nPower Consumption\n\n\n20mW/30mW/52mW @ standby(no radio)/standby(GSM)/standby(BT)\n\n\n\n\n\n\nQuad-band\n\n\n850/900/1800/1900 MHz\n\n\n\n\n\n\nGPRS\n\n\nClass 12 modem\n\n\n\n\n\n\nClock Speed\n\n\n260 MHz\n\n\n\n\n\n\nConnectors\n\n\n35 PIN Connector \n 11 PIN Connector for Xadow Modules; JST 1.0 Connector for the battery\n\n\n\n\n\n\nInterfaces\n\n\nLCD, Audio, I2C, SPI, UART, and GPIOs etc\n\n\n\n\n\n\nDimensions\n\n\n25.37mm \u00d7 20.30mm / 1\u201d \u00d7 0.8\u201d\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n \n\n\nThe image below illustrates the Pin Definitions of 11 Pin Xadow Connector, Solder-able Breakout Pins and the 35 Pin Xadow Connector in a sequence from \nLeft to Right\n.  \n\n\n  \n\n\nPower Up\n\uf0c1\n\n\nPower up the RePhone/Xadow GSM+BLE with a battery of \n3,5V ~ 4,2V\n and \nJST 1.0 male connector\n, or power it up through the breakout \nPIN 3(VCC)\n and breakout \nPIN 6(GND)\n as illustrated in the Hardwareview above.  \n\n\nBattery Charging\n\uf0c1\n\n\nXadow GSM+BLE uses the \nJST 1.0 female connector\n for the battery, you can charge the battery by simply connect your board with a USB cable.  \n\n\nOperating Mode\n\uf0c1\n\n\nThe Xadow GSM+BLE has two operating mode when you power it up and connect it with PC - \npress and hold to power key for 2 seconds\n to turn the module \nON\n or \nOFF\n to access the \nMass Storage Mode\n or \nFlash/Debug Mode.\n\n\n  \n\n\nMass Storage Mode\n\uf0c1\n\n\nWhen the Xadow GSM+BLE is \nOFF\n, connect the board (with battery connected) to PC via Micro USB cable, you can access the 5MB \u2018Mass Storage Mode\u2019 on PC. All the applications (vxp files) and system settings are stored in this 5MB disk.\n\n\n  \n\n\nFlash/Debug Mode\n\uf0c1\n\n\nWhen the Xadow GSM+BLE is \nON\n, connect the board (with battery connected) to PC via Micro USB cable, you can find two \nCOM ports\n on your \n\u2018Device Manager\u2019\n\uff1a \n\n\n\n\nMTK USB Debug Port(COM4)\n  \n\n\nMTK USB Modem Port(COM5)\n  \n\n\n\n\nThe COM number might be different on your PC. Each COM port has different function according to the development environment you use, please refer to the Getting Started section for more details.  \n\n\nOpen \nDevice Manager\n by clicking the \nStart\n button, clicking \nControl Panel\n, clicking \nSystem and Security\n, and then, under \nSystem\n, clicking \nDevice Manager\n. If you\nre prompted for an administrator password or confirmation, type the password or provide confirmation. See the following image:\n\n\n  \n\n\nGetting Started\n\uf0c1\n\n\nWe have developed rich libraries hooking into Arduino IDE, Lua and JavaScript, with detailed example sketches to help entry-level programmers develop with RePhone modules easily and quickly.\n\n\nWe also provide a powerful SDK based on Eclipse IDE for C/C++ developers to work with more intelligent applications.\n\n\n  \n\n\n \n \n\n\n\n\n \n \n\n\nFor more info you can refer to the RePhone Development Environment at RePhone Main Page:  \n\n\n\nRePhone Development Environment\n  \n\n\nRelated Projects\n\uf0c1\n\n\nCheck on awesome RePhone projects that has been achieved with RePhone.\n\n\nA Traceable Dog Collar\n\n5 steps to make a traceable dog collar for your lovely puppy. \n\n\n  \n\n\nRePhone Community\n\uf0c1\n\n\n \n \n\nWe\u2019ve been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the RePhone Community.\n\n\nNow join us in the \nRePhone Community\n! Together we seek answers, make interesting stuff, care about each other, and share our experiences.\n\n\nFrequently Asked Questions\n\uf0c1\n\n\nSome frequently asked questions in RePhone Community are collected and answered to the topic \nFrequently Asked Questions of RePhone (FAQ)\n , the topic will be kept updating whenever a new FAQ comes out.  \n\n\nResources\n\uf0c1\n\n\nThe schematic diagram of Xadow GSM+BLE is provided in the following link:\n\n\n- Xadow_GSM+BLE eagle files \n\nCheck more info about the chipset MT2502:\n\n\n- Datasheet for eagle files\n\nCheck out this excel for the compatibility with Xadow 1.0 modules:\n\n\n- Compatibility between GSM+BLE and Xadow 1.0 modules", 
            "title": "Xadow GSM&#43;BLE"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#features", 
            "text": "Based on the smallest commercial System-on-Chip    (5.4mm x 6.2mm) currently on the market    Open source and modular design    Slim and small    Built-in Xadow Connectors for easy pluggable FPC cables    Stackable, chain-able and sew-able with other Xadow Modules    Core module for most of RePhone Kits    Perfect choice for long distance and short-range communication", 
            "title": "Features"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#specification", 
            "text": "Microcontroller  MT2502      MCU Core  32-bit ARM7EJ-STM RISC processor    RAM  4 MB    Flash Memory  16 MB    Power Supply  3.3 ~ 4.2V(no SIM)/3.5 ~ 4.2V(with SIM)    Power Consumption  20mW/30mW/52mW @ standby(no radio)/standby(GSM)/standby(BT)    Quad-band  850/900/1800/1900 MHz    GPRS  Class 12 modem    Clock Speed  260 MHz    Connectors  35 PIN Connector   11 PIN Connector for Xadow Modules; JST 1.0 Connector for the battery    Interfaces  LCD, Audio, I2C, SPI, UART, and GPIOs etc    Dimensions  25.37mm \u00d7 20.30mm / 1\u201d \u00d7 0.8\u201d", 
            "title": "Specification"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#hardware-overview", 
            "text": "The image below illustrates the Pin Definitions of 11 Pin Xadow Connector, Solder-able Breakout Pins and the 35 Pin Xadow Connector in a sequence from  Left to Right .", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#power-up", 
            "text": "Power up the RePhone/Xadow GSM+BLE with a battery of  3,5V ~ 4,2V  and  JST 1.0 male connector , or power it up through the breakout  PIN 3(VCC)  and breakout  PIN 6(GND)  as illustrated in the Hardwareview above.", 
            "title": "Power Up"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#battery-charging", 
            "text": "Xadow GSM+BLE uses the  JST 1.0 female connector  for the battery, you can charge the battery by simply connect your board with a USB cable.", 
            "title": "Battery Charging"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#operating-mode", 
            "text": "The Xadow GSM+BLE has two operating mode when you power it up and connect it with PC -  press and hold to power key for 2 seconds  to turn the module  ON  or  OFF  to access the  Mass Storage Mode  or  Flash/Debug Mode.", 
            "title": "Operating Mode"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#mass-storage-mode", 
            "text": "When the Xadow GSM+BLE is  OFF , connect the board (with battery connected) to PC via Micro USB cable, you can access the 5MB \u2018Mass Storage Mode\u2019 on PC. All the applications (vxp files) and system settings are stored in this 5MB disk.", 
            "title": "Mass Storage Mode"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#flashdebug-mode", 
            "text": "When the Xadow GSM+BLE is  ON , connect the board (with battery connected) to PC via Micro USB cable, you can find two  COM ports  on your  \u2018Device Manager\u2019 \uff1a    MTK USB Debug Port(COM4)     MTK USB Modem Port(COM5)      The COM number might be different on your PC. Each COM port has different function according to the development environment you use, please refer to the Getting Started section for more details.    Open  Device Manager  by clicking the  Start  button, clicking  Control Panel , clicking  System and Security , and then, under  System , clicking  Device Manager . If you re prompted for an administrator password or confirmation, type the password or provide confirmation. See the following image:", 
            "title": "Flash/Debug Mode"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#getting-started", 
            "text": "We have developed rich libraries hooking into Arduino IDE, Lua and JavaScript, with detailed example sketches to help entry-level programmers develop with RePhone modules easily and quickly.  We also provide a powerful SDK based on Eclipse IDE for C/C++ developers to work with more intelligent applications.                 For more info you can refer to the RePhone Development Environment at RePhone Main Page:    \nRePhone Development Environment", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#related-projects", 
            "text": "Check on awesome RePhone projects that has been achieved with RePhone.  A Traceable Dog Collar \n5 steps to make a traceable dog collar for your lovely puppy.", 
            "title": "Related Projects"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#rephone-community", 
            "text": "We\u2019ve been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the RePhone Community.  Now join us in the  RePhone Community ! Together we seek answers, make interesting stuff, care about each other, and share our experiences.", 
            "title": "RePhone Community"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#frequently-asked-questions", 
            "text": "Some frequently asked questions in RePhone Community are collected and answered to the topic  Frequently Asked Questions of RePhone (FAQ)  , the topic will be kept updating whenever a new FAQ comes out.", 
            "title": "Frequently Asked Questions"
        }, 
        {
            "location": "/Xadow_GSMPlusBLE/#resources", 
            "text": "The schematic diagram of Xadow GSM+BLE is provided in the following link:  - Xadow_GSM+BLE eagle files  \nCheck more info about the chipset MT2502:  - Datasheet for eagle files \nCheck out this excel for the compatibility with Xadow 1.0 modules:  - Compatibility between GSM+BLE and Xadow 1.0 modules", 
            "title": "Resources"
        }, 
        {
            "location": "/Wio_Link/", 
            "text": "What\ns the toughest part of building IoT applications? Someone says the jump wires usually make him frustrated, while the other guy says he hates soldering the most. There are even some people who don\nt like breadboard. Maybe you are not one of them, but the knowledge of electronic engineering, micro-controller programming, network programming, IoT protocols handling are still great burden between you and a successful IoT project.\n\n\n\n\nIn order to simplify all these steps, at the end of 2015, Seeed Studio initiated Wio Link on \nKickStarter\n, defined a new way of developing IoT applications. Wio Link is an ESP8266 SoC based open-source Wi-Fi development board, the best part of it is the associated platform that allows users to create IoT applications by virtualizing plug-n-play modules to RESTful APIs with mobile Apps. It means that there will be no hardware programming, no breadboard, no jumper wires, and no soldering, just by installing an App on your mobile phone, you are able to build a simple IoT project in 5 minutes.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nNo hardware programming, No breadboard, No jumper wires, No soldering required.\n\n\nA lot of Grove modules are supported (Check the list in Mobile App).\n\n\nPlug-n-Play Grove Modules\n\n\nVisual configuration instead of microcontroller programming.\n\n\nUpdate automatically via cloud compiling and OTA.\n\n\nBring real world to virtual platform. All sensors become virtual RESTful API.\n\n\nAndroid \n iOS Apps to manage Wio Link.\n\n\nIFTTT supported by Seeed\ns Channel\n\n\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nGeneral\n\n\nValue\n\n\nPower Management\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSize\n\n\n55mm * 48mm\n\n\nDC Current Per I/O Pin\n\n\n12mA\n\n\n\n\n\n\nCrystal\n\n\n26MHz\n\n\nInput Voltage (Micro USB)\n\n\n5V\n\n\n\n\n\n\nFlash Memory\n\n\n4MBytes (W25Q32B)\n\n\nInput Voltage (Battery holder)\n\n\n3.4~4.2V\n\n\n\n\n\n\nWi-Fi Network Protocol\n\n\n802.11b/g/n\n\n\nOutput DC Current\n\n\n1000mA MAX\n\n\n\n\n\n\nWi-Fi Encryption Technology\n\n\nWEP/TKIP/AES\n\n\nOperating Voltage\n\n\n3.3V\n\n\n\n\n\n\nGrove Connectors\n\n\n6\n\n\nCharge Current\n\n\n500mA MAX\n\n\n\n\n\n\nFlash\n\n\n4MB (W25Q32B)\n\n\n\n\n\n\n\n\n\n\n\n\nMake with Wio Link\n\uf0c1\n\n\n\n\nWio Link is well designed to provide simple Wi-Fi solutions for projects like:\n\n\n\n\nSmart Home\n\n\nIntelligent environmental monitoring\n\n\nFunny Toys\n\n\nWeb of Things\n\n\nInternet of Things\n\n\n\n\nIn fact, we have already designed many projects in our \nrecipe\n, come and visit it to find some interesting projects or even share you own projects, I am sure it will gain a lot of fans for you ~\n\n\n\n\n\n\n\n\nIrrigation control system\n\n\nThe internet of led wall\n\n\nDog feeding machine\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW\n\n\nMAKE IT NOW\n\n\nMAKE IT NOW\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKickstarter Monitor\n\n\nMIssing Call Monitor\n\n\nBoss Key\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW\n\n\nMAKE IT NOW\n\n\nMAKE IT NOW\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nSome of the recipe are made for Wio Node, but it can apply to Wio Link too.\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n\n\n\n\n\n\nPart\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\nMCU\n\n\nESP8266\n\n\n\n\n\n\nDigital Port 0\n\n\nGPIO 14\n\n\n\n\n\n\nDigital Port 1\n\n\nGPIO 12\n\n\n\n\n\n\nDigital Port 2\n\n\nGPIO 13\n\n\n\n\n\n\nAnalog Port\n\n\nA3\n\n\n\n\n\n\nUART Port\n\n\nPin 1 \n Pin 3\n\n\n\n\n\n\nI2C Port\n\n\nPin 4 \n Pin 5\n\n\n\n\n\n\nStatus Light\n\n\nBlue LED is the WiFi status indicator, Red LED indicates the working status\n\n\n\n\n\n\nConfigure Button\n\n\nTo configure and manage your Wio Link\n\n\n\n\n\n\nBattery Holder\n\n\nJST2.0\n\n\n\n\n\n\nMicro USB\n\n\nTo power the board or communicate to the PC\n\n\n\n\n\n\nReset Button\n\n\nTo reset the MCU\n\n\n\n\n\n\n\n\nStatus LEDs\n\uf0c1\n\n\nNear to the FUNCTION button there\u2019re 2 status Leds, a blue one and a red one. The BLUE led is the network status indicating led. It has the following blink patterns:\n\n\n\n\nbreathing Under configuration mode\n\n\nblink twice quickly then off 1s requesting IP address from router\n\n\nblink once quickly then off 1s connecting to the server\n\n\non 1s then off 1s The node is online\n\n\non constantly the node is dead for not getting IP or not connecting to server.\n\n\nblink quickly (on 100ms then off 100ms) OTA  \n\n\n\n\n\n\nNote\n\n\n\n\nThe BLUE led is attached to GPIO2 which is also the TX pin of UART1. When downloading firmware, the UART1 dumps the data transmitting on UART0 by instinct. So the BLUE led will blink while downloading firmware. After startup the GPIO2 will be configured as a GPIO not TX of UART1.\n\n\n\n\n\n\nThe RED led is another status led which indicates the power status of Grove modules. All the six Grove interface\u2019s VCC converge together and can be controlled with GPIO 15. When the node is in deep sleep mode, all the grove modules lose their power too. The RED led will light on when Grove modules are powered and will go off when Grove modules aren\u2019t powered.\n\n\nBonus!\n\uf0c1\n\n\nWio Link has an inbuilt LiPo battery charger, so you can charge 3.7v LiPo battery through JST 2.0 Port when USB is connecting.\n\n\n\n\n\n\nNote\n\n\n\n\nBattery needs to be bought separately. Please visit \nBazzar\n where we arranged many choices for you.\n\n\n\n\n\n\nGet Started\n\uf0c1\n\n\n\n\nLet us build a very basic LED application with Wio Link, in this application you will be able to control LED by your smartphone in about 5 minutes. Before we start, please make sure you have below things on hand:\n\n\n\n\n\n\n\n\nWio Link\n\n\nGrove - LED\n\n\nMicro USB Cable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nA smartphone is needed as well (Android OS version 4.1 or advanced, iOS version 7 or advanced)\n\n\nGrove - LED include a Grove cable already\n\n\n\n\n\n\nSTEP 1:\n Install Android/iOS App\n\uf0c1\n\n\nYou need to install the Wio Link App to manage and configure your Wio Link devices.\n\n\nDownload the Android or iOS App and install. Or you can go to App Store of Apple or Google Market and search \nWio Link\n, you will find it.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet Android App\n\n\nGet iOS App\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nMake sure your Android OS version is 4.1 or advanced, iOS version is 7 or advanced.\n\n\n\n\n\n\nSTEP 2:\n Create your Account\n\uf0c1\n\n\n\n\nIf it is your first time to use Wio APP, it may require GPS authorization, please approve it, then sign up.\n\n\nIf you already have an account, check the server location before logging in.\n\n\n\n\n\n\nNote\n\n\n\n\nPlease pay attention to the server location, because wrong server location will lead to failure when connecting to Wio Link.\n\n\n\n\n\n\n\n\nSTEP 3\n: Connect Wio Link Wi-Fi AP\n\uf0c1\n\n\n\n\nPush and hold the CONFIG button until the blue LED turns into breathing mode (i.e. blinking with fade in \n fade out effect). It means that Wio Link has turned to configuration mode successfully and can be detected by the Wio App.\n\n\n\n\n\n\n\n\nPush \nAdd your first Device\n.\n\n\nChoose Wio Link\n\n\nGo to Wi-Fi list\n will lead you to the Wi-Fi setting interface of your smartphone.\n\n\n\n\n\n\n\n\nIf you have successfully made the blue LED turn into breathing mode, you will find the Wio Link in the Wi-Fi list, connect to it!(Usually it is not called Wio Link in the Wi-Fi list, in the example, mine is Wio_8B2F12, you may find one named wio_xxxxxx in your list.)\n\n\nOnce connected, you will receive a notice, then you can go back to the app\n\n\nNext step is connecting to the Wi-Fi of your home or company\n\n\n\n\n\n\n\n\nIf there is password pf the Wi-Fi you want to connect, it may require you to enter the password\n\n\nConsider that you may need to connect more than 1 Wio device in the future, a special name will make you distinguish them from each other easily.\n\n\n\n\n\n\nSTEP 4:\n Virtually interconnect modules with Wio Link and update firmware\n\uf0c1\n\n\n\n\nClick the Wio Link and you will be in the main interface.\n\n\nThere are 6 grove connectors, select the first one on the left.\n\n\nBecause LED is output devices. Choose output category\n\n\nFind the icon that looks like a bulb, choose it.\n\n\nThen you will find the bottom rectangle button becomes red and \nView API\n becomes \nUpdate Firmware\n. Choose \nUpdate Firmware\n\n\n\n\n\n\n\n\nSince you selected the Digital 0 port to connect with LED in the APP, you need to connect the real Grove-LED to Digital 0 port of Wio Link too.\n\n\n\n\n\n\nSTEP 5\n: Test application using APIs\n\uf0c1\n\n\n\n\nNow that  you have successfully connect the LED to Wio Link, click \nView API\n to check the API of Wio Link\n\n\nInput \n1\n or \n0\n in the \nTest Request\n area, and click \nPost\n button and see what will happen.\n\n\n\n\n\n\nGet started with IFTTT \n DoButton\n\uf0c1\n\n\n\n\nDont\nt know how to code? Don\nt worry, with the help of \nIFTTT\n, even if you know nothing about coding, you are still able to build some simple projects.\n\n\nIFTTT is an abbreviation of \nIf This Then That\n, it is a free web-based service that allows users to create chains of simple conditional statements, called \nrecipes\n, which are triggered based on changes to other web services such as Gmail, Facebook, Instagram. How does IFTTT work with Wio Link? As you can see in below pictures, Seeed provided cloud service at wio.seeed.io, which can interchange data and send instructions to IFTTT and Wio Link. So by creating some simple recipe, you are able to hack things without coding.\n\n\n\n\nIf you don\nt have an IFTTT account, click \nhere\n to sign up.\n\n\nIf you already have an IFTTT account,click \nhere\n to connect with Seeed, or search Seeed at IFTTT website. There you will find 9 recipes by Seeed to teach you how to us e IFTTT.\n\n\n\nWhat is DoButton? DoButton is one of IFTTT\ns application that empowers you to create your own personalized button with just a tap, it is very suitable for building IoT projects and control it through your smartphone, here are two examples to show you how to use IFTTT\nDoButton to make useful applications.\n\n\nExample:\n\uf0c1\n\n\n\n\n\n\n\n\nIFTTT\n\n\nDoButton\n\n\n\n\n\n\n\n\n\n\n[\nRecipe\n]\nDIY an Automatic Garden Irrigation without coding\n\n\n[\nRecipe\n]\nHow to feed your pets when you\nre not home\n\n\n\n\n\n\n[\nVideo\n]\nHow to use ITFFF\n\n\n[\nVideo\n]\nHow to use DoButton\n\n\n\n\n\n\n\n\nGuide for advanced users\n\uf0c1\n\n\n\n\nFeel those examples too simple? Wanna make more complicated projects? Here are the best guides for advanced users to hack things with Wio Link. By these guides, advanced users are able to know more detail information about Wio Link, deploy private server, even write module driver for Wio Link.\n\n\n\n\nThe guide covers:\n\n\n\n\nAPI Reference\n\n\nServer Deployment Guide\n\n\nAdvanced User Guide\n\n\nHow to write module driver for Wio Link?\n\n\n\n\nAdvanced Tutorial\n\uf0c1\n\n\nIf you have successfully controlled the grove-led with your smartphone, and want to try something more difficult and not that complicated, why not try this tutorial, after learning it, you will be able to  build a temperature and humidity monitor and light up the RGB Led strip with Wio Link.\n\n\nBefore you start, please check if you have below devices on hand.\n\n\n\n\n\n\n\n\nRGB Led strip\n\n\nGrove-Temperature and Humidity Sensor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet One Now\n\n\nGet One Now\n\n\n\n\n\n\n\n\n\n\nStep1: Remove the Grove LED from the grove connector, plug the Led strip to Wio Link and drag the same module to Wio Link in the App.\n\n\nUpdate the firmware.\n\n\n\n\n\n\n\n\nStep2\uff1aPlug the Grove-Temperature and Humidity Sensor to Wio Link and drag the same module to Wio Link in the App.\n\n\nUpdate the firmware.\n\n\n\n\n\n\n\n\nStep3: View the APIs and read the temperature \n humidity in your house. Below image shows the temperature change before and after holding the grove in hand. I increased the temperature by 1 Celsius. Try and see how you can change the temperature and humidity in your house.\n\n\n\n\n\n\n\n\nStep4: Control the light of Led strip by changing RGB value.\n\n\n\n\nBecause the Wio Link App read hex RGB value, RGB value need to be converted to hex value. Here I would like to recommend the website \nRGB t0 Hex\n. Just by inputting RGB value for the 3 RGB elements (Red, Green, Blue), the website will converts the RGB value to hex very easily. Here is some example.\n- Input 255, 0, 0\n\n\n\n\n\n\nConvert it, then you will get the hex value as FF0000, the color is Red.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nThe RGB value you input should be any nature number between 0 and 255 (Including 0 and 255)\n\n\n\n\n\n\nThen input how many Leds you want to lighten and the hex value in the app, here my Led strip has 30 Leds, so I lighten all of them.\n\n\n\n\nYou can also specific which part of the strip be lighted and give a special color to it, or even make like blink in rainbow mode. A lot of amazing functions are waiting for your exploration!\n\n\nResource\n\uf0c1\n\n\n\n\nHardware\n\n\n\n\nEAGLE Schematic files\n\n\nEAGLE PCB file\n\n\nSchematic files(pdf)\n\n\n\n\nSoftware\n\n\n\n\nSource Code on Github.\n\n\n\n\nMore documentation and references\n\n\n\n\nAPI Reference\n\n\nServer Deployment Guide\n\n\nHow to write module driver for Wio Link\n\n\niot.seeed.cc\n to get more info.\n\n\n\n\nFAQ\n\uf0c1\n\n\n\n\nHere are some questions that we usually received from new users. If you have any other issues when you are using Wio Link or other Wio products, welcome to the \nCommunity of Wio\n where there are many professional users waiting to give you advices and also many advanced users providing plenty of ideas on how to use Wio products!\n\n\n1. Power \n Battery \uff0d Does Wio Link come with a Lipo battery?\n\n\nNope. Each Wio Link goes with a micro USB cable for charging or you can purchase a 3.7V Lipo battery from our Bazzar. Here\u2019s the specs for your reference:\n- maximum input voltage: 4.2V;\n- maximum charging current: 500mA.\n\n\n2. Power \n Battery - Can I use a power adapter with Wio Link? Which type? And common battery holders?\n\n\nThere are two ways to power the Wio Link, Micro USB cable or a 3.7V Lipo battery. If both Micro USB and battery are plugged into the board, the battery will be charged by the USB power. You can use all kinds of power adapter which can connect with Micro USB cable and 5Vdc output. The battery holder is a JST-2.0 connector.\n\n\n3. Power Consumption - What\u2019s the power consumption of Wio Link?\n\n\nThe average power consumption is 70mA. With a battery of 700mAh, it can keep alive up to 10 hours. There are Low-Power-APIs which allows you to change the Wio Link from working-mode to sleeping-mode. It will reduce average power consumption to 150uA or less.\n\n\n4. Grove Cables - Are the Groves equipped with cables in all kits?\n\n\nYes, we have each Grove modules packed with one standard 4-pin Grove cable.\n\n\n5. RESTful APIs - Where are the endpoints? The calls aren\nt required to go through some cloud servers are they? Is it an internet connection required or can they be made all through a local network?\n\n\nWe deploy the REST API server to iot.seeed.cc, so you can get access to sensor and actuator from iot.seeed.cc. At the moment, Wio Link must connect to the Internet. Also, we will open-source the server so as to enable users deploy local servers in very simple Docker way. With local servers deployed, they can utilize the compiling and data exchange service locally instead of going online.\n\n\n6. Programming Methods Supported - Will other programming methods be supported, such as Arduino IDE?\n\n\nWio Link can be programed with Arduino IDE, in that case it will lose the functionality of RESTful APIs except you implement another one in the same time. Wio Link is mostly expected to archive the Web of Things conversion for physical hardware, so interactions are expected to perform in web / internet. But no worries, the software architecture is flexible, you can pull down the source code to local and connect Wio Link to the local servers, then you could modify the source code which will be compiled.\n\n\nIf you would like to interact with Arduino or RPI, you can develop a 3rd-party module driver and here\u2019s the guide: https://github.com/Seeed-Studio/Wio_Link/wiki/How-to-write-module-driver-for-Wio-Link%3F and example driver: https://github.com/Seeed-Studio/Wio_Link/tree/master/grove_drivers/grove_example\n\n\n7. Platform Supported -Does Wio Link support Windows Platform?\n\n\nBy now Wio Link provides Android and iOS two mobile Apps. We have all services as RESTful API, such like user accounts and OTA, following API documents, the third-party developers can build their own applications say Mobile Apps or Desktop Apps.\nWio Link is an community friendly project. It won\nt be limited to a certain platform. We really expect people can play with Wio Link in their way.\n\n\n8. Can I use Wio Link to interact with existing systems?\n\n\nYes. Who Link can interact with your existing system in several ways. First, connect any GPIO of Wio Link to other system, select \u201cGeneric Digital Input\u201d or \u201cGeneric Digital Output\u201d virtual Grove modules in the mobile App, then send/read signals to/from the existing system with RESTful API calls. Second, connect the analog port of Wio Link to other system, select \u201cGeneric Analog Input\u201d virtual Grove module in the mobile App, then read analog measurement for some physical quantity of your existing system. Third, to interact with existing system more flexible, you can develop a 3rd party module driver in which dispatch the requests from internet to your existing system through I2C or UART interface. We have a guide[1] about how to develop 3rd party module driver and also we can provide technical support for your development.\n\n\n[1]https://github.com/Seeed-Studio/Wio_Link#how-to-write-module-driver-for-wio-link\n\n\n9. How many Groves supported on Wio Link?\n\n\nThere are 150+ kinds of plug and play Groves modules available, among which 36 were supported on Wio Link till now, and you can find most of them in the Rewards, we\nre working to add more continuously.\n\n\nHere\ns the list of supported Groves so far:\n\n\nGrove Support List\n\uf0c1\n\n\n\n\n\n\n\n\nSKU\n\n\nName\n\n\nInterface\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n101020008\n\n\nGrove - Moisture Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020014\n\n\nGrove - Light Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020015\n\n\nGrove - Temperature Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020017\n\n\nGrove - Rotary Angle Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020022\n\n\nGrove - Light Sensor(P)\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020023\n\n\nGrove - Sound Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020027\n\n\nGrove - Electricity Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020036\n\n\nGrove - Slide Potentiometer\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020042\n\n\nGrove - 80cm Infrared Proximity Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020043\n\n\nGrove - UV Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020048\n\n\nGrove - Rotary Angle Sensor(P)\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020063\n\n\nGrove - Loudness Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020076\n\n\nGrove - Luminance Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020078\n\n\nGrove - Air quality sensor v1.3\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020003\n\n\nGrove - Button\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020004\n\n\nGrove - Switch(P)\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020005\n\n\nGrove - Collision Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020009\n\n\nGrove - Line Finder\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020018\n\n\nGrove - Water Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020020\n\n\nGrove - PIR Motion Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020025\n\n\nGrove - Tilt Switch\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020037\n\n\nGrove - Touch Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020038\n\n\nGrove - Magnetic Switch\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020046\n\n\nGrove - Hall Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020049\n\n\nGrove - Flame Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n111020000\n\n\nGrove - Button(P)\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020073\n\n\nGrove - Electromagnet\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n101020090\n\n\nGrove - Water Atomization v1.0\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020004\n\n\nGrove - Solid State Relay\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020005\n\n\nGrove - Relay\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020008\n\n\nGrove - MOSFET\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020010\n\n\nGrove - 2-Coil Latching Relay\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020012\n\n\nGrove - SPDT Relay(30A)\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020014\n\n\nGrove - Dry-Reed Relay\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104020001\n\n\nGrove - Variable Color LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104020002\n\n\nGrove - Purple LED (3mm)\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104020005\n\n\nGrove - LED String Light\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030005\n\n\nGrove - Red LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030007\n\n\nGrove - Green LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030009\n\n\nGrove - White LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030010\n\n\nGrove - Blue LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030014\n\n\nGrove - Multi Color Flash LED (5mm)\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n105020003\n\n\nGrove - Vibration Motor\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n105020004\n\n\nGrove - Mini Fan\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n105020005\n\n\nGrove - EL Driver\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n107020000\n\n\nGrove - Buzzer\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n107020001\n\n\nGrove - Speaker\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n101020034\n\n\nGrove - 3-Axis Digital Compass\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020039\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020050\n\n\nGrove - 3-Axis Digital Gyro\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020072\n\n\nGrove - Barometer Sensor (BMP180)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020083\n\n\nGrove - Gesture\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020088\n\n\nGrove - Multichannel Gas Sensor\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n103020013\n\n\nGrove - I2C ADC\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n104030008\n\n\nGrove - OLED Display 1.12\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n104030011\n\n\nGrove - OLED Display 0.96\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n105020001\n\n\nGrove - I2C Motor Driver\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n107020006\n\n\nGrove - I2C FM Receiver\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020192\n\n\nGrove - Barometer(BMP280)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020193\n\n\nGrove - Temp\nHumi\nBarometer Sensor(BME280)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020010\n\n\nGrove - Ultrasonic Ranger\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020016\n\n\nGrove - Infrared Receiver\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020019\n\n\nGrove - Temperature\nHumidity Sensor Pro\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020026\n\n\nGrove - Infrared Emitter\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020029\n\n\nGrove - Infrared Reflective Sensor\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020030\n\n\nGrove - Digital Light Sensor\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020040\n\n\nGrove - IR Distance Interrupter\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n103020018\n\n\nGrove - Recorder\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n104020006\n\n\nGrove - LED Bar v2.0\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n104030003\n\n\nGrove - 4-Digit Display\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n316010005\n\n\nGrove - Servo\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020067\n\n\nGrove - CO2 Sensor\n\n\nUART\n\n\nlink", 
            "title": "Wio Link"
        }, 
        {
            "location": "/Wio_Link/#features", 
            "text": "No hardware programming, No breadboard, No jumper wires, No soldering required.  A lot of Grove modules are supported (Check the list in Mobile App).  Plug-n-Play Grove Modules  Visual configuration instead of microcontroller programming.  Update automatically via cloud compiling and OTA.  Bring real world to virtual platform. All sensors become virtual RESTful API.  Android   iOS Apps to manage Wio Link.  IFTTT supported by Seeed s Channel", 
            "title": "Features"
        }, 
        {
            "location": "/Wio_Link/#specification", 
            "text": "General  Value  Power Management  Value      Size  55mm * 48mm  DC Current Per I/O Pin  12mA    Crystal  26MHz  Input Voltage (Micro USB)  5V    Flash Memory  4MBytes (W25Q32B)  Input Voltage (Battery holder)  3.4~4.2V    Wi-Fi Network Protocol  802.11b/g/n  Output DC Current  1000mA MAX    Wi-Fi Encryption Technology  WEP/TKIP/AES  Operating Voltage  3.3V    Grove Connectors  6  Charge Current  500mA MAX    Flash  4MB (W25Q32B)", 
            "title": "Specification"
        }, 
        {
            "location": "/Wio_Link/#make-with-wio-link", 
            "text": "Wio Link is well designed to provide simple Wi-Fi solutions for projects like:   Smart Home  Intelligent environmental monitoring  Funny Toys  Web of Things  Internet of Things   In fact, we have already designed many projects in our  recipe , come and visit it to find some interesting projects or even share you own projects, I am sure it will gain a lot of fans for you ~     Irrigation control system  The internet of led wall  Dog feeding machine           MAKE IT NOW  MAKE IT NOW  MAKE IT NOW        Kickstarter Monitor  MIssing Call Monitor  Boss Key           MAKE IT NOW  MAKE IT NOW  MAKE IT NOW      Note   Some of the recipe are made for Wio Node, but it can apply to Wio Link too.", 
            "title": "Make with Wio Link"
        }, 
        {
            "location": "/Wio_Link/#hardware-overview", 
            "text": "Part  Function      MCU  ESP8266    Digital Port 0  GPIO 14    Digital Port 1  GPIO 12    Digital Port 2  GPIO 13    Analog Port  A3    UART Port  Pin 1   Pin 3    I2C Port  Pin 4   Pin 5    Status Light  Blue LED is the WiFi status indicator, Red LED indicates the working status    Configure Button  To configure and manage your Wio Link    Battery Holder  JST2.0    Micro USB  To power the board or communicate to the PC    Reset Button  To reset the MCU", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Wio_Link/#status-leds", 
            "text": "Near to the FUNCTION button there\u2019re 2 status Leds, a blue one and a red one. The BLUE led is the network status indicating led. It has the following blink patterns:   breathing Under configuration mode  blink twice quickly then off 1s requesting IP address from router  blink once quickly then off 1s connecting to the server  on 1s then off 1s The node is online  on constantly the node is dead for not getting IP or not connecting to server.  blink quickly (on 100ms then off 100ms) OTA      Note   The BLUE led is attached to GPIO2 which is also the TX pin of UART1. When downloading firmware, the UART1 dumps the data transmitting on UART0 by instinct. So the BLUE led will blink while downloading firmware. After startup the GPIO2 will be configured as a GPIO not TX of UART1.    The RED led is another status led which indicates the power status of Grove modules. All the six Grove interface\u2019s VCC converge together and can be controlled with GPIO 15. When the node is in deep sleep mode, all the grove modules lose their power too. The RED led will light on when Grove modules are powered and will go off when Grove modules aren\u2019t powered.", 
            "title": "Status LEDs"
        }, 
        {
            "location": "/Wio_Link/#bonus", 
            "text": "Wio Link has an inbuilt LiPo battery charger, so you can charge 3.7v LiPo battery through JST 2.0 Port when USB is connecting.    Note   Battery needs to be bought separately. Please visit  Bazzar  where we arranged many choices for you.", 
            "title": "Bonus!"
        }, 
        {
            "location": "/Wio_Link/#get-started", 
            "text": "Let us build a very basic LED application with Wio Link, in this application you will be able to control LED by your smartphone in about 5 minutes. Before we start, please make sure you have below things on hand:     Wio Link  Grove - LED  Micro USB Cable           GET ONE NOW  GET ONE NOW  GET ONE NOW      Note   A smartphone is needed as well (Android OS version 4.1 or advanced, iOS version 7 or advanced)  Grove - LED include a Grove cable already", 
            "title": "Get Started"
        }, 
        {
            "location": "/Wio_Link/#step-1-install-androidios-app", 
            "text": "You need to install the Wio Link App to manage and configure your Wio Link devices.  Download the Android or iOS App and install. Or you can go to App Store of Apple or Google Market and search  Wio Link , you will find it.           Get Android App  Get iOS App      Note   Make sure your Android OS version is 4.1 or advanced, iOS version is 7 or advanced.", 
            "title": "STEP 1: Install Android/iOS App"
        }, 
        {
            "location": "/Wio_Link/#step-2-create-your-account", 
            "text": "If it is your first time to use Wio APP, it may require GPS authorization, please approve it, then sign up.  If you already have an account, check the server location before logging in.    Note   Please pay attention to the server location, because wrong server location will lead to failure when connecting to Wio Link.", 
            "title": "STEP 2: Create your Account"
        }, 
        {
            "location": "/Wio_Link/#step-3-connect-wio-link-wi-fi-ap", 
            "text": "Push and hold the CONFIG button until the blue LED turns into breathing mode (i.e. blinking with fade in   fade out effect). It means that Wio Link has turned to configuration mode successfully and can be detected by the Wio App.     Push  Add your first Device .  Choose Wio Link  Go to Wi-Fi list  will lead you to the Wi-Fi setting interface of your smartphone.     If you have successfully made the blue LED turn into breathing mode, you will find the Wio Link in the Wi-Fi list, connect to it!(Usually it is not called Wio Link in the Wi-Fi list, in the example, mine is Wio_8B2F12, you may find one named wio_xxxxxx in your list.)  Once connected, you will receive a notice, then you can go back to the app  Next step is connecting to the Wi-Fi of your home or company     If there is password pf the Wi-Fi you want to connect, it may require you to enter the password  Consider that you may need to connect more than 1 Wio device in the future, a special name will make you distinguish them from each other easily.", 
            "title": "STEP 3: Connect Wio Link Wi-Fi AP"
        }, 
        {
            "location": "/Wio_Link/#step-4-virtually-interconnect-modules-with-wio-link-and-update-firmware", 
            "text": "Click the Wio Link and you will be in the main interface.  There are 6 grove connectors, select the first one on the left.  Because LED is output devices. Choose output category  Find the icon that looks like a bulb, choose it.  Then you will find the bottom rectangle button becomes red and  View API  becomes  Update Firmware . Choose  Update Firmware     Since you selected the Digital 0 port to connect with LED in the APP, you need to connect the real Grove-LED to Digital 0 port of Wio Link too.", 
            "title": "STEP 4: Virtually interconnect modules with Wio Link and update firmware"
        }, 
        {
            "location": "/Wio_Link/#step-5-test-application-using-apis", 
            "text": "Now that  you have successfully connect the LED to Wio Link, click  View API  to check the API of Wio Link  Input  1  or  0  in the  Test Request  area, and click  Post  button and see what will happen.", 
            "title": "STEP 5: Test application using APIs"
        }, 
        {
            "location": "/Wio_Link/#get-started-with-ifttt-dobutton", 
            "text": "Dont t know how to code? Don t worry, with the help of  IFTTT , even if you know nothing about coding, you are still able to build some simple projects.  IFTTT is an abbreviation of  If This Then That , it is a free web-based service that allows users to create chains of simple conditional statements, called  recipes , which are triggered based on changes to other web services such as Gmail, Facebook, Instagram. How does IFTTT work with Wio Link? As you can see in below pictures, Seeed provided cloud service at wio.seeed.io, which can interchange data and send instructions to IFTTT and Wio Link. So by creating some simple recipe, you are able to hack things without coding.   If you don t have an IFTTT account, click  here  to sign up.  If you already have an IFTTT account,click  here  to connect with Seeed, or search Seeed at IFTTT website. There you will find 9 recipes by Seeed to teach you how to us e IFTTT.  What is DoButton? DoButton is one of IFTTT s application that empowers you to create your own personalized button with just a tap, it is very suitable for building IoT projects and control it through your smartphone, here are two examples to show you how to use IFTTT DoButton to make useful applications.", 
            "title": "Get started with IFTTT &amp; DoButton"
        }, 
        {
            "location": "/Wio_Link/#example", 
            "text": "IFTTT  DoButton      [ Recipe ] DIY an Automatic Garden Irrigation without coding  [ Recipe ] How to feed your pets when you re not home    [ Video ] How to use ITFFF  [ Video ] How to use DoButton", 
            "title": "Example:"
        }, 
        {
            "location": "/Wio_Link/#guide-for-advanced-users", 
            "text": "Feel those examples too simple? Wanna make more complicated projects? Here are the best guides for advanced users to hack things with Wio Link. By these guides, advanced users are able to know more detail information about Wio Link, deploy private server, even write module driver for Wio Link.   The guide covers:   API Reference  Server Deployment Guide  Advanced User Guide  How to write module driver for Wio Link?", 
            "title": "Guide for advanced users"
        }, 
        {
            "location": "/Wio_Link/#advanced-tutorial", 
            "text": "If you have successfully controlled the grove-led with your smartphone, and want to try something more difficult and not that complicated, why not try this tutorial, after learning it, you will be able to  build a temperature and humidity monitor and light up the RGB Led strip with Wio Link.  Before you start, please check if you have below devices on hand.     RGB Led strip  Grove-Temperature and Humidity Sensor          Get One Now  Get One Now      Step1: Remove the Grove LED from the grove connector, plug the Led strip to Wio Link and drag the same module to Wio Link in the App.  Update the firmware.     Step2\uff1aPlug the Grove-Temperature and Humidity Sensor to Wio Link and drag the same module to Wio Link in the App.  Update the firmware.     Step3: View the APIs and read the temperature   humidity in your house. Below image shows the temperature change before and after holding the grove in hand. I increased the temperature by 1 Celsius. Try and see how you can change the temperature and humidity in your house.     Step4: Control the light of Led strip by changing RGB value.   Because the Wio Link App read hex RGB value, RGB value need to be converted to hex value. Here I would like to recommend the website  RGB t0 Hex . Just by inputting RGB value for the 3 RGB elements (Red, Green, Blue), the website will converts the RGB value to hex very easily. Here is some example.\n- Input 255, 0, 0    Convert it, then you will get the hex value as FF0000, the color is Red.     Note   The RGB value you input should be any nature number between 0 and 255 (Including 0 and 255)    Then input how many Leds you want to lighten and the hex value in the app, here my Led strip has 30 Leds, so I lighten all of them.   You can also specific which part of the strip be lighted and give a special color to it, or even make like blink in rainbow mode. A lot of amazing functions are waiting for your exploration!", 
            "title": "Advanced Tutorial"
        }, 
        {
            "location": "/Wio_Link/#resource", 
            "text": "Hardware   EAGLE Schematic files  EAGLE PCB file  Schematic files(pdf)   Software   Source Code on Github.   More documentation and references   API Reference  Server Deployment Guide  How to write module driver for Wio Link  iot.seeed.cc  to get more info.", 
            "title": "Resource"
        }, 
        {
            "location": "/Wio_Link/#faq", 
            "text": "Here are some questions that we usually received from new users. If you have any other issues when you are using Wio Link or other Wio products, welcome to the  Community of Wio  where there are many professional users waiting to give you advices and also many advanced users providing plenty of ideas on how to use Wio products!  1. Power   Battery \uff0d Does Wio Link come with a Lipo battery?  Nope. Each Wio Link goes with a micro USB cable for charging or you can purchase a 3.7V Lipo battery from our Bazzar. Here\u2019s the specs for your reference:\n- maximum input voltage: 4.2V;\n- maximum charging current: 500mA.  2. Power   Battery - Can I use a power adapter with Wio Link? Which type? And common battery holders?  There are two ways to power the Wio Link, Micro USB cable or a 3.7V Lipo battery. If both Micro USB and battery are plugged into the board, the battery will be charged by the USB power. You can use all kinds of power adapter which can connect with Micro USB cable and 5Vdc output. The battery holder is a JST-2.0 connector.  3. Power Consumption - What\u2019s the power consumption of Wio Link?  The average power consumption is 70mA. With a battery of 700mAh, it can keep alive up to 10 hours. There are Low-Power-APIs which allows you to change the Wio Link from working-mode to sleeping-mode. It will reduce average power consumption to 150uA or less.  4. Grove Cables - Are the Groves equipped with cables in all kits?  Yes, we have each Grove modules packed with one standard 4-pin Grove cable.  5. RESTful APIs - Where are the endpoints? The calls aren t required to go through some cloud servers are they? Is it an internet connection required or can they be made all through a local network?  We deploy the REST API server to iot.seeed.cc, so you can get access to sensor and actuator from iot.seeed.cc. At the moment, Wio Link must connect to the Internet. Also, we will open-source the server so as to enable users deploy local servers in very simple Docker way. With local servers deployed, they can utilize the compiling and data exchange service locally instead of going online.  6. Programming Methods Supported - Will other programming methods be supported, such as Arduino IDE?  Wio Link can be programed with Arduino IDE, in that case it will lose the functionality of RESTful APIs except you implement another one in the same time. Wio Link is mostly expected to archive the Web of Things conversion for physical hardware, so interactions are expected to perform in web / internet. But no worries, the software architecture is flexible, you can pull down the source code to local and connect Wio Link to the local servers, then you could modify the source code which will be compiled.  If you would like to interact with Arduino or RPI, you can develop a 3rd-party module driver and here\u2019s the guide: https://github.com/Seeed-Studio/Wio_Link/wiki/How-to-write-module-driver-for-Wio-Link%3F and example driver: https://github.com/Seeed-Studio/Wio_Link/tree/master/grove_drivers/grove_example  7. Platform Supported -Does Wio Link support Windows Platform?  By now Wio Link provides Android and iOS two mobile Apps. We have all services as RESTful API, such like user accounts and OTA, following API documents, the third-party developers can build their own applications say Mobile Apps or Desktop Apps.\nWio Link is an community friendly project. It won t be limited to a certain platform. We really expect people can play with Wio Link in their way.  8. Can I use Wio Link to interact with existing systems?  Yes. Who Link can interact with your existing system in several ways. First, connect any GPIO of Wio Link to other system, select \u201cGeneric Digital Input\u201d or \u201cGeneric Digital Output\u201d virtual Grove modules in the mobile App, then send/read signals to/from the existing system with RESTful API calls. Second, connect the analog port of Wio Link to other system, select \u201cGeneric Analog Input\u201d virtual Grove module in the mobile App, then read analog measurement for some physical quantity of your existing system. Third, to interact with existing system more flexible, you can develop a 3rd party module driver in which dispatch the requests from internet to your existing system through I2C or UART interface. We have a guide[1] about how to develop 3rd party module driver and also we can provide technical support for your development.  [1]https://github.com/Seeed-Studio/Wio_Link#how-to-write-module-driver-for-wio-link  9. How many Groves supported on Wio Link?  There are 150+ kinds of plug and play Groves modules available, among which 36 were supported on Wio Link till now, and you can find most of them in the Rewards, we re working to add more continuously.  Here s the list of supported Groves so far:", 
            "title": "FAQ"
        }, 
        {
            "location": "/Wio_Link/#grove-support-list", 
            "text": "SKU  Name  Interface  Link      101020008  Grove - Moisture Sensor  Generic Analog Input  link    101020014  Grove - Light Sensor  Generic Analog Input  link    101020015  Grove - Temperature Sensor  Generic Analog Input  link    101020017  Grove - Rotary Angle Sensor  Generic Analog Input  link    101020022  Grove - Light Sensor(P)  Generic Analog Input  link    101020023  Grove - Sound Sensor  Generic Analog Input  link    101020027  Grove - Electricity Sensor  Generic Analog Input  link    101020036  Grove - Slide Potentiometer  Generic Analog Input  link    101020042  Grove - 80cm Infrared Proximity Sensor  Generic Analog Input  link    101020043  Grove - UV Sensor  Generic Analog Input  link    101020048  Grove - Rotary Angle Sensor(P)  Generic Analog Input  link    101020063  Grove - Loudness Sensor  Generic Analog Input  link    101020076  Grove - Luminance Sensor  Generic Analog Input  link    101020078  Grove - Air quality sensor v1.3  Generic Analog Input  link    101020003  Grove - Button  Generic Digital Input  link    101020004  Grove - Switch(P)  Generic Digital Input  link    101020005  Grove - Collision Sensor  Generic Digital Input  link    101020009  Grove - Line Finder  Generic Digital Input  link    101020018  Grove - Water Sensor  Generic Digital Input  link    101020020  Grove - PIR Motion Sensor  Generic Digital Input  link    101020025  Grove - Tilt Switch  Generic Digital Input  link    101020037  Grove - Touch Sensor  Generic Digital Input  link    101020038  Grove - Magnetic Switch  Generic Digital Input  link    101020046  Grove - Hall Sensor  Generic Digital Input  link    101020049  Grove - Flame Sensor  Generic Digital Input  link    111020000  Grove - Button(P)  Generic Digital Input  link    101020073  Grove - Electromagnet  Generic Digital Output  link    101020090  Grove - Water Atomization v1.0  Generic Digital Output  link    103020004  Grove - Solid State Relay  Generic Digital Output  link    103020005  Grove - Relay  Generic Digital Output  link    103020008  Grove - MOSFET  Generic Digital Output  link    103020010  Grove - 2-Coil Latching Relay  Generic Digital Output  link    103020012  Grove - SPDT Relay(30A)  Generic Digital Output  link    103020014  Grove - Dry-Reed Relay  Generic Digital Output  link    104020001  Grove - Variable Color LED  Generic Digital Output  link    104020002  Grove - Purple LED (3mm)  Generic Digital Output  link    104020005  Grove - LED String Light  Generic Digital Output  link    104030005  Grove - Red LED  Generic Digital Output  link    104030007  Grove - Green LED  Generic Digital Output  link    104030009  Grove - White LED  Generic Digital Output  link    104030010  Grove - Blue LED  Generic Digital Output  link    104030014  Grove - Multi Color Flash LED (5mm)  Generic Digital Output  link    105020003  Grove - Vibration Motor  Generic Digital Output  link    105020004  Grove - Mini Fan  Generic Digital Output  link    105020005  Grove - EL Driver  Generic Digital Output  link    107020000  Grove - Buzzer  Generic Digital Output  link    107020001  Grove - Speaker  Generic Digital Output  link    101020034  Grove - 3-Axis Digital Compass  I2C  link    101020039  Grove - 3-Axis Digital Accelerometer(\u00b11.5g)  I2C  link    101020050  Grove - 3-Axis Digital Gyro  I2C  link    101020072  Grove - Barometer Sensor (BMP180)  I2C  link    101020083  Grove - Gesture  I2C  link    101020088  Grove - Multichannel Gas Sensor  I2C  link    103020013  Grove - I2C ADC  I2C  link    104030008  Grove - OLED Display 1.12  I2C  link    104030011  Grove - OLED Display 0.96  I2C  link    105020001  Grove - I2C Motor Driver  I2C  link    107020006  Grove - I2C FM Receiver  I2C  link    101020192  Grove - Barometer(BMP280)  I2C  link    101020193  Grove - Temp Humi Barometer Sensor(BME280)  I2C  link    101020010  Grove - Ultrasonic Ranger  Others  link    101020016  Grove - Infrared Receiver  Others  link    101020019  Grove - Temperature Humidity Sensor Pro  Others  link    101020026  Grove - Infrared Emitter  Others  link    101020029  Grove - Infrared Reflective Sensor  Others  link    101020030  Grove - Digital Light Sensor  Others  link    101020040  Grove - IR Distance Interrupter  Others  link    103020018  Grove - Recorder  Others  link    104020006  Grove - LED Bar v2.0  Others  link    104030003  Grove - 4-Digit Display  Others  link    316010005  Grove - Servo  Others  link    101020067  Grove - CO2 Sensor  UART  link", 
            "title": "Grove Support List"
        }, 
        {
            "location": "/Wio_Link_Bootcamp_Kit/", 
            "text": "If you have no programming skills, and you want to build some cool gadgets for your life, this kit will be a perfect starter. It contains a relay, a recorder, a strip of LEDs, a buzzer and a servo motor which will perform basic actions required in daily life. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let\ns get started to build some useful stuff.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCompletely easy to make things around you smarter and add fun to daily life.\n\n\nCost-effective\n\n\nWeight: 285 g\n\n\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Relay\n\n\n1PC\n\n\n\n\n\n\nGrove - Recorder\n\n\n1PC\n\n\n\n\n\n\nGrove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter\n\n\n1PC\n\n\n\n\n\n\nGrove - Buzzer\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\nGrove - Servo\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\uf0c1\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\uf0c1\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\uf0c1\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\uf0c1\n\n\nPlease go to \nRecipe\n for the detailed manual.", 
            "title": "Wio Link Bootcamp Kit"
        }, 
        {
            "location": "/Wio_Link_Bootcamp_Kit/#features", 
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Completely easy to make things around you smarter and add fun to daily life.  Cost-effective  Weight: 285 g", 
            "title": "Features"
        }, 
        {
            "location": "/Wio_Link_Bootcamp_Kit/#parts-list", 
            "text": "Parts name  Quantity      Grove - Relay  1PC    Grove - Recorder  1PC    Grove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter  1PC    Grove - Buzzer  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC    Grove - Servo  1PC", 
            "title": "Parts list"
        }, 
        {
            "location": "/Wio_Link_Bootcamp_Kit/#a-simple-demo", 
            "text": "This demo can used as a compilation result-indicator.", 
            "title": "A simple demo"
        }, 
        {
            "location": "/Wio_Link_Bootcamp_Kit/#preliminary-guide", 
            "text": "Travis CI  Wio Link", 
            "title": "Preliminary Guide"
        }, 
        {
            "location": "/Wio_Link_Bootcamp_Kit/#prerequisites", 
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/Wio_Link_Bootcamp_Kit/#a-detailed-how-to", 
            "text": "Please go to  Recipe  for the detailed manual.", 
            "title": "A detailed how-to"
        }, 
        {
            "location": "/Wio_Link_Environment_Kit/", 
            "text": "We are always closely connected with our surrounding environment. So it is important for us to get some details from an environment. This kit is supposed to do this task perfectly, at least at a primary level. In this kit, you can find common functional modules to collect data, such as humidity or light level indoor, from the environment in our house. The most amazing part of this kit is the Wio Link development board which can be utilized for various purposes, without requiring any programming skills. All the actions you want your modules to perform and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet from anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. So let\ns get an understanding for those conditions you are in.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCost-effective\n\n\nWeight\u00a0: 154 g\n\n\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Moisture Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Temp\nHumi Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Digital Light Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Air quality sensor v1.3\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\uf0c1\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\uf0c1\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\uf0c1\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\uf0c1\n\n\nPlease go to \nRecipe\n for the detailed manual.", 
            "title": "Wio Link Environment Kit"
        }, 
        {
            "location": "/Wio_Link_Environment_Kit/#features", 
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Cost-effective  Weight\u00a0: 154 g", 
            "title": "Features"
        }, 
        {
            "location": "/Wio_Link_Environment_Kit/#parts-list", 
            "text": "Parts name  Quantity      Grove - Moisture Sensor  1PC    Grove - Temp Humi Sensor  1PC    Grove - Digital Light Sensor  1PC    Grove - Air quality sensor v1.3  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC", 
            "title": "Parts list"
        }, 
        {
            "location": "/Wio_Link_Environment_Kit/#a-simple-demo", 
            "text": "This demo can used as a compilation result-indicator.", 
            "title": "A simple demo"
        }, 
        {
            "location": "/Wio_Link_Environment_Kit/#preliminary-guide", 
            "text": "Travis CI  Wio Link", 
            "title": "Preliminary Guide"
        }, 
        {
            "location": "/Wio_Link_Environment_Kit/#prerequisites", 
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/Wio_Link_Environment_Kit/#a-detailed-how-to", 
            "text": "Please go to  Recipe  for the detailed manual.", 
            "title": "A detailed how-to"
        }, 
        {
            "location": "/Wio_Link_Event_Kit/", 
            "text": "Wio Link Event Kit is a event-monitoring kit which include some typical event-triggered \nGrove\n functional modules to build smart IoT devices. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over the internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let\ns get familiar with some event-triggered modules included in this Kit.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nInclude common frequently-used event-monitoring functional modules.\n\n\nCompletely easy to make things around you smarter.\n\n\nGrove port interfaced, more practical function and less work.\n\n\nWeight: 145 g\n\n\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - IR Distance Interrupt\n\n\n1PC\n\n\n\n\n\n\nGrove - Button\n\n\n1PC\n\n\n\n\n\n\nGrove - Magnetic Switch\n\n\n1PC\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\uf0c1\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\uf0c1\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\uf0c1\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\uf0c1\n\n\nPlease go to \nRecipe\n for the detailed manual:", 
            "title": "Wio Link Event Kit"
        }, 
        {
            "location": "/Wio_Link_Event_Kit/#features", 
            "text": "Include common frequently-used event-monitoring functional modules.  Completely easy to make things around you smarter.  Grove port interfaced, more practical function and less work.  Weight: 145 g", 
            "title": "Features"
        }, 
        {
            "location": "/Wio_Link_Event_Kit/#parts-list", 
            "text": "Parts name  Quantity      Grove - IR Distance Interrupt  1PC    Grove - Button  1PC    Grove - Magnetic Switch  1PC    Grove - 3-Axis Digital Accelerometer(\u00b11.5g)  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC", 
            "title": "Parts list"
        }, 
        {
            "location": "/Wio_Link_Event_Kit/#a-simple-demo", 
            "text": "This demo can used as a compilation result-indicator.", 
            "title": "A simple demo"
        }, 
        {
            "location": "/Wio_Link_Event_Kit/#preliminary-guide", 
            "text": "Travis CI  Wio Link", 
            "title": "Preliminary Guide"
        }, 
        {
            "location": "/Wio_Link_Event_Kit/#prerequisites", 
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/Wio_Link_Event_Kit/#a-detailed-how-to", 
            "text": "Please go to  Recipe  for the detailed manual:", 
            "title": "A detailed how-to"
        }, 
        {
            "location": "/Wio_Link_Starter_Kit/", 
            "text": "This kit is aimed at novices wanting to become a maker. The functional modules included in this kit are selected especially for a beginner which all are frequently required modules, and it is cost-effective. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let\ns enjoy being a maker.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCompletely easy to make things around you smarter and add fun to daily life.\n\n\nCost-effective\n\n\nWeight: 267 g\n\n\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Button\n\n\n1PC\n\n\n\n\n\n\nGrove - Relay\n\n\n1PC\n\n\n\n\n\n\nGrove - Temp\nHumi Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Digital Light Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter\n\n\n1PC\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\uf0c1\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\uf0c1\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\uf0c1\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\uf0c1\n\n\nPlease go to \nRecipe\n for the detailed manual.", 
            "title": "Wio Link Starter Kit"
        }, 
        {
            "location": "/Wio_Link_Starter_Kit/#features", 
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Completely easy to make things around you smarter and add fun to daily life.  Cost-effective  Weight: 267 g", 
            "title": "Features"
        }, 
        {
            "location": "/Wio_Link_Starter_Kit/#parts-list", 
            "text": "Parts name  Quantity      Grove - Button  1PC    Grove - Relay  1PC    Grove - Temp Humi Sensor  1PC    Grove - Digital Light Sensor  1PC    Grove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter  1PC    Grove - 3-Axis Digital Accelerometer(\u00b11.5g)  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC", 
            "title": "Parts list"
        }, 
        {
            "location": "/Wio_Link_Starter_Kit/#a-simple-demo", 
            "text": "This demo can used as a compilation result-indicator.", 
            "title": "A simple demo"
        }, 
        {
            "location": "/Wio_Link_Starter_Kit/#preliminary-guide", 
            "text": "Travis CI  Wio Link", 
            "title": "Preliminary Guide"
        }, 
        {
            "location": "/Wio_Link_Starter_Kit/#prerequisites", 
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/Wio_Link_Starter_Kit/#a-detailed-how-to", 
            "text": "Please go to  Recipe  for the detailed manual.", 
            "title": "A detailed how-to"
        }, 
        {
            "location": "/Wio_Node/", 
            "text": "Building IoT projects is exciting, as you can connect almost everything around you and control them. However sometime it is not easy to build IoT applications since it requires a lot of hard works, such as hardware,  programming, jump wires and soldering etc. Even a well-trained user would spend hours to handle all the work, let alone beginners. In order to simplify the development of IoT project, Seeed launched \nWio Link\n on \nkickstarter\n and it turn out a big success. The slogan on Kickstarter well defined the main feature of Wio link: \n\n\n3 steps. 5 minutes. Build your own IoT applications!\n \n\n\nIt is so simple, it is fast building, however it is not ideal for all conditions.\nWhat if we only need 2 grove connectors? What if there is limited space in the application but Wio Link is over sized? What if we want to cost down? So right after we released Wio Link, a micro and economic solution was put on schedule, for months Seeeder has redesigned and optimized the Wi-Fi board and here it is, the new member of Wio family\nWio Node\n.\n\n\n\n\nJust like the meaning of its name, Wio Node is truly a Wi-Fi node that connect things in IoT project. If Wio Link is big brother, Wio Node must be the little brother in the Wio family coz this cute little guy is only quarter size of Wio link while integrates all the basic features of Wio Link.\n\n\nThe ecosystem of Wio Node also consists of Open Hardware \nWio Node board\n, \nOpen Source Wio Link Mobile App\n and \nOpen Source IoT Server implementation\n. So the software platform for Wio Link is also available for Wio Node.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nNo hardware programming or No breadboard or No jumper wires or No soldering required.\n\n\nA lot of Grove modules are supported (Check the list in Mobile App).\n\n\nPlug-n-Play Grove Modules\n\n\nVisual configuration instead of microcontroller programming.\n\n\nUpdate automatically via cloud compiling and OTA.\n\n\nBring Real-world to Virtual platform. All sensors become virtual RESTful API.\n\n\nAndroid \n iOS Apps to manage Wio Node.\n\n\nIFTTT supported by Seeed\ns Channel\n\n\nCE/FCC/TELEC Certified for core module ESP-WROOM-02\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nGeneral\n\n\nValue\n\n\nPower Management\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nSize\n\n\n28mm * 28mm\n\n\nDC Current Per I/O Pin\n\n\n12mA\n\n\n\n\n\n\nCrystal\n\n\n26MHz\n\n\nInput Voltage (Micro USB)\n\n\n5V\n\n\n\n\n\n\nFlash Memory\n\n\n4MBytes (W25Q32B)\n\n\nInput Voltage (Battery holder)\n\n\n3.4~4.2V\n\n\n\n\n\n\nWi-Fi Network Protocol\n\n\n802.11b/g/n\n\n\nOutput DC Current\n\n\n1000mA MAX\n\n\n\n\n\n\nWi-Fi Encryption Technology\n\n\nWEP/TKIP/AES\n\n\nOperating Voltage\n\n\n3.3V\n\n\n\n\n\n\nExpansion Grove Connector1\n\n\nUART0/I2C0/D0\n\n\nCharge Current\n\n\n500mA MAX\n\n\n\n\n\n\nExpansion Grove Connector2\n\n\nAnalog/I2C1/D1\n\n\n\n\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nWio Node is well designed to provide simple and economic Wi-Fi solutions for projects like:\n\n\n\n\nSmart Home\n\n\nIntelligent environmental monitoring\n\n\nFunny Toys\n\n\nWeb of Things\n\n\nInternet of Things\n\n\n\n\nIn fact, there\nre many projects in our \nrecipe\n, come and visit it to find some interesting projects or even share you own projects, I am sure it will gain a lot of fans for you.\n\n\n\n\n\n\n\n\nIrrigation control system\n\n\nThe internet of led wall\n\n\nDog feeding machine\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW\n\n\nMAKE IT NOW\n\n\nMAKE IT NOW\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKickstarter Monitor\n\n\nMIssing Call Monitor\n\n\nBoss Key\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW\n\n\nMAKE IT NOW\n\n\nMAKE IT NOW\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nSome of the recipes are made by Wio Link, you can replace it with a Wio Node.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n\n\n\n\n\n\nNo.\n\n\nName\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\n1\n\n\nFunction\n\n\nSet Wio Node working mode\n\n\n\n\n\n\n2\n\n\nESP8266\n\n\nMicrocontroller based on ESP8266\n\n\n\n\n\n\n3\n\n\nReset\n\n\nReset the device\n\n\n\n\n\n\n4\n\n\nMicro USB\n\n\nSupply the device and charge the battery\n\n\n\n\n\n\n5\n\n\nBattery Holder\n\n\nA jst2.0 connector, connect a 3.7V Li-Battery\n\n\n\n\n\n\n6\n\n\nAnalog/I2C1/D1\n\n\nGrove port, you can connect a Digital/I2C/Analog type Grove module\n\n\n\n\n\n\n7\n\n\nUART/I2C0/D0\n\n\nGrove port, you can connect a UART/I2C/Digital type Grove module\n\n\n\n\n\n\n\n\nStatus LEDs\n\uf0c1\n\n\nNear to the FUNCTION button there\nre 2 status Leds, a blue one and a red one. The BLUE led is the network status indicating led. It has the following blink patterns:\n\n\n\n\nbreathing Under configuration mode\n\n\nblink twice quickly then off 1s requesting IP address from router\n\n\nblink once quickly then off 1s connecting to the server\n\n\non 1s then off 1s The node is online\n\n\non constantly the node is dead for not getting IP or not connecting to server.\n\n\nblink quickly (on 100ms then off 100ms) OTA\n\n\n\n\n\n\nNote\n\n\nThe BLUE led is attached to GPIO2 which is also the TX pin of UART1. When downloading firmware, the UART1 dumps the data transmitting on UART0 by instinct. So the BLUE led will blink while downloading firmware. After startup the GPIO2 will be configured as a GPIO not TX of UART1.\n\n\n\n\nThe RED led is another status led which indicates the power status of Grove modules. All the six Grove interface\ns VCC converge together and can be controlled with GPIO 15. When the node is in deep sleep mode, all the grove modules lose their power too. The RED led will light on when Grove modules are powered and will go off when Grove modules aren\nt powered.\n\n\nBonus!\n\uf0c1\n\n\nWio Node has an inbuilt LiPo battery charger, so you can charge 3.7v LiPo battery through JST 2.0 Port when USB is connecting.\n\n\n\n\nNote\n\n\n\n\nPlease handle the USB micro type-B socket gently, or you may break the socket apart from the board.\n\n\nBattery is not included in the package. But we have arranged plenty of choices for you in \nBazzar\n.\n\n\n\n\n\n\nGet Started\n\uf0c1\n\n\n\n\nLet us build a very basic LED application with Wio Node, in this application you will be able to control LED by your smartphone in about 5 minutes. Before we start, please make sure you have below things on hand:\n\n\n\n\n\n\n\n\nWio Node\n\n\nGrove - LED\n\n\nMicro USB Cable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\nGET ONE NOW\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nA smartphone is needed as well (Android OS version 4.1 or advanced, iOS version 7 or advanced)\n\n\nGrove - LED include a Grove cable already\n\n\n\n\n\n\nSTEP 1:\n Install Android/iOS App\n\uf0c1\n\n\nYou need to install the Wio Link App to manage and configure your Wio Node devices.\n\n\nDownload the Android or iOS App and install. Or you can go to app store of Apple or Google market and search \nWio Link\n, you will find it.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet Android App\n\n\nGet iOS App\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nMake sure your Android OS version is 4.1 or advanced, iOS version is 7 or advanced.\n\n\n\n\nSTEP 2:\n Create your Account\n\uf0c1\n\n\n\n\nIf it is your first time to use Wio APP, it may require GPS authorization, please approve it, then sign up.\n\n\nIf you already have an account, check the server location before logging in.\n\n\n\n\n\n\nNote\n\n\n\n\nPlease pay attention to the server location, because wrong server location will lead to failure when connecting to Wio Node.\n\n\n\n\nSTEP 3\n: Connect Wio Node to Internet\n\uf0c1\n\n\n\n\nPush and hold the CONFIG button until the blue LED turns into breathing mode (i.e. blinking with fade in \n fade out effect). It means that Wio Node has turned to configuration mode successfully and can be detected by the Wio App.\n\n\n\nPush \nAdd your first Device\n.\n\n\nChoose Wio Node\n\n\nGo to Wi-Fi list\n will lead you to the Wi-Fi setting interface of your smartphone.\n\n\n\n\n\n\n\n\nIf you have successfully made the blue LED turn into breathing mode, you will find the Wio Node in the Wi-Fi list, connect to it!(Usually it is not called Wio Node in the Wi-Fi list, in the example, mine is Wio_091016, you may find one named wio_xxxxxx in your list.)\n\n\nOnce connected, you will receive a notice, then you can go back to the app \n\n\nNext step is connecting to the Wi-Fi of your home or company\n\n\n\n\n\n\n\n\nIf there is password pf the Wi-Fi you want to connect, it may require you to enter the password\n\n\nConsider that you may need to connect more than 1 Wio Node in the future, a special name will make you distinguish them from each other easily.\n\n\n\n\n\n\nSTEP 4:\n Virtually interconnect modules with Wio Node and update firmware\n\uf0c1\n\n\n\n\nClick the Wio Node and you will be in the main interface.\n\n\nThere are 2 grove connectors, select the left one (D0).\n\n\nBecause LED is output devices. Choose output category\n\n\nFind the icon that looks like a bulb, choose it.\n\n\nThen you will find the bottom rectangle button becomes red and \nView API\n becomes \nUpdate Firmware\n. Choose \nUpdate Firmware\n\n\n\n\n\n\n\n\nSince you selected the D0 port to connect with LED in the APP, you need to connect the real Grove-LED to D0 port of Wio Node too.\n\n\n\n\n\n\nSTEP 5\n: Test application using APIs\n\uf0c1\n\n\n\n\nNow that  you have successfully connect the LED to Wio Node, click \nView API\n to check the API of Wio Node\n\n\nInput \n1\n or \n0\n in the \nTest Request\n area, and click \nPost\n button and see what will happen.\n\n\n\n\n\n\nGet started with IFTTT \n DoButton\n\uf0c1\n\n\n\n\nDont\nt know how to code? Don\nt worry, with the help of \nIFTTT\n, even if you know nothing about coding, you are still able to build some simple projects.\n\n\nIFTTT is an abbreviation of \nIf This Then That\n, it is a free web-based service that allows users to create chains of simple conditional statements, called \nrecipes\n, which are triggered based on changes to other web services such as Gmail, Facebook, Instagram. How does IFTTT work with Wio Node\uff1f As you can see in below pictures, seeed provided cloud service at wio.seeed.io, which can interchange data and send instructions to IFTTT and Wio Node. So by creating some simple recipe, you are able to hack things without coding.\n\n\n\n\nIf you don\nt have an IFTTT account, click \nhere\n to sign up.\n\n\nIf you already have an IFTTT account,click \nhere\n to connect with Seeed, or search Seeed at IFTTT website. There you will find 9 recipes by Seeed to teach you how to us e IFTTT.\n\n\nWhat is DoButton? DoButton is one of IFTTT\ns application that empowers you to create your own personalized button with just a tap, it is very suitable for building IoT projects and control it through your smartphone, here are two examples to show you how to use IFTTT\nDoButton to make useful applications.\n\n\nExample:\n\uf0c1\n\n\n\n\n\n\n\n\nIFTTT\n\n\nDoButton\n\n\n\n\n\n\n\n\n\n\n[\nRecipe\n]\nDIY an Automatic Garden Irrigation without coding\n\n\n[\nRecipe\n]\nHow to feed your pets when you\nre not home\n\n\n\n\n\n\n[\nVideo\n]\nHow to use ITFFF\n\n\n[\nVideo\n]\nHow to use DoButton\n\n\n\n\n\n\n\n\nAdvanced Guide\n\uf0c1\n\n\n\n\nFeel those examples too simple? Wanna make more complicated proejects? Here are the best guides for advanced users to hack things with Wio nude. By these guides, advanced users are able to know more detail information about Wio Node, deploy private server, even write module driver for Wio Node. \n\n\n\n\nThe guide covers:\n\n\n\n\nAPI Reference\n\n\nServer Deployment Guide\n\n\nAdvanced User Guide\n\n\nHow to write module driver for Wio Link?\n\n\n\n\n\n\nNote\n\n\nThe guide is writen for Wio Link, but applies to Wio Node as well.\n\n\n\n\nGrove Support List\n\uf0c1\n\n\n\n\n\n\n\n\nSKU\n\n\nName\n\n\nInterface\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n101020008\n\n\nGrove - Moisture Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020014\n\n\nGrove - Light Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020015\n\n\nGrove - Temperature Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020017\n\n\nGrove - Rotary Angle Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020022\n\n\nGrove - Light Sensor(P)\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020023\n\n\nGrove - Sound Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020027\n\n\nGrove - Electricity Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020036\n\n\nGrove - Slide Potentiometer\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020042\n\n\nGrove - 80cm Infrared Proximity Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020043\n\n\nGrove - UV Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020048\n\n\nGrove - Rotary Angle Sensor(P)\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020063\n\n\nGrove - Loudness Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020076\n\n\nGrove - Luminance Sensor\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020078\n\n\nGrove - Air quality sensor v1.3\n\n\nGeneric Analog Input\n\n\nlink\n\n\n\n\n\n\n101020003\n\n\nGrove - Button\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020004\n\n\nGrove - Switch(P)\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020005\n\n\nGrove - Collision Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020009\n\n\nGrove - Line Finder\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020018\n\n\nGrove - Water Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020020\n\n\nGrove - PIR Motion Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020025\n\n\nGrove - Tilt Switch\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020037\n\n\nGrove - Touch Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020038\n\n\nGrove - Magnetic Switch\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020046\n\n\nGrove - Hall Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020049\n\n\nGrove - Flame Sensor\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n111020000\n\n\nGrove - Button(P)\n\n\nGeneric Digital Input\n\n\nlink\n\n\n\n\n\n\n101020073\n\n\nGrove - Electromagnet\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n101020090\n\n\nGrove - Water Atomization v1.0\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020004\n\n\nGrove - Solid State Relay\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020005\n\n\nGrove - Relay\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020008\n\n\nGrove - MOSFET\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020010\n\n\nGrove - 2-Coil Latching Relay\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020012\n\n\nGrove - SPDT Relay(30A)\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n103020014\n\n\nGrove - Dry-Reed Relay\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104020001\n\n\nGrove - Variable Color LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104020002\n\n\nGrove - Purple LED (3mm)\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104020005\n\n\nGrove - LED String Light\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030005\n\n\nGrove - Red LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030007\n\n\nGrove - Green LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030009\n\n\nGrove - White LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030010\n\n\nGrove - Blue LED\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n104030014\n\n\nGrove - Multi Color Flash LED (5mm)\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n105020003\n\n\nGrove - Vibration Motor\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n105020004\n\n\nGrove - Mini Fan\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n105020005\n\n\nGrove - EL Driver\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n107020000\n\n\nGrove - Buzzer\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n107020001\n\n\nGrove - Speaker\n\n\nGeneric Digital Output\n\n\nlink\n\n\n\n\n\n\n101020034\n\n\nGrove - 3-Axis Digital Compass\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020039\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020050\n\n\nGrove - 3-Axis Digital Gyro\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020072\n\n\nGrove - Barometer Sensor (BMP180)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020083\n\n\nGrove - Gesture\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020088\n\n\nGrove - Multichannel Gas Sensor\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n103020013\n\n\nGrove - I2C ADC\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n104030008\n\n\nGrove - OLED Display 1.12\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n104030011\n\n\nGrove - OLED Display 0.96\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n105020001\n\n\nGrove - I2C Motor Driver\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n107020006\n\n\nGrove - I2C FM Receiver\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020192\n\n\nGrove - Barometer(BMP280)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020193\n\n\nGrove - Temp\nHumi\nBarometer Sensor(BME280)\n\n\nI2C\n\n\nlink\n\n\n\n\n\n\n101020010\n\n\nGrove - Ultrasonic Ranger\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020016\n\n\nGrove - Infrared Receiver\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020019\n\n\nGrove - Temperature\nHumidity Sensor Pro\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020026\n\n\nGrove - Infrared Emitter\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020029\n\n\nGrove - Infrared Reflective Sensor\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020030\n\n\nGrove - Digital Light Sensor\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020040\n\n\nGrove - IR Distance Interrupter\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n103020018\n\n\nGrove - Recorder\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n104020006\n\n\nGrove - LED Bar v2.0\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n104030003\n\n\nGrove - 4-Digit Display\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n316010005\n\n\nGrove - Servo\n\n\nOthers\n\n\nlink\n\n\n\n\n\n\n101020067\n\n\nGrove - CO2 Sensor\n\n\nUART\n\n\nlink\n\n\n\n\n\n\n\n\nFAQ\n\uf0c1\n\n\n\n\nHere are some questions that we usually received from new users. If you have any other issues when you are using Wio Node or other Wio products, welcome to the \nCommunity of Wio\n where there are many professional users waiting to give you advices and also many advanced users providing plenty of ideas on how to use Wio products! \n\n\nQ1. What\ns the difference between Wio Node and Wio Link?\n\n\n\n\nWio Node is like mini Wio Link, it is only quarter size of Wio Link and much cheaper. Despite the size and price, Wio Node still has full function of Wio Link. For those who prefer smaller size to more grove connectors. Wio node is the best choice.\n\n\n\n\n2. What should I do if can\nt connect with Server?\n\n\n\n\nLog out and check if you chose wrong server before logging in. If you are not in China Mainland, please choose global server.\n\n\n\n\n3. Fail to configure Wio Node and can\nt find Wio Node in wifi list?\n\n\n\n\nPay attention to the blue LED. Make sure it is in breathing mode (blinking with fade in \n fade out effect, it is a very unique mode, very easy to recognize) before any further steps. Only the LED in breathing mode can Wio Node be found in WiFi list.\n\n\n\n\n4. If I want to connect more than 1 I2C devices, what should I do?\n\n\n\n\nGrove-I2C hub\n can branch 1 I2C port into 4. Come to \nBazzar\n to get one!\n\n\n\n\n5. Can I change Wio Node into sleep mode?\n\n\n\n\nYes, please check the last API, where you can command Wio Node into sleep mode.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\n\n\nDocumentation and references\n\n\nAPI Reference\n\n\nServer Deployment Guide\n\n\nHow to write module driver for Wio Link\n\n\n\n\n\n\nSoftware\n\n\nSourcecode on \nGithub\n\n\n\n\n\n\nHardware\n\n\nSchematic File in \nPDF\n\n\nSchematic File in \nEagle\n\n\n\n\n\n\nCertificate\n\n\nCE/FCC/TELEC Certified(only) for core module ESP-WROOM-02", 
            "title": "Wio Node"
        }, 
        {
            "location": "/Wio_Node/#features", 
            "text": "No hardware programming or No breadboard or No jumper wires or No soldering required.  A lot of Grove modules are supported (Check the list in Mobile App).  Plug-n-Play Grove Modules  Visual configuration instead of microcontroller programming.  Update automatically via cloud compiling and OTA.  Bring Real-world to Virtual platform. All sensors become virtual RESTful API.  Android   iOS Apps to manage Wio Node.  IFTTT supported by Seeed s Channel  CE/FCC/TELEC Certified for core module ESP-WROOM-02", 
            "title": "Features"
        }, 
        {
            "location": "/Wio_Node/#specifications", 
            "text": "General  Value  Power Management  Value      Size  28mm * 28mm  DC Current Per I/O Pin  12mA    Crystal  26MHz  Input Voltage (Micro USB)  5V    Flash Memory  4MBytes (W25Q32B)  Input Voltage (Battery holder)  3.4~4.2V    Wi-Fi Network Protocol  802.11b/g/n  Output DC Current  1000mA MAX    Wi-Fi Encryption Technology  WEP/TKIP/AES  Operating Voltage  3.3V    Expansion Grove Connector1  UART0/I2C0/D0  Charge Current  500mA MAX    Expansion Grove Connector2  Analog/I2C1/D1", 
            "title": "Specifications"
        }, 
        {
            "location": "/Wio_Node/#application-ideas", 
            "text": "Wio Node is well designed to provide simple and economic Wi-Fi solutions for projects like:   Smart Home  Intelligent environmental monitoring  Funny Toys  Web of Things  Internet of Things   In fact, there re many projects in our  recipe , come and visit it to find some interesting projects or even share you own projects, I am sure it will gain a lot of fans for you.     Irrigation control system  The internet of led wall  Dog feeding machine           MAKE IT NOW  MAKE IT NOW  MAKE IT NOW        Kickstarter Monitor  MIssing Call Monitor  Boss Key           MAKE IT NOW  MAKE IT NOW  MAKE IT NOW      Note  Some of the recipes are made by Wio Link, you can replace it with a Wio Node.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Wio_Node/#hardware-overview", 
            "text": "No.  Name  Function      1  Function  Set Wio Node working mode    2  ESP8266  Microcontroller based on ESP8266    3  Reset  Reset the device    4  Micro USB  Supply the device and charge the battery    5  Battery Holder  A jst2.0 connector, connect a 3.7V Li-Battery    6  Analog/I2C1/D1  Grove port, you can connect a Digital/I2C/Analog type Grove module    7  UART/I2C0/D0  Grove port, you can connect a UART/I2C/Digital type Grove module", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Wio_Node/#status-leds", 
            "text": "Near to the FUNCTION button there re 2 status Leds, a blue one and a red one. The BLUE led is the network status indicating led. It has the following blink patterns:   breathing Under configuration mode  blink twice quickly then off 1s requesting IP address from router  blink once quickly then off 1s connecting to the server  on 1s then off 1s The node is online  on constantly the node is dead for not getting IP or not connecting to server.  blink quickly (on 100ms then off 100ms) OTA    Note  The BLUE led is attached to GPIO2 which is also the TX pin of UART1. When downloading firmware, the UART1 dumps the data transmitting on UART0 by instinct. So the BLUE led will blink while downloading firmware. After startup the GPIO2 will be configured as a GPIO not TX of UART1.   The RED led is another status led which indicates the power status of Grove modules. All the six Grove interface s VCC converge together and can be controlled with GPIO 15. When the node is in deep sleep mode, all the grove modules lose their power too. The RED led will light on when Grove modules are powered and will go off when Grove modules aren t powered.", 
            "title": "Status LEDs"
        }, 
        {
            "location": "/Wio_Node/#bonus", 
            "text": "Wio Node has an inbuilt LiPo battery charger, so you can charge 3.7v LiPo battery through JST 2.0 Port when USB is connecting.   Note   Please handle the USB micro type-B socket gently, or you may break the socket apart from the board.  Battery is not included in the package. But we have arranged plenty of choices for you in  Bazzar .", 
            "title": "Bonus!"
        }, 
        {
            "location": "/Wio_Node/#get-started", 
            "text": "Let us build a very basic LED application with Wio Node, in this application you will be able to control LED by your smartphone in about 5 minutes. Before we start, please make sure you have below things on hand:     Wio Node  Grove - LED  Micro USB Cable           GET ONE NOW  GET ONE NOW  GET ONE NOW      Note   A smartphone is needed as well (Android OS version 4.1 or advanced, iOS version 7 or advanced)  Grove - LED include a Grove cable already", 
            "title": "Get Started"
        }, 
        {
            "location": "/Wio_Node/#step-1-install-androidios-app", 
            "text": "You need to install the Wio Link App to manage and configure your Wio Node devices.  Download the Android or iOS App and install. Or you can go to app store of Apple or Google market and search  Wio Link , you will find it.           Get Android App  Get iOS App      Note  Make sure your Android OS version is 4.1 or advanced, iOS version is 7 or advanced.", 
            "title": "STEP 1: Install Android/iOS App"
        }, 
        {
            "location": "/Wio_Node/#step-2-create-your-account", 
            "text": "If it is your first time to use Wio APP, it may require GPS authorization, please approve it, then sign up.  If you already have an account, check the server location before logging in.    Note   Please pay attention to the server location, because wrong server location will lead to failure when connecting to Wio Node.", 
            "title": "STEP 2: Create your Account"
        }, 
        {
            "location": "/Wio_Node/#step-3-connect-wio-node-to-internet", 
            "text": "Push and hold the CONFIG button until the blue LED turns into breathing mode (i.e. blinking with fade in   fade out effect). It means that Wio Node has turned to configuration mode successfully and can be detected by the Wio App.  Push  Add your first Device .  Choose Wio Node  Go to Wi-Fi list  will lead you to the Wi-Fi setting interface of your smartphone.     If you have successfully made the blue LED turn into breathing mode, you will find the Wio Node in the Wi-Fi list, connect to it!(Usually it is not called Wio Node in the Wi-Fi list, in the example, mine is Wio_091016, you may find one named wio_xxxxxx in your list.)  Once connected, you will receive a notice, then you can go back to the app   Next step is connecting to the Wi-Fi of your home or company     If there is password pf the Wi-Fi you want to connect, it may require you to enter the password  Consider that you may need to connect more than 1 Wio Node in the future, a special name will make you distinguish them from each other easily.", 
            "title": "STEP 3: Connect Wio Node to Internet"
        }, 
        {
            "location": "/Wio_Node/#step-4-virtually-interconnect-modules-with-wio-node-and-update-firmware", 
            "text": "Click the Wio Node and you will be in the main interface.  There are 2 grove connectors, select the left one (D0).  Because LED is output devices. Choose output category  Find the icon that looks like a bulb, choose it.  Then you will find the bottom rectangle button becomes red and  View API  becomes  Update Firmware . Choose  Update Firmware     Since you selected the D0 port to connect with LED in the APP, you need to connect the real Grove-LED to D0 port of Wio Node too.", 
            "title": "STEP 4: Virtually interconnect modules with Wio Node and update firmware"
        }, 
        {
            "location": "/Wio_Node/#step-5-test-application-using-apis", 
            "text": "Now that  you have successfully connect the LED to Wio Node, click  View API  to check the API of Wio Node  Input  1  or  0  in the  Test Request  area, and click  Post  button and see what will happen.", 
            "title": "STEP 5: Test application using APIs"
        }, 
        {
            "location": "/Wio_Node/#get-started-with-ifttt-dobutton", 
            "text": "Dont t know how to code? Don t worry, with the help of  IFTTT , even if you know nothing about coding, you are still able to build some simple projects.  IFTTT is an abbreviation of  If This Then That , it is a free web-based service that allows users to create chains of simple conditional statements, called  recipes , which are triggered based on changes to other web services such as Gmail, Facebook, Instagram. How does IFTTT work with Wio Node\uff1f As you can see in below pictures, seeed provided cloud service at wio.seeed.io, which can interchange data and send instructions to IFTTT and Wio Node. So by creating some simple recipe, you are able to hack things without coding.   If you don t have an IFTTT account, click  here  to sign up.  If you already have an IFTTT account,click  here  to connect with Seeed, or search Seeed at IFTTT website. There you will find 9 recipes by Seeed to teach you how to us e IFTTT. \nWhat is DoButton? DoButton is one of IFTTT s application that empowers you to create your own personalized button with just a tap, it is very suitable for building IoT projects and control it through your smartphone, here are two examples to show you how to use IFTTT DoButton to make useful applications.", 
            "title": "Get started with IFTTT &amp; DoButton"
        }, 
        {
            "location": "/Wio_Node/#example", 
            "text": "IFTTT  DoButton      [ Recipe ] DIY an Automatic Garden Irrigation without coding  [ Recipe ] How to feed your pets when you re not home    [ Video ] How to use ITFFF  [ Video ] How to use DoButton", 
            "title": "Example:"
        }, 
        {
            "location": "/Wio_Node/#advanced-guide", 
            "text": "Feel those examples too simple? Wanna make more complicated proejects? Here are the best guides for advanced users to hack things with Wio nude. By these guides, advanced users are able to know more detail information about Wio Node, deploy private server, even write module driver for Wio Node.    The guide covers:   API Reference  Server Deployment Guide  Advanced User Guide  How to write module driver for Wio Link?    Note  The guide is writen for Wio Link, but applies to Wio Node as well.", 
            "title": "Advanced Guide"
        }, 
        {
            "location": "/Wio_Node/#grove-support-list", 
            "text": "SKU  Name  Interface  Link      101020008  Grove - Moisture Sensor  Generic Analog Input  link    101020014  Grove - Light Sensor  Generic Analog Input  link    101020015  Grove - Temperature Sensor  Generic Analog Input  link    101020017  Grove - Rotary Angle Sensor  Generic Analog Input  link    101020022  Grove - Light Sensor(P)  Generic Analog Input  link    101020023  Grove - Sound Sensor  Generic Analog Input  link    101020027  Grove - Electricity Sensor  Generic Analog Input  link    101020036  Grove - Slide Potentiometer  Generic Analog Input  link    101020042  Grove - 80cm Infrared Proximity Sensor  Generic Analog Input  link    101020043  Grove - UV Sensor  Generic Analog Input  link    101020048  Grove - Rotary Angle Sensor(P)  Generic Analog Input  link    101020063  Grove - Loudness Sensor  Generic Analog Input  link    101020076  Grove - Luminance Sensor  Generic Analog Input  link    101020078  Grove - Air quality sensor v1.3  Generic Analog Input  link    101020003  Grove - Button  Generic Digital Input  link    101020004  Grove - Switch(P)  Generic Digital Input  link    101020005  Grove - Collision Sensor  Generic Digital Input  link    101020009  Grove - Line Finder  Generic Digital Input  link    101020018  Grove - Water Sensor  Generic Digital Input  link    101020020  Grove - PIR Motion Sensor  Generic Digital Input  link    101020025  Grove - Tilt Switch  Generic Digital Input  link    101020037  Grove - Touch Sensor  Generic Digital Input  link    101020038  Grove - Magnetic Switch  Generic Digital Input  link    101020046  Grove - Hall Sensor  Generic Digital Input  link    101020049  Grove - Flame Sensor  Generic Digital Input  link    111020000  Grove - Button(P)  Generic Digital Input  link    101020073  Grove - Electromagnet  Generic Digital Output  link    101020090  Grove - Water Atomization v1.0  Generic Digital Output  link    103020004  Grove - Solid State Relay  Generic Digital Output  link    103020005  Grove - Relay  Generic Digital Output  link    103020008  Grove - MOSFET  Generic Digital Output  link    103020010  Grove - 2-Coil Latching Relay  Generic Digital Output  link    103020012  Grove - SPDT Relay(30A)  Generic Digital Output  link    103020014  Grove - Dry-Reed Relay  Generic Digital Output  link    104020001  Grove - Variable Color LED  Generic Digital Output  link    104020002  Grove - Purple LED (3mm)  Generic Digital Output  link    104020005  Grove - LED String Light  Generic Digital Output  link    104030005  Grove - Red LED  Generic Digital Output  link    104030007  Grove - Green LED  Generic Digital Output  link    104030009  Grove - White LED  Generic Digital Output  link    104030010  Grove - Blue LED  Generic Digital Output  link    104030014  Grove - Multi Color Flash LED (5mm)  Generic Digital Output  link    105020003  Grove - Vibration Motor  Generic Digital Output  link    105020004  Grove - Mini Fan  Generic Digital Output  link    105020005  Grove - EL Driver  Generic Digital Output  link    107020000  Grove - Buzzer  Generic Digital Output  link    107020001  Grove - Speaker  Generic Digital Output  link    101020034  Grove - 3-Axis Digital Compass  I2C  link    101020039  Grove - 3-Axis Digital Accelerometer(\u00b11.5g)  I2C  link    101020050  Grove - 3-Axis Digital Gyro  I2C  link    101020072  Grove - Barometer Sensor (BMP180)  I2C  link    101020083  Grove - Gesture  I2C  link    101020088  Grove - Multichannel Gas Sensor  I2C  link    103020013  Grove - I2C ADC  I2C  link    104030008  Grove - OLED Display 1.12  I2C  link    104030011  Grove - OLED Display 0.96  I2C  link    105020001  Grove - I2C Motor Driver  I2C  link    107020006  Grove - I2C FM Receiver  I2C  link    101020192  Grove - Barometer(BMP280)  I2C  link    101020193  Grove - Temp Humi Barometer Sensor(BME280)  I2C  link    101020010  Grove - Ultrasonic Ranger  Others  link    101020016  Grove - Infrared Receiver  Others  link    101020019  Grove - Temperature Humidity Sensor Pro  Others  link    101020026  Grove - Infrared Emitter  Others  link    101020029  Grove - Infrared Reflective Sensor  Others  link    101020030  Grove - Digital Light Sensor  Others  link    101020040  Grove - IR Distance Interrupter  Others  link    103020018  Grove - Recorder  Others  link    104020006  Grove - LED Bar v2.0  Others  link    104030003  Grove - 4-Digit Display  Others  link    316010005  Grove - Servo  Others  link    101020067  Grove - CO2 Sensor  UART  link", 
            "title": "Grove Support List"
        }, 
        {
            "location": "/Wio_Node/#faq", 
            "text": "Here are some questions that we usually received from new users. If you have any other issues when you are using Wio Node or other Wio products, welcome to the  Community of Wio  where there are many professional users waiting to give you advices and also many advanced users providing plenty of ideas on how to use Wio products!   Q1. What s the difference between Wio Node and Wio Link?   Wio Node is like mini Wio Link, it is only quarter size of Wio Link and much cheaper. Despite the size and price, Wio Node still has full function of Wio Link. For those who prefer smaller size to more grove connectors. Wio node is the best choice.   2. What should I do if can t connect with Server?   Log out and check if you chose wrong server before logging in. If you are not in China Mainland, please choose global server.   3. Fail to configure Wio Node and can t find Wio Node in wifi list?   Pay attention to the blue LED. Make sure it is in breathing mode (blinking with fade in   fade out effect, it is a very unique mode, very easy to recognize) before any further steps. Only the LED in breathing mode can Wio Node be found in WiFi list.   4. If I want to connect more than 1 I2C devices, what should I do?   Grove-I2C hub  can branch 1 I2C port into 4. Come to  Bazzar  to get one!   5. Can I change Wio Node into sleep mode?   Yes, please check the last API, where you can command Wio Node into sleep mode.", 
            "title": "FAQ"
        }, 
        {
            "location": "/Wio_Node/#resources", 
            "text": "Documentation and references  API Reference  Server Deployment Guide  How to write module driver for Wio Link    Software  Sourcecode on  Github    Hardware  Schematic File in  PDF  Schematic File in  Eagle    Certificate  CE/FCC/TELEC Certified(only) for core module ESP-WROOM-02", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Differential_Amplifier_v1.2/", 
            "text": "This Grove is designed for precise differential-input amplification. Input the differential signals of your sensor to this module through the male pins, then your Arduino will get a precisely amplified output from the Grove interface. The gain scale factor is selectable. You can get a 35 times or 1085 times amplification via a switch on the board. \n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nHigh amplifying precision\n\n\nSelectable scale factor\n\n\nCan be conveniently read by Arduino\n\n\n\n\nApplications\n\uf0c1\n\n\n\n\nData acquisition\n\n\nBattery operated systems\n\n\nPressure and temperature bridge amplifiers\n\n\nGeneral purpose instrumentation\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nOperating Voltage\n\n\n\n\n2.7\n\n\n\n\n5.0\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nInput Voltage\n\n\n\n\n0.1\n\n\n\n\n\\\\\n\n\n\n\n(Vcc-0.8)/Gain\n\n\n\n\nmV\n\n\n\n\n\n\n\n\nOutput Voltage\n\n\n\n\n0\n\n\n\n\n\\\\\n\n\n\n\nVcc-0.80\n\n\n\n\nmV\n\n\n\n\n\n\n\n\nGain\n\n\n\n\nSelect 35\n\n\n\n\n/\n\n\n\n\n35\n\n\n\n\n/\n\n\n\n\n/\n\n\n\n\n\n\n\n\nSelect 1085\n\n\n\n\n/\n\n\n\n\n1085\n\n\n\n\n/\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\n1. Sensor Choosing\n\n\nThe amplifier can turn signals in mA scale up to A scale. Before using it, make sure the output range of your sensor is in mA scale. For example, \nWeight Sensor\n is one of them.\n\n\n2. Connector Reforming\n\n\nTo pair the weight sensor up with the male pins on the amplifier, female connectors need to be soldered on its wires.\n\n\n\n\n3. Hardware Hookup\n\n\nConnect the weight sensor to the amplifier as the picture depicts below.\n\n\n\n\n4. Measurement\n\n\nCopy and paste the demo code below to Arduino IDE and upload it.\n\n\n    void setup()\n    {\n      Serial.begin(9600);\n      Serial.println(\nstart\n);\n    }\n\n    void loop()\n    {\n      int i;\n      int value;\n      float V,Vo;\n      float Sum=0;\n      for(i=0;i\n10;i++)\n      {\n        value=analogRead(4);\n        V=value*5.00/1023;\n        Sum+=V;\n        delay(10);\n      }\n      Vo=Sum/10;\n      Serial.print(\nOutput score:\n);\n      Serial.println(Vo);\n      delay(1000);\n    } \n\n\n\n\nYou can view the amplified signals via serial monitor. For the value of the input signal, you need to use the multimeter to measure the voltage difference between VIN+ and VIN-.\n\n\nResources\n\uf0c1\n\n\n\n\nv1.2 Eagle File\n\n\nv1.2 Schematic\n\n\nINA132 Datasheet", 
            "title": "Grove - Differential Amplifier v1.2"
        }, 
        {
            "location": "/Grove-Differential_Amplifier_v1.2/#features", 
            "text": "High amplifying precision  Selectable scale factor  Can be conveniently read by Arduino", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Differential_Amplifier_v1.2/#applications", 
            "text": "Data acquisition  Battery operated systems  Pressure and temperature bridge amplifiers  General purpose instrumentation", 
            "title": "Applications"
        }, 
        {
            "location": "/Grove-Differential_Amplifier_v1.2/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nOperating Voltage  \n2.7  \n5.0  \n5.5  \nVDC    \nInput Voltage  \n0.1  \n\\\\  \n(Vcc-0.8)/Gain  \nmV    \nOutput Voltage  \n0  \n\\\\  \nVcc-0.80  \nmV    \nGain  \nSelect 35  \n/  \n35  \n/  \n/    \nSelect 1085  \n/  \n1085  \n/", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Differential_Amplifier_v1.2/#usage", 
            "text": "1. Sensor Choosing  The amplifier can turn signals in mA scale up to A scale. Before using it, make sure the output range of your sensor is in mA scale. For example,  Weight Sensor  is one of them.  2. Connector Reforming  To pair the weight sensor up with the male pins on the amplifier, female connectors need to be soldered on its wires.   3. Hardware Hookup  Connect the weight sensor to the amplifier as the picture depicts below.   4. Measurement  Copy and paste the demo code below to Arduino IDE and upload it.      void setup()\n    {\n      Serial.begin(9600);\n      Serial.println( start );\n    }\n\n    void loop()\n    {\n      int i;\n      int value;\n      float V,Vo;\n      float Sum=0;\n      for(i=0;i 10;i++)\n      {\n        value=analogRead(4);\n        V=value*5.00/1023;\n        Sum+=V;\n        delay(10);\n      }\n      Vo=Sum/10;\n      Serial.print( Output score: );\n      Serial.println(Vo);\n      delay(1000);\n    }   You can view the amplified signals via serial monitor. For the value of the input signal, you need to use the multimeter to measure the voltage difference between VIN+ and VIN-.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Differential_Amplifier_v1.2/#resources", 
            "text": "v1.2 Eagle File  v1.2 Schematic  INA132 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-I2C_Hub/", 
            "text": "I2C Hub Grove is an extension Grove module for connecting multiply I2C devices to Grove Base Shield. It can use with \nUniversal 4 Pin to X2 4 Pin cable\n and connects up to 3 I2C devices which may cover most developing purpose.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nChainable\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nUsing more I2C devices than you otherwise have room for on your Grove platform.\n\n\n\n\nUsage\n\uf0c1\n\n\nIt does not conflict if you use the same I2C Socket simultaneously because every I2C device has its own address. Hardware installation is shown below.\n\n\n\n\nHere we do not list a specific example.\n\n\nResources\n\uf0c1\n\n\nI2C Hub Eagle File", 
            "title": "Grove - I2C Hub"
        }, 
        {
            "location": "/Grove-I2C_Hub/#features", 
            "text": "Chainable", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-I2C_Hub/#application-ideas", 
            "text": "Using more I2C devices than you otherwise have room for on your Grove platform.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-I2C_Hub/#usage", 
            "text": "It does not conflict if you use the same I2C Socket simultaneously because every I2C device has its own address. Hardware installation is shown below.   Here we do not list a specific example.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-I2C_Hub/#resources", 
            "text": "I2C Hub Eagle File", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-MOSFET/", 
            "text": "Grove \u2013 MOSFET enables you to control higher voltage project, say 15VDC, with low voltage, say 5V, on microcontroller. MOSFET is also a kind of switch, but its switching frequency can reach up to 5MHz, much faster than normal mechanical relay. There are two screw terminals on the board. One for outer power source and the other for device you want to control. Grove \u2013 MOSFET will pass the power from one end to another when closed. But if outer power source is absent, your device can still draw power from microcontroller via the Grove interface.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nWorking voltage: 5V\n\n\nVin: 5 ~ 15V\n\n\nMOSFET Model: CJQ4435\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nVin: Accepts 5V ~ 15V power of which current is less than 2A.\n\n\nVout: Attach actuators here.\n\n\nDemonstration\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nHere we demonstrate how to use Grove - MOSFET to control a motor. We provide power for it with external power source, but if your controlled device needs current smaller than 300mA, Seeeduino can totally support it and no extra power source needed.\n\n\n\n\n    // demo of Grove - MOSFET\n    // use pin 6 to control a motor\n\n    int motorPin = 6;\n\n    void setup()\n    {\n        Serial.begin(38400);\n        pinMode(motorPin, OUTPUT);\n        Serial.println(\nGrove - MOSFET Test Demo!\n);\n    }\n\n    void loop()\n    {\n        motorOnThenOffWithSpeed();\n        motorAcceleration();\n    }\n\n    void motorOnThenOffWithSpeed()\n    {\n        int onSpeed  = 200;                         // a number between 0 (stopped) and 255 (full speed)\n        int onTime   = 2500;\n        int offSpeed = 50;                          // a number between 0 (stopped) and 255 (full speed)\n        int offTime  = 1000;\n        analogWrite(motorPin, onSpeed);\n        delay(onTime);\n        analogWrite(motorPin, offSpeed);\n        delay(offTime);\n    }\n\n    void motorAcceleration()\n    {\n        int delayTime = 50;\n        for(int i=0; i\n256; i++)\n        {\n            analogWrite(motorPin, i);\n            delay(delayTime);\n        }\n\n        for(int i=255; i\n=0; i--)\n        {\n            analogWrite(motorPin, i);\n            delay(delayTime);\n        }\n    }\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D6 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_mosfet.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove MOSFET to analog port D6\n    # SIG,NC,VCC,GND\n    mosfet = 6\n\n    grovepi.pinMode(mosfet,\nOUTPUT\n)\n    time.sleep(1)\n\n    while True:\n        try:\n            # Full speed\n            grovepi.analogWrite(mosfet,255)\n            print \nfull speed\n\n            time.sleep(2)\n\n            # Half speed\n            grovepi.analogWrite(mosfet,128)\n            print \nhalf speed\n\n            time.sleep(2)\n\n            # Off\n            grovepi.analogWrite(mosfet,0)\n            print \noff\n\n            time.sleep(2)\n\n        except KeyboardInterrupt:\n            grovepi.analogWrite(mosfet,0)\n            break\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_mosfet.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - MOSFET Eagle File\n\n\nCJQ4435 Datasheet\n\n\nMOSFET Wikipedia\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - MOSFET"
        }, 
        {
            "location": "/Grove-MOSFET/#specifications", 
            "text": "Working voltage: 5V  Vin: 5 ~ 15V  MOSFET Model: CJQ4435", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-MOSFET/#hardware-overview", 
            "text": "Vin: Accepts 5V ~ 15V power of which current is less than 2A.  Vout: Attach actuators here.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-MOSFET/#demonstration", 
            "text": "", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-MOSFET/#with-arduino", 
            "text": "Here we demonstrate how to use Grove - MOSFET to control a motor. We provide power for it with external power source, but if your controlled device needs current smaller than 300mA, Seeeduino can totally support it and no extra power source needed.       // demo of Grove - MOSFET\n    // use pin 6 to control a motor\n\n    int motorPin = 6;\n\n    void setup()\n    {\n        Serial.begin(38400);\n        pinMode(motorPin, OUTPUT);\n        Serial.println( Grove - MOSFET Test Demo! );\n    }\n\n    void loop()\n    {\n        motorOnThenOffWithSpeed();\n        motorAcceleration();\n    }\n\n    void motorOnThenOffWithSpeed()\n    {\n        int onSpeed  = 200;                         // a number between 0 (stopped) and 255 (full speed)\n        int onTime   = 2500;\n        int offSpeed = 50;                          // a number between 0 (stopped) and 255 (full speed)\n        int offTime  = 1000;\n        analogWrite(motorPin, onSpeed);\n        delay(onTime);\n        analogWrite(motorPin, offSpeed);\n        delay(offTime);\n    }\n\n    void motorAcceleration()\n    {\n        int delayTime = 50;\n        for(int i=0; i 256; i++)\n        {\n            analogWrite(motorPin, i);\n            delay(delayTime);\n        }\n\n        for(int i=255; i =0; i--)\n        {\n            analogWrite(motorPin, i);\n            delay(delayTime);\n        }\n    }", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-MOSFET/#with-raspberry-pi", 
            "text": "1.You should have a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D6 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_mosfet.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove MOSFET to analog port D6\n    # SIG,NC,VCC,GND\n    mosfet = 6\n\n    grovepi.pinMode(mosfet, OUTPUT )\n    time.sleep(1)\n\n    while True:\n        try:\n            # Full speed\n            grovepi.analogWrite(mosfet,255)\n            print  full speed \n            time.sleep(2)\n\n            # Half speed\n            grovepi.analogWrite(mosfet,128)\n            print  half speed \n            time.sleep(2)\n\n            # Off\n            grovepi.analogWrite(mosfet,0)\n            print  off \n            time.sleep(2)\n\n        except KeyboardInterrupt:\n            grovepi.analogWrite(mosfet,0)\n            break\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_mosfet.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-MOSFET/#resources", 
            "text": "Grove - MOSFET Eagle File  CJQ4435 Datasheet  MOSFET Wikipedia", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-MOSFET/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Mini_Camera/", 
            "text": "If you are searching a small size camera, perhaps, Grove-Mini Camera would be your best choice. It\u2019s a mini camera which can be controlled by Arduino. It has integrated image processing to generate 1280*720 JPEG image. The captured pictures are stored in SD card and you can read SD card information via Mini 8Pin USB interface.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nStandard USB Interface and Grove Interface\n\n\nHigh resolution\n\n\nTiny size and light weight\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nPerformance Parameter\n\n\n\n\n\n\n\n\n\n\nCPU\n\n\nARM9\n\n\n\n\n\n\nVideo Decode\n\n\nH.263 Accele\n\n\n\n\n\n\nVideo Format\n\n\nAVI\n\n\n\n\n\n\nVideo Encode\n\n\nMPEG4\n\n\n\n\n\n\nVideo Resolution\n\n\n640*480\n\n\n\n\n\n\nVideo Frame Rate\n\n\n30FPS\n\n\n\n\n\n\nRun Software\n\n\nsupport AVI Player\n\n\n\n\n\n\nPhoto Format\n\n\nJPEG\n\n\n\n\n\n\nImage Resolution\n\n\n1280*720\n\n\n\n\n\n\nCharge mode\n\n\nDC5V\n\n\n\n\n\n\nData Communication Interface\n\n\nMini 8Pin USB\n\n\n\n\n\n\nStorage Medium\n\n\nMicro SD (Max 32G)\n\n\n\n\n\n\n\n\nDemonstration\n\uf0c1\n\n\nDifferent from general camera, Grove - Mini Camera can be controlled by Arduino/Seeeduino.\n\n\nNow let us use the Grove - Mini camera to achieve this function: shoot a picture every time when someone approaches.\n\n\nTo do it, we need a \nGrove - PIR Motion sensor\n which can spot any motion within a certain scope.\n\n\nLet us start to make it:\n\n\n\n\nPlug SD card into SD card socket, SD card is not included in this Grove and its size can\nt be larger than 32G.\n\n\nConnect Grove - Mini Camera to D2 port of \nGrove - Base Shield\n, and Grove - PIR Motion Sensor to D5 port.\n\n\nPlug Grove - Base Shield into Arduino/Seeeduino, then connect Arduino/Seeeduino to PC using a USB cable.\n\n\n\n\n\n\n\n\nOpen Arduino IDE, copy and paste the code below to a new sketch:\n\n\n\n\n    /*Using digital 2 to control Camera*/\n    /*Using digital 5 to receive sensor signal*/\n    #define KEY 2\n    #define PIR_MOTION_SENSOR 5  \n\n    void setup()\n    { \n      Serial.begin(9600);\n      pinMode(KEY,OUTPUT);\n      pinMode(PIR_MOTION_SENSOR,INPUT);\n      delay(100);\n      enterStandbyMode();\n      makeVideo(5000);\n\n    }\n    void loop()\n    {\n        int sensorValue = digitalRead(PIR_MOTION_SENSOR);\n        if(sensorValue == HIGH)  //when the sensor value is HIGH, someone is in here\n        {\n           takePicture();\n               delay(5000);      \n        }\n    }\n    void takePicture(void)\n    {\n       digitalWrite(KEY,HIGH);\n       delay(1000);\n       digitalWrite(KEY,LOW);\n       delay(1000);\n    }\n    void enterStandbyMode(void)\n    {\n      //set the key pin as high level for 2s,enter the standby state  \n      digitalWrite(KEY,HIGH);\n      delay(2000);\n      digitalWrite(KEY,LOW);\n      delay(1000); \n    }\n    void makeVideo(long int videoTime)\n    {\n      //set the key pin as high level for 2s again, from the standby state to video state\n      digitalWrite(KEY,HIGH);\n      delay(2000);\n      digitalWrite(KEY,LOW);\n      delay(videoTime); //make a  video for videoTime.Its unit is ms.  \n     // stop the video\n      digitalWrite(KEY,HIGH);\n      delay(1000);\n      digitalWrite(KEY,LOW);\n      delay(1000);\n    }\n    void PoweroffMode(void)\n    {\n      //set the key pin as high level for 5s,enter the poweroff state  \n      digitalWrite(KEY,HIGH);\n      delay(5000);\n      digitalWrite(KEY,LOW);\n      delay(1000); \n    }\n\n\n\n\n\n\nUpload the code. Please click \nhere\n if you do not know how to upload.\n\n\nNow there should be a video in the SD card because we call the function once during Setup(). To play the video, you can either directly connect the camera to PC via USB cable or use a reader to read it. And if somebody approaches when it\ns working, you should also find some pictures in the SD cards also.\n\n\n\n\nReference\n\uf0c1\n\n\nHere is the state description of this mini camera. There are 5 working states.\n\n\n1. Standby\uff1a\n Set key as high level for 2 seconds when in the power off state, Red LED will come on. Mini camera enters Standby state.\n\n\n2. Power off:\n Set key as high level for 5 seconds, camera enter Power off state, Red LED will fade out.\n\n\n3. Take pictures:\n Set key as high level for about 1000ms when in the power on state, camera can take a picture. Red LED will blink once to tell you that one picture has been taken. Afterwards, it automatically enters standby state.\n\n\n4. Video:\n Set key as high level for 2 seconds when in the standby state, Camera will enter video state and red LED blinks continuously. To stop it, set key as high level for about 1000ms, camera will enter to standby state.\n\n\n5. Files storage:\n Connect camera to pc using USB cable, you can open image file and VIDEO file. You can also access the files in the SD card by a SD card reader.\n\n\nResources\n\uf0c1\n\n\n\n\nMini Camera Eagle File\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Mini Camera"
        }, 
        {
            "location": "/Grove-Mini_Camera/#features", 
            "text": "Standard USB Interface and Grove Interface  High resolution  Tiny size and light weight", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Mini_Camera/#specifications", 
            "text": "Item  Performance Parameter      CPU  ARM9    Video Decode  H.263 Accele    Video Format  AVI    Video Encode  MPEG4    Video Resolution  640*480    Video Frame Rate  30FPS    Run Software  support AVI Player    Photo Format  JPEG    Image Resolution  1280*720    Charge mode  DC5V    Data Communication Interface  Mini 8Pin USB    Storage Medium  Micro SD (Max 32G)", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Mini_Camera/#demonstration", 
            "text": "Different from general camera, Grove - Mini Camera can be controlled by Arduino/Seeeduino.  Now let us use the Grove - Mini camera to achieve this function: shoot a picture every time when someone approaches.  To do it, we need a  Grove - PIR Motion sensor  which can spot any motion within a certain scope.  Let us start to make it:   Plug SD card into SD card socket, SD card is not included in this Grove and its size can t be larger than 32G.  Connect Grove - Mini Camera to D2 port of  Grove - Base Shield , and Grove - PIR Motion Sensor to D5 port.  Plug Grove - Base Shield into Arduino/Seeeduino, then connect Arduino/Seeeduino to PC using a USB cable.     Open Arduino IDE, copy and paste the code below to a new sketch:       /*Using digital 2 to control Camera*/\n    /*Using digital 5 to receive sensor signal*/\n    #define KEY 2\n    #define PIR_MOTION_SENSOR 5  \n\n    void setup()\n    { \n      Serial.begin(9600);\n      pinMode(KEY,OUTPUT);\n      pinMode(PIR_MOTION_SENSOR,INPUT);\n      delay(100);\n      enterStandbyMode();\n      makeVideo(5000);\n\n    }\n    void loop()\n    {\n        int sensorValue = digitalRead(PIR_MOTION_SENSOR);\n        if(sensorValue == HIGH)  //when the sensor value is HIGH, someone is in here\n        {\n           takePicture();\n               delay(5000);      \n        }\n    }\n    void takePicture(void)\n    {\n       digitalWrite(KEY,HIGH);\n       delay(1000);\n       digitalWrite(KEY,LOW);\n       delay(1000);\n    }\n    void enterStandbyMode(void)\n    {\n      //set the key pin as high level for 2s,enter the standby state  \n      digitalWrite(KEY,HIGH);\n      delay(2000);\n      digitalWrite(KEY,LOW);\n      delay(1000); \n    }\n    void makeVideo(long int videoTime)\n    {\n      //set the key pin as high level for 2s again, from the standby state to video state\n      digitalWrite(KEY,HIGH);\n      delay(2000);\n      digitalWrite(KEY,LOW);\n      delay(videoTime); //make a  video for videoTime.Its unit is ms.  \n     // stop the video\n      digitalWrite(KEY,HIGH);\n      delay(1000);\n      digitalWrite(KEY,LOW);\n      delay(1000);\n    }\n    void PoweroffMode(void)\n    {\n      //set the key pin as high level for 5s,enter the poweroff state  \n      digitalWrite(KEY,HIGH);\n      delay(5000);\n      digitalWrite(KEY,LOW);\n      delay(1000); \n    }   Upload the code. Please click  here  if you do not know how to upload.  Now there should be a video in the SD card because we call the function once during Setup(). To play the video, you can either directly connect the camera to PC via USB cable or use a reader to read it. And if somebody approaches when it s working, you should also find some pictures in the SD cards also.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Mini_Camera/#reference", 
            "text": "Here is the state description of this mini camera. There are 5 working states.  1. Standby\uff1a  Set key as high level for 2 seconds when in the power off state, Red LED will come on. Mini camera enters Standby state.  2. Power off:  Set key as high level for 5 seconds, camera enter Power off state, Red LED will fade out.  3. Take pictures:  Set key as high level for about 1000ms when in the power on state, camera can take a picture. Red LED will blink once to tell you that one picture has been taken. Afterwards, it automatically enters standby state.  4. Video:  Set key as high level for 2 seconds when in the standby state, Camera will enter video state and red LED blinks continuously. To stop it, set key as high level for about 1000ms, camera will enter to standby state.  5. Files storage:  Connect camera to pc using USB cable, you can open image file and VIDEO file. You can also access the files in the SD card by a SD card reader.", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-Mini_Camera/#resources", 
            "text": "Mini Camera Eagle File", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Mini_Camera/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Serial_Camera/", 
            "text": "The Serial Camera is a JPEG color camera module easy for MCU use.It has integrated image processing DSP to generate 320\n240 or 640\n480 JPEG image without thumbnail information, Captured picture will be stored in internal buffer and transferred via UART port.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove Interface\n\n\nJPEG compressed image without Thumbnail Information\n\n\n5V power supply\n\n\nSmall and compact\n\n\nProtocol control\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nOperating Voltage\n\n\n\n\n4,8\n\n\n\n\n5.0\n\n\n\n\n5.3\n\n\n\n\nV\n\n\n\n\n\n\n\n\nResolution (default)\n\n\n\n\n640x480 / 320x240\n\n\n\n\n/\n\n\n\n\n\n\n\n\nDefault Baud rate of serial port\n\n\n\n\n115200\n\n\n\n\nBaud\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nDigital Cameras with the \nSD card shield\n\n\nVideo monitoring system\n\n\n\n\nUsage\n\uf0c1\n\n\nUse Camera on PC\n\uf0c1\n\n\nStep 1\n:Download dedicated serial port debugging tool \nVC0703COMTOOL.rar\n and install it.\n\n\nStep 2\n: Connect Serial camera to PC with USB to use serial converter tool \nUartSBee\n\n\n\n\n\n\n\n\nSerial camera\n\n\nUart_SB v3.1\n\n\n\n\n\n\n\n\n\n\nGND (black)\n\n\nGND\n\n\n\n\n\n\nVCC (red)\n\n\nVCC\n\n\n\n\n\n\nRX (white)\n\n\nTX\n\n\n\n\n\n\nTX (Yellow)\n\n\nRX\n\n\n\n\n\n\n\n\nStep 3:\n Connect the Uart_SB v3.1 with Computer and Open the vc0703CommTool software. Choose the correct COM number of the port you link to the camera, default baudrate 115200 ,and then open the port.\n\n\nStep 4:\n Click the button \nGet Version\n and it will reset the camera.\n\n\nStep 5:\n Click the button \nFbuf\n to get ready to take a picture.\n\n\n\n\n\n\nClick \nstop CFbuf\n to take a picture.\n\n\n\n\n\n\nClick \nSel File\n to select the file name to store the picture.\n\n\n\n\n\n\nClick \nRead\n to read the data from the buffer to store in the file selected as shown below:\n\n\n\n\n\n\n\n\nClick \nResume\n to resume frame update so you can continue to take another picture.\n\n\n\n\n\n\nUse Camera with Arduino and SD card\n\uf0c1\n\n\nStep 1\n: Connected Grove - Serial Camera to Arduino board, Hardware parts include \nSeeeduino V3.0\n, \nSD Card Shield\n, SanDisk microSD\u2122 Card 2GB, \nGrove - Button\n.\n\n\n\n\nStep 2\n: Change the serial receive buffer(default 64 bytes) to 128 bytes. Open up hardware/arduino/cores directory, and edit the file named wiring_serial.c or HardwareSerial.cpp near the top is a #define SERIAL_BUFFER_SIZE 64, which means 64 bytes are used for the buffer. You need to change this to 128 .More details, please refer to \nArduino Hacks\n.\n\n\nStep 3\n: Download the \nGrove - Serial Camera Library\n, upload it to Seeeduino. If it can\nt be complied, please confirm if the \nSD Library\n is in your Arduino IDE folder.\n\n\nStep 4\n: Open the Serial Monitor , press the button to take picture after SD card and Camera initialization.\n\n\nResources\n\uf0c1\n\n\n\n\nVC0703 debug tool\n\n\nManual for serial camera.pdf\n\n\nGrove - Serial Camera Library", 
            "title": "Grove - Serial Camera"
        }, 
        {
            "location": "/Grove-Serial_Camera/#features", 
            "text": "Grove Interface  JPEG compressed image without Thumbnail Information  5V power supply  Small and compact  Protocol control", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Serial_Camera/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nOperating Voltage  \n4,8  \n5.0  \n5.3  \nV    \nResolution (default)  \n640x480 / 320x240  \n/    \nDefault Baud rate of serial port  \n115200  \nBaud", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Serial_Camera/#application-ideas", 
            "text": "Digital Cameras with the  SD card shield  Video monitoring system", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Serial_Camera/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Serial_Camera/#use-camera-on-pc", 
            "text": "Step 1 :Download dedicated serial port debugging tool  VC0703COMTOOL.rar  and install it.  Step 2 : Connect Serial camera to PC with USB to use serial converter tool  UartSBee     Serial camera  Uart_SB v3.1      GND (black)  GND    VCC (red)  VCC    RX (white)  TX    TX (Yellow)  RX     Step 3:  Connect the Uart_SB v3.1 with Computer and Open the vc0703CommTool software. Choose the correct COM number of the port you link to the camera, default baudrate 115200 ,and then open the port.  Step 4:  Click the button  Get Version  and it will reset the camera.  Step 5:  Click the button  Fbuf  to get ready to take a picture.    Click  stop CFbuf  to take a picture.    Click  Sel File  to select the file name to store the picture.    Click  Read  to read the data from the buffer to store in the file selected as shown below:     Click  Resume  to resume frame update so you can continue to take another picture.", 
            "title": "Use Camera on PC"
        }, 
        {
            "location": "/Grove-Serial_Camera/#use-camera-with-arduino-and-sd-card", 
            "text": "Step 1 : Connected Grove - Serial Camera to Arduino board, Hardware parts include  Seeeduino V3.0 ,  SD Card Shield , SanDisk microSD\u2122 Card 2GB,  Grove - Button .   Step 2 : Change the serial receive buffer(default 64 bytes) to 128 bytes. Open up hardware/arduino/cores directory, and edit the file named wiring_serial.c or HardwareSerial.cpp near the top is a #define SERIAL_BUFFER_SIZE 64, which means 64 bytes are used for the buffer. You need to change this to 128 .More details, please refer to  Arduino Hacks .  Step 3 : Download the  Grove - Serial Camera Library , upload it to Seeeduino. If it can t be complied, please confirm if the  SD Library  is in your Arduino IDE folder.  Step 4 : Open the Serial Monitor , press the button to take picture after SD card and Camera initialization.", 
            "title": "Use Camera with Arduino and SD card"
        }, 
        {
            "location": "/Grove-Serial_Camera/#resources", 
            "text": "VC0703 debug tool  Manual for serial camera.pdf  Grove - Serial Camera Library", 
            "title": "Resources"
        }, 
        {
            "location": "/Platform_Others/", 
            "text": "// to be continued", 
            "title": "Platform Others"
        }, 
        {
            "location": "/Grove_System/", 
            "text": "What is the Grove System?\n\uf0c1\n\n\nGrove is a modular, standardized connector prototyping system. Grove takes a building block approach to assembling electronics. Compared to the jumper or solder based system, it is easier to connect, experiment and build and simplifies the learning system, but not to the point where it becomes dumbed down. Some of the other prototype systems out there takes the level down to building blocks. Good stuff to be learned that way, but the Grove system allows you to build real systems. It requires some learning and expertise to hook things up.\n\n\nThe Grove system consists of a base unit (stem) and various modules (twigs) with standardized connectors.  The people originating the Grove system (Seeedstudio) have tried to use \nstems\nand \ntwigs\n as part of the Grove lexicon.  After a short period of consideration, we are dropping those names.   They just aren\nt needed and just confuse the issue.\n\n\nThe Base unit, generally a microprocessor, allows for easy connection of any input or output from the Grove modules. And every Grove module typically addresses a single function, such as a simple button or a more complex heart rate sensor.\n\n\nYou don\nt need a Base unit to connect up to Grove modules. You can use a cable (Grove to Pin Header Converter) to run from the pins on the Raspberry Pi or Arduino to the Grove connectors.\n\n\nGrove Projects\n\uf0c1\n\n\nHere are some project made with Grove for your reference, more projects please refer to \nRecipe\n or \nInstructables\n.\n\n\n\n\n\n\n\n\nDIY a Humidifier\n\n\nPersonal Voice Assistant\n\n\nAcrylic Monitor Stand\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSensor hub \n Win10 IoT\n\n\nSteam-punk Style Award\n\n\nPlant Watering Device\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWi-Fi Speaker\n\n\nDIY a toy car\n\n\nRetro Wooden Lamp\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPokemon Go SAFETY BADGE\n\n\n3WD OmniRover\n\n\nQuality of Life Meter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHackable RGB ornament\n\n\nThe Internet Of Led Wall\n\n\nFashion Envelope Bag\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\nMAKE IT NOW!\n\n\n\n\n\n\n\n\nSize of Grove\n\uf0c1\n\n\nThere\nre 5 size of Grove. \n\n\n\n\n\n\n\n\n1X1\n\n\n1X2\n\n\n1X3\n\n\n2X2\n\n\n2X3\n\n\n\n\n\n\n\n\n\n\n20x20mm\n\n\n20x40mm\n\n\n20x60mm\n\n\n40x40mm\n\n\n40x60mm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHow to connect Grove to your board\n\uf0c1\n\n\nIf there\ns no Grove connector on your board, you need a \nGrove Expansion Board\n which to attach the Grove modules. The Grove Expansion Board provides the processing power, and the modules offer the input sensors and output actuators of your system. There are many Grove Expansion Board for different platform already, they include Arduino UNO, Particle Phone, BeagleBone board etc.\n\n\n\n\n\n\n\n\nArduino Base Shield\n\n\nBeagleBone board\n\n\nArduino Mega\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBUY ONE NOW!\n\n\nBUY ONE NOW!\n\n\nBUY ONE NOW!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIOIO-OTG\n\n\nParticle Photon\n\n\nNodeMCU\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBUY ONE NOW!\n\n\nBUY ONE NOW!\n\n\nBUY ONE NOW!\n\n\n\n\n\n\n\n\n\n\nNote\n\n\nArduino Base Shield works for:\n\n\n\n\nArduino UNO/Leonardo\n\n\nSeeeduino V3/4/4.1/Lite/Clio/Lotus/Stalker\n\n\nLinkIt ONE\n\n\n\n\n\n\nInterface of Grove modules\n\uf0c1\n\n\nYou may notice that there\nre 4 color of the Grove cable. \n\n\n\n\npin 1\n - Yellow (for example, SCL on I2C Grove Connectors)\n\n\npin 2\n - White (for example, SDA on I2C Grove Connectors)\n\n\npin 3\n - Red - VCC on all Grove Connectors\n\n\npin 4\n - Black - GND on all Grove Connectors\n\n\n\n\nThere\nre mainly 4 type of Interface of Grove modules. \n\n\nDigital\n\uf0c1\n\n\nA digital Grove connector consists of the standard four lines coming into the Grove plug.   The two signal lines are generically called D0 and D1.  Most modules only use D0, but some do (like the LED Bar Grove display) use both.   Often base units will have the first connector called D0 and the second called D1 and they will be wired D0/D1 and then D1/D2, etc.\n\n\nExamples of Grove Digital modules are:   Switch Modules, the Fan Module, and the LED Module.  In Figure 8, you can see what the Grove connector looks like on the schematic for the LED Grove module.   They range from the simple to the very complex.\n\n\n\n\n\n\n\n\npin\n\n\nFunction\n\n\nNote\n\n\n\n\n\n\n\n\n\n\npin1\n\n\nDn\n\n\nPrimary Digital Input/Output\n\n\n\n\n\n\npin2\n\n\nDn+1\n\n\nSecondary Digital Input/Output\n\n\n\n\n\n\npin3\n\n\nVCC\n\n\nPower for Grove Module, 5V/3.3V\n\n\n\n\n\n\npin4\n\n\nGND\n\n\nGround\n\n\n\n\n\n\n\n\nGrove Analog\n\uf0c1\n\n\nAn Grove Analog connector consists of the standard four lines coming into the Grove plug.   The two signal lines are generically called A0 and A1.  Most modules only use A0.   Often base units will have the first connector called A0 and the second called A1 and they will be wired A0/A1 and then A1/A2, etc.\n\n\n\n\n\n\n\n\npin\n\n\nFunction\n\n\nNote\n\n\n\n\n\n\n\n\n\n\npin1\n\n\nAn\n\n\nPrimary Analog Input\n\n\n\n\n\n\npin2\n\n\nAn+1\n\n\nSecondary Analog Input\n\n\n\n\n\n\npin3\n\n\nVCC\n\n\nPower for Grove Module, 5V/3.3V\n\n\n\n\n\n\npin4\n\n\nGND\n\n\nGround\n\n\n\n\n\n\n\n\nGrove UART\n\uf0c1\n\n\nThe Grove UART module is a specialized version of a Grove Digital Module.  It uses both Pin 1 and Pin 2 for the serial input and transmit.  The Grove UART plug is labeled from the base unit point of view.   In other words, Pin 1 is the RX line (which the base unit uses to receive data, so it is an input) where Pin 2 is the TX line (which the base unit uses to transmit data to the Grove module).\n\n\n\n\n\n\n\n\npin\n\n\nFunction\n\n\nNote\n\n\n\n\n\n\n\n\n\n\npin1\n\n\nRX\n\n\nSerial Receive\n\n\n\n\n\n\npin2\n\n\nTX\n\n\nSerial Transmit\n\n\n\n\n\n\npin3\n\n\nVCC\n\n\nPower for Grove Module, 5V/3.3V\n\n\n\n\n\n\npin4\n\n\nGND\n\n\nGround\n\n\n\n\n\n\n\n\nGrove I2C\n\uf0c1\n\n\nThose long term readers of this blog know that our favourite devices are I2C sensors.   There are many types of I2C Grove sensors available.   Most are 5V/3.3V devices, but there are a few that are only 3.3V or 5.0V.  You need to check the specifications.\n\n\nThe Grove I2C connector has the standard layout.   Pin 1 is the SCL signal and Pin 2 is the SDA signal.   Power and Ground are the same as the other connectors.  This is another special version of the Grove Digital Connector.  In fact, often the I2C bus on a controller (like the ESP8266, Raspberry Pi and the Arduino) just uses Digital I/O pins to implement the I2C bus.  The pins on the Raspberry Pi and Arduino are special with hardware support for the I2C bus. \n\n\n\n\n\n\n\n\npin\n\n\nFunction\n\n\nNote\n\n\n\n\n\n\n\n\n\n\npin1\n\n\nSCL\n\n\nI2C Clock\n\n\n\n\n\n\npin2\n\n\nSDA\n\n\nI2C Data\n\n\n\n\n\n\npin3\n\n\nVCC\n\n\nPower for Grove Module, 5V/3.3V\n\n\n\n\n\n\npin4\n\n\nGND\n\n\nGround\n\n\n\n\n\n\n\n\nGrove Cables\n\uf0c1\n\n\nNormal Grove Cable\n\uf0c1\n\n\nThere\nre 4 size of Grove cables for your projects, the length is consist of 5cm, 20cm, 30cm, 40cm as well as 50 cm. As shown below.\n\n\n\n\n\n\n\n\n5cm\n\n\n20 cm\n\n\n30 cm\n\n\n40 cm\n\n\n50 cm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBUY ONE NOW!\n\n\nBUY ONE NOW!\n\n\nBUY ONE NOW!\n\n\nBUY ONE NOW!\n\n\nBUY ONE NOW!\n\n\n\n\n\n\n\n\nGrove - Branch Cable\n\uf0c1\n\n\nGrove Branch Cable is a cable used in the Grove system. It consists of three male-type latching connectors and four color-coded wires. Grove Branch Cables can be used to support daisy-chaining multiple Grove devices to a Grove shield. Typically, one end is connected to a Grove shield, and the second and third connectors are attached to two Grove devices. \n\n\nAs with other members of the Grove cable family, the male connectors are keyed. This means that they are shaped uniquely and will fit one and only one way into their matching connectors on shields and devices. Also, when attaching the connectors to shields or devices, be sure to press firmly to mate the male connectors on the Grove Branch Cable with the female receptacles on the Grove shield or Grove devices. Since Grove Branch Cables have latches (sometimes referred to as \nbuckles\n or \nbuckled cables\n), when the latch closes, you will hear a small sound and should see the latch close over its corresponding part. These latches (or buckles) improve connections, and are especially handy in high-vibration or production environments, since some force must be used when disconnecting the cable. When moving your Grove device, or changing it, you must also apply a small bit of pressure to release the latch on the Grove Branch Cable connector, and then pull to remove the it from the receptacle or socket.\n\n\nUse extra care if connecting multiple devices using the Grove Branch Cable. Be aware that the analog or digital pin on the Grove Shield will be shared by both Grove devices. Such configurations may be inappropriate for two analog devices. Using a Grove Branch Cable to connect an analog and a digital Grove device may not work at all.\n\n\n\n\nSample applications include:\n\n\n\n\nConnecting or daisy chaining two or more I2C devices. Multiple branch cables can be used to extend I2C busses.\n\n\nConnecting two devices that need to work at the same time. For example, a LED and a Relay could be connected to a Grove Shield using a single Grove Branch Cable. It would then be possible to turn both the LED and the Relay off or on simultaneously since the two devices would be controlled by a single digital pin.\n\n\n\n\nGrove - Branch Cable for Servo\n\uf0c1\n\n\nGrove Branch Cable for Servos are another type of Grove Cable, and are primarily used to connect one or two servos to your project. They consist of three connectors: one keyed four pin male connector suitable for connecting to a Grove Shield, and two three pin male post-type connectors. In this configuration, power and ground (pins 3 and 4 from the four pin male) are carried to both three pin male connectors. Pin 1 (yellow)of the four pin connector is connected to one of the pins of the Arduino capable of PWM, and is carried out to one of the three pin male post connectors. Pin 2 (white wire) of the four pin connector is also connected to a second PWM-capable pin of the Arduino, and is carried out to the second three pin male post connector.\n\n\nThe four pin keyed connector of the Grove Branch Cable for Servos will usually be connected to a Grove Shield digital socket such as D2-D9. When connecting servos, make a note of the wire color of the digital PWM cable (yellow or white) to know which digital pin corresponds to the servo input.\n\n\n\n\nGrove to 4pin Female/Mail Jumper\n\uf0c1\n\n\nYou can use it for:\n\n\n\n\nConnect Grove device to the other MCUs, such as you want to connect Grove - Light Sensor to Raspberry Pi.\n\n\nUse Base Shield to control some non-grove device\n\n\n\n\n\n\nLink to buy a cable\n\uf0c1\n\n\n\n\n\n\n\n\nCable\n\n\nLink\n\n\n\n\n\n\n\n\n\n\nBranch Cable\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nBranch Cable for Servo\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove to 4Pin Female\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove to 4Pin Male\n\n\nBUY ONE NOW!\n\n\n\n\n\n\n\n\nGrove Starter Kit\n\uf0c1\n\n\nWe designed many kit for the beginner. Normally, a Grove starter kit include a Grove Extension Board, many Grove modules and a user manual, which include many lessons for the beginners. If you want to start a platform or just learn about electronic, Grove Starter kit is your best choice. \n\n\n\n\nThere are many kits for different platform.\n\n\n\n\n\n\n\n\nKit Name\n\n\nLink\n\n\n\n\n\n\n\n\n\n\nGrove - Starter Kit for Arduino\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove Starter Kit for mbed\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove Starter Kit for LinkIt ONE\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove Starter Kit for LaunchPad\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove Starter Kit for Photon\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove Starter Kit for BeagleBone Green\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove Starter Kit for LinkIt 7688 Duo\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove Starter Kit for 96Boards\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrove Starter kit for Arduino\nGenuino 101\n\n\nBUY ONE NOW!\n\n\n\n\n\n\nGrovePi+ Starter Kit for Raspberry Pi\n\n\nBUY ONE NOW!\n\n\n\n\n\n\n\n\nChoose your Grove\n\uf0c1\n\n\nWant some Grove modules for your project? Here are some recommend. \n\n\nGrove Basic Input and Output\n\uf0c1\n\n\n\n\n\n\n\n\nGrove - LED\n\n\nGrove - Rotary Angle Sensor\n\n\nGrove - Button\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrove - Switch\n\n\nGrove - Encoder\n\n\nGrove - Touch Sensor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\nGrove for Display\n\uf0c1\n\n\n\n\n\n\n\n\nI2C_LCD\n\n\nGrove - OLED Display 0.96\n\n\nGrove - OLED Display 1.12\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrove - LCD RGB Backlight\n\n\nGrove - 4-Digit Display\n\n\nGrove LED Bar v2.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\nGrove for Motion Detect\n\uf0c1\n\n\n\n\n\n\n\n\nGrove - IMU 10DOF v2.0\n\n\nDigital Accelerometer(\u00b1400g)\n\n\n3-Axis Digital Gyro\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3-Axis Digital Compass\n\n\n3-Axis Digital Accelerometer(\u00b11.5g)\n\n\n3-Axis Analog Accelerometer\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3-Axis Digital Acc(\u00b116g)\n\n\n6-Axis Acc\nCompass v2.0\n\n\n6-Axis Acc\nGyroscope\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\nGrove for Communication\n\uf0c1\n\n\n\n\n\n\n\n\nGrove \u2013 Uart Wifi\n\n\n433MHz Simple RF link kit\n\n\n315MHz Simple RF Link Kit\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrove - Serial RF Pro\n\n\n125KHz RFID Reader\n\n\nGrove - BLE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrove - BLE (dual model)\n\n\nGrove - NFC\n\n\nGrove - NFC Tag\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\nGrove for Environment\n\uf0c1\n\n\n\n\n\n\n\n\nAir quality sensor\n\n\nGas Sensor(MQ2)\n\n\nGas Sensor(MQ5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGas Sensor(MQ3)\n\n\nGas Sensor(MQ9)\n\n\nGas Sensor(O2)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDust Sensor\n\n\nMoisture Sensor\n\n\nTemperature\nHumidity Sensor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\nGrove for Robot\n\uf0c1\n\n\n\n\n\n\n\n\nI2C Mini Motor Driver\n\n\nI2C Motor Driver\n\n\nGrove - Servo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLine Finder\n\n\nUltrasonic Ranger\n\n\n80cm Infrared Proximity Sensor\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMore Details\n\n\nMore Details\n\n\nMore Details", 
            "title": "Grove System"
        }, 
        {
            "location": "/Grove_System/#what-is-the-grove-system", 
            "text": "Grove is a modular, standardized connector prototyping system. Grove takes a building block approach to assembling electronics. Compared to the jumper or solder based system, it is easier to connect, experiment and build and simplifies the learning system, but not to the point where it becomes dumbed down. Some of the other prototype systems out there takes the level down to building blocks. Good stuff to be learned that way, but the Grove system allows you to build real systems. It requires some learning and expertise to hook things up.  The Grove system consists of a base unit (stem) and various modules (twigs) with standardized connectors.  The people originating the Grove system (Seeedstudio) have tried to use  stems and  twigs  as part of the Grove lexicon.  After a short period of consideration, we are dropping those names.   They just aren t needed and just confuse the issue.  The Base unit, generally a microprocessor, allows for easy connection of any input or output from the Grove modules. And every Grove module typically addresses a single function, such as a simple button or a more complex heart rate sensor.  You don t need a Base unit to connect up to Grove modules. You can use a cable (Grove to Pin Header Converter) to run from the pins on the Raspberry Pi or Arduino to the Grove connectors.", 
            "title": "What is the Grove System?"
        }, 
        {
            "location": "/Grove_System/#grove-projects", 
            "text": "Here are some project made with Grove for your reference, more projects please refer to  Recipe  or  Instructables .     DIY a Humidifier  Personal Voice Assistant  Acrylic Monitor Stand           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!        Sensor hub   Win10 IoT  Steam-punk Style Award  Plant Watering Device           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!        Wi-Fi Speaker  DIY a toy car  Retro Wooden Lamp           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!        Pokemon Go SAFETY BADGE  3WD OmniRover  Quality of Life Meter           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!        Hackable RGB ornament  The Internet Of Led Wall  Fashion Envelope Bag           MAKE IT NOW!  MAKE IT NOW!  MAKE IT NOW!", 
            "title": "Grove Projects"
        }, 
        {
            "location": "/Grove_System/#size-of-grove", 
            "text": "There re 5 size of Grove.      1X1  1X2  1X3  2X2  2X3      20x20mm  20x40mm  20x60mm  40x40mm  40x60mm", 
            "title": "Size of Grove"
        }, 
        {
            "location": "/Grove_System/#how-to-connect-grove-to-your-board", 
            "text": "If there s no Grove connector on your board, you need a  Grove Expansion Board  which to attach the Grove modules. The Grove Expansion Board provides the processing power, and the modules offer the input sensors and output actuators of your system. There are many Grove Expansion Board for different platform already, they include Arduino UNO, Particle Phone, BeagleBone board etc.     Arduino Base Shield  BeagleBone board  Arduino Mega           BUY ONE NOW!  BUY ONE NOW!  BUY ONE NOW!        IOIO-OTG  Particle Photon  NodeMCU           BUY ONE NOW!  BUY ONE NOW!  BUY ONE NOW!      Note  Arduino Base Shield works for:   Arduino UNO/Leonardo  Seeeduino V3/4/4.1/Lite/Clio/Lotus/Stalker  LinkIt ONE", 
            "title": "How to connect Grove to your board"
        }, 
        {
            "location": "/Grove_System/#interface-of-grove-modules", 
            "text": "You may notice that there re 4 color of the Grove cable.    pin 1  - Yellow (for example, SCL on I2C Grove Connectors)  pin 2  - White (for example, SDA on I2C Grove Connectors)  pin 3  - Red - VCC on all Grove Connectors  pin 4  - Black - GND on all Grove Connectors   There re mainly 4 type of Interface of Grove modules.", 
            "title": "Interface of Grove modules"
        }, 
        {
            "location": "/Grove_System/#digital", 
            "text": "A digital Grove connector consists of the standard four lines coming into the Grove plug.   The two signal lines are generically called D0 and D1.  Most modules only use D0, but some do (like the LED Bar Grove display) use both.   Often base units will have the first connector called D0 and the second called D1 and they will be wired D0/D1 and then D1/D2, etc.  Examples of Grove Digital modules are:   Switch Modules, the Fan Module, and the LED Module.  In Figure 8, you can see what the Grove connector looks like on the schematic for the LED Grove module.   They range from the simple to the very complex.     pin  Function  Note      pin1  Dn  Primary Digital Input/Output    pin2  Dn+1  Secondary Digital Input/Output    pin3  VCC  Power for Grove Module, 5V/3.3V    pin4  GND  Ground", 
            "title": "Digital"
        }, 
        {
            "location": "/Grove_System/#grove-analog", 
            "text": "An Grove Analog connector consists of the standard four lines coming into the Grove plug.   The two signal lines are generically called A0 and A1.  Most modules only use A0.   Often base units will have the first connector called A0 and the second called A1 and they will be wired A0/A1 and then A1/A2, etc.     pin  Function  Note      pin1  An  Primary Analog Input    pin2  An+1  Secondary Analog Input    pin3  VCC  Power for Grove Module, 5V/3.3V    pin4  GND  Ground", 
            "title": "Grove Analog"
        }, 
        {
            "location": "/Grove_System/#grove-uart", 
            "text": "The Grove UART module is a specialized version of a Grove Digital Module.  It uses both Pin 1 and Pin 2 for the serial input and transmit.  The Grove UART plug is labeled from the base unit point of view.   In other words, Pin 1 is the RX line (which the base unit uses to receive data, so it is an input) where Pin 2 is the TX line (which the base unit uses to transmit data to the Grove module).     pin  Function  Note      pin1  RX  Serial Receive    pin2  TX  Serial Transmit    pin3  VCC  Power for Grove Module, 5V/3.3V    pin4  GND  Ground", 
            "title": "Grove UART"
        }, 
        {
            "location": "/Grove_System/#grove-i2c", 
            "text": "Those long term readers of this blog know that our favourite devices are I2C sensors.   There are many types of I2C Grove sensors available.   Most are 5V/3.3V devices, but there are a few that are only 3.3V or 5.0V.  You need to check the specifications.  The Grove I2C connector has the standard layout.   Pin 1 is the SCL signal and Pin 2 is the SDA signal.   Power and Ground are the same as the other connectors.  This is another special version of the Grove Digital Connector.  In fact, often the I2C bus on a controller (like the ESP8266, Raspberry Pi and the Arduino) just uses Digital I/O pins to implement the I2C bus.  The pins on the Raspberry Pi and Arduino are special with hardware support for the I2C bus.      pin  Function  Note      pin1  SCL  I2C Clock    pin2  SDA  I2C Data    pin3  VCC  Power for Grove Module, 5V/3.3V    pin4  GND  Ground", 
            "title": "Grove I2C"
        }, 
        {
            "location": "/Grove_System/#grove-cables", 
            "text": "", 
            "title": "Grove Cables"
        }, 
        {
            "location": "/Grove_System/#normal-grove-cable", 
            "text": "There re 4 size of Grove cables for your projects, the length is consist of 5cm, 20cm, 30cm, 40cm as well as 50 cm. As shown below.     5cm  20 cm  30 cm  40 cm  50 cm             BUY ONE NOW!  BUY ONE NOW!  BUY ONE NOW!  BUY ONE NOW!  BUY ONE NOW!", 
            "title": "Normal Grove Cable"
        }, 
        {
            "location": "/Grove_System/#grove-branch-cable", 
            "text": "Grove Branch Cable is a cable used in the Grove system. It consists of three male-type latching connectors and four color-coded wires. Grove Branch Cables can be used to support daisy-chaining multiple Grove devices to a Grove shield. Typically, one end is connected to a Grove shield, and the second and third connectors are attached to two Grove devices.   As with other members of the Grove cable family, the male connectors are keyed. This means that they are shaped uniquely and will fit one and only one way into their matching connectors on shields and devices. Also, when attaching the connectors to shields or devices, be sure to press firmly to mate the male connectors on the Grove Branch Cable with the female receptacles on the Grove shield or Grove devices. Since Grove Branch Cables have latches (sometimes referred to as  buckles  or  buckled cables ), when the latch closes, you will hear a small sound and should see the latch close over its corresponding part. These latches (or buckles) improve connections, and are especially handy in high-vibration or production environments, since some force must be used when disconnecting the cable. When moving your Grove device, or changing it, you must also apply a small bit of pressure to release the latch on the Grove Branch Cable connector, and then pull to remove the it from the receptacle or socket.  Use extra care if connecting multiple devices using the Grove Branch Cable. Be aware that the analog or digital pin on the Grove Shield will be shared by both Grove devices. Such configurations may be inappropriate for two analog devices. Using a Grove Branch Cable to connect an analog and a digital Grove device may not work at all.   Sample applications include:   Connecting or daisy chaining two or more I2C devices. Multiple branch cables can be used to extend I2C busses.  Connecting two devices that need to work at the same time. For example, a LED and a Relay could be connected to a Grove Shield using a single Grove Branch Cable. It would then be possible to turn both the LED and the Relay off or on simultaneously since the two devices would be controlled by a single digital pin.", 
            "title": "Grove - Branch Cable"
        }, 
        {
            "location": "/Grove_System/#grove-branch-cable-for-servo", 
            "text": "Grove Branch Cable for Servos are another type of Grove Cable, and are primarily used to connect one or two servos to your project. They consist of three connectors: one keyed four pin male connector suitable for connecting to a Grove Shield, and two three pin male post-type connectors. In this configuration, power and ground (pins 3 and 4 from the four pin male) are carried to both three pin male connectors. Pin 1 (yellow)of the four pin connector is connected to one of the pins of the Arduino capable of PWM, and is carried out to one of the three pin male post connectors. Pin 2 (white wire) of the four pin connector is also connected to a second PWM-capable pin of the Arduino, and is carried out to the second three pin male post connector.  The four pin keyed connector of the Grove Branch Cable for Servos will usually be connected to a Grove Shield digital socket such as D2-D9. When connecting servos, make a note of the wire color of the digital PWM cable (yellow or white) to know which digital pin corresponds to the servo input.", 
            "title": "Grove - Branch Cable for Servo"
        }, 
        {
            "location": "/Grove_System/#grove-to-4pin-femalemail-jumper", 
            "text": "You can use it for:   Connect Grove device to the other MCUs, such as you want to connect Grove - Light Sensor to Raspberry Pi.  Use Base Shield to control some non-grove device", 
            "title": "Grove to 4pin Female/Mail Jumper"
        }, 
        {
            "location": "/Grove_System/#link-to-buy-a-cable", 
            "text": "Cable  Link      Branch Cable  BUY ONE NOW!    Branch Cable for Servo  BUY ONE NOW!    Grove to 4Pin Female  BUY ONE NOW!    Grove to 4Pin Male  BUY ONE NOW!", 
            "title": "Link to buy a cable"
        }, 
        {
            "location": "/Grove_System/#grove-starter-kit", 
            "text": "We designed many kit for the beginner. Normally, a Grove starter kit include a Grove Extension Board, many Grove modules and a user manual, which include many lessons for the beginners. If you want to start a platform or just learn about electronic, Grove Starter kit is your best choice.    There are many kits for different platform.     Kit Name  Link      Grove - Starter Kit for Arduino  BUY ONE NOW!    Grove Starter Kit for mbed  BUY ONE NOW!    Grove Starter Kit for LinkIt ONE  BUY ONE NOW!    Grove Starter Kit for LaunchPad  BUY ONE NOW!    Grove Starter Kit for Photon  BUY ONE NOW!    Grove Starter Kit for BeagleBone Green  BUY ONE NOW!    Grove Starter Kit for LinkIt 7688 Duo  BUY ONE NOW!    Grove Starter Kit for 96Boards  BUY ONE NOW!    Grove Starter kit for Arduino Genuino 101  BUY ONE NOW!    GrovePi+ Starter Kit for Raspberry Pi  BUY ONE NOW!", 
            "title": "Grove Starter Kit"
        }, 
        {
            "location": "/Grove_System/#choose-your-grove", 
            "text": "Want some Grove modules for your project? Here are some recommend.", 
            "title": "Choose your Grove"
        }, 
        {
            "location": "/Grove_System/#grove-basic-input-and-output", 
            "text": "Grove - LED  Grove - Rotary Angle Sensor  Grove - Button           More Details  More Details  More Details        Grove - Switch  Grove - Encoder  Grove - Touch Sensor           More Details  More Details  More Details", 
            "title": "Grove Basic Input and Output"
        }, 
        {
            "location": "/Grove_System/#grove-for-display", 
            "text": "I2C_LCD  Grove - OLED Display 0.96  Grove - OLED Display 1.12           More Details  More Details  More Details        Grove - LCD RGB Backlight  Grove - 4-Digit Display  Grove LED Bar v2.0           More Details  More Details  More Details", 
            "title": "Grove for Display"
        }, 
        {
            "location": "/Grove_System/#grove-for-motion-detect", 
            "text": "Grove - IMU 10DOF v2.0  Digital Accelerometer(\u00b1400g)  3-Axis Digital Gyro           More Details  More Details  More Details        3-Axis Digital Compass  3-Axis Digital Accelerometer(\u00b11.5g)  3-Axis Analog Accelerometer           More Details  More Details  More Details        3-Axis Digital Acc(\u00b116g)  6-Axis Acc Compass v2.0  6-Axis Acc Gyroscope           More Details  More Details  More Details", 
            "title": "Grove for Motion Detect"
        }, 
        {
            "location": "/Grove_System/#grove-for-communication", 
            "text": "Grove \u2013 Uart Wifi  433MHz Simple RF link kit  315MHz Simple RF Link Kit           More Details  More Details  More Details        Grove - Serial RF Pro  125KHz RFID Reader  Grove - BLE           More Details  More Details  More Details        Grove - BLE (dual model)  Grove - NFC  Grove - NFC Tag           More Details  More Details  More Details", 
            "title": "Grove for Communication"
        }, 
        {
            "location": "/Grove_System/#grove-for-environment", 
            "text": "Air quality sensor  Gas Sensor(MQ2)  Gas Sensor(MQ5)           More Details  More Details  More Details        Gas Sensor(MQ3)  Gas Sensor(MQ9)  Gas Sensor(O2)           More Details  More Details  More Details        Dust Sensor  Moisture Sensor  Temperature Humidity Sensor           More Details  More Details  More Details", 
            "title": "Grove for Environment"
        }, 
        {
            "location": "/Grove_System/#grove-for-robot", 
            "text": "I2C Mini Motor Driver  I2C Motor Driver  Grove - Servo           More Details  More Details  More Details        Line Finder  Ultrasonic Ranger  80cm Infrared Proximity Sensor           More Details  More Details  More Details", 
            "title": "Grove for Robot"
        }, 
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/", 
            "text": "The ADXL335 is a small, thin, low power, complete 3-axis accelerometer with signal conditioned voltage outputs. The product measures acceleration with a minimum full-scale range of \u00b13 g.\nThe module was designed as breakout board because ADXL335\ns signal is analog( more ports requested ). But the board outline is grove module that you can fix it conveniently like other groves. The sensor combined 3.3 and 5V power supply, can be used in standard Arduino device and Seeeduino Stalker. The following program code includes first-order filter which can make the output smoothly if the sensor was used in robot or toy car.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nWide power range DC3V to 5V\n\n\nGrove outline\n\n\n3 axis sensing\n\n\nSmall, low-profile package: 4\u00d74\u00d71.45mm LFCSP\n\n\nLow power 350\u00b5A at 3V (typical)\n\n\nHigh sensitive\n\n\n10,000 g shock survival\n\n\nBW adjustment with a single capacitor per axis\n\n\nRoHS/WEEE lead-free compliant\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nMotion Sensor\n\n\nShock detector\n\n\nVibration sensor\n\n\nToy car\n\n\nRobot\n\n\n\n\nUsage\n\uf0c1\n\n\nThe sensor\ns outline is breakout board, you can welding wire in the board or use jumper wire to connect the sensor.\n\n\n\n\nThe VCC connect to power source\uff08DC5V or DC3.3V\uff09, GND to ground, X to Arduino analog port A0, Y to A1, Z to A2.\n    \n\n\nDownload the \n3-Axis Analog Accelerometer Library\n and Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\nRegulate the sensor\n\n\n\n\nThe sensor is analog device, you should regulate the sensor before combining it with your system.\n\n\nStep 1:\n Open the Demo: Calibration and upload it to Arduino.Please click \nhere\n if you do not know how to upload.\n\n\nStep 2:\n Open your serial monitor, make sure the sensor is connected. Follow the axis institutions printed on sensor\ns board. First, make sure that Z-axis direction is straight up, please type any character if you are ready. Change the sensor position, repeat the above operation to obtain X-axis and Y-axis direction are straight up .\n\n\n\n\nStep 3:\n You can get the values as shown above. Please modify the macro definitions with these results in ADXL335.h\n\n\n\n\nNow the calibration has been completed.\n\n\n\n\nDownloading the demo code: Measuring Acceleration, then open serial monitor, turn the sensor any angle, you can see the digital angle value sent from the accelerometer to the monitor.\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\n\n\nGrove - 3-Axis Analog Accelerometer Eagle File\n\n\n\n\n\n\n3-Axis Analog Accelerometer Library\n\n\n\n\n\n\ngithub repository for 3-Axis Analog Accelerometer\n\n\n\n\n\n\nADXL335 datasheet.pdf", 
            "title": "Grove - 3-Axis Analog Accelerometer"
        }, 
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#features", 
            "text": "Wide power range DC3V to 5V  Grove outline  3 axis sensing  Small, low-profile package: 4\u00d74\u00d71.45mm LFCSP  Low power 350\u00b5A at 3V (typical)  High sensitive  10,000 g shock survival  BW adjustment with a single capacitor per axis  RoHS/WEEE lead-free compliant", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#application-ideas", 
            "text": "Motion Sensor  Shock detector  Vibration sensor  Toy car  Robot", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#usage", 
            "text": "The sensor s outline is breakout board, you can welding wire in the board or use jumper wire to connect the sensor.   The VCC connect to power source\uff08DC5V or DC3.3V\uff09, GND to ground, X to Arduino analog port A0, Y to A1, Z to A2.\n      Download the  3-Axis Analog Accelerometer Library  and Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  Regulate the sensor   The sensor is analog device, you should regulate the sensor before combining it with your system.  Step 1:  Open the Demo: Calibration and upload it to Arduino.Please click  here  if you do not know how to upload.  Step 2:  Open your serial monitor, make sure the sensor is connected. Follow the axis institutions printed on sensor s board. First, make sure that Z-axis direction is straight up, please type any character if you are ready. Change the sensor position, repeat the above operation to obtain X-axis and Y-axis direction are straight up .   Step 3:  You can get the values as shown above. Please modify the macro definitions with these results in ADXL335.h   Now the calibration has been completed.   Downloading the demo code: Measuring Acceleration, then open serial monitor, turn the sensor any angle, you can see the digital angle value sent from the accelerometer to the monitor.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#resources", 
            "text": "Grove - 3-Axis Analog Accelerometer Eagle File    3-Axis Analog Accelerometer Library    github repository for 3-Axis Analog Accelerometer    ADXL335 datasheet.pdf", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-3-Axis_Compass_V1.0/", 
            "text": "This 3-axis digital compass features a low field magnetic sensing multi-chip module HMC5883L, which provides up to 1\u00b0 to 2\u00b0 heading accuracy. HMC5883L consists of high-resolution HMC118X series magneto-resistive sensors, as well as Honeywell developed ASIC containing amplification, automatic degaussing strap drivers, offset cancellation and 12 bit ADC. With peripheral power management circuit added, this is an easy to use and reliable compass module for low cost compassing and magnetometry.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nInput Voltage: 3.3V, 5V\n\n\nSleep Mode Current: 2.5uA\n\n\nMeasurement Mode Current: 640uA\n\n\nHigh resolution\n\n\nEasy to control I2C interface\n\n\nCompatible with either 3.3V or 5.0V development platform\n\n\nMax 116Hz output rate\n\n\nHigh heading accuracy\n\n\n\n\nDemonstration\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThis demo is going to show you how to read raw data, how to calibrate the data with your local magnetic declination angle and how to get heading angle.\n\n\nFirst off, before any action you are going to take, you need to prepare a parameter you are going to use in your demo. That\ns your local magnetic declination.\n\n\nYou can find it out in degree via \nthe magnetic declination webpage\n. For example, mine is -2\u00b037\u2019, which is -2.617 degree.\n\n\nThen transfer it from degree to radians, and there you get the \ndeclinationAngle\n. For example, in my case, declinationAngle = -2.617 * \u03c0 / 180 = -0.0456752665 rad. Three significant figures are enough. So I would shorten it into -0.0456 rad. And this is the parameter you are going to replace the value of \ndeclinationAngle\n in the demo code with.\n\n\nNow let\ns start to run your compass.\n\n\n\n\n\n\nPlug the 3-axis compass into the I2C port of Grove - Base Shield.\n\n\n\n\n\n\nDownload the library file: \nDigital Compass Library\n. Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n\n\n\n\nOpen the demo\u00a0by the path:File -\nExample -\nDigital Compass -\nHMC5883L_Example.\n\n\n\n\n\n\n\n\nReplace the value of variable \ndeclinitionAngle\n with the one you\nve figured out already.\n\n\n\n\n\n\nUpload the Code. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n\nCheck the output result by opening the serial monitor.\n\n\n\n\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n   cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_compass_lib.py       \n    nano grove_compass_example.py    \n\n\n\n\n    import grove_compass_lib\n    c=grove_compass_lib.compass()\n    while True:\n            print \nX:\n,c.x,\nY:\n,c.y,\nX:\n,c.z,\nHeading:\n,c.headingDegrees\n            c.update()\n            time.sleep(.1)\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_compass_example.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-3-Axis Digital Compass Eagle File\n\n\nHMC5883.pdf\n\n\nDigital Compass Library", 
            "title": "Grove - 3-Axis Compass V1.0"
        }, 
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#specifications", 
            "text": "Input Voltage: 3.3V, 5V  Sleep Mode Current: 2.5uA  Measurement Mode Current: 640uA  High resolution  Easy to control I2C interface  Compatible with either 3.3V or 5.0V development platform  Max 116Hz output rate  High heading accuracy", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#demonstration", 
            "text": "", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#with-arduino", 
            "text": "This demo is going to show you how to read raw data, how to calibrate the data with your local magnetic declination angle and how to get heading angle.  First off, before any action you are going to take, you need to prepare a parameter you are going to use in your demo. That s your local magnetic declination.  You can find it out in degree via  the magnetic declination webpage . For example, mine is -2\u00b037\u2019, which is -2.617 degree.  Then transfer it from degree to radians, and there you get the  declinationAngle . For example, in my case, declinationAngle = -2.617 * \u03c0 / 180 = -0.0456752665 rad. Three significant figures are enough. So I would shorten it into -0.0456 rad. And this is the parameter you are going to replace the value of  declinationAngle  in the demo code with.  Now let s start to run your compass.    Plug the 3-axis compass into the I2C port of Grove - Base Shield.    Download the library file:  Digital Compass Library . Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.    Open the demo\u00a0by the path:File - Example - Digital Compass - HMC5883L_Example.     Replace the value of variable  declinitionAngle  with the one you ve figured out already.    Upload the Code. Please click  here  if you do not know how to upload.    Check the output result by opening the serial monitor.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.   4.Navigate to the demos  directory:     cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_compass_lib.py       \n    nano grove_compass_example.py          import grove_compass_lib\n    c=grove_compass_lib.compass()\n    while True:\n            print  X: ,c.x, Y: ,c.y, X: ,c.z, Heading: ,c.headingDegrees\n            c.update()\n            time.sleep(.1)  5.Run the demo.      sudo python grove_compass_example.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#resources", 
            "text": "Grove-3-Axis Digital Compass Eagle File  HMC5883.pdf  Digital Compass Library", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/", 
            "text": "Grove - 3-Axis Digital Accelerometer v1.2\n\n\n\n\nGrove - 3-Axis Digital Accelerometer v1.2b\n\n\n\n\n\n\n\n\n\n\n3-Axis Digital Accelerometer is the key part in projects like orientation detection, gesture detection and Motion detection. This 3-Axis Digital Accelerometer(\u00b11.5g) is based on Freescale\ns low power consumption module, MMA7660FC. It features up to 10,000g high shock survivability and configurable Samples per Second rate. For generous applications that don\nt require too large measurement range, this is a great choice because it\ns durable, energy saving and cost-efficient.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nWorking voltage: 3.0 - 5.5V\n\n\nOff Mode Current: 0.4\u03bcA\n\n\nStandby Mode Current: 2\u03bcA\n\n\nActive Mode Current: 47 \u03bcA at 1 ODR\n\n\nTest Range: \u00b11.5g\n\n\nSensitivity: 21LSB/g\n\n\nSuli-compatible Library\n\n\n\n\n\n\nNote\n\nFor more details about Suli-compatible Library, please refer to \nSuli\n.\n\n\n\n\nDemonstration\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nHere we are going to show you how to get raw data and data measured by \ng\n from this sensor.\u00a0\n\n\nConnect this module to the I2C port of Grove - Base Shield\u00a0via a Grove cable.\n\n\n\n\nNote\n\nIf you want to activate the Interrupt function of this module, you need to connect the INT soldering pad we broke out on the board with a pin of Arduino that's capable of Interrupt Service Routine.\u00a0\n\n\n\n\n\n\nInstall the library we provide in the \nResources\n section.\n\n\nOpen the code directly by the path:File -\n Example -\nDigitalAccelerometer_MMA7660FC -\nMMA7660FC_Demo.\n\n\nIn this program, acceleration information are sent from the sensor to Seeeduino via I2C bus and then Seeeduino printed them onto the serial monitor.\nOpen the serial monitor to check the result.\n\n\n\n\nThe outputs of this sensor consist of two parts: raw data and 3-axis acceleration info converted into the unit of gravity, \ng\n.\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n   cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_i2c_accelerometer.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Accelerometer (+/- 1.5g) to any I2C port eg. I2C-1\n    # Can be found at I2C address 0x4c\n    # SCL,SDA,VCC,GND\n\n    while True:\n        try:\n            print grovepi.acc_xyz()\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_i2c_accelerometer.py\n\n\n\n\nReference\n\uf0c1\n\n\nBelow are two figures helping you understand the physical meaning of the result.\n\n\nThe first figure is about the direction of each axis:\n\n\n\nThe second figure gives some examples:\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nDatasheet of MMA7660FC\n\n\nGrove - 3-Axis Digital Accelerometer Eagle File\n\n\nDigitalAccelerometer_MMA7660FC Library\n\n\ngithub repository for 3-Axis Digital Accelerometer(\u00b11.5g)", 
            "title": "Grove - 3-Axis Digital Accelerometer(\u00b11.5g)"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#specifications", 
            "text": "Working voltage: 3.0 - 5.5V  Off Mode Current: 0.4\u03bcA  Standby Mode Current: 2\u03bcA  Active Mode Current: 47 \u03bcA at 1 ODR  Test Range: \u00b11.5g  Sensitivity: 21LSB/g  Suli-compatible Library    Note \nFor more details about Suli-compatible Library, please refer to  Suli .", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#demonstration", 
            "text": "", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#with-arduino", 
            "text": "Here we are going to show you how to get raw data and data measured by  g  from this sensor.\u00a0  Connect this module to the I2C port of Grove - Base Shield\u00a0via a Grove cable.   Note \nIf you want to activate the Interrupt function of this module, you need to connect the INT soldering pad we broke out on the board with a pin of Arduino that's capable of Interrupt Service Routine.\u00a0   Install the library we provide in the  Resources  section.  Open the code directly by the path:File -  Example - DigitalAccelerometer_MMA7660FC - MMA7660FC_Demo.  In this program, acceleration information are sent from the sensor to Seeeduino via I2C bus and then Seeeduino printed them onto the serial monitor.\nOpen the serial monitor to check the result.   The outputs of this sensor consist of two parts: raw data and 3-axis acceleration info converted into the unit of gravity,  g .", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.   4.Navigate to the demos  directory:     cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_i2c_accelerometer.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Accelerometer (+/- 1.5g) to any I2C port eg. I2C-1\n    # Can be found at I2C address 0x4c\n    # SCL,SDA,VCC,GND\n\n    while True:\n        try:\n            print grovepi.acc_xyz()\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_i2c_accelerometer.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#reference", 
            "text": "Below are two figures helping you understand the physical meaning of the result.  The first figure is about the direction of each axis:  The second figure gives some examples:", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#resources", 
            "text": "Datasheet of MMA7660FC  Grove - 3-Axis Digital Accelerometer Eagle File  DigitalAccelerometer_MMA7660FC Library  github repository for 3-Axis Digital Accelerometer(\u00b11.5g)", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/", 
            "text": "The H3LIS331DL is a low power high performance 3-axis linear accelerometer belonging to the \u201cnano\u201d family, with digital I2C serial interface standard output. The device features ultra low power operational modes that allow advanced power saving and smart sleep to wake-up functions. The H3LIS331DL has dynamically user selectable full scales of \u00b1100g/\u00b1200 g/\u00b1400 g and it is capable of measuring accelerations with output data rates from 0.5 Hz to 1 kHz.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nWide power range DC3.3V to 5V\n\n\nGrove outline\n\n\n3 axis sensing\n\n\nSmall, low-profile package: 3\u00d73\u00d71mm TFLGA\n\n\nLow power 300\u00b5A at 3.3V (typical)\n\n\n\u00b1100g /\u00b1200 g /\u00b1400 g dynamically selectable full scale\n\n\nI2C digital output interface\n\n\n10000 g high shock survivability\n\n\nECOPACK\u00aeRoHS and \u201cGreen\u201d compliant\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nShock detector\n\n\nImpact recognition and logging\n\n\nConcussion detection\n\n\n\n\nUsage\n\uf0c1\n\n\nHere below we show you how to read the raw data from this accelerometer.\n\n\n\n\n\n\nPlug it onto the I2C port of your\u00a0\nGrove - Base Shield\n.\n\n\n\n\n\n\n\nDownload the \nDigital Accelerometer(\u00b1400g) Library\n and unpack it into arduino-1.0\\libraries in your Arduino installation folder.\n\n\n\n\n\n\nOpen the demo code directly by the path:File -\n Example -\nGrove_3Axis_Digital_Accelerometer_H3LIS331DL-\nH3LIS331DL_AdjVal. It is a sketch to adjust the raw data of H3LIS331DL to make it more precise.\n\n\n\n\n\n\nUpload the code and open the serial monitor. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n\nOpen the serial monitor to get the adjust value of reference as the steps described in serial output.\n\n\n\n\n\n\n\nOpen the demo code directly by the path:File -\n Example -\nGrove_3Axis_Digital_Accelerometer_H3LIS331DL-\nH3LIS331DL_Demo. Then modify the VAL_X_AXIS/VAL_Y_AXIS/VAL_Z_AXIS according to what you get from H3LIS331DL_AdjVal Sketch.\n\n\n\n\n\n\n\nUpload the code and open the serial monitor and open the serial monitor to check the result.\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b1400g) Eagle File\n\n\ngithub repository for 3-Axis Digital Accelerometer(\u00b1400g)\n\n\nH3LIS331DL Datasheet PDF", 
            "title": "Grove - 3-Axis Digital Accelerometer(\u00b1400g)"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#features", 
            "text": "Wide power range DC3.3V to 5V  Grove outline  3 axis sensing  Small, low-profile package: 3\u00d73\u00d71mm TFLGA  Low power 300\u00b5A at 3.3V (typical)  \u00b1100g /\u00b1200 g /\u00b1400 g dynamically selectable full scale  I2C digital output interface  10000 g high shock survivability  ECOPACK\u00aeRoHS and \u201cGreen\u201d compliant", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#application-ideas", 
            "text": "Shock detector  Impact recognition and logging  Concussion detection", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#usage", 
            "text": "Here below we show you how to read the raw data from this accelerometer.    Plug it onto the I2C port of your\u00a0 Grove - Base Shield .    Download the  Digital Accelerometer(\u00b1400g) Library  and unpack it into arduino-1.0\\libraries in your Arduino installation folder.    Open the demo code directly by the path:File -  Example - Grove_3Axis_Digital_Accelerometer_H3LIS331DL- H3LIS331DL_AdjVal. It is a sketch to adjust the raw data of H3LIS331DL to make it more precise.    Upload the code and open the serial monitor. Please click  here  if you do not know how to upload.    Open the serial monitor to get the adjust value of reference as the steps described in serial output.    Open the demo code directly by the path:File -  Example - Grove_3Axis_Digital_Accelerometer_H3LIS331DL- H3LIS331DL_Demo. Then modify the VAL_X_AXIS/VAL_Y_AXIS/VAL_Z_AXIS according to what you get from H3LIS331DL_AdjVal Sketch.    Upload the code and open the serial monitor and open the serial monitor to check the result.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#resources", 
            "text": "Grove - 3-Axis Digital Accelerometer(\u00b1400g) Eagle File  github repository for 3-Axis Digital Accelerometer(\u00b1400g)  H3LIS331DL Datasheet PDF", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Gyro/", 
            "text": "Grove - 3-Axis Digital Gyro module based on ITG 3200. It is the world\u2019s first single-chip, digital-output, 3-axis MEMS motion processing gyro optimised for gaming, 3D mice, and motion-based remote control applications for Internet connected Digital TVs and Set Top Boxes. The ITG-3200 features three 16-bit analog-to-digital converters (ADCs) for digitising the gyro outputs, a user-selectable internal low-pass filter bandwidth, and a Fast-Mode \nI2C\n (400kHz) interface.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nSupply Voltage: 3.3V, 5V\n\n\nOperation Current: 6.5mA\n\n\nStandby current: 5\u03bcA\n\n\nSensitivity: 14 LSBs per \u00b0/sec\n\n\nFull scale range: \u00b12000\u00b0/sec\n\n\nAcceleration: 10,000g for 0.3ms\n\n\nI2C Interface\n\n\n\u00b12000\u00b0/s full scale range and 14.375 LSBs per \u00b0/s sensitivity\n\n\nThree integrated 16-bit ADCs\n\n\nOn-chip temperature sensor\n\n\nIntegrated amplifiers and low-pass filters\n\n\nHermetically sealed for temp and humidity resistance\n\n\nRoHS and Green compliant\n\n\n\n\nDemonstration\n\uf0c1\n\n\nThis demo will show you how to get data from this digital gyro, the data is in the unit of rad/s.\n\n\nHere we need a Grove - 3-Axis Digital Gyro and a Seeeduino V3.0.\n\n\nHardware Installation\n\uf0c1\n\n\nHardware installation is very easy, because there\ns an I2C Grove in Seeeduino,\n\n\nSo, what we need to do is connect it to I2C Grove via a Grove cable.\n\n\n\n\nDownload Code and Upload\n\uf0c1\n\n\nYou can download the library in github, click \nhere\n, then extract it to libraries folder of Arduino.\n\n\nThen open File -\n examples -\n Grove_3_Digital_Gyro -\n ITG3200_gyro, you can open the demo code.\n\n\n\n\nClick Upload to upload the code, if you have any problem about how to start Arduino, please click \nhere\n for some help.\n\n\nCheck the result\n\uf0c1\n\n\nNow, you can open the serial monitor to check the result.\n\n\n\n\nReference\n\uf0c1\n\n\nThe diagram below shows the orientations of the 3 axes. You can use it to understand the physical meanings of the result.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nDatasheet of ITG-3200.\n\n\nGrove - 3-Axis Digital Gyro Eagle File\n\n\nDigital Gyro Library", 
            "title": "Grove - 3-Axis Digital Gyro"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#features", 
            "text": "Supply Voltage: 3.3V, 5V  Operation Current: 6.5mA  Standby current: 5\u03bcA  Sensitivity: 14 LSBs per \u00b0/sec  Full scale range: \u00b12000\u00b0/sec  Acceleration: 10,000g for 0.3ms  I2C Interface  \u00b12000\u00b0/s full scale range and 14.375 LSBs per \u00b0/s sensitivity  Three integrated 16-bit ADCs  On-chip temperature sensor  Integrated amplifiers and low-pass filters  Hermetically sealed for temp and humidity resistance  RoHS and Green compliant", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#demonstration", 
            "text": "This demo will show you how to get data from this digital gyro, the data is in the unit of rad/s.  Here we need a Grove - 3-Axis Digital Gyro and a Seeeduino V3.0.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#hardware-installation", 
            "text": "Hardware installation is very easy, because there s an I2C Grove in Seeeduino,  So, what we need to do is connect it to I2C Grove via a Grove cable.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#download-code-and-upload", 
            "text": "You can download the library in github, click  here , then extract it to libraries folder of Arduino.  Then open File -  examples -  Grove_3_Digital_Gyro -  ITG3200_gyro, you can open the demo code.   Click Upload to upload the code, if you have any problem about how to start Arduino, please click  here  for some help.", 
            "title": "Download Code and Upload"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#check-the-result", 
            "text": "Now, you can open the serial monitor to check the result.", 
            "title": "Check the result"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#reference", 
            "text": "The diagram below shows the orientations of the 3 axes. You can use it to understand the physical meanings of the result.", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#resources", 
            "text": "Datasheet of ITG-3200.  Grove - 3-Axis Digital Gyro Eagle File  Digital Gyro Library", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/", 
            "text": "The Grove \u20136-Axis Accelerometer\nCompass V2.0 is a 3-axis accelerometer combined with a 3-axis magnetic sensor. It is an upgraded version of \nGrove - 6-Axis Accelerometer\nCompass V1.0\n and based on the sensor module LSM303D which has a selectable linear acceleration full scale range of \u00b12g / \u00b14g / \u00b18g / \u00b116g and a selectable magnetic field full scale range of \u00b12 /\u00b14 / \u00b18 / \u00b112 gauss. Both the magnetic parts and the accelerometer parts can be powered down separately to reduce the power consumption. The Arduino can get these data via the I2C interface with the given library for this module.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nInput Voltage: 5V\n\n\nI2C Interface and selectable SPI Interface\n\n\nMeasuring scale selectable\n\n\n6D orientation detection\n\n\n2 independent programmable interrupt generators\n\n\nPower-down mode\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n\u2460Grove interface,connect to I2C\n\n\n\u2461SPI Interface\n\n\n\u2462I2C or SPI select pad(default is I2C), if want to use SPI, disconnect this pad\n\n\n\u2463Interrupt digital output\n\n\n\u2464Address select pad, default connected b and a address is 0x1E, if connect b and c address is 0x1D, if want to use SPI, disconnect this pad to either side.\n\n\n\n\nDemonstration\n\uf0c1\n\n\nThe LSM303D is a 6D sensor module that contains a 3D accelerometer and a 3D magnetic sensor. It has an I2C digital interface so that the analog to digital converter is avoided.\n\n\nThe MCU can collect 6D sensor data directly through the I2C interface.OK, let\ns start on using this LSM303D 6D sensor module.\n\n\nHardware Installation\n\uf0c1\n\n\n\n\nHardware installation is very easy, because there\ns an I2C Grove in Seeeduino, so what we need to do is connect it to I2C Grove via a Grove cable.\n\n\nConnect the Seeeduino to PC via a USB cable to power up this system.\n\n\n\n\n\n\nDownload Code and Upload\n\uf0c1\n\n\n\n\nDownload \ndemo_code\n which shows how to calculate level and 6-Axis Accelerometer\nCompass heading using the LSM303D.\n\n\nUpload the Code. Please click \nhere\n if you do not know how to upload.\n\n\n\n\nOpen the serial monitor, you will see the output result of Color Sensor as shown below:\n\n\n\n\n\n\n\n\nYou can see the acceleration values and the clockwise angle between the magnetic north and x-axis.\n\n\n\n\n\n\nThe X/Y/Z shows the 3 axis acceleration; and then the angle between the magnetic north and x-axis calculated.\n\n\nAnd also the the angle between the magnetic north and the projection of positive x-axis calculated.\n\n\nPlease refer \nhere\n to know more about this parameter.\n\n\n\n\n\n\n\n\nNotes\n\n\n1.  All ST MEMS accelerometers are factory calibrated, allowing the user to avoid any further calibration for most of the applications. However, to reach a heading accuracy of below 2\u00b0, an easy calibration procedure is needed.\n\n\n2.  When test The clockwise angle between the magnetic north and x-axis, you can align the device Xa axis to any direction, but do not make it face down. Refer to the below picture:\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\n6-Axis Accelerometer\nCompass v2.0 Library\n\n\nLSM303D_datashet\n\n\n6-Axis_Accelerometer%26Compass_v2.0 eagle file", 
            "title": "Grove - 6-Axis Accelerometer&amp;Compass V2.0"
        }, 
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#specifications", 
            "text": "Input Voltage: 5V  I2C Interface and selectable SPI Interface  Measuring scale selectable  6D orientation detection  2 independent programmable interrupt generators  Power-down mode", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#hardware-overview", 
            "text": "\u2460Grove interface,connect to I2C  \u2461SPI Interface  \u2462I2C or SPI select pad(default is I2C), if want to use SPI, disconnect this pad  \u2463Interrupt digital output  \u2464Address select pad, default connected b and a address is 0x1E, if connect b and c address is 0x1D, if want to use SPI, disconnect this pad to either side.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#demonstration", 
            "text": "The LSM303D is a 6D sensor module that contains a 3D accelerometer and a 3D magnetic sensor. It has an I2C digital interface so that the analog to digital converter is avoided.  The MCU can collect 6D sensor data directly through the I2C interface.OK, let s start on using this LSM303D 6D sensor module.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#hardware-installation", 
            "text": "Hardware installation is very easy, because there s an I2C Grove in Seeeduino, so what we need to do is connect it to I2C Grove via a Grove cable.  Connect the Seeeduino to PC via a USB cable to power up this system.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#download-code-and-upload", 
            "text": "Download  demo_code  which shows how to calculate level and 6-Axis Accelerometer Compass heading using the LSM303D.  Upload the Code. Please click  here  if you do not know how to upload.   Open the serial monitor, you will see the output result of Color Sensor as shown below:     You can see the acceleration values and the clockwise angle between the magnetic north and x-axis.    The X/Y/Z shows the 3 axis acceleration; and then the angle between the magnetic north and x-axis calculated.  And also the the angle between the magnetic north and the projection of positive x-axis calculated.  Please refer  here  to know more about this parameter.     Notes  1.  All ST MEMS accelerometers are factory calibrated, allowing the user to avoid any further calibration for most of the applications. However, to reach a heading accuracy of below 2\u00b0, an easy calibration procedure is needed.  2.  When test The clockwise angle between the magnetic north and x-axis, you can align the device Xa axis to any direction, but do not make it face down. Refer to the below picture:", 
            "title": "Download Code and Upload"
        }, 
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#resources", 
            "text": "6-Axis Accelerometer Compass v2.0 Library  LSM303D_datashet  6-Axis_Accelerometer%26Compass_v2.0 eagle file", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/", 
            "text": "The 80cm Infrared Proximity Sensor is a General Purpose Type Distance Measuring Sensor. This sensor SharpGP2Y0A21YK, boasts a small package and very low current consumption, takes a continuous distance reading and returns a corresponding analog voltage with a range of 10cm (4\n) to 80cm (30\n). Can be used in TVs, personal computers, cars and so on.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nEasy to use\n\n\nWide supply voltage range: 2.5V\u20137V\n\n\nGrove Interface\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nWaterdrop conservation\n\n\nToys\n\n\nRobotics\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMinimum\n\n\n\n\nTypical\n\n\n\n\nMaximum\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n2.5V\n\n\n\n\n5V\n\n\n\n\n7V\n\n\n\n\n\n\n\n\nAnalog Output Voltage(80cm)\n\n\n\n\n0.25V\n\n\n\n\n0.4V\n\n\n\n\n0.5V\n\n\n\n\n\n\n\n\nAverage Current Consumption\n\n\n\n\n-\n\n\n\n\n33mA\n\n\n\n\n50mA\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith Arduino\n\uf0c1\n\n\nThe Infrared Proximity sensor is easy to use. The relationship between the voltage reading and the distance as shown below. When we read the voltage, which indicate the distance from the object in front to this sensor.\n\n\n\n\nConnect the 3-pin connector to the sensor, and connect the 4-pin connector to the A1 port of the \nGrove-Base Shield\n.\n\n\n\n\n\n\nNote\n\nThis sensor is quite small and use a tiny connector called the Japan Solderless Terminal (JST) connector. These connectors have three wires: Ground, Vcc, and the Output signal. Because this sensor fires continuously and doesn't need any clock to initiate a reading cycle, it is easy to interface with any microcontroller. For Arduino \n&\n Seeeduino, we prepared a 4-pin to 3-pin wire to convert the 3-pin connecter on the sensor to 4-pin connecter on the Grove Base Shield, to compatible with the Seeeduino Grove interface.\n\n\n\n\n\n\nConnect Arduino/Seeeduino via a USB cable.\n\n\n\n\n\n\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\n    #define IR_PROXIMITY_SENSOR A1 // Analog input pin that  is attached to the sensor\n    #define ADC_REF 5//reference voltage of ADC is 5v.If the Vcc switch on the Seeeduino\n                     //board switches to 3V3, the ADC_REF should be 3.3\n    float voltage;//the sensor voltage, you can calculate or find the distance\n                    // to the reflective object according to the figures\n                    //on page 4 or page 5 of the datasheet of the GP2Y0A21YK.\n\n    void setup() \n    {\n        // initialise serial communications at 9600 bps:\n        Serial.begin(9600); \n    }\n\n    void loop() \n    {\n        voltage = getVoltage();\n        Serial.print(\nsensor voltage  = \n );                       \n        Serial.print(voltage); \n        // wait 500 milliseconds before the next loop\n        delay(500); \n    }\n    /****************************************************************************/\n    /*Function: Get voltage from the sensor pin that is connected with analog pin*/\n    /*Parameter:-void                                                       */\n    /*Return:   -float,the voltage of the analog pin                        */\n    float getVoltage()\n    {\n        int sensor_value;\n        int sum;  \n        // read the analog in value:\n        for (int i = 0;i \n 20;i ++)//Continuous sampling 20 times\n        {\n            sensor_value = analogRead(IR_PROXIMITY_SENSOR); \n            sum += sensor_value;\n        }\n        sensor_value = sum / 20;\n        float voltage;\n        voltage = (float)sensor_value*ADC_REF/1024;\n        return voltage;\n    } \n\n\n\n\n\n\nUpload the code, please click \nhere\n if you do not know how to upload.\n\n\nOpen the Serial Monitor, you can get the voltage. you can calculate or find the distance to the reflective object according to the below figures.\n\n\n\n\n\n\n\n\nNote\n\nBecause of some basic trigonometry within the triangle from the emitter to reflection spot to receiver, the output of the detector is non-linear with respect to the distance being measured.\n\n\n\n\nWith Raspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development environment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D4 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n   cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_infrared_distance_interrupt.py    # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Infrared Distance Interrupt Sensor to digital port D4\n    # SIG,NC,VCC,GND\n    sensor = 4\n\n    grovepi.pinMode(sensor,\nINPUT\n)\n\n    while True:\n        try:\n            # Sensor returns LOW and onboard LED lights up when the\n            # received infrared light intensity exceeds the calibrated level\n            if grovepi.digitalRead(sensor) == 0:\n                print \nfound something\n\n            else:\n                print \nnothing\n\n\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_infrared_distance_interrupt.py\n\n\n\n\nReference\n\uf0c1\n\n\nThis new rangers use triangulation and a small linear CCD array to compute the distance and/or presence of objects in the field of view. The basic idea is this: a pulse of IR light is emitted by the emitter. This light travels out in the field of view and either hits an object or just keeps on going. In the case of no object, the light is never reflected and the reading shows no object. If the light reflects off an object, it returns to the detector and creates a triangle between the point of reflection, the emitter, and the detector.\n\n\n\n\nThe angles in this triangle vary based on the distance to the object. The receiver portion of these new detectors is actually a precision lens that transmits the reflected light onto various portions of the enclosed linear CCD array based on the angle of the triangle described above. The CCD array can then determine what angle the reflected light came back at and therefore, it can calculate the distance to the object.\n\n\nThis new method of ranging is almost immune to interference from ambient light and offers amazing indifference to the color of object being detected. Detecting a black wall in full sunlight is now possible.\n\n\nResources\n\uf0c1\n\n\n\n\nGP2Y0A21YK datasheet", 
            "title": "Grove - 80cm Infrared Proximity Sensor"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/#features", 
            "text": "Easy to use  Wide supply voltage range: 2.5V\u20137V  Grove Interface", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/#application-ideas", 
            "text": "Waterdrop conservation  Toys  Robotics", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/#specifications", 
            "text": "Item  \nMinimum  \nTypical  \nMaximum    \nWorking Voltage  \n2.5V  \n5V  \n7V    \nAnalog Output Voltage(80cm)  \n0.25V  \n0.4V  \n0.5V    \nAverage Current Consumption  \n-  \n33mA  \n50mA", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/#with-arduino", 
            "text": "The Infrared Proximity sensor is easy to use. The relationship between the voltage reading and the distance as shown below. When we read the voltage, which indicate the distance from the object in front to this sensor.   Connect the 3-pin connector to the sensor, and connect the 4-pin connector to the A1 port of the  Grove-Base Shield .    Note \nThis sensor is quite small and use a tiny connector called the Japan Solderless Terminal (JST) connector. These connectors have three wires: Ground, Vcc, and the Output signal. Because this sensor fires continuously and doesn't need any clock to initiate a reading cycle, it is easy to interface with any microcontroller. For Arduino  &  Seeeduino, we prepared a 4-pin to 3-pin wire to convert the 3-pin connecter on the sensor to 4-pin connecter on the Grove Base Shield, to compatible with the Seeeduino Grove interface.   Connect Arduino/Seeeduino via a USB cable.     Copy and paste code below to a new Arduino sketch.       #define IR_PROXIMITY_SENSOR A1 // Analog input pin that  is attached to the sensor\n    #define ADC_REF 5//reference voltage of ADC is 5v.If the Vcc switch on the Seeeduino\n                     //board switches to 3V3, the ADC_REF should be 3.3\n    float voltage;//the sensor voltage, you can calculate or find the distance\n                    // to the reflective object according to the figures\n                    //on page 4 or page 5 of the datasheet of the GP2Y0A21YK.\n\n    void setup() \n    {\n        // initialise serial communications at 9600 bps:\n        Serial.begin(9600); \n    }\n\n    void loop() \n    {\n        voltage = getVoltage();\n        Serial.print( sensor voltage  =   );                       \n        Serial.print(voltage); \n        // wait 500 milliseconds before the next loop\n        delay(500); \n    }\n    /****************************************************************************/\n    /*Function: Get voltage from the sensor pin that is connected with analog pin*/\n    /*Parameter:-void                                                       */\n    /*Return:   -float,the voltage of the analog pin                        */\n    float getVoltage()\n    {\n        int sensor_value;\n        int sum;  \n        // read the analog in value:\n        for (int i = 0;i   20;i ++)//Continuous sampling 20 times\n        {\n            sensor_value = analogRead(IR_PROXIMITY_SENSOR); \n            sum += sensor_value;\n        }\n        sensor_value = sum / 20;\n        float voltage;\n        voltage = (float)sensor_value*ADC_REF/1024;\n        return voltage;\n    }    Upload the code, please click  here  if you do not know how to upload.  Open the Serial Monitor, you can get the voltage. you can calculate or find the distance to the reflective object according to the below figures.     Note \nBecause of some basic trigonometry within the triangle from the emitter to reflection spot to receiver, the output of the detector is non-linear with respect to the distance being measured.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development environment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D4 by using a grove cable.   4.Navigate to the demos  directory:     cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_infrared_distance_interrupt.py    #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Infrared Distance Interrupt Sensor to digital port D4\n    # SIG,NC,VCC,GND\n    sensor = 4\n\n    grovepi.pinMode(sensor, INPUT )\n\n    while True:\n        try:\n            # Sensor returns LOW and onboard LED lights up when the\n            # received infrared light intensity exceeds the calibrated level\n            if grovepi.digitalRead(sensor) == 0:\n                print  found something \n            else:\n                print  nothing \n\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_infrared_distance_interrupt.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/#reference", 
            "text": "This new rangers use triangulation and a small linear CCD array to compute the distance and/or presence of objects in the field of view. The basic idea is this: a pulse of IR light is emitted by the emitter. This light travels out in the field of view and either hits an object or just keeps on going. In the case of no object, the light is never reflected and the reading shows no object. If the light reflects off an object, it returns to the detector and creates a triangle between the point of reflection, the emitter, and the detector.   The angles in this triangle vary based on the distance to the object. The receiver portion of these new detectors is actually a precision lens that transmits the reflected light onto various portions of the enclosed linear CCD array based on the angle of the triangle described above. The CCD array can then determine what angle the reflected light came back at and therefore, it can calculate the distance to the object.  This new method of ranging is almost immune to interference from ambient light and offers amazing indifference to the color of object being detected. Detecting a black wall in full sunlight is now possible.", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-80cm_Infrared_Proximity_Sensor/#resources", 
            "text": "GP2Y0A21YK datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Alcohol_Sensor/", 
            "text": "Grove - Alcohol Sensor is a complete alcohol sensor module for Arduino or Seeeduino. It is built with \nMQ303A\n semiconductor alcohol sensor. It has good sensitivity and fast response to alcohol. It is suitable for making Breathalyzer. This Grove implements all the necessary circuitry for MQ303A like power conditioning and heater power supply. This sensor outputs a voltage inversely proportional to the alcohol concentration in air.\n\n\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nInput Voltage: 5V\n\n\nWorking Current: 120mA\n\n\nDetectable Concentration: 20-1000ppm\n\n\nGrove Compatible connector\n\n\nHighly sensitive to alcohol.\n\n\nFast response and resumes quickly after alcohol exposure.\n\n\nLong life.\n\n\nCompact form factor.\n\n\n\n\nUsage\n\uf0c1\n\n\nHardware Installation\n\uf0c1\n\n\nGrove products have a eco system and all have a same connector which can plug onto the \nBase Shield\n. Connect this module to the A0 port of Base Shield, however, you can also connect Gas sensor to Arduino without Base Shield by jumper wires.\n\n\n\n\n\n\n\n\nArduino UNO\n\n\nAlcohol Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nAnalog A1\n\n\nSCL\n\n\n\n\n\n\nAnalog A0\n\n\nDAT\n\n\n\n\n\n\n\n\nYou can gain the present voltage through the DAT pin of sensor. Sensitivity can be regulated by rotating the potentiometer. \nPlease note the best preheat time of the sensor is above 48 hours\n. For the detailed information about the Alcohol sensor please refer to the datasheet.\n\n\n\n\nDownload Code and Upload\n\uf0c1\n\n\nThere are two steps you need to do before getting the concentration of gas.\n\n\nFirst, connect the module with Grove Shield using A0 like the picture above. And put the sensor in a clear air and use the program below.\n\n\n#define heaterSelPin 15\n\u00a0\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(heaterSelPin,OUTPUT);   // set the heaterSelPin as digital output.\n  digitalWrite(heaterSelPin,LOW); // Start to heat the sensor\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float sensorValue;\n\u00a0\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x \n 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\u00a0\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = sensor_volt/(5.0-sensor_volt); // omit *R16\n  Serial.print(\nsensor_volt = \n);\n  Serial.print(sensor_volt);\n  Serial.println(\nV\n);\n  Serial.print(\nRS_air = \n);\n  Serial.println(RS_air);\n  delay(1000);\n\u00a0\n}\n\n\n\n\nThen, open the monitor of Arduino IDE, you can see some data are printed, write down the value of RS_air and you need to use it in the following program. During this step, you may pay a while time to test the value of RS_air.\n\n\n#define heaterSelPin 15\n\u00a0\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(heaterSelPin,OUTPUT);   // set the heaterSelPin as digital output.\n  digitalWrite(heaterSelPin,LOW); // Start to heat the sensor  \n}\n\u00a0\nvoid loop() {\n\u00a0\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = sensor_volt/5.0-sensor_volt; // omit *R16\n\u00a0\n  /*-Replace the name \nR0\n with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/RS_air;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\u00a0\n  Serial.print(\nsensor_volt = \n);\n  Serial.println(sensor_volt);\n  Serial.print(\nRS_ratio = \n);\n  Serial.println(RS_gas);\n  Serial.print(\nRs/R0 = \n);\n  Serial.println(ratio);\n\u00a0\n  Serial.print(\n\\n\\n\n);\n\u00a0\n  delay(1000);\n\u00a0\n}\n\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 20ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.002% and 1%. However, we can\nt provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\nNotes\n\n\n a. The value varies between 500 - 905. Hence any value above 650 indicates alcohol vapor in the vicinity.\n\n\n b. Once exposed to alcohol vapor, it takes some time for the sensor value to decrease completely.\n\n\n c. Yet, any new exposure will show instant increase in sensor value.\n\n\n\n\n\n\n\nCaution\n\n\n a. Alcohol sensor is very sensitive semiconductor device. Handle with care.\n\n\n b. Do not expose to organic silicon steam, alkali or corrosive gases.\n\n\n c. Do not use freeze or spill water.\n\n\n d. Maintain proper working voltage.\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-Alcohol Sensor Eagle File\n\n\nGrove-Alcohol Sensor v1.2 Eagle File\n\n\nSchematics in PDF Format\n\n\nHow to Choose A Gas Sensor\n\n\nMQ303A", 
            "title": "Grove - Alcohol Sensor"
        }, 
        {
            "location": "/Grove-Alcohol_Sensor/#features", 
            "text": "Input Voltage: 5V  Working Current: 120mA  Detectable Concentration: 20-1000ppm  Grove Compatible connector  Highly sensitive to alcohol.  Fast response and resumes quickly after alcohol exposure.  Long life.  Compact form factor.", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Alcohol_Sensor/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Alcohol_Sensor/#hardware-installation", 
            "text": "Grove products have a eco system and all have a same connector which can plug onto the  Base Shield . Connect this module to the A0 port of Base Shield, however, you can also connect Gas sensor to Arduino without Base Shield by jumper wires.     Arduino UNO  Alcohol Sensor      5V  VCC    GND  GND    Analog A1  SCL    Analog A0  DAT     You can gain the present voltage through the DAT pin of sensor. Sensitivity can be regulated by rotating the potentiometer.  Please note the best preheat time of the sensor is above 48 hours . For the detailed information about the Alcohol sensor please refer to the datasheet.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-Alcohol_Sensor/#download-code-and-upload", 
            "text": "There are two steps you need to do before getting the concentration of gas.  First, connect the module with Grove Shield using A0 like the picture above. And put the sensor in a clear air and use the program below.  #define heaterSelPin 15\n\u00a0\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(heaterSelPin,OUTPUT);   // set the heaterSelPin as digital output.\n  digitalWrite(heaterSelPin,LOW); // Start to heat the sensor\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float sensorValue;\n\u00a0\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x   100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\u00a0\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = sensor_volt/(5.0-sensor_volt); // omit *R16\n  Serial.print( sensor_volt =  );\n  Serial.print(sensor_volt);\n  Serial.println( V );\n  Serial.print( RS_air =  );\n  Serial.println(RS_air);\n  delay(1000);\n\u00a0\n}  Then, open the monitor of Arduino IDE, you can see some data are printed, write down the value of RS_air and you need to use it in the following program. During this step, you may pay a while time to test the value of RS_air.  #define heaterSelPin 15\n\u00a0\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(heaterSelPin,OUTPUT);   // set the heaterSelPin as digital output.\n  digitalWrite(heaterSelPin,LOW); // Start to heat the sensor  \n}\n\u00a0\nvoid loop() {\n\u00a0\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = sensor_volt/5.0-sensor_volt; // omit *R16\n\u00a0\n  /*-Replace the name  R0  with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/RS_air;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\u00a0\n  Serial.print( sensor_volt =  );\n  Serial.println(sensor_volt);\n  Serial.print( RS_ratio =  );\n  Serial.println(RS_gas);\n  Serial.print( Rs/R0 =  );\n  Serial.println(ratio);\n\u00a0\n  Serial.print( \\n\\n );\n\u00a0\n  delay(1000);\n\u00a0\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 20ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.002% and 1%. However, we can t provide a formula because the relation between ratio and concentration is nonlinear.   Notes   a. The value varies between 500 - 905. Hence any value above 650 indicates alcohol vapor in the vicinity.   b. Once exposed to alcohol vapor, it takes some time for the sensor value to decrease completely.   c. Yet, any new exposure will show instant increase in sensor value.    Caution   a. Alcohol sensor is very sensitive semiconductor device. Handle with care.   b. Do not expose to organic silicon steam, alkali or corrosive gases.   c. Do not use freeze or spill water.   d. Maintain proper working voltage.", 
            "title": "Download Code and Upload"
        }, 
        {
            "location": "/Grove-Alcohol_Sensor/#resources", 
            "text": "Grove-Alcohol Sensor Eagle File  Grove-Alcohol Sensor v1.2 Eagle File  Schematics in PDF Format  How to Choose A Gas Sensor  MQ303A", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Barometer-High-Accuracy/", 
            "text": "This Grove - Barometer (High-Accuracy) Sensor features a HP206C high-accuracy chip to detect barometric pressure ,Altimeter and temperature. It can widely measure pressure ranging from 300mbar~1200mbar, with a super high accuracy of 0.01mbar(0.1m) in ultra-high resolution mode.The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification.It is designed to be connected directly to a micro-controller via the I2C bus.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nDigital two wire (I2C) interface\n\n\nCommand-based Reading, Compensated (Optional)\n\n\nProgrammable Events and Interrupt Controls\n\n\nFull Data Compensation\n\n\nWide barometric pressure range\n\n\nFlexible supply voltage range\n\n\nUltra-low power consumption\n\n\nAltitude Resolution down to 0.01 meter\n\n\nTemperature measurement included\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nHigh Precision Mobile Altimeter / Barometer\n\n\nIndustrial Pressure and Temperature Sensor System\n\n\nAutomotive Systems\n\n\nPersonal Electronics Altimetry\n\n\nAdventure and Sports watches\n\n\nMedical Gas Control System\n\n\nWeather Station Equipment\n\n\nIndoor Navigation and Map Assist\n\n\nHeating, Ventilation, Air Conditioning\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3.3\n\n\n\n\n5\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n635\n\n\n\n\n/\n\n\n\n\n1100\n\n\n\n\nuA\n\n\n\n\n\n\n\n\nPressure Range\n\n\n\n\n300\n\n\n\n\n/\n\n\n\n\n1200\n\n\n\n\nhPa\n\n\n\n\n\n\n\n\nFaster I2C data transfer\n\n\n\n\n/\n\n\n\n\n/\n\n\n\n\n10\n\n\n\n\nMHz\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n20.4*41.8*9.7\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nWeight\n\n\n\n\n/\n\n\n\n\ng\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nBarometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor.\n\n\n1.Connect it to I2C port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.\n\n\n\n\n2.Download the library \nGrove_Barometer_HP20x\n;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -\n Example -\nBarometer_Sensor-\nBarometer_Sensor.\n\n\n    /*\n     * Demo name  \u00a0: HP20x_dev demo \n     * Usage      \u00a0: I2C PRECISION BAROMETER AND ALTIMETER [HP206C hopeRF] \n     * Author     \u00a0: Oliver Wang from Seeed Studio\n     * Version    \u00a0: V0.1\n     * Change log \u00a0: Add kalman filter 2014/04/04\n    */\n\n    #include \nHP20x_dev.h\n\n    #include \nArduino.h\n\n    #include \nWire.h\n \n    #include \nKalmanFilter.h\n\n    unsigned char ret = 0;\n\n    /* Instance */\n    KalmanFilter t_filter;    //temperature filter\n    KalmanFilter p_filter;    //pressure filter\n    KalmanFilter a_filter;    //altitude filter\n\n\n    void setup()\n    {  \n      Serial.begin(9600);        // start serial for output\n\n      Serial.println(\n****HP20x_dev demo by seeed studio****\\n\n);\n      Serial.println(\nCalculation formula: H = [8.5(101325-P)]/100 \\n\n);\n      /* Power up,delay 150ms,until voltage is stable */\n      delay(150);\n      /* Reset HP20x_dev */\n      HP20x.begin();\n      delay(100);\n\n      /* Determine HP20x_dev is available or not */\n      ret = HP20x.isAvailable();\n      if(OK_HP20X_DEV == ret)\n      {\n        Serial.println(\nHP20x_dev is available.\\n\n);    \n      }\n      else\n      {\n        Serial.println(\nHP20x_dev isn't available.\\n\n);\n      }\n\n    }\n\n\n    void loop()\n    {\n        char display[40];\n        if(OK_HP20X_DEV == ret)\n        { \n          Serial.println(\n------------------\\n\n);\n          long Temper = HP20x.ReadTemperature();\n          Serial.println(\nTemper:\n);\n          float t = Temper/100.0;\n          Serial.print(t);    \n          Serial.println(\nC.\\n\n);\n          Serial.println(\nFilter:\n);\n          Serial.print(t_filter.Filter(t));\n          Serial.println(\nC.\\n\n);\n\n          long Pressure = HP20x.ReadPressure();\n          Serial.println(\nPressure:\n);\n          t = Pressure/100.0;\n          Serial.print(t);\n          Serial.println(\nhPa.\\n\n);\n          Serial.println(\nFilter:\n);\n          Serial.print(p_filter.Filter(t));\n          Serial.println(\nhPa\\n\n);\n\n          long Altitude = HP20x.ReadAltitude();\n          Serial.println(\nAltitude:\n);\n          t = Altitude/100.0;\n          Serial.print(t);\n          Serial.println(\nm.\\n\n);\n          Serial.println(\nFilter:\n);\n          Serial.print(a_filter.Filter(t));\n          Serial.println(\nm.\\n\n);\n          Serial.println(\n------------------\\n\n);\n          delay(1000);\n        }\n    }\n\n\n\n\n4.Open the serial monitor to receive the sensor\ns data including temperature, barometric pressure value, relative atmosphere pressure and altitude.\n\n\n\n\nThe following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove_Barometer_High-Accuracy_v1.0_sch_pcb Eagle File\n\n\nHP206C Datasheet\n\n\nGithub repository for Grove_Barometer_HP20x", 
            "title": "Grove - Barometer (High-Accuracy)"
        }, 
        {
            "location": "/Grove-Barometer-High-Accuracy/#features", 
            "text": "Digital two wire (I2C) interface  Command-based Reading, Compensated (Optional)  Programmable Events and Interrupt Controls  Full Data Compensation  Wide barometric pressure range  Flexible supply voltage range  Ultra-low power consumption  Altitude Resolution down to 0.01 meter  Temperature measurement included", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Barometer-High-Accuracy/#application-ideas", 
            "text": "High Precision Mobile Altimeter / Barometer  Industrial Pressure and Temperature Sensor System  Automotive Systems  Personal Electronics Altimetry  Adventure and Sports watches  Medical Gas Control System  Weather Station Equipment  Indoor Navigation and Map Assist  Heating, Ventilation, Air Conditioning", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Barometer-High-Accuracy/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3.3  \n5  \n5.5  \nVDC    \nCurrent  \n635  \n/  \n1100  \nuA    \nPressure Range  \n300  \n/  \n1200  \nhPa    \nFaster I2C data transfer  \n/  \n/  \n10  \nMHz    \nDimension  \n20.4*41.8*9.7  \nmm    \nWeight  \n/  \ng", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Barometer-High-Accuracy/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Barometer-High-Accuracy/#with-arduino", 
            "text": "Barometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor.  1.Connect it to I2C port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.   2.Download the library  Grove_Barometer_HP20x ;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -  Example - Barometer_Sensor- Barometer_Sensor.      /*\n     * Demo name  \u00a0: HP20x_dev demo \n     * Usage      \u00a0: I2C PRECISION BAROMETER AND ALTIMETER [HP206C hopeRF] \n     * Author     \u00a0: Oliver Wang from Seeed Studio\n     * Version    \u00a0: V0.1\n     * Change log \u00a0: Add kalman filter 2014/04/04\n    */\n\n    #include  HP20x_dev.h \n    #include  Arduino.h \n    #include  Wire.h  \n    #include  KalmanFilter.h \n    unsigned char ret = 0;\n\n    /* Instance */\n    KalmanFilter t_filter;    //temperature filter\n    KalmanFilter p_filter;    //pressure filter\n    KalmanFilter a_filter;    //altitude filter\n\n\n    void setup()\n    {  \n      Serial.begin(9600);        // start serial for output\n\n      Serial.println( ****HP20x_dev demo by seeed studio****\\n );\n      Serial.println( Calculation formula: H = [8.5(101325-P)]/100 \\n );\n      /* Power up,delay 150ms,until voltage is stable */\n      delay(150);\n      /* Reset HP20x_dev */\n      HP20x.begin();\n      delay(100);\n\n      /* Determine HP20x_dev is available or not */\n      ret = HP20x.isAvailable();\n      if(OK_HP20X_DEV == ret)\n      {\n        Serial.println( HP20x_dev is available.\\n );    \n      }\n      else\n      {\n        Serial.println( HP20x_dev isn't available.\\n );\n      }\n\n    }\n\n\n    void loop()\n    {\n        char display[40];\n        if(OK_HP20X_DEV == ret)\n        { \n          Serial.println( ------------------\\n );\n          long Temper = HP20x.ReadTemperature();\n          Serial.println( Temper: );\n          float t = Temper/100.0;\n          Serial.print(t);    \n          Serial.println( C.\\n );\n          Serial.println( Filter: );\n          Serial.print(t_filter.Filter(t));\n          Serial.println( C.\\n );\n\n          long Pressure = HP20x.ReadPressure();\n          Serial.println( Pressure: );\n          t = Pressure/100.0;\n          Serial.print(t);\n          Serial.println( hPa.\\n );\n          Serial.println( Filter: );\n          Serial.print(p_filter.Filter(t));\n          Serial.println( hPa\\n );\n\n          long Altitude = HP20x.ReadAltitude();\n          Serial.println( Altitude: );\n          t = Altitude/100.0;\n          Serial.print(t);\n          Serial.println( m.\\n );\n          Serial.println( Filter: );\n          Serial.print(a_filter.Filter(t));\n          Serial.println( m.\\n );\n          Serial.println( ------------------\\n );\n          delay(1000);\n        }\n    }  4.Open the serial monitor to receive the sensor s data including temperature, barometric pressure value, relative atmosphere pressure and altitude.   The following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Barometer-High-Accuracy/#resources", 
            "text": "Grove_Barometer_High-Accuracy_v1.0_sch_pcb Eagle File  HP206C Datasheet  Github repository for Grove_Barometer_HP20x", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Barometer_Sensor/", 
            "text": "This Grove - Barometer Sensor features a Bosch BMP085 high-accuracy chip to detect barometric pressure and temperature. It can widely measure pressure ranging from 300hPa to 1100hPa, AKA +9000m to -500m above sea level, with a super high accuracy of 0.03hPa(0.25m) in ultra-high resolution mode. The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification. It is designed to be connected directly to a micro-controller via the I2C bus.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nDigital two wire (I2C) interface\n\n\nWide barometric pressure range\n\n\nFlexible supply voltage range\n\n\nUltra-low power consumption\n\n\nLow noise measurement\n\n\nFully calibrated\n\n\nTemperature measurement included\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nEnhancement of GPS navigation\n\n\nIndoor and outdoor navigation\n\n\nLeisure and sports\n\n\nWeather forecast\n\n\nVertical velocity indication (rise/sink speed)\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3\n\n\n\n\n5\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n89\n\n\n\n\n/\n\n\n\n\n130\n\n\n\n\nuA\n\n\n\n\n\n\n\n\nPressure Range\n\n\n\n\n300\n\n\n\n\n/\n\n\n\n\n1100\n\n\n\n\nhPa\n\n\n\n\n\n\n\n\nFaster I2C data transfer\n\n\n\n\n/\n\n\n\n\n/\n\n\n\n\n3.4\n\n\n\n\nMHZ\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n20.4*24.3*9.7\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nWeight\n\n\n\n\n2\n\n\n\n\ng\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nBarometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor.\n\n\n1.Connect it to IIC port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.\n\n\n\n2.Download the library \nBarometer_Sensor Library\n;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -\n Example -\nBarometer_Sensor-\nBarometer_Sensor.\n\n\n    /* Barometer demo V1.0\n    * Based largely on code by  Jim Lindblom\n    * Get pressure, altitude, and temperature from the BMP085.\n    * Serial.print it out at 9600 baud to serial monitor.\n    *\n    * By:http://www.seeedstudio.com\n    */\n    #include \nBarometer.h\n\n    #include \nWire.h\n\n    float temperature;\n    float pressure;\n    float atm;\n    float altitude;\n    Barometer myBarometer;\n    void setup(){\n      Serial.begin(9600);\n      myBarometer.init();\n\n    }\n\n    void loop()\n    {\n       temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n       pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n       altitude = myBarometer.calcAltitude(pressure); //Uncompensated calculation - in Meters \n       atm = pressure / 101325; \n\n      Serial.print(\nTemperature: \n);\n      Serial.print(temperature, 2); //display 2 decimal places\n      Serial.println(\ndeg C\n);\n\n      Serial.print(\nPressure: \n);\n      Serial.print(pressure, 0); //whole number only.\n      Serial.println(\n Pa\n);\n\n      Serial.print(\nRalated Atmosphere: \n);\n      Serial.println(atm, 4); //display 4 decimal places\n\n      Serial.print(\nAltitude: \n);\n      Serial.print(altitude, 2); //display 2 decimal places\n      Serial.println(\n m\n);\n\n      Serial.println();\n\n      delay(1000); //wait a second and get values again.\n    }\n\n\n\n\n4.Open the serial monitor to receive the sensor\ns data including temperature, barometric pressure value, relative atmosphere pressure and altitude.\n\n\n\n\nThe following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the barometer sensor into the i2c sockets on grovepi.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/grove_barometer/adafruit/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_i2c_barometic_sensor_example.py   # \nCtrl+x\n to exit #\n\n\n\n\n    #!/usr/bin/python\n\n    import smbus\n    import RPi.GPIO as GPIO\n    #import grovepi\n    from grove_i2c_barometic_sensor import BMP085\n\n    # ===========================================================================\n    # Example Code\n    # ===========================================================================\n\n    # Initialise the BMP085 and use STANDARD mode (default value)\n    # bmp = BMP085(0x77, debug=True)\n    bmp = BMP085(0x77, 1)\n\n    # To specify a different operating mode, uncomment one of the following:\n    # bmp = BMP085(0x77, 0)  # ULTRALOWPOWER Mode\n    # bmp = BMP085(0x77, 1)  # STANDARD Mode\n    # bmp = BMP085(0x77, 2)  # HIRES Mode\n    # bmp = BMP085(0x77, 3)  # ULTRAHIRES Mode\n\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        bus = smbus.SMBus(1)\n    else:\n        bus = smbus.SMBus(0)\n\n    temp = bmp.readTemperature()\n\n    # Read the current barometric pressure level\n    pressure = bmp.readPressure()\n\n    # To calculate altitude based on an estimated mean sea level pressure\n    # (1013.25 hPa) call the function as follows, but this won't be very accurate\n    # altitude = bmp.readAltitude()\n\n    # To specify a more accurate altitude, enter the correct mean sea level\n    # pressure level.  For example, if the current pressure level is 1023.50 hPa\n    # enter 102350 since we include two decimal places in the integer value\n    altitude = bmp.readAltitude(101560)\n\n    print \nTemperature:\u00a0%.2f C\n\u00a0% temp\n    print \nPressure:   \u00a0%.2f hPa\n\u00a0% (pressure / 100.0)\n    print \nAltitude:   \u00a0%.2f m\n\u00a0% altitude\n\n\n\n\n5.Run the demo.\n\n\n       sudo python grove_i2c_barometic_sensor_example.py\n\n\n\n\n6.Result\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Barometer Sensor Eagle File\n\n\nBarometer_Sensor Library\n\n\nGithub repository for Barometer Sensor Library\n\n\nBST-BMP085-DS000-06", 
            "title": "Grove - Barometer Sensor"
        }, 
        {
            "location": "/Grove-Barometer_Sensor/#features", 
            "text": "Digital two wire (I2C) interface  Wide barometric pressure range  Flexible supply voltage range  Ultra-low power consumption  Low noise measurement  Fully calibrated  Temperature measurement included", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Barometer_Sensor/#application-ideas", 
            "text": "Enhancement of GPS navigation  Indoor and outdoor navigation  Leisure and sports  Weather forecast  Vertical velocity indication (rise/sink speed)", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Barometer_Sensor/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3  \n5  \n5.5  \nVDC    \nCurrent  \n89  \n/  \n130  \nuA    \nPressure Range  \n300  \n/  \n1100  \nhPa    \nFaster I2C data transfer  \n/  \n/  \n3.4  \nMHZ    \nDimension  \n20.4*24.3*9.7  \nmm    \nWeight  \n2  \ng", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Barometer_Sensor/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Barometer_Sensor/#with-arduino", 
            "text": "Barometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor.  1.Connect it to IIC port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.  2.Download the library  Barometer_Sensor Library ;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -  Example - Barometer_Sensor- Barometer_Sensor.      /* Barometer demo V1.0\n    * Based largely on code by  Jim Lindblom\n    * Get pressure, altitude, and temperature from the BMP085.\n    * Serial.print it out at 9600 baud to serial monitor.\n    *\n    * By:http://www.seeedstudio.com\n    */\n    #include  Barometer.h \n    #include  Wire.h \n    float temperature;\n    float pressure;\n    float atm;\n    float altitude;\n    Barometer myBarometer;\n    void setup(){\n      Serial.begin(9600);\n      myBarometer.init();\n\n    }\n\n    void loop()\n    {\n       temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n       pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n       altitude = myBarometer.calcAltitude(pressure); //Uncompensated calculation - in Meters \n       atm = pressure / 101325; \n\n      Serial.print( Temperature:  );\n      Serial.print(temperature, 2); //display 2 decimal places\n      Serial.println( deg C );\n\n      Serial.print( Pressure:  );\n      Serial.print(pressure, 0); //whole number only.\n      Serial.println(  Pa );\n\n      Serial.print( Ralated Atmosphere:  );\n      Serial.println(atm, 4); //display 4 decimal places\n\n      Serial.print( Altitude:  );\n      Serial.print(altitude, 2); //display 2 decimal places\n      Serial.println(  m );\n\n      Serial.println();\n\n      delay(1000); //wait a second and get values again.\n    }  4.Open the serial monitor to receive the sensor s data including temperature, barometric pressure value, relative atmosphere pressure and altitude.   The following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Barometer_Sensor/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the barometer sensor into the i2c sockets on grovepi.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/grove_barometer/adafruit/   To see the code       nano grove_i2c_barometic_sensor_example.py   #  Ctrl+x  to exit #      #!/usr/bin/python\n\n    import smbus\n    import RPi.GPIO as GPIO\n    #import grovepi\n    from grove_i2c_barometic_sensor import BMP085\n\n    # ===========================================================================\n    # Example Code\n    # ===========================================================================\n\n    # Initialise the BMP085 and use STANDARD mode (default value)\n    # bmp = BMP085(0x77, debug=True)\n    bmp = BMP085(0x77, 1)\n\n    # To specify a different operating mode, uncomment one of the following:\n    # bmp = BMP085(0x77, 0)  # ULTRALOWPOWER Mode\n    # bmp = BMP085(0x77, 1)  # STANDARD Mode\n    # bmp = BMP085(0x77, 2)  # HIRES Mode\n    # bmp = BMP085(0x77, 3)  # ULTRAHIRES Mode\n\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        bus = smbus.SMBus(1)\n    else:\n        bus = smbus.SMBus(0)\n\n    temp = bmp.readTemperature()\n\n    # Read the current barometric pressure level\n    pressure = bmp.readPressure()\n\n    # To calculate altitude based on an estimated mean sea level pressure\n    # (1013.25 hPa) call the function as follows, but this won't be very accurate\n    # altitude = bmp.readAltitude()\n\n    # To specify a more accurate altitude, enter the correct mean sea level\n    # pressure level.  For example, if the current pressure level is 1023.50 hPa\n    # enter 102350 since we include two decimal places in the integer value\n    altitude = bmp.readAltitude(101560)\n\n    print  Temperature:\u00a0%.2f C \u00a0% temp\n    print  Pressure:   \u00a0%.2f hPa \u00a0% (pressure / 100.0)\n    print  Altitude:   \u00a0%.2f m \u00a0% altitude  5.Run the demo.         sudo python grove_i2c_barometic_sensor_example.py  6.Result", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Barometer_Sensor/#resources", 
            "text": "Grove - Barometer Sensor Eagle File  Barometer_Sensor Library  Github repository for Barometer Sensor Library  BST-BMP085-DS000-06", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP180/", 
            "text": "This is a Grove module for the Bosch BMP180 high-precision, low-power digital barometer. The BMP180 offers a pressure measuring range of 300 to 1100 hPa with an accuracy down to 0.02 hPa in advanced resolution mode. It\u2019s based on piezo-resistive technology for high accuracy, ruggedness and long term stability. The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification.It is designed to be connected directly to a micro-controller via the I2C bus.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nDigital two wire (I2C) interface\n\n\nWide barometric pressure range\n\n\nFlexible supply voltage range\n\n\nUltra-low power consumption\n\n\nLow noise measurement\n\n\nFactory-calibrated\n\n\n-40 to +85\u00b0C operational range, \u00b12\u00b0C temperature accuracy\n\n\nI2C address: 0x77\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nEnhancement of GPS navigation\n\n\nIndoor and outdoor navigation\n\n\nLeisure and sports\n\n\nWeather forecast\n\n\nVertical velocity indication (rise/sink speed)\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3\n\n\n\n\n5\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n1.1\n\n\n\n\n/\n\n\n\n\n20\n\n\n\n\nuA\n\n\n\n\n\n\n\n\nPressure Range\n\n\n\n\n300\n\n\n\n\n/\n\n\n\n\n1100\n\n\n\n\nhPa\n\n\n\n\n\n\n\n\nFaster I2C data transfer\n\n\n\n\n/\n\n\n\n\n/\n\n\n\n\n3.4\n\n\n\n\nMHZ\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n40.1*20.2*9.7\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nBarometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor (BMP180).\n\n\n1.Connect it to IIC port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.\n\n\n2.Download \nthe library\n(the barometer library is shared by Grove - Barometer Sensor (BMP180) and Grove - Barometer Sensor(BMP085));Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -\n Example -\nBarometer_Sensor-\nBarometer_Sensor.\n\n\n    /* Barometer demo V1.0\n    * Based largely on code by  Jim Lindblom\n    * Get pressure, altitude, and temperature from the BMP085.\n    * Serial.print it out at 9600 baud to serial monitor.\n    *\n    * By:http://www.seeedstudio.com\n    */\n    #include \nBarometer.h\n\n    #include \nWire.h\n\n    float temperature;\n    float pressure;\n    float atm;\n    float altitude;\n    Barometer myBarometer;\n    void setup(){\n      Serial.begin(9600);\n      myBarometer.init();\n\n    }\n\n    void loop()\n    {\n       temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n       pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n       altitude = myBarometer.calcAltitude(pressure); //Uncompensated calculation - in Meters \n       atm = pressure / 101325; \n\n      Serial.print(\nTemperature: \n);\n      Serial.print(temperature, 2); //display 2 decimal places\n      Serial.println(\ndeg C\n);\n\n      Serial.print(\nPressure: \n);\n      Serial.print(pressure, 0); //whole number only.\n      Serial.println(\n Pa\n);\n\n      Serial.print(\nRalated Atmosphere: \n);\n      Serial.println(atm, 4); //display 4 decimal places\n\n      Serial.print(\nAltitude: \n);\n      Serial.print(altitude, 2); //display 2 decimal places\n      Serial.println(\n m\n);\n\n      Serial.println();\n\n      delay(1000); //wait a second and get values again.\n    }\n\n\n\n\n4.Open the serial monitor to receive the sensor\ns data including temperature, barometric pressure value, relative atmosphere pressure and altitude.\n\n\n\n\nThe following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n   cd yourpath/GrovePi/Software/Python/grove_barometer/adafruit\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_i2c_barometic_sensor_example.py   # \nCtrl+x\n to exit #\n\n\n\n\n    #!/usr/bin/python\n\n    import smbus\n    import RPi.GPIO as GPIO\n    #import grovepi\n    from grove_i2c_barometic_sensor import BMP085\n\n    # ===========================================================================\n    # Example Code\n    # ===========================================================================\n\n    # Initialise the BMP085 and use STANDARD mode (default value)\n    # bmp = BMP085(0x77, debug=True)\n    bmp = BMP085(0x77, 1)\n\n    # To specify a different operating mode, uncomment one of the following:\n    # bmp = BMP085(0x77, 0)  # ULTRALOWPOWER Mode\n    # bmp = BMP085(0x77, 1)  # STANDARD Mode\n    # bmp = BMP085(0x77, 2)  # HIRES Mode\n    # bmp = BMP085(0x77, 3)  # ULTRAHIRES Mode\n\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        bus = smbus.SMBus(1)\n    else:\n        bus = smbus.SMBus(0)\n\n    temp = bmp.readTemperature()\n\n    # Read the current barometric pressure level\n    pressure = bmp.readPressure()\n\n    # To calculate altitude based on an estimated mean sea level pressure\n    # (1013.25 hPa) call the function as follows, but this won't be very accurate\n    # altitude = bmp.readAltitude()\n\n    # To specify a more accurate altitude, enter the correct mean sea level\n    # pressure level.  For example, if the current pressure level is 1023.50 hPa\n    # enter 102350 since we include two decimal places in the integer value\n    altitude = bmp.readAltitude(101560)\n\n    print \nTemperature:\u00a0%.2f C\n\u00a0% temp\n    print \nPressure:   \u00a0%.2f hPa\n\u00a0% (pressure / 100.0)\n    print \nAltitude:   \u00a0%.2f m\n\u00a0% altitude\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_i2c_barometic_sensor_example.py\n\n\n\n\n6.Result\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Barometer Sensor(BMP180) Eagle File\n\n\nBarometer_Sensor Library\n\n\nBMP180 datasheet", 
            "title": "Grove - Barometer Sensor (BMP180)"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#features", 
            "text": "Digital two wire (I2C) interface  Wide barometric pressure range  Flexible supply voltage range  Ultra-low power consumption  Low noise measurement  Factory-calibrated  -40 to +85\u00b0C operational range, \u00b12\u00b0C temperature accuracy  I2C address: 0x77", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#application-ideas", 
            "text": "Enhancement of GPS navigation  Indoor and outdoor navigation  Leisure and sports  Weather forecast  Vertical velocity indication (rise/sink speed)", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3  \n5  \n5.5  \nVDC    \nCurrent  \n1.1  \n/  \n20  \nuA    \nPressure Range  \n300  \n/  \n1100  \nhPa    \nFaster I2C data transfer  \n/  \n/  \n3.4  \nMHZ    \nDimension  \n40.1*20.2*9.7  \nmm", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#with-arduino", 
            "text": "Barometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor (BMP180).  1.Connect it to IIC port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.  2.Download  the library (the barometer library is shared by Grove - Barometer Sensor (BMP180) and Grove - Barometer Sensor(BMP085));Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -  Example - Barometer_Sensor- Barometer_Sensor.      /* Barometer demo V1.0\n    * Based largely on code by  Jim Lindblom\n    * Get pressure, altitude, and temperature from the BMP085.\n    * Serial.print it out at 9600 baud to serial monitor.\n    *\n    * By:http://www.seeedstudio.com\n    */\n    #include  Barometer.h \n    #include  Wire.h \n    float temperature;\n    float pressure;\n    float atm;\n    float altitude;\n    Barometer myBarometer;\n    void setup(){\n      Serial.begin(9600);\n      myBarometer.init();\n\n    }\n\n    void loop()\n    {\n       temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n       pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n       altitude = myBarometer.calcAltitude(pressure); //Uncompensated calculation - in Meters \n       atm = pressure / 101325; \n\n      Serial.print( Temperature:  );\n      Serial.print(temperature, 2); //display 2 decimal places\n      Serial.println( deg C );\n\n      Serial.print( Pressure:  );\n      Serial.print(pressure, 0); //whole number only.\n      Serial.println(  Pa );\n\n      Serial.print( Ralated Atmosphere:  );\n      Serial.println(atm, 4); //display 4 decimal places\n\n      Serial.print( Altitude:  );\n      Serial.print(altitude, 2); //display 2 decimal places\n      Serial.println(  m );\n\n      Serial.println();\n\n      delay(1000); //wait a second and get values again.\n    }  4.Open the serial monitor to receive the sensor s data including temperature, barometric pressure value, relative atmosphere pressure and altitude.   The following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.   4.Navigate to the demos  directory:     cd yourpath/GrovePi/Software/Python/grove_barometer/adafruit   To see the code       nano grove_i2c_barometic_sensor_example.py   #  Ctrl+x  to exit #      #!/usr/bin/python\n\n    import smbus\n    import RPi.GPIO as GPIO\n    #import grovepi\n    from grove_i2c_barometic_sensor import BMP085\n\n    # ===========================================================================\n    # Example Code\n    # ===========================================================================\n\n    # Initialise the BMP085 and use STANDARD mode (default value)\n    # bmp = BMP085(0x77, debug=True)\n    bmp = BMP085(0x77, 1)\n\n    # To specify a different operating mode, uncomment one of the following:\n    # bmp = BMP085(0x77, 0)  # ULTRALOWPOWER Mode\n    # bmp = BMP085(0x77, 1)  # STANDARD Mode\n    # bmp = BMP085(0x77, 2)  # HIRES Mode\n    # bmp = BMP085(0x77, 3)  # ULTRAHIRES Mode\n\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        bus = smbus.SMBus(1)\n    else:\n        bus = smbus.SMBus(0)\n\n    temp = bmp.readTemperature()\n\n    # Read the current barometric pressure level\n    pressure = bmp.readPressure()\n\n    # To calculate altitude based on an estimated mean sea level pressure\n    # (1013.25 hPa) call the function as follows, but this won't be very accurate\n    # altitude = bmp.readAltitude()\n\n    # To specify a more accurate altitude, enter the correct mean sea level\n    # pressure level.  For example, if the current pressure level is 1023.50 hPa\n    # enter 102350 since we include two decimal places in the integer value\n    altitude = bmp.readAltitude(101560)\n\n    print  Temperature:\u00a0%.2f C \u00a0% temp\n    print  Pressure:   \u00a0%.2f hPa \u00a0% (pressure / 100.0)\n    print  Altitude:   \u00a0%.2f m \u00a0% altitude  5.Run the demo.      sudo python grove_i2c_barometic_sensor_example.py  6.Result", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#resources", 
            "text": "Grove - Barometer Sensor(BMP180) Eagle File  Barometer_Sensor Library  BMP180 datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/", 
            "text": "Grove - Barometer Sensor (BMP280)\n is a breakout board for Bosch BMP280 high-precision and low-power digital barometer. This module can be used to measure \ntemperature\n and \natmospheric pressure\n accurately. As the atmospheric pressure changes with altitude, it can also measure approximate \naltitude\n of a place. It can be connected to a microcontroller with I\n2\nC (integrated with Grove socket) or through SPI bus. We have also provided highly abstracted library to make this product easier to use.\n\n\nThe BMP280 is an upgraded version of BMP180. BMP280 gets dramatic improvements from BMP180. BMP280 comes with a smaller footprint, lower power consumption, lower noise measurements, higher resolutions for pressure and temperature, lower RMS noise, newly added interface SPI, more measuring modes, higher measuring rate and newly added filter against environmental interference. Since the atmosphere pressure reading is affected by altitude and temperature, we have added compensation features in the library. Hence, Grove - Barometer Sensor (BMP280) would be more reliable in providing precise temperature, atmospheric pressure values and approximate altitude data.\n\n\nUsing the sensor is easy. For \nSeeeduino\n (compliant with Arduino), just connect this breakout board using \nGrove cable\n to I2C Grove connector. Then, use the provided library and example code from GitHub. If you are using an Arduino either use Base Shield v2.0 or simply connect the VCC pin to the 5V voltage pin, GND to ground, SCL to I2C Clock (Analog 5) and SDA to I2C Data (Analog 4).\n\n\nTypical applications: Enhancement of GPS navigation, outdoor/indoor navigation, weather forecast, or any other project that requires an accurate atmospheric pressure reading.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGet more precise temperature, atmospheric pressure values, and approximate altitude data.\n\n\nGrove compatible and easy to use\n\n\nHighly abstracted library for building projects quicker\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nInput voltage\n\n\n3.3V or 5V\n\n\n\n\n\n\nI/O voltage\n\n\n3.3V or 5V\n\n\n\n\n\n\nOperating current\n\n\n0.6mA\n\n\n\n\n\n\nOperating temperature\n\n\n-40 - 85 \u2103\n\n\n\n\n\n\nEffective pressure measurement range\n\n\n300 - 1100 hPa (1 hPa= one hundred Pa) with \u00b11.0 hPa accuracy\n\n\n\n\n\n\nTemperature measurement accuracy\n\n\n\u00b11.0\u00b0C\n\n\n\n\n\n\nMeasurement modes\n\n\nPiezo \n Temperature, forced or periodic\n\n\n\n\n\n\nChip\n\n\nBMP280 (\ndatasheet\n)\n\n\n\n\n\n\nPossible sampling rate\n\n\n182 Hz (typical)\n\n\n\n\n\n\nInterface Bus\n\n\nSPI, I\n2\nC (use either one of them)\n\n\n\n\n\n\nWeight\n\n\n3 g (for breakout board)\n\n\n\n\n\n\nDimensions\n\n\n40 (width) \u00d7 20 (depth) mm\n\n\n\n\n\n\n\n\n\n\nNotes\n\n\n 1. We will show/describe how to select interface bus soon.\n\n\n 2. The altitude is calculated by a combination of temperature and atmospheric pressure. No specialized components for altitude.\n\n\n\n\n\nPlatforms supported (only for battery)\n\uf0c1\n\n\n\n\n\n\n\nPlatform\n\n\n\n\nSeeeduino/Arduino\n\n\n\n\nRasberry Pi\n\n\n\n\nBeaglebone\n\n\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\nSupported status\n\n\n\n\nSupported\n\n\n\n\nNot supported\n\n\n\n\nSupported\n\n\n\n\nSupported\n\n\n\n\n\n\n\n\nNotes\n\n\n\n\nIf no version number is present for a specific platform, it means this product supports all versions within this platform.\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nSPI soldering pads\n, a voltage monitoring circuit.\n\n\nInterface bus selection pads\n , to select I\n2\nC bus, connect the two pads by soldering (this is connected by default); to select SPI bus, cut the two pads with a sharp knife or a soldering iron.\n\n\nSlave board address selection pads\n, to select slave board address to avoid address collision.\n\n\n\n\nIf you have selected I2C bus, the default address for slave board is \n0x77\n(right-two pads are connected). If you want to use the address \n0x76\n, connect only left two (disconnect right two) by soldering. \n\n\nTips:\n You can disconnect pads with just a sharp knife.\n\n\nIf you have selected SPI bus, the default address for slave board is \n0x77\n(right-two pads are connected). If you want to use the address \n0x76\n, disconnect all three pads.\n\n\n\n\nNote\n\nDo not touch or shake or let this product in vibration when it works. This will cause interference and will affect the accuracy of data collected.\n\n\n\n\nPackage includes\n (main parts)\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Barometer Sensor (BMP280)\n\n\n1 piece\n\n\n\n\n\n\nGrove cable\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nNow let us run some basic examples with this module.\n\n\nWith Arduino\n\uf0c1\n\n\nThis section shows you how to build a simple project with Arduino platform. Even if you are using a different type of main control board, these instructions and source code are useful.\n\n\nMaterials required\n\uf0c1\n\n\n\n\nGrove - Barometer Sensor (BMP280) \u00d7 1\n\n\nSeeeduino 4.2\n (fully compatible with Arduino) or Arduino UNO (other models are also fine) \u00d7 1\n\n\nGrove - Base Shield\n \u00d7 1 (it is optional if you are using Seeeduino which has two I2C sockets on Seeeduino v4.2)\n\n\nUSB cable (type A to type B, for Arduino) \u00d7 1 or USB cable (Type-A to micro Type-B, for Seeeduino) \u00d7 1\n\n\nGrove cable\n \u00d7 1\n\n\n\n\nConnections\n\uf0c1\n\n\nConnect all parts as follows: the first picture shows connection with Seeeduino, the second one demonstrates connection with Arduino UNO:\n\n\n\n\n\n\nCoding\n\uf0c1\n\n\nYou can find more demo sketches \nhere\n and development library \nhere\n\n\n\n\n\n\nA typical demo code. You can upload code to main control board with \nCodebender\n.\n\n\n\n\n\n\n\n\n\n\nDownload and upload the code. If you do not know how to upload an Arduino sketch, please visit \nhttps://www.arduino.cc/en/Guide/Windows\n for Windows user or \nhttps://www.arduino.cc/en/Guide/MacOSX\n for Mac user. You can see the result as below.\n\n\n\n\n\n\nTips:\n if you use Seeeduino, please also select \nBoards\n under \nTools\n as you upload sketches.\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic(Eagle) file\n\n\nBMP280 Datasheet\n\n\nLibrary and example code\n on GitHub\n\n\nI\n2\nC how-to for Arduino", 
            "title": "Grove - Barometer Sensor (BMP280)"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#features", 
            "text": "Get more precise temperature, atmospheric pressure values, and approximate altitude data.  Grove compatible and easy to use  Highly abstracted library for building projects quicker", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#specifications", 
            "text": "Parameter  Value      Input voltage  3.3V or 5V    I/O voltage  3.3V or 5V    Operating current  0.6mA    Operating temperature  -40 - 85 \u2103    Effective pressure measurement range  300 - 1100 hPa (1 hPa= one hundred Pa) with \u00b11.0 hPa accuracy    Temperature measurement accuracy  \u00b11.0\u00b0C    Measurement modes  Piezo   Temperature, forced or periodic    Chip  BMP280 ( datasheet )    Possible sampling rate  182 Hz (typical)    Interface Bus  SPI, I 2 C (use either one of them)    Weight  3 g (for breakout board)    Dimensions  40 (width) \u00d7 20 (depth) mm      Notes   1. We will show/describe how to select interface bus soon.   2. The altitude is calculated by a combination of temperature and atmospheric pressure. No specialized components for altitude.", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#platforms-supported-only-for-battery", 
            "text": "Platform  \nSeeeduino/Arduino  \nRasberry Pi  \nBeaglebone  \nLinkIt ONE    \nSupported status  \nSupported  \nNot supported  \nSupported  \nSupported    \nNotes  \nIf no version number is present for a specific platform, it means this product supports all versions within this platform.", 
            "title": "Platforms supported (only for battery)"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#hardware-overview", 
            "text": "SPI soldering pads , a voltage monitoring circuit.  Interface bus selection pads  , to select I 2 C bus, connect the two pads by soldering (this is connected by default); to select SPI bus, cut the two pads with a sharp knife or a soldering iron.  Slave board address selection pads , to select slave board address to avoid address collision.   If you have selected I2C bus, the default address for slave board is  0x77 (right-two pads are connected). If you want to use the address  0x76 , connect only left two (disconnect right two) by soldering.   Tips:  You can disconnect pads with just a sharp knife.  If you have selected SPI bus, the default address for slave board is  0x77 (right-two pads are connected). If you want to use the address  0x76 , disconnect all three pads.   Note \nDo not touch or shake or let this product in vibration when it works. This will cause interference and will affect the accuracy of data collected.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#package-includes-main-parts", 
            "text": "Parts name  Quantity      Grove - Barometer Sensor (BMP280)  1 piece    Grove cable  1 piece", 
            "title": "Package includes (main parts)"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#getting-started", 
            "text": "Now let us run some basic examples with this module.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#with-arduino", 
            "text": "This section shows you how to build a simple project with Arduino platform. Even if you are using a different type of main control board, these instructions and source code are useful.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#materials-required", 
            "text": "Grove - Barometer Sensor (BMP280) \u00d7 1  Seeeduino 4.2  (fully compatible with Arduino) or Arduino UNO (other models are also fine) \u00d7 1  Grove - Base Shield  \u00d7 1 (it is optional if you are using Seeeduino which has two I2C sockets on Seeeduino v4.2)  USB cable (type A to type B, for Arduino) \u00d7 1 or USB cable (Type-A to micro Type-B, for Seeeduino) \u00d7 1  Grove cable  \u00d7 1", 
            "title": "Materials required"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#connections", 
            "text": "Connect all parts as follows: the first picture shows connection with Seeeduino, the second one demonstrates connection with Arduino UNO:", 
            "title": "Connections"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#coding", 
            "text": "You can find more demo sketches  here  and development library  here    A typical demo code. You can upload code to main control board with  Codebender .      Download and upload the code. If you do not know how to upload an Arduino sketch, please visit  https://www.arduino.cc/en/Guide/Windows  for Windows user or  https://www.arduino.cc/en/Guide/MacOSX  for Mac user. You can see the result as below.    Tips:  if you use Seeeduino, please also select  Boards  under  Tools  as you upload sketches.", 
            "title": "Coding"
        }, 
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#resources", 
            "text": "Schematic(Eagle) file  BMP280 Datasheet  Library and example code  on GitHub  I 2 C how-to for Arduino", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-CO2_Sensor/", 
            "text": "The Grove - CO2 Sensor module is infrared CO2 sensor high sensitivity and high resolution. Infrared CO2 sensor MH-Z16 Is a general-purpose, small sensors, the use of non-dispersive infrared (NDIR) Present in the principle of the air CO2 Detect, with good selectivity, oxygen- dependent, long life, built-in temperature sensor, temperature compensation, with UART output, easy to use. It can be widely used in HVAC and indoor air quality monitoring, industrial process monitoring and security, agriculture and livestock production process monitoring.\n\n\n\n\n\n\nCaution\n\nNote that the sensor value only reflects the approximated trend of gas concentration in a permissible error range. It DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nMeasuring the range of 0-2000 parts per million (PPM)\n\n\nResolution of 1 PPM 0-2000 parts per million (PPM)\n\n\nAccuracy of 200 PPM\n\n\nA Warm - up time 3 minutes\n\n\nResponse Time \n 90s\n\n\nOperating temperature 0 to 50\u2103\n\n\nOperating Humidity 0% ~ 90% RH\n\n\nStorage temperature - 20-60\u2103\n\n\nOperating Voltage4.5 V to 6 V DC\n\n\nThe Current maximum Current of less than 100 ma, the average Current of less than 50 ma\n\n\nOutput mode UART\n\n\n\n\nDemonstration\n\uf0c1\n\n\nConnect the module with Grove Shield using like following picture and use the program below to gain the voltage.\n\n\nPlease note that the best preheat time of the sensor is about 180s. For the detailed information about the sensor, please refer to the datasheet.\n\n\n\n\n#include \nSoftwareSerial.h\n\n\u00a0\n#define DEBUG 0\n\u00a0\nconst int pinRx = 8;\nconst int pinTx = 7;\n\u00a0\nSoftwareSerial sensor(pinTx,pinRx);\n\u00a0\nconst unsigned char cmd_get_sensor[] =\n{\n    0xff, 0x01, 0x86, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x79\n};\nunsigned char dataRevice[9];\nint temperature;\nint CO2PPM;\n\u00a0\nvoid setup()\n{\n    sensor.begin(9600);\n    Serial.begin(115200);\n    Serial.println(\nget a 'g', begin to read from sensor!\n);\n    Serial.println(\n********************************************************\n);\n    Serial.println();\n}\n\u00a0\nvoid loop()\n{\n    if(dataRecieve())\n    {\n        Serial.print(\nTemperature: \n);\n        Serial.print(temperature);\n        Serial.print(\n  CO2: \n);\n        Serial.print(CO2PPM);\n        Serial.println(\n);\n    }\n    delay(1000);\n}\n\u00a0\nbool dataRecieve(void)\n{\n    byte data[9];\n    int i = 0;\n\u00a0\n    //transmit command data\n    for(i=0; i\nsizeof(cmd_get_sensor); i++)\n    {\n        sensor.write(cmd_get_sensor[i]);\n    }\n    delay(10);\n    //begin reveiceing data\n    if(sensor.available())\n    {\n        while(sensor.available())\n        {\n            for(int i=0;i\n9; i++)\n            {\n                data[i] = sensor.read();\n            }\n        }\n    }\n\u00a0\n#if DEBUG\n    for(int j=0; j\n9; j++)\n    {\n        Serial.print(data[j]);\n        Serial.print(\n \n);\n    }\n    Serial.println(\n);\n#endif\n\u00a0\n    if((i != 9) || (1 + (0xFF ^ (byte)(data[1] + data[2] + data[3]\n    + data[4] + data[5] + data[6] + data[7]))) != data[8])\n    {\n        return false;\n    }\n    CO2PPM = (int)data[2] * 256 + (int)data[3];\n    temperature = (int)data[4] - 40;\n\u00a0\n    return true;\n}\n\n\n\n\n\n\nReference\n\uf0c1\n\n\n\n\n350~450ppm: General outdoor environment\n\n\n350~1000ppm\uff1aThe air is fresh and breathing smooth\n\n\n1000~2000ppm\uff1aThe air was stagnant and feel asleep\n\n\n2000~5000ppm\uff1aheadache, asleep, dull, unable To Focus, heart beat rock and even mild nausea\n\n\n5000ppm\uff1asevere depletion of oxygen, permanent brain damage and even death\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nMH-Z16_CO2 datasheet_ZH_CN.pdf\n\n\nMH-Z16_CO2 datasheet_EN.pdf", 
            "title": "Grove - CO2 Sensor"
        }, 
        {
            "location": "/Grove-CO2_Sensor/#specifications", 
            "text": "Measuring the range of 0-2000 parts per million (PPM)  Resolution of 1 PPM 0-2000 parts per million (PPM)  Accuracy of 200 PPM  A Warm - up time 3 minutes  Response Time   90s  Operating temperature 0 to 50\u2103  Operating Humidity 0% ~ 90% RH  Storage temperature - 20-60\u2103  Operating Voltage4.5 V to 6 V DC  The Current maximum Current of less than 100 ma, the average Current of less than 50 ma  Output mode UART", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-CO2_Sensor/#demonstration", 
            "text": "Connect the module with Grove Shield using like following picture and use the program below to gain the voltage.  Please note that the best preheat time of the sensor is about 180s. For the detailed information about the sensor, please refer to the datasheet.   #include  SoftwareSerial.h \n\u00a0\n#define DEBUG 0\n\u00a0\nconst int pinRx = 8;\nconst int pinTx = 7;\n\u00a0\nSoftwareSerial sensor(pinTx,pinRx);\n\u00a0\nconst unsigned char cmd_get_sensor[] =\n{\n    0xff, 0x01, 0x86, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x79\n};\nunsigned char dataRevice[9];\nint temperature;\nint CO2PPM;\n\u00a0\nvoid setup()\n{\n    sensor.begin(9600);\n    Serial.begin(115200);\n    Serial.println( get a 'g', begin to read from sensor! );\n    Serial.println( ******************************************************** );\n    Serial.println();\n}\n\u00a0\nvoid loop()\n{\n    if(dataRecieve())\n    {\n        Serial.print( Temperature:  );\n        Serial.print(temperature);\n        Serial.print(   CO2:  );\n        Serial.print(CO2PPM);\n        Serial.println( );\n    }\n    delay(1000);\n}\n\u00a0\nbool dataRecieve(void)\n{\n    byte data[9];\n    int i = 0;\n\u00a0\n    //transmit command data\n    for(i=0; i sizeof(cmd_get_sensor); i++)\n    {\n        sensor.write(cmd_get_sensor[i]);\n    }\n    delay(10);\n    //begin reveiceing data\n    if(sensor.available())\n    {\n        while(sensor.available())\n        {\n            for(int i=0;i 9; i++)\n            {\n                data[i] = sensor.read();\n            }\n        }\n    }\n\u00a0\n#if DEBUG\n    for(int j=0; j 9; j++)\n    {\n        Serial.print(data[j]);\n        Serial.print(   );\n    }\n    Serial.println( );\n#endif\n\u00a0\n    if((i != 9) || (1 + (0xFF ^ (byte)(data[1] + data[2] + data[3]\n    + data[4] + data[5] + data[6] + data[7]))) != data[8])\n    {\n        return false;\n    }\n    CO2PPM = (int)data[2] * 256 + (int)data[3];\n    temperature = (int)data[4] - 40;\n\u00a0\n    return true;\n}", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-CO2_Sensor/#reference", 
            "text": "350~450ppm: General outdoor environment  350~1000ppm\uff1aThe air is fresh and breathing smooth  1000~2000ppm\uff1aThe air was stagnant and feel asleep  2000~5000ppm\uff1aheadache, asleep, dull, unable To Focus, heart beat rock and even mild nausea  5000ppm\uff1asevere depletion of oxygen, permanent brain damage and even death", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-CO2_Sensor/#resources", 
            "text": "MH-Z16_CO2 datasheet_ZH_CN.pdf  MH-Z16_CO2 datasheet_EN.pdf", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Chest_Strap_Heart_Rate_Sensor/", 
            "text": "This heart rate chest strap kit contains a chest belt and a 5.3 KHz AM receiver module. The heart rate measurement kit can be used to monitor the heart rate of patients and athletes, meanwhile the result can be displayed on a screen via serial port and saved for analysis. The entire system has lots of advantages, e.g. high sensitivity, low power consumption and portability. Because the modules communicate with each other via AM, it is very convenient to let you move (notice that the effective distance is 30cm).\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nLow power consumption\n\n\nWireless\n\n\nConvenient to use\n\n\nBuilt-in ferrite antenna\n\n\nHigh sensitivity\n\n\nFully RoHS compliant\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3.0\n\n\n\n\n5.0\n\n\n\n\n5.5\n\n\n\n\nV\n\n\n\n\n\n\n\n\nbust range\n\n\n\n\n65\n\n\n\n\n-\n\n\n\n\n145\n\n\n\n\ncm\n\n\n\n\n\n\n\n\nModulation mode\n\n\n\n\n5.3KHz AM modulate\n\n\n\n\n/\n\n\n\n\n\n\n\n\nBattery life\n\n\n\n\nmore than a half year (depending on your usage)\n\n\n\n\n/\n\n\n\n\n\n\n\n\nEffective receiving distance\n\n\n\n\n30\n\n\n\n\ncm\n\n\n\n\n\n\n\n\nReceiving modules\n\n\n\n\n48 X 25 X 10\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nHeart rate monitor.\n\n\n\n\n\n\nCaution\n\n\nThe chest belt is powered by a CR2032 coin battery. Open the back cover with a coin to replace it.\n\n\nIf not used for a long time please remove the battery.\n\n\n\n\n\nUsage\n\uf0c1\n\n\nThe following sketch demonstrates a simple application of using the Chest Strap Heart Rate Sensor to measure heart rate.\n\n\n\n\nConnect this module to the digital port D2 on your \nbase shield\n. And connect Grove-LED to Digital port 4.\n\n\nPlug the Base Shield into Arduino/Seeeduino.\n\n\n\n\n\n\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\n    #define LED 4//indicator, Grove - LED is connected with D4 of Arduino\n    boolean led_state = LOW;//state of LED, each time an external interrupt \n                                    //will change the state of LED\n    unsigned char counter;\n    unsigned long temp[21];\n    unsigned long sub;\n    bool data_effect=true;\n    unsigned int heart_rate;//the measurement result of heart rate\n\n    const int max_heartpluse_duty = 2000;//you can change it follow your system's request.\n                            //2000 meams 2 seconds. System return error \n                            //if the duty overtrip 2 second.\n    void setup()\n    {\n        pinMode(LED, OUTPUT);\n        Serial.begin(9600);\n        Serial.println(\nPlease ready your chest belt.\n);\n        delay(5000);\n        arrayInit();\n        Serial.println(\nHeart rate test begin.\n);\n        attachInterrupt(0, interrupt, RISING);//set interrupt 0,digital port 2\n    }\n    void loop()\n    {\n        digitalWrite(LED, led_state);//Update the state of the indicator\n    }\n    /*Function: calculate the heart rate*/\n    void sum()\n    {\n     if(data_effect)\n        {\n          heart_rate=1200000/(temp[20]-temp[0]);//60*20*1000/20_total_time \n          Serial.print(\nHeart_rate_is:\\t\n);\n          Serial.println(heart_rate);\n        }\n       data_effect=1;//sign bit\n    }\n    /*Function: Interrupt service routine.Get the sigal from the external interrupt*/\n    void interrupt()\n    {\n        temp[counter]=millis();\n        Serial.println(counter,DEC);\n        Serial.println(temp[counter]);\n        switch(counter)\n        {\n            case 0:\n                sub=temp[counter]-temp[20];\n                Serial.println(sub);\n                break;\n            default:\n                sub=temp[counter]-temp[counter-1];\n                Serial.println(sub);\n                break;\n        }\n        if(sub\nmax_heartpluse_duty)//set 2 seconds as max heart pluse duty\n        {\n            data_effect=0;//sign bit\n            counter=0;\n            Serial.println(\nHeart rate measure error,test will restart!\n );\n            arrayInit();\n        }\n        if (counter==20\ndata_effect)\n        {\n            counter=0;\n            sum();\n        }\n        else if(counter!=20\ndata_effect)\n        counter++;\n        else \n        {\n            counter=0;\n            data_effect=1;\n        }\n\n    }\n    /*Function: Initialization for the array(temp)*/\n    void arrayInit()\n    {\n        for(unsigned char i=0;i \n 20;i ++)\n        {\n            temp[i]=0;\n        }\n        temp[20]=millis();\n    }\n\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n\n\nThis is the signal when we are measuring the heart rate:\n\n\n\n\n \n\n\n\n\nIn the first of the figures which is a waveform diagram of the detected heartbeat, a high pulse comes when beating. \n\n\n\n\nNotes\n\n\n 1) The chest belt's wings must have contact with your skin to get a high accuracy.\n\n\n2) The maximal distance between chest belt and receive module must be less than 30cm.\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Chest Strap Heart Rate Sensor EAGLE File\n\n\nChest Strap Heart Rate Sensor Demo Code", 
            "title": "Grove - Chest Strap Heart Rate Sensor"
        }, 
        {
            "location": "/Grove-Chest_Strap_Heart_Rate_Sensor/#features", 
            "text": "Low power consumption  Wireless  Convenient to use  Built-in ferrite antenna  High sensitivity  Fully RoHS compliant", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Chest_Strap_Heart_Rate_Sensor/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3.0  \n5.0  \n5.5  \nV    \nbust range  \n65  \n-  \n145  \ncm    \nModulation mode  \n5.3KHz AM modulate  \n/    \nBattery life  \nmore than a half year (depending on your usage)  \n/    \nEffective receiving distance  \n30  \ncm    \nReceiving modules  \n48 X 25 X 10  \nmm", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Chest_Strap_Heart_Rate_Sensor/#application-ideas", 
            "text": "Heart rate monitor.    Caution  The chest belt is powered by a CR2032 coin battery. Open the back cover with a coin to replace it.  If not used for a long time please remove the battery.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Chest_Strap_Heart_Rate_Sensor/#usage", 
            "text": "The following sketch demonstrates a simple application of using the Chest Strap Heart Rate Sensor to measure heart rate.   Connect this module to the digital port D2 on your  base shield . And connect Grove-LED to Digital port 4.  Plug the Base Shield into Arduino/Seeeduino.     Copy and paste code below to a new Arduino sketch.       #define LED 4//indicator, Grove - LED is connected with D4 of Arduino\n    boolean led_state = LOW;//state of LED, each time an external interrupt \n                                    //will change the state of LED\n    unsigned char counter;\n    unsigned long temp[21];\n    unsigned long sub;\n    bool data_effect=true;\n    unsigned int heart_rate;//the measurement result of heart rate\n\n    const int max_heartpluse_duty = 2000;//you can change it follow your system's request.\n                            //2000 meams 2 seconds. System return error \n                            //if the duty overtrip 2 second.\n    void setup()\n    {\n        pinMode(LED, OUTPUT);\n        Serial.begin(9600);\n        Serial.println( Please ready your chest belt. );\n        delay(5000);\n        arrayInit();\n        Serial.println( Heart rate test begin. );\n        attachInterrupt(0, interrupt, RISING);//set interrupt 0,digital port 2\n    }\n    void loop()\n    {\n        digitalWrite(LED, led_state);//Update the state of the indicator\n    }\n    /*Function: calculate the heart rate*/\n    void sum()\n    {\n     if(data_effect)\n        {\n          heart_rate=1200000/(temp[20]-temp[0]);//60*20*1000/20_total_time \n          Serial.print( Heart_rate_is:\\t );\n          Serial.println(heart_rate);\n        }\n       data_effect=1;//sign bit\n    }\n    /*Function: Interrupt service routine.Get the sigal from the external interrupt*/\n    void interrupt()\n    {\n        temp[counter]=millis();\n        Serial.println(counter,DEC);\n        Serial.println(temp[counter]);\n        switch(counter)\n        {\n            case 0:\n                sub=temp[counter]-temp[20];\n                Serial.println(sub);\n                break;\n            default:\n                sub=temp[counter]-temp[counter-1];\n                Serial.println(sub);\n                break;\n        }\n        if(sub max_heartpluse_duty)//set 2 seconds as max heart pluse duty\n        {\n            data_effect=0;//sign bit\n            counter=0;\n            Serial.println( Heart rate measure error,test will restart!  );\n            arrayInit();\n        }\n        if (counter==20 data_effect)\n        {\n            counter=0;\n            sum();\n        }\n        else if(counter!=20 data_effect)\n        counter++;\n        else \n        {\n            counter=0;\n            data_effect=1;\n        }\n\n    }\n    /*Function: Initialization for the array(temp)*/\n    void arrayInit()\n    {\n        for(unsigned char i=0;i   20;i ++)\n        {\n            temp[i]=0;\n        }\n        temp[20]=millis();\n    }   Upload the code, Please click  here  if you do not know how to upload.  This is the signal when we are measuring the heart rate:       In the first of the figures which is a waveform diagram of the detected heartbeat, a high pulse comes when beating.    Notes   1) The chest belt's wings must have contact with your skin to get a high accuracy.  2) The maximal distance between chest belt and receive module must be less than 30cm.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Chest_Strap_Heart_Rate_Sensor/#resources", 
            "text": "Grove - Chest Strap Heart Rate Sensor EAGLE File  Chest Strap Heart Rate Sensor Demo Code", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Collision_Sensor/", 
            "text": "Grove - Collision Sensor can detect whether any collision movement or vibration happens. It will output a low pulse signal when vibration is detected. To make the output signal more reliable and neat, we added a necessary exterior circuit to reduce the noise impact. So, normal shaking will not cause any output. The sensor has a high sensitivity. You can use it to apply to your project, such as automatic wake-up and power-down for battery management.\n\n\nIts working voltage is 5V which makes it compatible with standard Arduino/Seeeduino 5V system.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nVoltage: 3.3/5V\n\n\n\n\nDemonstration\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nBased on the output signal will change when a collision happens, we design this demo: each time the sensor detects collision, the LED will light up. Here the LED is as a managed device, and you can refer to the demo to control your device, such as bicycle light.\n\n\nThe procedure is as follows:\n\n\n1.Connect the collision sensor to the Digital port 2 of Grove - Basic Shield using a Grove cable and connect an LED to Pin 13.\n\n\n2.Plug the Grove - Basic Shield into Arduino.\n\n\n3.Connect Arduino/Seeeduino to PC by using a USB cable.\n\n\n4.Copy and paste code below to a new Arduino sketch. And upload it to your Arduino.\n\n\n    /****************************************************************************/  \n    //  Function: Monitor if there is any collision\n    //  Hardware: Grove - Collision Sensor\n    //  Arduino IDE: Arduino-1.0\n    //  by www.seeedstudio.com\n    //\n    //  This library is free software; you can redistribute it and/or\n    //  modify it under the terms of the GNU Lesser General Public\n    //  License as published by the Free Software Foundation; either\n    //  version 2.1 of the License, or (at your option) any later version.\n    //\n    //  This library is distributed in the hope that it will be useful,\n    //  but WITHOUT ANY WARRANTY; without even the implied warranty of\n    //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    //  Lesser General Public License for more details.\n    //\n    //  You should have received a copy of the GNU Lesser General Public\n    //  License along with this library; if not, write to the Free Software\n    //  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n    //\n    /*******************************************************************************/ \n\n    #define LED 13 //the onboard LED of Arduino or Seeeduino\n    #define COLLISION_SENSOR 2//collision sensor is connected with D2 of Arduino\n    void setup()\n    {\n        pins_init();\n    }\n\n    void loop()\n    {\n        if(isTriggered())\n        {\n           turnOnLED();\n           delay(2000);\n        }\n        else turnOffLED();\n     }\n    void pins_init()\n    {\n        pinMode(LED,OUTPUT);\n        turnOffLED();\n        pinMode(COLLISION_SENSOR,INPUT);\n    }\n    boolean isTriggered()\n    {\n        if(!digitalRead(COLLISION_SENSOR))\n        {\n             delay(50);  \n            if(!digitalRead(COLLISION_SENSOR))\n        return true;//the collision sensor triggers\n         }\n        return false;\n    }\n    void turnOnLED()\n    {\n        digitalWrite(LED,HIGH);//the LED is on\n    }\n    void turnOffLED()\n    {\n        digitalWrite(LED,LOW);//the LED is off\n    }\n\n\n\n\n5.Now you can check the status of LED. The LED should light up every time you drum fingers on the table.\n\n\nYou can adjust the sensor sensitivity by changing the function delay(50) in code.\n\n\n    if(!digitalRead(COLLISION_SENSOR))\n    {\n        return true;//the collision sensor triggers\n    }\n    return false;\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D2 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n   cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_collision_sensor.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Collision Sensor to digital port D2\n    # SIG,NC,VCC,GND\n    collision_sensor = 2\n\n    grovepi.pinMode(collision_sensor,\nINPUT\n)\n\n    while True:\n        try:\n            print grovepi.digitalRead(collision_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_collision_sensor.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Collision Sensor Eagle File\n\n\nMVS0608.02 datasheet", 
            "title": "Grove - Collision Sensor"
        }, 
        {
            "location": "/Grove-Collision_Sensor/#specifications", 
            "text": "Voltage: 3.3/5V", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Collision_Sensor/#demonstration", 
            "text": "", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Collision_Sensor/#with-arduino", 
            "text": "Based on the output signal will change when a collision happens, we design this demo: each time the sensor detects collision, the LED will light up. Here the LED is as a managed device, and you can refer to the demo to control your device, such as bicycle light.  The procedure is as follows:  1.Connect the collision sensor to the Digital port 2 of Grove - Basic Shield using a Grove cable and connect an LED to Pin 13.  2.Plug the Grove - Basic Shield into Arduino.  3.Connect Arduino/Seeeduino to PC by using a USB cable.  4.Copy and paste code below to a new Arduino sketch. And upload it to your Arduino.      /****************************************************************************/  \n    //  Function: Monitor if there is any collision\n    //  Hardware: Grove - Collision Sensor\n    //  Arduino IDE: Arduino-1.0\n    //  by www.seeedstudio.com\n    //\n    //  This library is free software; you can redistribute it and/or\n    //  modify it under the terms of the GNU Lesser General Public\n    //  License as published by the Free Software Foundation; either\n    //  version 2.1 of the License, or (at your option) any later version.\n    //\n    //  This library is distributed in the hope that it will be useful,\n    //  but WITHOUT ANY WARRANTY; without even the implied warranty of\n    //  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n    //  Lesser General Public License for more details.\n    //\n    //  You should have received a copy of the GNU Lesser General Public\n    //  License along with this library; if not, write to the Free Software\n    //  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n    //\n    /*******************************************************************************/ \n\n    #define LED 13 //the onboard LED of Arduino or Seeeduino\n    #define COLLISION_SENSOR 2//collision sensor is connected with D2 of Arduino\n    void setup()\n    {\n        pins_init();\n    }\n\n    void loop()\n    {\n        if(isTriggered())\n        {\n           turnOnLED();\n           delay(2000);\n        }\n        else turnOffLED();\n     }\n    void pins_init()\n    {\n        pinMode(LED,OUTPUT);\n        turnOffLED();\n        pinMode(COLLISION_SENSOR,INPUT);\n    }\n    boolean isTriggered()\n    {\n        if(!digitalRead(COLLISION_SENSOR))\n        {\n             delay(50);  \n            if(!digitalRead(COLLISION_SENSOR))\n        return true;//the collision sensor triggers\n         }\n        return false;\n    }\n    void turnOnLED()\n    {\n        digitalWrite(LED,HIGH);//the LED is on\n    }\n    void turnOffLED()\n    {\n        digitalWrite(LED,LOW);//the LED is off\n    }  5.Now you can check the status of LED. The LED should light up every time you drum fingers on the table.  You can adjust the sensor sensitivity by changing the function delay(50) in code.      if(!digitalRead(COLLISION_SENSOR))\n    {\n        return true;//the collision sensor triggers\n    }\n    return false;", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Collision_Sensor/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D2 by using a grove cable.   4.Navigate to the demos  directory:     cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_collision_sensor.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Collision Sensor to digital port D2\n    # SIG,NC,VCC,GND\n    collision_sensor = 2\n\n    grovepi.pinMode(collision_sensor, INPUT )\n\n    while True:\n        try:\n            print grovepi.digitalRead(collision_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_collision_sensor.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Collision_Sensor/#resources", 
            "text": "Grove - Collision Sensor Eagle File  MVS0608.02 datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Digital_Infrared_Temperature_Sensor/", 
            "text": "The Digital Infrared temperature sensor is a non-contact temperature measurement module which bases on MLX90615.Both the IR sensitive thermopile detector chip and the signal conditioning chip are integrated in the same package.This module communicates with Arduino using SMBus,up to 127 sensors can be read via common 2 wires.Thanks to the module\ns low noise amplifier, 16-bit ADC and powerful DSP unit, it can achieved a high accuracy of 1\u2103 over wide temperature rage and a high measurement resolution of 0.02\u2103.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n2.6\n\n\n\n\n3\n\n\n\n\n3.4\n\n\n\n\nV\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n\n\n\n\n1.4\n\n\n\n\n1.5\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nAmbient Temperature Range\n\n\n\n\n-40 - 85\n\n\n\n\n\u2103\n\n\n\n\n\n\n\n\nObject Temperature Range\n\n\n\n\n-40 - 115\n\n\n\n\n\u2103\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n\u00a020x40x9.6\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nPin Number\n\n\nName\n\n\nType\n\n\nFunction Description\n\n\n\n\n\n\n\n\n\n\n1\n\n\nGND\n\n\n-\n\n\nSignal ground\n\n\n\n\n\n\n2\n\n\nVCC\n\n\nin\n\n\nPositive Power Supply Input Terminal(3.3V or 5V)\n\n\n\n\n\n\n3\n\n\nSDA\n\n\nin/out\n\n\nI2C data input/output\n\n\n\n\n\n\n4\n\n\nSCL\n\n\nin\n\n\nI2C CLK\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWe will provide an example here to show you how to use this sensor to measure the temperature of the target which is in front of the sensor,and print the result on the serial monitor.\n\n\n\n\nConnect this module to seeeduino using \nGrove - Base Shield\n port D2.\n\n\n\n\n\n\nSoftware Part\n\uf0c1\n\n\n\n\nDownload the library and demo code \nDigital_Infrared_Temperature_Sensor_MLX90615\n.\n\n\nUnzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.\n\n\n\n\nOpen the demo code directly by the path:File -\n Examples -\nDigital_Infrared_Temperature_Sensor_MLX90615-\nMLX90615Soft.\n\n\nYou can see\u00a0:\n\n\n\n\nSince the sensor is factory calibrated with the digital SMBus compatible interface enabled,but the library is based on a soft i2c library,so you can use any digital pins on any AVR chip to drive the SDA and SCL lines.We use D2 as the SCL pin and D3 as the SDA pin in this demo code.\n\n\n\n\n\n\nUpload the code into Arduino. Please click \nhere\n if you do not know how to upload. Note that you should select the correct board type and COM port.\n\n\n\n\n\n\nStart up the Serial Monitor.\n\n\nYou can see\u00a0:\n\n\n\n\n\n\n\n\nNow, you can measure the temperature with this sensor.Ambient temperature is the MLX90615 package temperature and Object temperature is the object target temperature.According to our experiment,when you place the sensor in the normal indoor temperature,and ensure that there is nothing source of heat in front of the sensor\ns 1M scope.The Object temperature will approximately equal to Ambient temperature.When measuring the Object temperature,you should ensure the object is as close as possible whit the sensor,but do not touch the surface of the sensor,we recommend the distance is less than 3cm. Wish you have a fun try.\n\n\nResources\n\uf0c1\n\n\n\n\nGrove Digital Infrared Temperature Sensor v1.0 eagle file.zip\n\n\nMLX90615.pdf\n\n\nDemo Code", 
            "title": "Grove - Digital Infrared Temperature Sensor"
        }, 
        {
            "location": "/Grove-Digital_Infrared_Temperature_Sensor/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n2.6  \n3  \n3.4  \nV    \nCurrent    \n1.4  \n1.5  \nmA    \nAmbient Temperature Range  \n-40 - 85  \n\u2103    \nObject Temperature Range  \n-40 - 115  \n\u2103    \nDimension  \n\u00a020x40x9.6  \nmm", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Digital_Infrared_Temperature_Sensor/#hardware-overview", 
            "text": "Pin Number  Name  Type  Function Description      1  GND  -  Signal ground    2  VCC  in  Positive Power Supply Input Terminal(3.3V or 5V)    3  SDA  in/out  I2C data input/output    4  SCL  in  I2C CLK", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Digital_Infrared_Temperature_Sensor/#usage", 
            "text": "We will provide an example here to show you how to use this sensor to measure the temperature of the target which is in front of the sensor,and print the result on the serial monitor.   Connect this module to seeeduino using  Grove - Base Shield  port D2.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Digital_Infrared_Temperature_Sensor/#software-part", 
            "text": "Download the library and demo code  Digital_Infrared_Temperature_Sensor_MLX90615 .  Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.   Open the demo code directly by the path:File -  Examples - Digital_Infrared_Temperature_Sensor_MLX90615- MLX90615Soft.  You can see\u00a0:   Since the sensor is factory calibrated with the digital SMBus compatible interface enabled,but the library is based on a soft i2c library,so you can use any digital pins on any AVR chip to drive the SDA and SCL lines.We use D2 as the SCL pin and D3 as the SDA pin in this demo code.    Upload the code into Arduino. Please click  here  if you do not know how to upload. Note that you should select the correct board type and COM port.    Start up the Serial Monitor.  You can see\u00a0:     Now, you can measure the temperature with this sensor.Ambient temperature is the MLX90615 package temperature and Object temperature is the object target temperature.According to our experiment,when you place the sensor in the normal indoor temperature,and ensure that there is nothing source of heat in front of the sensor s 1M scope.The Object temperature will approximately equal to Ambient temperature.When measuring the Object temperature,you should ensure the object is as close as possible whit the sensor,but do not touch the surface of the sensor,we recommend the distance is less than 3cm. Wish you have a fun try.", 
            "title": "Software Part"
        }, 
        {
            "location": "/Grove-Digital_Infrared_Temperature_Sensor/#resources", 
            "text": "Grove Digital Infrared Temperature Sensor v1.0 eagle file.zip  MLX90615.pdf  Demo Code", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/", 
            "text": "This module is based on the I2C light-to-digital converter TSL2561 to transform light intensity to a digital signal. Different from traditional analog light sensor, as \nGrove - Light Sensor\n, this digital module features a selectable light spectrum range due to its dual light sensitive diodes: infrared and full spectrum.\n\n\nYou can switch among three detection modes to take your readings. They are infrared mode, full spectrum and human visible mode. When running under the human visible mode, this sensor will give you readings just close to your eye feelings.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nSelectable detection modes\n\n\nHigh resolution 16-Bit digital output at 400 kHz I2C Fast-Mode\n\n\nWide dynamic range: 0.1 - 40,000 LUX\n\n\nWide operating temperature range: -40\u00b0C to 85\u00b0C\n\n\nProgrammable interrupt function with User-Defined Upper and lower threshold settings\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItems\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nSupply voltage, VDD\n\n\n3.3\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nOperating temperature\n\n\n-30\n\n\n\\\n\n\n70\n\n\n\u2103\n\n\n\n\n\n\nSCL,SDA input low voltage\n\n\n-0.5\n\n\n\\\n\n\n0.8\n\n\nV\n\n\n\n\n\n\nSCL,SDA input high voltage\n\n\n2.3\n\n\n\\\n\n\n5.1\n\n\nV\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nU1:\n TSL2561 IC, Light-To-Digital Converter.\n\n\nU3:\n XC6206MR332 IC, Positive Voltage Regulators.\n\n\nQ1,Q2:\n BSN20 IC, N-channel Enhancement Mode Vertical D-MOS Transistor.\n\n\nSCL,SDA:\n I2C Signal Interface\n\n\nTSL2561 Functional Block Diagram\n\uf0c1\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\n1.Plug the Grove - Digital Light Sensor onto the I2C port on Grove - Base Shield, and then plug the base shield onto Arduino.\n\n\n\n\n2.Download the library from here \nDigital Light Sensor Library\n;\n\n\n3.Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n4.Create an Arduino sketch and paste the following code into it or open the code directly by the path:File -\n Example -\nDigital_Light_Sensor-\nDigital_Light_Sensor.\n\n\n    /*\n     * Digital_Light_Sensor.ino\n     * A library for TSL2561\n     *\n     * Copyright (c) 2012 seeed technology inc.\n     * Website   \u00a0: www.seeed.cc\n     * Author    \u00a0: zhangkun\n     * Create Time:\n     * Change Log\u00a0:\n     *\n     * The MIT License (MIT)\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \nSoftware\n), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in\n     * all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     * THE SOFTWARE.\n     */\n\n    #include \nWire.h\n\n    #include \nDigital_Light_TSL2561.h\n\n    void setup()\n    {\n      Wire.begin();\n      Serial.begin(9600);\n      TSL2561.init();\n    }\n\n    void loop()\n    {\n      Serial.print(\nThe Light value is: \n);\n      Serial.println(TSL2561.readVisibleLux());\n      delay(1000);\n    }\n\n\n\n\n5.Upload the code. Please click \nhere\n if you do not know how to upload.\n\n\n6.Open the serial monitor to see the result.\n\n\n\n\nIn the case of completely light matte, The output result is 0.\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug Digital Light Sensor to the I2C sockets on grovepi.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/grove_i2c_digital_light_sensor/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_i2c_digital_light_sensor.py  # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import smbus\n    from Adafruit_I2C import Adafruit_I2C\n    import RPi.GPIO as GPIO\n    import grovepi\n    from smbus import SMBus\n\n    global I2C_ADDRESS\n    global I2C_SMBUS\n    global _CMD\n    global _CMD_CLEAR\n    global _CMD_WORD\n    global _CMD_BLOCK\n    global _REG_CONTROL\n    global _REG_TIMING\n    global _REG_ID\n    global _REG_BLOCKREAD\n    global _REG_DATA0\n    global _REG_DATA1\n    global _POWER_UP\n    global _POWER_DOWN\n    global _GAIN_LOW\n    global _GAIN_HIGH\n    global _INTEGRATION_START\n    global _INTEGRATION_STOP\n    global _INTEGRATE_13\n    global _INTEGRATE_101\n    global _INTEGRATE_402\n    global _INTEGRATE_DEFAULT\n    global _INTEGRATE_NA\n    global _GAIN\n    global _MANUAL\n    global _INTEG\n    global _CHANNEL0\n    global _CHANNEL1\n    global _D0\n    global _D1\n    global _LUX\n\n\n    # bus parameters\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        I2C_SMBUS = smbus.SMBus(1)\n    else:\n        I2C_SMBUS = smbus.SMBus(0)\n\n    # Default I2C address\n    I2C_ADDRESS = 0x29\n\n    # Commands\n    _CMD       = 0x80\n    _CMD_CLEAR = 0x40\n    _CMD_WORD  = 0x20\n    _CMD_BLOCK = 0x10\n\n    # Registers\n    _REG_CONTROL   = 0x00\n    _REG_TIMING    = 0x01\n    _REG_ID        = 0x0A\n    _REG_BLOCKREAD = 0x0B\n    _REG_DATA0     = 0x0C\n    _REG_DATA1     = 0x0E\n\n    # Control parameters\n    _POWER_UP   = 0x03\n    _POWER_DOWN = 0x00\n\n    # Timing parameters\n    _GAIN_LOW          = 0b00000000\n    _GAIN_HIGH         = 0b00010000\n    _INTEGRATION_START = 0b00001000\n    _INTEGRATION_STOP  = 0b00000000\n    _INTEGRATE_13      = 0b00000000\n    _INTEGRATE_101     = 0b00000001\n    _INTEGRATE_402     = 0b00000010\n    _INTEGRATE_DEFAULT = _INTEGRATE_402\n    _INTEGRATE_NA      = 0b00000011\n\n    # Testing parameters\n    ambient  = None\n    IR       = None\n    _ambient = 0\n    _IR      = 0\n    _LUX     = None\n\n\n    class Tsl2561(object):\n            i2c = None\n\n            def _init__(self, bus = I2C_SMBUS, addr = I2C_ADDRESS, debug = 1, pause = 0.8):  # set debug = 0 stops debugging output on screen\n                    assert(bus is not None)\n                assert(addr \n 0b000111 and addr \n 0b1111000)\n\n                    self.i2c     = Adafruit_I2C(addr)\n                    self.pause   = pause\n                    self.debug   = debug\n                    self.gain    = 0\n                self._bus    = bus\n                    self._addr   = addr\n\n                ambient        = None\n                    IR             = None\n                self._ambient  = 0\n                    self._IR       = 0\n                self._LUX      = None\n                    self._control(_POWER_UP)\n                    self._partno_revision()\n\n    #        @property\n\n            def _lux(self, gain):\n                    '''\n                    Returns a lux value.  Returns None if no valid value is set yet.\n                    '''\n                    var = readLux(gain)\n                    ambient = var[0]\n                    IR = var[1]\n                    self._ambient = var[2]\n                    self._IR = var[3]\n                    self_LUX = var[4]\n                    return (ambient, IR, self._ambient, self._IR, self._LUX)\n\n\n            def setGain(self, gain = 1):\n                    \n Set the gain \n\n                    if (gain\u00a0!= self.gain):\n                            if (gain==1):\n                                    cmd = _CMD | _REG_TIMING\n                                    value = 0x02\n                                    self.i2c.write8(cmd, value)  # Set gain = 1X and timing = 402 mSec\n                                    if (self.debug):\n                                            print \nSetting low gain\n\n                            else:\n                                    cmd = _CMD | _REG_TIMING\n                                    value = 0x12\n                                    self.i2c.write8(cmd, value)  # Set gain = 16X and timing = 402 mSec\n                                    if (self.debug):\n                                            print \nSetting high gain\n\n                            self.gain=gain;  # Safe gain for calculation\n                            time.sleep(self.pause)  # Pause for integration (self.pause must be bigger than integration time)\n\n\n            def readWord(self, reg):\n                    \n Reads a word from the TSL2561 I2C device \n\n                    try:\n                            wordval = self.i2c.readU16(reg)\n                            newval = self.i2c.reverseByteOrder(wordval)\n                            if (self.debug):\n                                    print(\nI2C: Device 0x%02X: returned 0x%04X from reg 0x%02X\n\u00a0% (self._addr, wordval \n 0xFFFF, reg))\n                            return newval\n                    except IOError:\n                            print(\nError accessing 0x%02X: Chcekcyour I2C address\n\u00a0% self._addr)\n                            return -1\n\n\n            def readFull(self, reg = 0x8C):\n                    \n Read visible + IR diode from the TSL2561 I2C device \n\n                    return self.readWord(reg);\n\n            def readIR(self, reg = 0x8E):\n                    \n Reads only IR diode from the TSL2561 I2C device \n\n                    return self.readWord(reg);\n\n            def readLux(self, gain = 0):\n                    \n Grabs a lux reading either with autoranging (gain=0) or with specific gain (1, 16) \n\n                    if (self.debug):\n                            print \ngain = \n, gain\n                    if (gain == 1 or gain == 16):\n                            self.setGain(gain)  # Low/highGain\n                            ambient = self.readFull()\n                            IR = self.readIR()\n                    elif (gain == 0):  # Auto gain\n                            self.setGain(16)  # First try highGain\n                            ambient = self.readFull()\n                            if (ambient \n 65535):\n                                    IR = self.readIR()\n                            if (ambient \n= 65535 or IR \n= 65535):  # Value(s) exeed(s) datarange\n                                    self.setGain(1)  # Set lowGain\n                                    ambient = self.readFull()\n                                    IR = self.readIR()\n\n                    # If either sensor is saturated, no acculate lux value can be achieved.\n                    if (ambient == 0xffff or IR == 0xffff):\n                    self._LUX = None\n                    self._ambient = None\n                    self._IR = None\n                    return (self.ambient, self.IR, self._ambient, self._IR, self._LUX)\n                    if (self.gain == 1):\n                            self._ambient = 16 * ambient  # Scale 1x to 16x\n                            self._IR = 16 * IR            # Scale 1x to 16x\n                    else:\n                            self._ambient = 1 * ambient\n                            self._IR = 1 * IR\n                    if (self.debug):\n                            print \nIR Result without scaling: \n, IR\n                            print \nIR Result: \n, self._IR\n                            print \nAmbient Result without scaling: \n, ambient\n                            print \nAmbient Result: \n, self._ambient\n\n                    if (self._ambient == 0):\n                    # Sometimes, the channel 0 returns 0 when dark ...\n                    self._LUX = 0.0\n                    return (ambient, IR, self._ambient, self._IR, self._LUX)\n\n                    ratio = (self._IR / float(self._ambient))  # Change to make it run under python 2\n\n                    if (self.debug):\n                            print \nratio: \n, ratio\n\n                    if ((ratio \n= 0) and (ratio \n= 0.52)):\n                            self._LUX = (0.0315 * self._ambient) - (0.0593 * self._ambient * (ratio ** 1.4))\n                    elif (ratio \n= 0.65):\n                            self._LUX = (0.0229 * self._ambient) - (0.0291 * self._IR)\n                    elif (ratio \n= 0.80):\n                            self._LUX = (0.0157 * self._ambient) - (0.018 * self._IR)\n                    elif (ratio \n= 1.3):\n                            self._LUX = (0.00338 * self._ambient) - (0.0026 * self._IR)\n                    elif (ratio \n 1.3):\n                            self._LUX = 0\n\n                    return (ambient, IR, self._ambient, self._IR, self._LUX)\n\n            def _partno_revision(self):\n                    \n Read Partnumber and revision of the sensor \n\n                    cmd = _CMD | _REG_ID\n                    value = self.i2c.readS8(cmd)\n                    part = str(value)[7:4]\n                    if (part == \n0000\n):\n                            PartNo = \nTSL2560CS\n\n                    elif (part == \n0001\n):\n                            PartNo = \nTSL2561CS\n\n                    elif (part == \n0100\n):\n                            PartNo = \nTSL2560T/FN/CL\n\n                    elif (part == \n0101\n):\n                            PartNo = \nTSL2561T/FN/CL\n\n                    else:\n                            PartNo = \nnot TSL2560 or TSL 2561\n\n                    RevNo = str(value)[3:0]\n                    if (self.debug):\n                            print \nresponce: \n, value\n                            print \nPartNo = \n, PartNo\n                            print \nRevNo = \n, RevNo\n                    return (PartNo, RevNo)\n\n            def _control(self, params):\n                    if (params == _POWER_UP):\n                            print \nPower ON\n\n                    elif (params == _POWER_DOWN):\n                            print \nPower OFF\n\n                    else:\n                            print \nNo params given\n\n                    cmd = _CMD | _REG_CONTROL | params\n                    self.i2c.write8(self._addr, cmd)  # select command register and power on\n                time.sleep(0.4)  # Wait for 400ms to power up or power down.\n\n\n\n    def main():\n            TSL2561 = Tsl2561()\n            TSL2561._init__(I2C_SMBUS, I2C_ADDRESS)\n            while (True):\n                    gain=0\n                    val = TSL2561.readLux(gain)\n                    ambient = val[0]\n                    IR = val[1]\n                    _ambient = val[2]\n                    _IR = val[3]\n                    _LUX = val[4]\n                    if (ambient == 0xffff or IR == 0xffff):\n                            print (\nSensor is saturated, no lux value can be achieved:\n)\n                    print (\nambient = \n + ambient)\n                        print (\nIR = \n + IR)\n                            print (\nlight = \n + _LUX)\n                elif (_ambient == 0):\n                        print (\nIt's dark:\n)\n                            print (\nambient = \n + str(ambient))\n                    print (\nIR = \n + str(IR))\n                        print (\n_ambient = \n + str(_ambient))\n                            print (\n_IR = \n + str(_IR))\n                    print (\nLight = \n + str(_LUX) + \n lux.\n)\n                    else:\n                            print (\nThere is light:\n)\n                    print (\nambient = \n + str(ambient))\n                            print (\nIR = \n + str(IR))\n                            print (\n_ambient = \n + str(_ambient))\n                            print (\n_IR = \n + str(_IR))\n                            print (\nLight = \n + str(_LUX) + \n lux.\n)\n                    time.sleep(2)\n                    ambient  = None\n                    IR       = None\n                    _ambient = 0\n                    _IR      = 0\n                    _LUX     = None\n                TSL2561._control(_POWER_DOWN)\n\n\n    if __name__==\n__main__\n:\n            main()\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_i2c_digital_light_sensor.py\n\n\n\n\n6.Result\n\n\n\n\nReference\n\uf0c1\n\n\nRegister Map\n\uf0c1\n\n\nThe TSL2561 is controlled and monitored by sixteen registers (three are reserved) and a command register accessed through the serial interface. These registers provide for a variety of control functions and can be read to determine results of the ADC conversions. The register set is summarised as shown below.\n\n\n\n\nSpectrum Response Curve\n\uf0c1\n\n\n\n\nTwo channels of the digital light sensor have different response characteristic. That\ns why you can choose its working mode by having both of them on or one of them off.\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Digital Light Sensor Eagle File\n(include printed PDF format files)\n\n\nLibrary Github Repo\n\n\nTSL2561 Datasheet", 
            "title": "Grove - Digital Light Sensor"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#features", 
            "text": "Selectable detection modes  High resolution 16-Bit digital output at 400 kHz I2C Fast-Mode  Wide dynamic range: 0.1 - 40,000 LUX  Wide operating temperature range: -40\u00b0C to 85\u00b0C  Programmable interrupt function with User-Defined Upper and lower threshold settings", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#specifications", 
            "text": "Items  Min  Typical  Max  Unit      Supply voltage, VDD  3.3  5  5.1  V    Operating temperature  -30  \\  70  \u2103    SCL,SDA input low voltage  -0.5  \\  0.8  V    SCL,SDA input high voltage  2.3  \\  5.1  V", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#hardware-overview", 
            "text": "U1:  TSL2561 IC, Light-To-Digital Converter.  U3:  XC6206MR332 IC, Positive Voltage Regulators.  Q1,Q2:  BSN20 IC, N-channel Enhancement Mode Vertical D-MOS Transistor.  SCL,SDA:  I2C Signal Interface", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#tsl2561-functional-block-diagram", 
            "text": "", 
            "title": "TSL2561 Functional Block Diagram"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#with-arduino", 
            "text": "1.Plug the Grove - Digital Light Sensor onto the I2C port on Grove - Base Shield, and then plug the base shield onto Arduino.   2.Download the library from here  Digital Light Sensor Library ;  3.Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  4.Create an Arduino sketch and paste the following code into it or open the code directly by the path:File -  Example - Digital_Light_Sensor- Digital_Light_Sensor.      /*\n     * Digital_Light_Sensor.ino\n     * A library for TSL2561\n     *\n     * Copyright (c) 2012 seeed technology inc.\n     * Website   \u00a0: www.seeed.cc\n     * Author    \u00a0: zhangkun\n     * Create Time:\n     * Change Log\u00a0:\n     *\n     * The MIT License (MIT)\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the  Software ), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in\n     * all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     * THE SOFTWARE.\n     */\n\n    #include  Wire.h \n    #include  Digital_Light_TSL2561.h \n    void setup()\n    {\n      Wire.begin();\n      Serial.begin(9600);\n      TSL2561.init();\n    }\n\n    void loop()\n    {\n      Serial.print( The Light value is:  );\n      Serial.println(TSL2561.readVisibleLux());\n      delay(1000);\n    }  5.Upload the code. Please click  here  if you do not know how to upload.  6.Open the serial monitor to see the result.   In the case of completely light matte, The output result is 0.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug Digital Light Sensor to the I2C sockets on grovepi.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/grove_i2c_digital_light_sensor/   To see the code       nano grove_i2c_digital_light_sensor.py  #  Ctrl+x  to exit #      import time\n    import smbus\n    from Adafruit_I2C import Adafruit_I2C\n    import RPi.GPIO as GPIO\n    import grovepi\n    from smbus import SMBus\n\n    global I2C_ADDRESS\n    global I2C_SMBUS\n    global _CMD\n    global _CMD_CLEAR\n    global _CMD_WORD\n    global _CMD_BLOCK\n    global _REG_CONTROL\n    global _REG_TIMING\n    global _REG_ID\n    global _REG_BLOCKREAD\n    global _REG_DATA0\n    global _REG_DATA1\n    global _POWER_UP\n    global _POWER_DOWN\n    global _GAIN_LOW\n    global _GAIN_HIGH\n    global _INTEGRATION_START\n    global _INTEGRATION_STOP\n    global _INTEGRATE_13\n    global _INTEGRATE_101\n    global _INTEGRATE_402\n    global _INTEGRATE_DEFAULT\n    global _INTEGRATE_NA\n    global _GAIN\n    global _MANUAL\n    global _INTEG\n    global _CHANNEL0\n    global _CHANNEL1\n    global _D0\n    global _D1\n    global _LUX\n\n\n    # bus parameters\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        I2C_SMBUS = smbus.SMBus(1)\n    else:\n        I2C_SMBUS = smbus.SMBus(0)\n\n    # Default I2C address\n    I2C_ADDRESS = 0x29\n\n    # Commands\n    _CMD       = 0x80\n    _CMD_CLEAR = 0x40\n    _CMD_WORD  = 0x20\n    _CMD_BLOCK = 0x10\n\n    # Registers\n    _REG_CONTROL   = 0x00\n    _REG_TIMING    = 0x01\n    _REG_ID        = 0x0A\n    _REG_BLOCKREAD = 0x0B\n    _REG_DATA0     = 0x0C\n    _REG_DATA1     = 0x0E\n\n    # Control parameters\n    _POWER_UP   = 0x03\n    _POWER_DOWN = 0x00\n\n    # Timing parameters\n    _GAIN_LOW          = 0b00000000\n    _GAIN_HIGH         = 0b00010000\n    _INTEGRATION_START = 0b00001000\n    _INTEGRATION_STOP  = 0b00000000\n    _INTEGRATE_13      = 0b00000000\n    _INTEGRATE_101     = 0b00000001\n    _INTEGRATE_402     = 0b00000010\n    _INTEGRATE_DEFAULT = _INTEGRATE_402\n    _INTEGRATE_NA      = 0b00000011\n\n    # Testing parameters\n    ambient  = None\n    IR       = None\n    _ambient = 0\n    _IR      = 0\n    _LUX     = None\n\n\n    class Tsl2561(object):\n            i2c = None\n\n            def _init__(self, bus = I2C_SMBUS, addr = I2C_ADDRESS, debug = 1, pause = 0.8):  # set debug = 0 stops debugging output on screen\n                    assert(bus is not None)\n                assert(addr   0b000111 and addr   0b1111000)\n\n                    self.i2c     = Adafruit_I2C(addr)\n                    self.pause   = pause\n                    self.debug   = debug\n                    self.gain    = 0\n                self._bus    = bus\n                    self._addr   = addr\n\n                ambient        = None\n                    IR             = None\n                self._ambient  = 0\n                    self._IR       = 0\n                self._LUX      = None\n                    self._control(_POWER_UP)\n                    self._partno_revision()\n\n    #        @property\n\n            def _lux(self, gain):\n                    '''\n                    Returns a lux value.  Returns None if no valid value is set yet.\n                    '''\n                    var = readLux(gain)\n                    ambient = var[0]\n                    IR = var[1]\n                    self._ambient = var[2]\n                    self._IR = var[3]\n                    self_LUX = var[4]\n                    return (ambient, IR, self._ambient, self._IR, self._LUX)\n\n\n            def setGain(self, gain = 1):\n                      Set the gain  \n                    if (gain\u00a0!= self.gain):\n                            if (gain==1):\n                                    cmd = _CMD | _REG_TIMING\n                                    value = 0x02\n                                    self.i2c.write8(cmd, value)  # Set gain = 1X and timing = 402 mSec\n                                    if (self.debug):\n                                            print  Setting low gain \n                            else:\n                                    cmd = _CMD | _REG_TIMING\n                                    value = 0x12\n                                    self.i2c.write8(cmd, value)  # Set gain = 16X and timing = 402 mSec\n                                    if (self.debug):\n                                            print  Setting high gain \n                            self.gain=gain;  # Safe gain for calculation\n                            time.sleep(self.pause)  # Pause for integration (self.pause must be bigger than integration time)\n\n\n            def readWord(self, reg):\n                      Reads a word from the TSL2561 I2C device  \n                    try:\n                            wordval = self.i2c.readU16(reg)\n                            newval = self.i2c.reverseByteOrder(wordval)\n                            if (self.debug):\n                                    print( I2C: Device 0x%02X: returned 0x%04X from reg 0x%02X \u00a0% (self._addr, wordval   0xFFFF, reg))\n                            return newval\n                    except IOError:\n                            print( Error accessing 0x%02X: Chcekcyour I2C address \u00a0% self._addr)\n                            return -1\n\n\n            def readFull(self, reg = 0x8C):\n                      Read visible + IR diode from the TSL2561 I2C device  \n                    return self.readWord(reg);\n\n            def readIR(self, reg = 0x8E):\n                      Reads only IR diode from the TSL2561 I2C device  \n                    return self.readWord(reg);\n\n            def readLux(self, gain = 0):\n                      Grabs a lux reading either with autoranging (gain=0) or with specific gain (1, 16)  \n                    if (self.debug):\n                            print  gain =  , gain\n                    if (gain == 1 or gain == 16):\n                            self.setGain(gain)  # Low/highGain\n                            ambient = self.readFull()\n                            IR = self.readIR()\n                    elif (gain == 0):  # Auto gain\n                            self.setGain(16)  # First try highGain\n                            ambient = self.readFull()\n                            if (ambient   65535):\n                                    IR = self.readIR()\n                            if (ambient  = 65535 or IR  = 65535):  # Value(s) exeed(s) datarange\n                                    self.setGain(1)  # Set lowGain\n                                    ambient = self.readFull()\n                                    IR = self.readIR()\n\n                    # If either sensor is saturated, no acculate lux value can be achieved.\n                    if (ambient == 0xffff or IR == 0xffff):\n                    self._LUX = None\n                    self._ambient = None\n                    self._IR = None\n                    return (self.ambient, self.IR, self._ambient, self._IR, self._LUX)\n                    if (self.gain == 1):\n                            self._ambient = 16 * ambient  # Scale 1x to 16x\n                            self._IR = 16 * IR            # Scale 1x to 16x\n                    else:\n                            self._ambient = 1 * ambient\n                            self._IR = 1 * IR\n                    if (self.debug):\n                            print  IR Result without scaling:  , IR\n                            print  IR Result:  , self._IR\n                            print  Ambient Result without scaling:  , ambient\n                            print  Ambient Result:  , self._ambient\n\n                    if (self._ambient == 0):\n                    # Sometimes, the channel 0 returns 0 when dark ...\n                    self._LUX = 0.0\n                    return (ambient, IR, self._ambient, self._IR, self._LUX)\n\n                    ratio = (self._IR / float(self._ambient))  # Change to make it run under python 2\n\n                    if (self.debug):\n                            print  ratio:  , ratio\n\n                    if ((ratio  = 0) and (ratio  = 0.52)):\n                            self._LUX = (0.0315 * self._ambient) - (0.0593 * self._ambient * (ratio ** 1.4))\n                    elif (ratio  = 0.65):\n                            self._LUX = (0.0229 * self._ambient) - (0.0291 * self._IR)\n                    elif (ratio  = 0.80):\n                            self._LUX = (0.0157 * self._ambient) - (0.018 * self._IR)\n                    elif (ratio  = 1.3):\n                            self._LUX = (0.00338 * self._ambient) - (0.0026 * self._IR)\n                    elif (ratio   1.3):\n                            self._LUX = 0\n\n                    return (ambient, IR, self._ambient, self._IR, self._LUX)\n\n            def _partno_revision(self):\n                      Read Partnumber and revision of the sensor  \n                    cmd = _CMD | _REG_ID\n                    value = self.i2c.readS8(cmd)\n                    part = str(value)[7:4]\n                    if (part ==  0000 ):\n                            PartNo =  TSL2560CS \n                    elif (part ==  0001 ):\n                            PartNo =  TSL2561CS \n                    elif (part ==  0100 ):\n                            PartNo =  TSL2560T/FN/CL \n                    elif (part ==  0101 ):\n                            PartNo =  TSL2561T/FN/CL \n                    else:\n                            PartNo =  not TSL2560 or TSL 2561 \n                    RevNo = str(value)[3:0]\n                    if (self.debug):\n                            print  responce:  , value\n                            print  PartNo =  , PartNo\n                            print  RevNo =  , RevNo\n                    return (PartNo, RevNo)\n\n            def _control(self, params):\n                    if (params == _POWER_UP):\n                            print  Power ON \n                    elif (params == _POWER_DOWN):\n                            print  Power OFF \n                    else:\n                            print  No params given \n                    cmd = _CMD | _REG_CONTROL | params\n                    self.i2c.write8(self._addr, cmd)  # select command register and power on\n                time.sleep(0.4)  # Wait for 400ms to power up or power down.\n\n\n\n    def main():\n            TSL2561 = Tsl2561()\n            TSL2561._init__(I2C_SMBUS, I2C_ADDRESS)\n            while (True):\n                    gain=0\n                    val = TSL2561.readLux(gain)\n                    ambient = val[0]\n                    IR = val[1]\n                    _ambient = val[2]\n                    _IR = val[3]\n                    _LUX = val[4]\n                    if (ambient == 0xffff or IR == 0xffff):\n                            print ( Sensor is saturated, no lux value can be achieved: )\n                    print ( ambient =   + ambient)\n                        print ( IR =   + IR)\n                            print ( light =   + _LUX)\n                elif (_ambient == 0):\n                        print ( It's dark: )\n                            print ( ambient =   + str(ambient))\n                    print ( IR =   + str(IR))\n                        print ( _ambient =   + str(_ambient))\n                            print ( _IR =   + str(_IR))\n                    print ( Light =   + str(_LUX) +   lux. )\n                    else:\n                            print ( There is light: )\n                    print ( ambient =   + str(ambient))\n                            print ( IR =   + str(IR))\n                            print ( _ambient =   + str(_ambient))\n                            print ( _IR =   + str(_IR))\n                            print ( Light =   + str(_LUX) +   lux. )\n                    time.sleep(2)\n                    ambient  = None\n                    IR       = None\n                    _ambient = 0\n                    _IR      = 0\n                    _LUX     = None\n                TSL2561._control(_POWER_DOWN)\n\n\n    if __name__== __main__ :\n            main()  5.Run the demo.      sudo python grove_i2c_digital_light_sensor.py  6.Result", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#register-map", 
            "text": "The TSL2561 is controlled and monitored by sixteen registers (three are reserved) and a command register accessed through the serial interface. These registers provide for a variety of control functions and can be read to determine results of the ADC conversions. The register set is summarised as shown below.", 
            "title": "Register Map"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#spectrum-response-curve", 
            "text": "Two channels of the digital light sensor have different response characteristic. That s why you can choose its working mode by having both of them on or one of them off.", 
            "title": "Spectrum Response Curve"
        }, 
        {
            "location": "/Grove-Digital_Light_Sensor/#resources", 
            "text": "Grove - Digital Light Sensor Eagle File (include printed PDF format files)  Library Github Repo  TSL2561 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-EMG_Detector/", 
            "text": "EMG detector is a bridge connects human body and electrical, the sensor gathers small muscle signal then process with 2th amplify and filter, the output signal can be recognized by Arduino. You can add this signal into your control system. \n\n\n\n\nNote\n\nThe sensor cannot be used for medical purposes.\n\n\n\n\nIn standby mode, the output voltage is 1.5V. When detect muscle active, the output signal rise up, the maximum voltage is 3.3V. You can use this sensor in 3.3V or 5V system.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove Compatible\n\n\n3.5mm Connector\n\n\n6 Disposable Surface Electrodes\n\n\nPower supply voltage: 3.3V-5V\n\n\n1000mm Cable Leads\n\n\nNo additional power supply\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nJ2: grove interface, connect to analog I/O;\n\n\nJ1: EMG Disposable Surface Electrodes connector.\n\n\nU1: INA331IDGKT, difference amplifier.\n\n\nU2, U3: OPA333, Zero drift amplifier.\n\n\n\n\nDemonstration\n\uf0c1\n\n\nThis demonstration will show you how to use Grove - LCD RGB Backlight, we need a \nSeeeduino V3.0\n, a \nGrove - LED Bar\n and \nGrove - Base Shield\n.\n\n\nHardware Installation\n\uf0c1\n\n\nPlug Grove - Base Shield to Seeeduino, then connect Grove - LED Bar to D8, connect Grove - EMG Sensor to A0.\n\n\nFinally, tack the three electrodes to your muscle, and keep a distance between each electrodes.\n\n\n\n\nDownload Code and Upload\n\uf0c1\n\n\nYou can download the demo code in github, click \nhere\n, then extract it to anywhere.\n\n\nThen upload the code to Seeeduino, if you have any problem about code uploading, please refer to \nGetting Started With Seeeduino\n\n\n\n\nMove\n\uf0c1\n\n\nWhen finish downloading demo code, it\nll take about 5s to initialize, you should keep static when initializing.\n\n\nYou can see that when initializing, the Led Bar will go form level 10 to level 0. When Led Bar All off, you can move now.\n\n\nWhen you are moving, you can find that the level of Led Bar will change.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-EMG Sensor v1.0 Eagle File\n\n\nGrove-EMG Sensor v1.1 Eagle File\n\n\nGrove-EMG Sensor v1.1 schematic PDF\n\n\nDemo Code", 
            "title": "Grove - EMG Detector"
        }, 
        {
            "location": "/Grove-EMG_Detector/#features", 
            "text": "Grove Compatible  3.5mm Connector  6 Disposable Surface Electrodes  Power supply voltage: 3.3V-5V  1000mm Cable Leads  No additional power supply", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-EMG_Detector/#hardware-overview", 
            "text": "J2: grove interface, connect to analog I/O;  J1: EMG Disposable Surface Electrodes connector.  U1: INA331IDGKT, difference amplifier.  U2, U3: OPA333, Zero drift amplifier.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-EMG_Detector/#demonstration", 
            "text": "This demonstration will show you how to use Grove - LCD RGB Backlight, we need a  Seeeduino V3.0 , a  Grove - LED Bar  and  Grove - Base Shield .", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-EMG_Detector/#hardware-installation", 
            "text": "Plug Grove - Base Shield to Seeeduino, then connect Grove - LED Bar to D8, connect Grove - EMG Sensor to A0.  Finally, tack the three electrodes to your muscle, and keep a distance between each electrodes.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-EMG_Detector/#download-code-and-upload", 
            "text": "You can download the demo code in github, click  here , then extract it to anywhere.  Then upload the code to Seeeduino, if you have any problem about code uploading, please refer to  Getting Started With Seeeduino", 
            "title": "Download Code and Upload"
        }, 
        {
            "location": "/Grove-EMG_Detector/#move", 
            "text": "When finish downloading demo code, it ll take about 5s to initialize, you should keep static when initializing.  You can see that when initializing, the Led Bar will go form level 10 to level 0. When Led Bar All off, you can move now.  When you are moving, you can find that the level of Led Bar will change.", 
            "title": "Move"
        }, 
        {
            "location": "/Grove-EMG_Detector/#resources", 
            "text": "Grove-EMG Sensor v1.0 Eagle File  Grove-EMG Sensor v1.1 Eagle File  Grove-EMG Sensor v1.1 schematic PDF  Demo Code", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Ear-clip_Heart_Rate_Sensor/", 
            "text": "The Heart Rate Ear clip kit contains a ear clip and a receiver module. The heart rate measure kit can be used to monitor heart rate of patient and athlete. The result can be displayed on a screen via the serial port and can be saved for analysis. The entire system is a high sensitivity, low power consumption and portable.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nLow power consumption\n\n\nConvenient to use\n\n\nHigh sensitivity\n\n\nFully RoHS compliant\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3.0\n\n\n\n\n5.0\n\n\n\n\n5.25\n\n\n\n\nV\n\n\n\n\n\n\n\n\nWork Current\n\n\n\n\n6.5\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nLength of ear clip wire\n\n\n\n\n120\n\n\n\n\ncm\n\n\n\n\n\n\n\n\nMeasures Range\n\n\n\n\n\u226530/min\n\n\n\n\n-\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nHeart rate monitor.\n\n\n\n\nUsage\n\uf0c1\n\n\nThe following sketch demonstrates a simple application of using the Ear-clip Heart Rate Sensor to measure heart rate.\n\n\n\n\nConnect this module to the digital port D2 on \nGrove-Base shield\n. And connect Grove-LED to Digital port 4.\n\n\nPlug the Base Shield into Arduino/Seeeduino.\n\n\n\n\n\n\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\n    // Function: This program can be used to measure heart rate, the lowest pulse in the program be set to 30.\n    //         Use an external interrupt to measure it.\n    // Hardware: Grove - Ear-clip Heart Rate Sensor, Grove - Base Shield, Grove - LED\n    // Arduino IDE: Arduino-1.0\n    // Author: FrankieChu       \n    // Date: Jan 22, 2013\n    // Version: v1.0\n    // by www.seeedstudio.com\n    #define LED 4//indicator, Grove - LED is connected with D4 of Arduino\n    boolean led_state = LOW;//state of LED, each time an external interrupt \n                                    //will change the state of LED\n    unsigned char counter;\n    unsigned long temp[21];\n    unsigned long sub;\n    bool data_effect=true;\n    unsigned int heart_rate;//the measurement result of heart rate\n\n    const int max_heartpluse_duty = 2000;//you can change it follow your system's request.\n                            //2000 meams 2 seconds. System return error \n                            //if the duty overtrip 2 second.\n    void setup()\n    {\n        pinMode(LED, OUTPUT);\n        Serial.begin(9600);\n        Serial.println(\nPlease ready your chest belt.\n);\n        delay(5000);\n        arrayInit();\n        Serial.println(\nHeart rate test begin.\n);\n        attachInterrupt(0, interrupt, RISING);//set interrupt 0,digital port 2\n    }\n    void loop()\n    {\n        digitalWrite(LED, led_state);//Update the state of the indicator\n    }\n    /*Function: calculate the heart rate*/\n    void sum()\n    {\n     if(data_effect)\n        {\n          heart_rate=1200000/(temp[20]-temp[0]);//60*20*1000/20_total_time \n          Serial.print(\nHeart_rate_is:\\t\n);\n          Serial.println(heart_rate);\n        }\n       data_effect=1;//sign bit\n    }\n    /*Function: Interrupt service routine.Get the sigal from the external interrupt*/\n    void interrupt()\n    {\n        temp[counter]=millis();\n        Serial.println(counter,DEC);\n        Serial.println(temp[counter]);\n        switch(counter)\n        {\n            case 0:\n                sub=temp[counter]-temp[20];\n                Serial.println(sub);\n                break;\n            default:\n                sub=temp[counter]-temp[counter-1];\n                Serial.println(sub);\n                break;\n        }\n        if(sub\nmax_heartpluse_duty)//set 2 seconds as max heart pluse duty\n        {\n            data_effect=0;//sign bit\n            counter=0;\n            Serial.println(\nHeart rate measure error,test will restart!\n );\n            arrayInit();\n        }\n        if (counter==20\ndata_effect)\n        {\n            counter=0;\n            sum();\n        }\n        else if(counter!=20\ndata_effect)\n        counter++;\n        else \n        {\n            counter=0;\n            data_effect=1;\n        }\n\n    }\n    /*Function: Initialization for the array(temp)*/\n    void arrayInit()\n    {\n        for(unsigned char i=0;i \n 20;i ++)\n        {\n            temp[i]=0;\n        }\n        temp[20]=millis();\n    }\n\n\n\n\n\n\nUpload the code, please click \nhere\n if you do not know how to upload.\n\n\nMake sure the sensor contacts your ear skin. This is the signal when we are measuring the heart rate:\n\n\n\n\n\n\n\n\nIn the first of the figures, which is a waveform diagram of the detected heartbeat, a high pulse comes when beating. \n\n\n\n\nNote\n\nIf the serial monitor return an error message, please change the position of the sensor.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Ear-clip Heart Rate Sensor Demo code", 
            "title": "Grove - Ear-clip Heart Rate Sensor"
        }, 
        {
            "location": "/Grove-Ear-clip_Heart_Rate_Sensor/#features", 
            "text": "Low power consumption  Convenient to use  High sensitivity  Fully RoHS compliant", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Ear-clip_Heart_Rate_Sensor/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3.0  \n5.0  \n5.25  \nV    \nWork Current  \n6.5  \nmA    \nLength of ear clip wire  \n120  \ncm    \nMeasures Range  \n\u226530/min  \n-", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Ear-clip_Heart_Rate_Sensor/#application-ideas", 
            "text": "Heart rate monitor.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Ear-clip_Heart_Rate_Sensor/#usage", 
            "text": "The following sketch demonstrates a simple application of using the Ear-clip Heart Rate Sensor to measure heart rate.   Connect this module to the digital port D2 on  Grove-Base shield . And connect Grove-LED to Digital port 4.  Plug the Base Shield into Arduino/Seeeduino.     Copy and paste code below to a new Arduino sketch.       // Function: This program can be used to measure heart rate, the lowest pulse in the program be set to 30.\n    //         Use an external interrupt to measure it.\n    // Hardware: Grove - Ear-clip Heart Rate Sensor, Grove - Base Shield, Grove - LED\n    // Arduino IDE: Arduino-1.0\n    // Author: FrankieChu       \n    // Date: Jan 22, 2013\n    // Version: v1.0\n    // by www.seeedstudio.com\n    #define LED 4//indicator, Grove - LED is connected with D4 of Arduino\n    boolean led_state = LOW;//state of LED, each time an external interrupt \n                                    //will change the state of LED\n    unsigned char counter;\n    unsigned long temp[21];\n    unsigned long sub;\n    bool data_effect=true;\n    unsigned int heart_rate;//the measurement result of heart rate\n\n    const int max_heartpluse_duty = 2000;//you can change it follow your system's request.\n                            //2000 meams 2 seconds. System return error \n                            //if the duty overtrip 2 second.\n    void setup()\n    {\n        pinMode(LED, OUTPUT);\n        Serial.begin(9600);\n        Serial.println( Please ready your chest belt. );\n        delay(5000);\n        arrayInit();\n        Serial.println( Heart rate test begin. );\n        attachInterrupt(0, interrupt, RISING);//set interrupt 0,digital port 2\n    }\n    void loop()\n    {\n        digitalWrite(LED, led_state);//Update the state of the indicator\n    }\n    /*Function: calculate the heart rate*/\n    void sum()\n    {\n     if(data_effect)\n        {\n          heart_rate=1200000/(temp[20]-temp[0]);//60*20*1000/20_total_time \n          Serial.print( Heart_rate_is:\\t );\n          Serial.println(heart_rate);\n        }\n       data_effect=1;//sign bit\n    }\n    /*Function: Interrupt service routine.Get the sigal from the external interrupt*/\n    void interrupt()\n    {\n        temp[counter]=millis();\n        Serial.println(counter,DEC);\n        Serial.println(temp[counter]);\n        switch(counter)\n        {\n            case 0:\n                sub=temp[counter]-temp[20];\n                Serial.println(sub);\n                break;\n            default:\n                sub=temp[counter]-temp[counter-1];\n                Serial.println(sub);\n                break;\n        }\n        if(sub max_heartpluse_duty)//set 2 seconds as max heart pluse duty\n        {\n            data_effect=0;//sign bit\n            counter=0;\n            Serial.println( Heart rate measure error,test will restart!  );\n            arrayInit();\n        }\n        if (counter==20 data_effect)\n        {\n            counter=0;\n            sum();\n        }\n        else if(counter!=20 data_effect)\n        counter++;\n        else \n        {\n            counter=0;\n            data_effect=1;\n        }\n\n    }\n    /*Function: Initialization for the array(temp)*/\n    void arrayInit()\n    {\n        for(unsigned char i=0;i   20;i ++)\n        {\n            temp[i]=0;\n        }\n        temp[20]=millis();\n    }   Upload the code, please click  here  if you do not know how to upload.  Make sure the sensor contacts your ear skin. This is the signal when we are measuring the heart rate:     In the first of the figures, which is a waveform diagram of the detected heartbeat, a high pulse comes when beating.    Note \nIf the serial monitor return an error message, please change the position of the sensor.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Ear-clip_Heart_Rate_Sensor/#resources", 
            "text": "Grove - Ear-clip Heart Rate Sensor Demo code", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/", 
            "text": "The Electricity sensor module is a member of Grove. It is based on the TA12-200 current transformer which can transform the large AC into small amplitude. You can use it to test large alternating current up to 5A.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible interface\n\n\nMaximum 5A input\n\n\nHigh accuracy\n\n\nSmall size\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nAlternating current measurement\n\n\nDevice condition monitoring\n\n\n\n\nSpecification\n\uf0c1\n\n\nKey Specification\n\uf0c1\n\n\n\n\n\n\n\n\nItems\n\n\nMin\n\n\n\n\n\n\n\n\n\n\nPCB Size\n\n\n2.0cm*4.0cm\n\n\n\n\n\n\nInterface\n\n\n2.0mm pitch pin header\n\n\n\n\n\n\nIO Structure\n\n\nSIG,NC,NC,GND\n\n\n\n\n\n\nRoHS\n\n\nYES\n\n\n\n\n\n\n\n\nElectronic Characteristics\n\uf0c1\n\n\n\n\n\n\n\n\nItems\n\n\nMin\n\n\nNorm\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nTransformation ratio\n\n\n-\n\n\n2000:1\n\n\n-\n\n\n-\n\n\n\n\n\n\nInput Current\n\n\n0\n\n\n-\n\n\n5\n\n\nA\n\n\n\n\n\n\nOutput Current\n\n\n0\n\n\n-\n\n\n2.5\n\n\nmA\n\n\n\n\n\n\nSampling Resistance\n\n\n-\n\n\n800\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nSampling Voltage\n\n\n0\n\n\n-\n\n\n2\n\n\nV\n\n\n\n\n\n\nWorking Frequency\n\n\n20\n\n\n-\n\n\n20K\n\n\nHZ\n\n\n\n\n\n\nNonlinear scale\n\n\n-\n\n\n-\n\n\n0.2%\n\n\n-\n\n\n\n\n\n\nPhase Shift\n\n\n-\n\n\n-\n\n\n5\n\n\n-\n\n\n\n\n\n\nOperating Temperature\n\n\n-55\n\n\n-\n\n\n85\n\n\n\u2103\n\n\n\n\n\n\nDielectric strength\n\n\n-\n\n\n6\n\n\n-\n\n\nKVAC/1min\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThe following sketch demonstrates a simple application of measuring the amplitude of the alternating voltage. The SIG pin will output a alternating voltage based on the alternating current being measured. You can measure the value using ADC.\n\n\n\n\nConnect the module to the analog A0 of \nGrove - Base board\n.\n\n\nPut the alternating current wire through the hole of the current transformer.\n\n\n\n\n\n\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\n    /****************************************************************************/  \n    //  Function: Measure the amplitude current of the alternating current and \n    //            the effective current of the sinusoidal alternating current.\n    //  Hardware: Grove - Electricity Sensor        \n    //  Date:    Jan 19,2013\n    //  by www.seeedstudio.com\n    #define ELECTRICITY_SENSOR A0 // Analog input pin that sensor is attached to\n\n    float amplitude_current;               //amplitude current\n    float effective_value;       //effective current \n\n    void setup() \n    {\n        Serial.begin(9600); \n        pins_init();\n    }\n    void loop() \n    {\n        int sensor_max;\n        sensor_max = getMaxValue();\n        Serial.print(\nsensor_max = \n);\n        Serial.println(sensor_max);\n        //the VCC on the Grove interface of the sensor is 5v\n        amplitude_current=(float)sensor_max/1024*5/800*2000000;\n        effective_value=amplitude_current/1.414;//minimum_current=1/1024*5/800*2000000/1.414=8.6(mA) \n                            //Only for sinusoidal alternating current\n        Serial.println(\nThe amplitude of the current is(in mA)\n);\n        Serial.println(amplitude_current,1);//Only one number after the decimal point\n        Serial.println(\nThe effective value of the current is(in mA)\n);\n        Serial.println(effective_value,1);\n    }\n    void pins_init()\n    {\n        pinMode(ELECTRICITY_SENSOR, INPUT);\n    }\n    /*Function: Sample for 1000ms and get the maximum value from the SIG pin*/\n    int getMaxValue()\n    {\n        int sensorValue;             //value read from the sensor\n        int sensorMax = 0;\n        uint32_t start_time = millis();\n        while((millis()-start_time) \n 1000)//sample for 1000ms\n        {\n            sensorValue = analogRead(ELECTRICITY_SENSOR);\n            if (sensorValue \n sensorMax) \n            {\n                /*record the maximum sensor value*/\n                sensorMax = sensorValue;\n            }\n        }\n        return sensorMax;\n    }\n\n\n\n\n\n\nUpload the code, please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n\nNote\n\nThe minimum effective current that can be sensed by the code can be calculated using the equation below. minimum_current=1/1024*5/800*2000000/1.414=8.6(mA).\n\n\n\n\n\n\nOpen the serial monitor, The results is as follows\uff1a\n\n\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket A0 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n   cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_electricity_sensor.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Electricity Sensor to analog port A0\n    # SIG,NC,NC,GND\n    sensor = 0\n\n    grovepi.pinMode(sensor,\nINPUT\n)\n\n    # Vcc of the grove interface is normally 5v\n    grove_vcc = 5\n\n    while True:\n        try:\n            # Get sensor value\n            sensor_value = grovepi.analogRead(sensor)\n\n            # Calculate amplitude current (mA)\n            amplitude_current = (float)(sensor_value / 1024 * grove_vcc / 800 * 2000000)\n\n            # Calculate effective value (mA)\n            effective_value = amplitude_current / 1.414\n\n            # minimum_current = 1 / 1024 * grove_vcc / 800 * 2000000 / 1.414 = 8.6(mA)\n            # Only for sinusoidal alternating current\n\n            print \nsensor_value\n, sensor_value\n            print \nThe amplitude of the current is\n, amplitude_current, \nmA\n\n            print \nThe effective value of the current is\n, effective_value, \nmA\n\n            time.sleep(1)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_electricity_sensor.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove -Electricity Sensor Eagle File\n\n\nSchematic in PDF", 
            "title": "Grove - Electricity Sensor"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#features", 
            "text": "Grove compatible interface  Maximum 5A input  High accuracy  Small size", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#application-ideas", 
            "text": "Alternating current measurement  Device condition monitoring", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#specification", 
            "text": "", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#key-specification", 
            "text": "Items  Min      PCB Size  2.0cm*4.0cm    Interface  2.0mm pitch pin header    IO Structure  SIG,NC,NC,GND    RoHS  YES", 
            "title": "Key Specification"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#electronic-characteristics", 
            "text": "Items  Min  Norm  Max  Unit      Transformation ratio  -  2000:1  -  -    Input Current  0  -  5  A    Output Current  0  -  2.5  mA    Sampling Resistance  -  800  -  \u03a9    Sampling Voltage  0  -  2  V    Working Frequency  20  -  20K  HZ    Nonlinear scale  -  -  0.2%  -    Phase Shift  -  -  5  -    Operating Temperature  -55  -  85  \u2103    Dielectric strength  -  6  -  KVAC/1min", 
            "title": "Electronic Characteristics"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#with-arduino", 
            "text": "The following sketch demonstrates a simple application of measuring the amplitude of the alternating voltage. The SIG pin will output a alternating voltage based on the alternating current being measured. You can measure the value using ADC.   Connect the module to the analog A0 of  Grove - Base board .  Put the alternating current wire through the hole of the current transformer.     Copy and paste code below to a new Arduino sketch.       /****************************************************************************/  \n    //  Function: Measure the amplitude current of the alternating current and \n    //            the effective current of the sinusoidal alternating current.\n    //  Hardware: Grove - Electricity Sensor        \n    //  Date:    Jan 19,2013\n    //  by www.seeedstudio.com\n    #define ELECTRICITY_SENSOR A0 // Analog input pin that sensor is attached to\n\n    float amplitude_current;               //amplitude current\n    float effective_value;       //effective current \n\n    void setup() \n    {\n        Serial.begin(9600); \n        pins_init();\n    }\n    void loop() \n    {\n        int sensor_max;\n        sensor_max = getMaxValue();\n        Serial.print( sensor_max =  );\n        Serial.println(sensor_max);\n        //the VCC on the Grove interface of the sensor is 5v\n        amplitude_current=(float)sensor_max/1024*5/800*2000000;\n        effective_value=amplitude_current/1.414;//minimum_current=1/1024*5/800*2000000/1.414=8.6(mA) \n                            //Only for sinusoidal alternating current\n        Serial.println( The amplitude of the current is(in mA) );\n        Serial.println(amplitude_current,1);//Only one number after the decimal point\n        Serial.println( The effective value of the current is(in mA) );\n        Serial.println(effective_value,1);\n    }\n    void pins_init()\n    {\n        pinMode(ELECTRICITY_SENSOR, INPUT);\n    }\n    /*Function: Sample for 1000ms and get the maximum value from the SIG pin*/\n    int getMaxValue()\n    {\n        int sensorValue;             //value read from the sensor\n        int sensorMax = 0;\n        uint32_t start_time = millis();\n        while((millis()-start_time)   1000)//sample for 1000ms\n        {\n            sensorValue = analogRead(ELECTRICITY_SENSOR);\n            if (sensorValue   sensorMax) \n            {\n                /*record the maximum sensor value*/\n                sensorMax = sensorValue;\n            }\n        }\n        return sensorMax;\n    }   Upload the code, please click  here  if you do not know how to upload.    Note \nThe minimum effective current that can be sensed by the code can be calculated using the equation below. minimum_current=1/1024*5/800*2000000/1.414=8.6(mA).   Open the serial monitor, The results is as follows\uff1a", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket A0 by using a grove cable.   4.Navigate to the demos  directory:     cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_electricity_sensor.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Electricity Sensor to analog port A0\n    # SIG,NC,NC,GND\n    sensor = 0\n\n    grovepi.pinMode(sensor, INPUT )\n\n    # Vcc of the grove interface is normally 5v\n    grove_vcc = 5\n\n    while True:\n        try:\n            # Get sensor value\n            sensor_value = grovepi.analogRead(sensor)\n\n            # Calculate amplitude current (mA)\n            amplitude_current = (float)(sensor_value / 1024 * grove_vcc / 800 * 2000000)\n\n            # Calculate effective value (mA)\n            effective_value = amplitude_current / 1.414\n\n            # minimum_current = 1 / 1024 * grove_vcc / 800 * 2000000 / 1.414 = 8.6(mA)\n            # Only for sinusoidal alternating current\n\n            print  sensor_value , sensor_value\n            print  The amplitude of the current is , amplitude_current,  mA \n            print  The effective value of the current is , effective_value,  mA \n            time.sleep(1)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_electricity_sensor.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Electricity_Sensor/#resources", 
            "text": "Grove -Electricity Sensor Eagle File  Schematic in PDF", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Electromagnet/", 
            "text": "An electromagnet is a type of magnet in which the magnetic field is produced by electric current. An electric current flowing in a wire creates a magnetic field around the wire, due to Ampere\ns law(see drawing below). To concentrate the magnetic field, in an electromagnet the wire is wound into a coil with many turns of wire lying side by side. The magnetic field of all the turns of wire passes through the center of the coil, creating a strong magnetic field there. Grove - Electromagnet can suck 1KG weight and hold on. It is easy to use, to learn electromagnet principle.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove shape\n\n\n1KG peak suction\n\n\nLow standby current\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nWorking Voltage \uff1aDC 5V\n\n\nWorking Current \uff1a 400mA\n\n\nStandby current \uff1a 200uA\n\n\nLoad Weight\uff1a 1KG\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\n \n\n\n\n\nCODE:\n\n\n    /*\n      Turns on an Electromagnet on for one second, then off for one second, repeatedly.\n\n      This example code is in the public domain.\n     */\n\n    int Electromagnet = 0;\n    int LED = 13;\n\n    // the setup routine runs once when you press reset:\n    void setup() {                \n      // initialize the digital pin as an output.\n      pinMode(Electromagnet, OUTPUT); \n      pinMode(LED, OUTPUT);   \n    }\n\n    // the loop routine runs over and over again forever:\n    void loop() {\n      digitalWrite(Electromagnet, HIGH); // turn the Electromagnet on (HIGH is the voltage level)\n      digitalWrite(LED, HIGH);   // turn the LED on (HIGH is the voltage level)\n      delay(1000);               // wait for a second\n      digitalWrite(Electromagnet, LOW);// turn the Electromagnet off by making the voltage LOW\n      digitalWrite(LED, LOW);  // turn the LED off by making the voltage LOW\n      delay(1000);               // wait for a second\n    }\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D4 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_electromagnet.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # The electromagnet can hold a 1KG weight\n\n    # Connect the Grove Electromagnet to digital port D4\n    # SIG,NC,VCC,GND\n    electromagnet = 4\n\n    grovepi.pinMode(electromagnet,\nOUTPUT\n)\n    time.sleep(1)\n\n    while True:\n        try:\n            # Switch on electromagnet\n            grovepi.digitalWrite(electromagnet,1)\n            print \non\n\n            time.sleep(2)\n\n            # Switch off electromagnet\n            grovepi.digitalWrite(electromagnet,0)\n            print \noff\n\n            time.sleep(2)\n\n        except KeyboardInterrupt:\n            grovepi.digitalWrite(electromagnet,0)\n            break\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_electromagnet.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove Electromagnet v1.0 SCH PCB.zip\n\n\nDatasheet ZYE1-P20-15 PDF", 
            "title": "Grove - Electromagnet"
        }, 
        {
            "location": "/Grove-Electromagnet/#features", 
            "text": "Grove shape  1KG peak suction  Low standby current", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Electromagnet/#specifications", 
            "text": "Working Voltage \uff1aDC 5V  Working Current \uff1a 400mA  Standby current \uff1a 200uA  Load Weight\uff1a 1KG", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Electromagnet/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Electromagnet/#with-arduino", 
            "text": "CODE:      /*\n      Turns on an Electromagnet on for one second, then off for one second, repeatedly.\n\n      This example code is in the public domain.\n     */\n\n    int Electromagnet = 0;\n    int LED = 13;\n\n    // the setup routine runs once when you press reset:\n    void setup() {                \n      // initialize the digital pin as an output.\n      pinMode(Electromagnet, OUTPUT); \n      pinMode(LED, OUTPUT);   \n    }\n\n    // the loop routine runs over and over again forever:\n    void loop() {\n      digitalWrite(Electromagnet, HIGH); // turn the Electromagnet on (HIGH is the voltage level)\n      digitalWrite(LED, HIGH);   // turn the LED on (HIGH is the voltage level)\n      delay(1000);               // wait for a second\n      digitalWrite(Electromagnet, LOW);// turn the Electromagnet off by making the voltage LOW\n      digitalWrite(LED, LOW);  // turn the LED off by making the voltage LOW\n      delay(1000);               // wait for a second\n    }", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Electromagnet/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D4 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_electromagnet.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # The electromagnet can hold a 1KG weight\n\n    # Connect the Grove Electromagnet to digital port D4\n    # SIG,NC,VCC,GND\n    electromagnet = 4\n\n    grovepi.pinMode(electromagnet, OUTPUT )\n    time.sleep(1)\n\n    while True:\n        try:\n            # Switch on electromagnet\n            grovepi.digitalWrite(electromagnet,1)\n            print  on \n            time.sleep(2)\n\n            # Switch off electromagnet\n            grovepi.digitalWrite(electromagnet,0)\n            print  off \n            time.sleep(2)\n\n        except KeyboardInterrupt:\n            grovepi.digitalWrite(electromagnet,0)\n            break\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_electromagnet.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Electromagnet/#resources", 
            "text": "Grove Electromagnet v1.0 SCH PCB.zip  Datasheet ZYE1-P20-15 PDF", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Encoder/", 
            "text": "This module is an incremental rotary encoder. It encodes the rotation signal from the axis and output the signal by electronic pulse. The Grove \u2013 Encoder is one of the Grove series and has a standard Grove interface.\nWhen you need to add a rotary knob to your project, for example a volume knob for a speaker, a selection panel or a digital input, this will be your first choice.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nIncremental encoder.\n\n\nGrove Interface.\n\n\n360 degree rotary.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n4.5\n\n\n\n\n5\n\n\n\n\n5.5\n\n\n\n\nV\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n10\n\n\n\n\n20\n\n\n\n\n30\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n20x 20\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nNet Weight\n\n\n\n\n12\n\n\n\n\ng\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nThis Grove-Encoder is very easy to use with the \nEncoder Lib\n designed by seeedstudio. Simply connect this module to the D2 connector of Base Shield and you can start using. The following is a introduction of how to make a \nCircular LED bar\n (the idea came from \nseeedstudio wish\n\uff09.\n\n\n\n\nThis Circular LED bar consists of an Encoder and a \nGrove-CircularLED\n module. Connect the two modules to Base shield as the following picture:\n\n\n\n\n\n\n\n\n\n\nIn the project, the \nTimeOne Lib\n and \nEncoder Lib\n and \nCircularLED Library\n are needed. Download all the librarys and install them to your Arduino IDE.\n\n\n\n\n\n\nRestart the Arduino IDE and open the example by the path: File-\nExamples-\nEncoder-\nEncodeCircuiBar.\n\n\n\n\n\n\n#include \nCircularLED.h\n\n#include \nEncoder.h\n\n#include \nTimerOne.h\n\nCircularLED circularLED;\nunsigned int LED[24];\nint index_LED;\nvoid setup()\n{\n  encoder.Timer_init();\n}\nvoid loop()\n{\n    if (encoder.rotate_flag ==1)\n  {\n    if (encoder.direct==1)\n    {\n      index_LED++;\n      if (index_LED\n23)\n      index_LED=24;\n      SenttocircularBar(index_LED);\n    }\n     else\n     {\n      index_LED--;\n      if(index_LED\n0)\n      index_LED=0;\n      SenttocircularBar(index_LED);\n     }\n    encoder.rotate_flag =0;\n  }\n}\nvoid SenttocircularBar(int index)\n{\n  for (int i=0;i\n24;i++)\n  {\n    if (i\nindex)\n    {\n      LED[i]=0xff;\n    }\n    else\n    LED[i]=0;\n  }\n  circularLED.CircularLEDWrite(LED);\n}\n\n\n\n\n\n\nUpload it to your Arduino/Seeeduino, please refer to \nhere\n to learn how to upload sketches. You can see:\n\n\n\n\n\n\n\n\nNote\n\nIt is able to generate another signal when it is being pressed down. However due to the limitation of the number of Grove signal cables, the module is made without output of this signal.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nEncoder Spec\n\n\nDemo in Arduino forum\n\n\nTimeOne Lib\n\n\nEncoder Lib\n\n\nGrove-Encoder Eagle files", 
            "title": "Grove - Encoder"
        }, 
        {
            "location": "/Grove-Encoder/#features", 
            "text": "Incremental encoder.  Grove Interface.  360 degree rotary.", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Encoder/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n4.5  \n5  \n5.5  \nV    \nCurrent  \n10  \n20  \n30  \nmA    \nDimension  \n20x 20  \nmm    \nNet Weight  \n12  \ng", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Encoder/#getting-started", 
            "text": "This Grove-Encoder is very easy to use with the  Encoder Lib  designed by seeedstudio. Simply connect this module to the D2 connector of Base Shield and you can start using. The following is a introduction of how to make a  Circular LED bar  (the idea came from  seeedstudio wish \uff09.   This Circular LED bar consists of an Encoder and a  Grove-CircularLED  module. Connect the two modules to Base shield as the following picture:      In the project, the  TimeOne Lib  and  Encoder Lib  and  CircularLED Library  are needed. Download all the librarys and install them to your Arduino IDE.    Restart the Arduino IDE and open the example by the path: File- Examples- Encoder- EncodeCircuiBar.    #include  CircularLED.h \n#include  Encoder.h \n#include  TimerOne.h \nCircularLED circularLED;\nunsigned int LED[24];\nint index_LED;\nvoid setup()\n{\n  encoder.Timer_init();\n}\nvoid loop()\n{\n    if (encoder.rotate_flag ==1)\n  {\n    if (encoder.direct==1)\n    {\n      index_LED++;\n      if (index_LED 23)\n      index_LED=24;\n      SenttocircularBar(index_LED);\n    }\n     else\n     {\n      index_LED--;\n      if(index_LED 0)\n      index_LED=0;\n      SenttocircularBar(index_LED);\n     }\n    encoder.rotate_flag =0;\n  }\n}\nvoid SenttocircularBar(int index)\n{\n  for (int i=0;i 24;i++)\n  {\n    if (i index)\n    {\n      LED[i]=0xff;\n    }\n    else\n    LED[i]=0;\n  }\n  circularLED.CircularLEDWrite(LED);\n}   Upload it to your Arduino/Seeeduino, please refer to  here  to learn how to upload sketches. You can see:     Note \nIt is able to generate another signal when it is being pressed down. However due to the limitation of the number of Grove signal cables, the module is made without output of this signal.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Encoder/#resources", 
            "text": "Encoder Spec  Demo in Arduino forum  TimeOne Lib  Encoder Lib  Grove-Encoder Eagle files", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-FM_Receiver/", 
            "text": "Grove - FM Receiver is a wideband FM receiver module, this module is base on SX6119, it offers true single-chip voice FM receiver, which is built-in amplifier, VCO, filter and demodulator. The multifunction button provides greater convenience for users to control.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove interface\n\n\nFM receiver with a tuning range of 64 MHz to 108 MHz covering Eastern Europe (OIRT), Japan, Europe and US bands\n\n\nLower power consumption\n\n\nMultifunction button\n\n\nLED Indicator\n\n\nHeadsets interface\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n\u2460\uff1aHeadsets interface:It can drive 16 ohm or 32 ohm earphone or audio\u3002\n\n\n\n\n\u2461\uff1aMultifunction button \uff1aChange volume and select channel\n\n\n\n\nCenter\uff1aOpen FM/Close FM\uff08Keeping press 1S\uff09\n\n\nUp\uff1avolume add\n\n\nDown\uff1avolume sub\n\n\nLeft\uff1asearching down\n\n\nRight\uff1asearching up\n\n\n\n\n\n\n\n\n\u2462\uff1aGrove Interface\n\n\n\n\n\n\n\u2463\uff1aLED Indicator\n\n\n\n\nFM Close\uff1aLED off\n\n\nFM Open\uff1aLED light\n\n\nFM Searching\uff1aLED flash\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nPart list\uff1a\n\n\n\n\nGrove - USB Power\n\n\nGrove - FM Receiver\n\n\nMini Cable\n\n\nAudio\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - FM Receiver Eagle File\n\n\nSchematic in pdf\n\n\nDatasheet of SX6119", 
            "title": "Grove - FM Receiver"
        }, 
        {
            "location": "/Grove-FM_Receiver/#features", 
            "text": "Grove interface  FM receiver with a tuning range of 64 MHz to 108 MHz covering Eastern Europe (OIRT), Japan, Europe and US bands  Lower power consumption  Multifunction button  LED Indicator  Headsets interface", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-FM_Receiver/#hardware-overview", 
            "text": "\u2460\uff1aHeadsets interface:It can drive 16 ohm or 32 ohm earphone or audio\u3002   \u2461\uff1aMultifunction button \uff1aChange volume and select channel   Center\uff1aOpen FM/Close FM\uff08Keeping press 1S\uff09  Up\uff1avolume add  Down\uff1avolume sub  Left\uff1asearching down  Right\uff1asearching up     \u2462\uff1aGrove Interface    \u2463\uff1aLED Indicator   FM Close\uff1aLED off  FM Open\uff1aLED light  FM Searching\uff1aLED flash", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-FM_Receiver/#usage", 
            "text": "Part list\uff1a   Grove - USB Power  Grove - FM Receiver  Mini Cable  Audio", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-FM_Receiver/#resources", 
            "text": "Grove - FM Receiver Eagle File  Schematic in pdf  Datasheet of SX6119", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Fingerprint_Sensor/", 
            "text": "The Finger Print Sensor is one optical fingerprint sensor which will make fingerprint detection and verification adding super simple.There\ns a high powered DSP chip AS601 that does the image rendering, calculation, feature-finding and searching. You can also enroll new fingers directly - up to 162 finger prints can be stored in the onboard FLASH memory. There\ns a red LED in the lens which will light up during taking photos so that you know its working condition. It is easy to use and by far the best fingerprint sensor you can get.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nSupply voltage: 3.6~6.0 V\n\n\nOperating current(Max)\u00a0: 120 mA\n\n\nFingerprint imaging time: 1.0 S\n\n\nMatch Mode: Compare Mode 1:1\n\n\nSearch Mode: 1:N\n\n\nStorage capacity: 162 templates\n\n\nFalse Acceptance Rate\u00a0: 0.001% (Security level 3)\n\n\nFalse Reject Rate \uff1a1.0% (Security level 3)\n\n\nBaud rate \uff1a9600, 19200, 28800, 38400, 57600bps (default is 57600)\n\n\nInterface\uff1aTTL Serial\n\n\nWork Temperature\uff1a-20 ~ +50 \u2103\n\n\nInterface\n\n\n\n\n\n\n\n\n\n\nPin Number\n\n\nName\n\n\nType\n\n\nFunction Description\n\n\n\n\n\n\n\n\n\n\n1\n\n\nVin\n\n\nin\n\n\nPositive Power Supply Input Terminal(Line color:Red)\n\n\n\n\n\n\n2\n\n\nTD\n\n\nout\n\n\nSerial data output, TTL logic levels(Line color: Yellow)\n\n\n\n\n\n\n3\n\n\nRD\n\n\nin\n\n\nSerial data input, TTL logic levels(Line color: White)\n\n\n\n\n\n\n4\n\n\nGND\n\n\n-\n\n\nSignal ground(Line color: Black)\n\n\n\n\n\n\n\n\nDemonstration\n\uf0c1\n\n\nThe Finger Print Sensor module is typically used in safes - there\ns a high powered DSP chip that does the image rendering, calculation, feature-finding and searching. Connect to any microcontroller or system with TTL serial, and send packets of data to take photos, detect prints, hash and search. You can also enroll new fingers directly - up to 162 finger prints that can be stored in the onboard FLASH memory. There\ns a red LED in the lens which will light up during taking photos so that you know its working condition.\n\n\n\n\nConnect the Sensor to the Digital Port 2 of the \nGrove - Base Shield\n.\n\n\nPlug the Grove - Base Shield into Arduino and connect Arduino to PC by using a USB cable.\n\n\n\n\nWhen you plug in the power, you can see the red LED blink which indicates the sensor is working.\n\n\n\n\n\n\nDownload the \nFinger Print Sensor Library\n and Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n\n\nThe library can enroll and search so its perfect for any project. It can help you get running in under 10 minutes. There are basically two requirements for using the optical fingerprint sensor. First one, you\nll need to enroll fingerprints - that means assigning ID #\ns to each print so you can query them later. Once you\nve enrolled all your prints, you can easily \nsearch\n the sensor, asking it to identify which ID (if any) has currently been photographed.\n\n\n\n\nOpen the enroll code directly by the path: File-\nExample-\nFingerPrint-\nEnroll.\n\n\nUpload the code into Arduino. Please click \nhere\n if you do not know how to upload.\n\n\nStart up Serial Tool and Select the ComNum and BaudRate used by the Arduino.\n\n\nSelect the \nSendNew\n option. Send the ID # you want to use. You can use up to 162 ID numbers. And it will ask you to press the finger to the sensor. At the moment, you should see the red LED blink.\n\n\n\n\n\n\n\n\n\n\nIf your press is OK, you could see the following message. You will then have to repeat the process, to get a second clean print. Use the same finger! On success you will see the message.\n\n\n\n\n\n\n\n\nIf there\ns a problem such as a bad print or image, you\nll have to do it again.\n\n\n\n\n\n\nOnce you have the finger enrolled, it\ns a good idea to do a quick test to make sure it can be found in the database.\n\n\n\n\nOpen the demo code:fingerprint and upload it.\n\n\nWhen prompted, press a different/same finger to the sensor. If it is the same finger, you should get a match with the ID # as show below.\n\n\n\n\n\n\n\n\nIf it is not a finger in the database, This serial port will output nothing.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nFinger Print Sensor Library File\n\n\nFinger Print Sensor Datasheet", 
            "title": "Grove - Fingerprint Sensor"
        }, 
        {
            "location": "/Grove-Fingerprint_Sensor/#specifications", 
            "text": "Supply voltage: 3.6~6.0 V  Operating current(Max)\u00a0: 120 mA  Fingerprint imaging time: 1.0 S  Match Mode: Compare Mode 1:1  Search Mode: 1:N  Storage capacity: 162 templates  False Acceptance Rate\u00a0: 0.001% (Security level 3)  False Reject Rate \uff1a1.0% (Security level 3)  Baud rate \uff1a9600, 19200, 28800, 38400, 57600bps (default is 57600)  Interface\uff1aTTL Serial  Work Temperature\uff1a-20 ~ +50 \u2103  Interface      Pin Number  Name  Type  Function Description      1  Vin  in  Positive Power Supply Input Terminal(Line color:Red)    2  TD  out  Serial data output, TTL logic levels(Line color: Yellow)    3  RD  in  Serial data input, TTL logic levels(Line color: White)    4  GND  -  Signal ground(Line color: Black)", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Fingerprint_Sensor/#demonstration", 
            "text": "The Finger Print Sensor module is typically used in safes - there s a high powered DSP chip that does the image rendering, calculation, feature-finding and searching. Connect to any microcontroller or system with TTL serial, and send packets of data to take photos, detect prints, hash and search. You can also enroll new fingers directly - up to 162 finger prints that can be stored in the onboard FLASH memory. There s a red LED in the lens which will light up during taking photos so that you know its working condition.   Connect the Sensor to the Digital Port 2 of the  Grove - Base Shield .  Plug the Grove - Base Shield into Arduino and connect Arduino to PC by using a USB cable.   When you plug in the power, you can see the red LED blink which indicates the sensor is working.    Download the  Finger Print Sensor Library  and Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.   The library can enroll and search so its perfect for any project. It can help you get running in under 10 minutes. There are basically two requirements for using the optical fingerprint sensor. First one, you ll need to enroll fingerprints - that means assigning ID # s to each print so you can query them later. Once you ve enrolled all your prints, you can easily  search  the sensor, asking it to identify which ID (if any) has currently been photographed.   Open the enroll code directly by the path: File- Example- FingerPrint- Enroll.  Upload the code into Arduino. Please click  here  if you do not know how to upload.  Start up Serial Tool and Select the ComNum and BaudRate used by the Arduino.  Select the  SendNew  option. Send the ID # you want to use. You can use up to 162 ID numbers. And it will ask you to press the finger to the sensor. At the moment, you should see the red LED blink.      If your press is OK, you could see the following message. You will then have to repeat the process, to get a second clean print. Use the same finger! On success you will see the message.     If there s a problem such as a bad print or image, you ll have to do it again.    Once you have the finger enrolled, it s a good idea to do a quick test to make sure it can be found in the database.   Open the demo code:fingerprint and upload it.  When prompted, press a different/same finger to the sensor. If it is the same finger, you should get a match with the ID # as show below.     If it is not a finger in the database, This serial port will output nothing.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Fingerprint_Sensor/#resources", 
            "text": "Finger Print Sensor Library File  Finger Print Sensor Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Flame_Sensor/", 
            "text": "The Grove - Flame Sensor can be used to detect fire source or other light sources of the wavelength in the range of 760nm - 1100 nm. It is based on the YG1006 sensor which is a high speed and high sensitive NPN silicon phototransistor. Due to its black epoxy, the sensor is sensitive to infrared radiation. In fire fighting robot game, the sensor plays a very important role, it can be used as a robot eyes to find the fire source.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove Interface\n\n\nHigh Photo Sensitivity\n\n\nFast Response Time\n\n\nEasy to use\n\n\nSensitivity is adjustable\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n4.75\n\n\n\n\n5.0\n\n\n\n\n5.30\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n/\n\n\n\n\n20\n\n\n\n\n/\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nRange of Spectral Bandwidth\n\n\n\n\n760\n\n\n\n\n940\n\n\n\n\n1100\n\n\n\n\nnm\n\n\n\n\n\n\n\n\nDetection range\n\n\n\n\n0\n\n\n\n\n~\n\n\n\n\n1\n\n\n\n\nm\n\n\n\n\n\n\n\n\nResponse Time\n\n\n\n\n15\n\n\n\n\n\u03bcS\n\n\n\n\n\n\n\n\nOperating Temperature\n\n\n\n\n-25\n\n\n\n\n~\n\n\n\n\n85\n\n\n\n\n\u2103\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nThe module is mainly used to detect the infrared light. It outputs digital signal 0 and 1 through a Comparator output. The output value will be 0\u200b\u200b when infrared light is detected. And the sensitivity is adjustable by the precision potentiometer.\n\n\nLet\ns use it to control. When the output value is 0, the led will light up.\n\n\n1.Connect the module to the D3 of \nGrove - Base Shield\n using the 4-pin grove cable.\n\n\n2.Plug the Grove - Base Shield into Arduino.\n\n\n3.Connect Arduino to PC by using a USB cable.\n\n\n4.Copy and paste code below to a new Arduino sketch. Please click \nhere\n if you do not know how to upload.\n\n\n    /******************************************************************************/\n\n    #define SENSOR 3 //connect SENSOR to digital pin3\n    #define LED 2//connect Grove - LED to pin2\n\n    void setup() \n    {                \n        pinsInit();\n    }\n    void loop() \n    {\n      if(isFlameDetected())\n        turnOnLED();\n      else turnOffLED();\n    }\n    /********************************/\n    void pinsInit()\n    {\n        pinMode(FLAME_SENSOR, INPUT);\n        pinMode(LED,OUTPUT);\n        digitalWrite(LED,LOW);\n    }\n    void turnOnLED()\n    {\n        digitalWrite(LED,HIGH);\n    }\n    void turnOffLED()\n    {\n        digitalWrite(LED,LOW);\n    }\n    boolean isFlameDetected()\n    {\n        if(digitalRead(FLAME_SENSOR))\n            return false;\n        else return true;\n    }\n\n\n\n\n5.The LED will light up when there is infrared light. Please use it to designed your products.\n\n\nReference\n\uf0c1\n\n\nThe sensor can detect the light source whose wavelength is in the range of 760nm - 1100 nm. The picture below shows the spectral sensitivity.\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Flame Sensor Eagle File\n\n\nGithub repository for Grove_Flame_Sensor Library\n\n\nLM293D datasheet", 
            "title": "Grove - Flame Sensor"
        }, 
        {
            "location": "/Grove-Flame_Sensor/#features", 
            "text": "Grove Interface  High Photo Sensitivity  Fast Response Time  Easy to use  Sensitivity is adjustable", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Flame_Sensor/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n4.75  \n5.0  \n5.30  \nVDC    \nCurrent  \n/  \n20  \n/  \nmA    \nRange of Spectral Bandwidth  \n760  \n940  \n1100  \nnm    \nDetection range  \n0  \n~  \n1  \nm    \nResponse Time  \n15  \n\u03bcS    \nOperating Temperature  \n-25  \n~  \n85  \n\u2103", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Flame_Sensor/#usage", 
            "text": "The module is mainly used to detect the infrared light. It outputs digital signal 0 and 1 through a Comparator output. The output value will be 0\u200b\u200b when infrared light is detected. And the sensitivity is adjustable by the precision potentiometer.  Let s use it to control. When the output value is 0, the led will light up.  1.Connect the module to the D3 of  Grove - Base Shield  using the 4-pin grove cable.  2.Plug the Grove - Base Shield into Arduino.  3.Connect Arduino to PC by using a USB cable.  4.Copy and paste code below to a new Arduino sketch. Please click  here  if you do not know how to upload.      /******************************************************************************/\n\n    #define SENSOR 3 //connect SENSOR to digital pin3\n    #define LED 2//connect Grove - LED to pin2\n\n    void setup() \n    {                \n        pinsInit();\n    }\n    void loop() \n    {\n      if(isFlameDetected())\n        turnOnLED();\n      else turnOffLED();\n    }\n    /********************************/\n    void pinsInit()\n    {\n        pinMode(FLAME_SENSOR, INPUT);\n        pinMode(LED,OUTPUT);\n        digitalWrite(LED,LOW);\n    }\n    void turnOnLED()\n    {\n        digitalWrite(LED,HIGH);\n    }\n    void turnOffLED()\n    {\n        digitalWrite(LED,LOW);\n    }\n    boolean isFlameDetected()\n    {\n        if(digitalRead(FLAME_SENSOR))\n            return false;\n        else return true;\n    }  5.The LED will light up when there is infrared light. Please use it to designed your products.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Flame_Sensor/#reference", 
            "text": "The sensor can detect the light source whose wavelength is in the range of 760nm - 1100 nm. The picture below shows the spectral sensitivity.", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-Flame_Sensor/#resources", 
            "text": "Grove - Flame Sensor Eagle File  Github repository for Grove_Flame_Sensor Library  LM293D datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-GSR_Sensor/", 
            "text": "GSR, standing for galvanic skin response, is a method of measuring the electrical conductance of the skin. Strong emotion can cause stimulus to your sympathetic nervous system, resulting more sweat being secreted by the sweat glands. Grove \u2013 GSR allows you to spot such strong emotions by simple attaching two electrodes to two fingers on one hand, an interesting gear to create emotion related projects, like sleep quality monitor.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nInput Voltage: 5V/3.3V\n\n\nSensitivity adjustable via a potentiometer\n\n\nExternal measuring finger cots\n\n\n\n\nDemonstration\n\uf0c1\n\n\nIn the following we are showing you how to use the Grove - GSR.\nConnect Grove - GSR Sensor to the analog port A2 of Grove-Basic Shield and Grove - Buzzer to digital port 3. \n\nCopy and paste the code below to a new Arduino sketch and upload it to Arduino.\n\n\nconst int BUZZER=3;\nconst int GSR=A2;\nint threshold=0;\nint sensorValue;\n\nvoid setup(){\n  long sum=0;\n  Serial.begin(9600);\n  pinMode(BUZZER,OUTPUT);\n  digitalWrite(BUZZER,LOW);\n  delay(1000);\n\n  for(int i=0;i\n500;i++)\n  {\n  sensorValue=analogRead(GSR);\n  sum += sensorValue;\n  delay(5);\n  }\n  threshold = sum/500;\n   Serial.print(\"threshold =\");\n   Serial.println(threshold);\n  }\n\nvoid loop(){\n  int temp;\n  sensorValue=analogRead(GSR);\n  Serial.print(\"sensorValue=\");\n  Serial.println(sensorValue);\n  temp = threshold - sensorValue;\n  if(abs(temp)\n50)\n  {\n    sensorValue=analogRead(GSR);\n    temp = threshold - sensorValue;\n    if(abs(temp)\n50){\n    digitalWrite(BUZZER,HIGH);\n    Serial.println(\"YES!\");\n    delay(3000);\n    digitalWrite(BUZZER,LOW);\n    delay(1000);}\n  }\n  }\n\n\n\nWear the finger sheath and relax, Now open serial monitor, we can see:\n\n\n\n\nThen take a deep breath. The buzzer should buzz now. And an obvious change in the output value should be observed.\nThe below is a graphs which is created in Excel using the data above. X axis represents time. and Y axis GSR data.\n\n\n\n\nReference\n\uf0c1\n\n\nThere are several graphs which are created in excel using GSR data.You can open the \nGSR sensor data.xls\n to see the detail data.\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - GSR Eagle File\n\n\nLM324 datasheet\n\n\nGSR sensor data.xls", 
            "title": "Grove - GSR Sensor"
        }, 
        {
            "location": "/Grove-GSR_Sensor/#specifications", 
            "text": "Input Voltage: 5V/3.3V  Sensitivity adjustable via a potentiometer  External measuring finger cots", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-GSR_Sensor/#demonstration", 
            "text": "In the following we are showing you how to use the Grove - GSR.\nConnect Grove - GSR Sensor to the analog port A2 of Grove-Basic Shield and Grove - Buzzer to digital port 3.  \nCopy and paste the code below to a new Arduino sketch and upload it to Arduino.  const int BUZZER=3;\nconst int GSR=A2;\nint threshold=0;\nint sensorValue;\n\nvoid setup(){\n  long sum=0;\n  Serial.begin(9600);\n  pinMode(BUZZER,OUTPUT);\n  digitalWrite(BUZZER,LOW);\n  delay(1000);\n\n  for(int i=0;i 500;i++)\n  {\n  sensorValue=analogRead(GSR);\n  sum += sensorValue;\n  delay(5);\n  }\n  threshold = sum/500;\n   Serial.print(\"threshold =\");\n   Serial.println(threshold);\n  }\n\nvoid loop(){\n  int temp;\n  sensorValue=analogRead(GSR);\n  Serial.print(\"sensorValue=\");\n  Serial.println(sensorValue);\n  temp = threshold - sensorValue;\n  if(abs(temp) 50)\n  {\n    sensorValue=analogRead(GSR);\n    temp = threshold - sensorValue;\n    if(abs(temp) 50){\n    digitalWrite(BUZZER,HIGH);\n    Serial.println(\"YES!\");\n    delay(3000);\n    digitalWrite(BUZZER,LOW);\n    delay(1000);}\n  }\n  }  Wear the finger sheath and relax, Now open serial monitor, we can see:   Then take a deep breath. The buzzer should buzz now. And an obvious change in the output value should be observed.\nThe below is a graphs which is created in Excel using the data above. X axis represents time. and Y axis GSR data.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-GSR_Sensor/#reference", 
            "text": "There are several graphs which are created in excel using GSR data.You can open the  GSR sensor data.xls  to see the detail data.", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-GSR_Sensor/#resources", 
            "text": "Grove - GSR Eagle File  LM324 datasheet  GSR sensor data.xls", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Gas_Sensor/", 
            "text": "The Grove - Gas Sensor module is useful for gas leakage detecting(in home and industry). It can detect LPG, i-butane, methane, alcohol, Hydrogen, smoke and so on. Measurements can be taken as soon as possible based on its fast response time. Also the sensitivity can be adjusted by the potentiometer.\n\n\nEach Grove - Gas Sensor Kit consists of one gas sensor base and four detectors. You can switch the detector on the base according to specific target gases.\n\n\n\n\nGrove - Gas Sensor(MQ2)\n\uff1aCombustible Gas, Smoke\n\n\nGrove - Gas Sensor(MQ3)\n\uff1aAlcohol Vapor\n\n\nGrove - Gas Sensor(MQ5)\n\uff1aLPG, Natural Gas, Town Gas\n\n\nGrove - Gas Sensor(MQ9)\n\uff1aCarbon Monoxide, Coal Gas, Liquefied Gas\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\nWorking Voltage: 4.9-5.1V\n\n\nHeating consumption: 0.5-800mW\n\n\nLoad resistance: can adjust\n\n\nHeater resistance: 33\u03a9\n\n\nSensing Resistance: 3-30k\u03a9\n\n\nWorking Temperature: -25~70 \u2103\n\n\n\n\nDemonstration\n\uf0c1\n\n\nConnect the module with Grove Shield using A0 like following picture and use the program below to gain the voltage. The higher the concentration of the gas is, the bigger the output voltage of the SIG pin gets. Sensitivity can be regulated by rotating the potentiometer. Please note that the best preheat time of the sensor is about 24 hours. For the detailed information about the sensor, please refer to the datasheet.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nMQ-2 Datasheet\n\n\nMQ-3 Datasheet\n\n\nMQ-5 Datasheet\n\n\nMQ-9 Datasheet\n\n\nDemo code on github", 
            "title": "Grove - Gas Sensor"
        }, 
        {
            "location": "/Grove-Gas_Sensor/#specification", 
            "text": "Working Voltage: 4.9-5.1V  Heating consumption: 0.5-800mW  Load resistance: can adjust  Heater resistance: 33\u03a9  Sensing Resistance: 3-30k\u03a9  Working Temperature: -25~70 \u2103", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-Gas_Sensor/#demonstration", 
            "text": "Connect the module with Grove Shield using A0 like following picture and use the program below to gain the voltage. The higher the concentration of the gas is, the bigger the output voltage of the SIG pin gets. Sensitivity can be regulated by rotating the potentiometer. Please note that the best preheat time of the sensor is about 24 hours. For the detailed information about the sensor, please refer to the datasheet.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Gas_Sensor/#resources", 
            "text": "MQ-2 Datasheet  MQ-3 Datasheet  MQ-5 Datasheet  MQ-9 Datasheet  Demo code on github", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/", 
            "text": "The Grove - Gas Sensor(MQ2) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nH2, LPG, CH4, CO, Alcohol, Smoke or Propane\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer. \n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n800\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n3\n\n\n-\n\n\n30\n\n\nk\u03a9\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-2 sensor, please refer the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\uf0c1\n\n\n\n\nConnect the Grove - Gas Sensor(MQ2) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\uf0c1\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\nsensor_volt = \n);\n  Serial.print(sensor_volt);\n  Serial.println(\nV\n);\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\uf0c1\n\n\nThese examples demonstrate ways to know the approximate concentration of Gas. As per the data-sheet of the MQx sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x \n 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.8; // The ratio of RS/R0 is 9.8 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the graph, we can see that the minimum concentration we can test is 100ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.01% and 1%. However, we can\nt provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\uf0c1\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat\ns LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-2 Datasheet", 
            "title": "Grove - Gas Sensor(MQ2)"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/#features", 
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/#specification", 
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  800  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33  -  \u03a9    Rs  Sensing Resistance  3  -  30  k\u03a9", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/#application-ideas", 
            "text": "Gas leakage detection.  Toys.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/#hardware-overview", 
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-2 sensor, please refer the data-sheet provided in  Resources  section.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/#getting-started", 
            "text": "Connect the Grove - Gas Sensor(MQ2) to A0 port as shown in the picture above.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/#gas-detection-basic-example", 
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print( sensor_volt =  );\n  Serial.print(sensor_volt);\n  Serial.println( V );\n  delay(1000);\n}", 
            "title": "Gas Detection\u00a0: Basic Example"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/#measurement-approximation", 
            "text": "These examples demonstrate ways to know the approximate concentration of Gas. As per the data-sheet of the MQx sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x   100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.8; // The ratio of RS/R0 is 9.8 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the graph, we can see that the minimum concentration we can test is 100ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.01% and 1%. However, we can t provide a formula because the relation between ratio and concentration is nonlinear.", 
            "title": "Measurement\u00a0: Approximation"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ2/#resources", 
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What s LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-2 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/", 
            "text": "The Grove - Gas Sensor(MQ3) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nAlcohol, Benzine, CH4, Hexane, LPG, CO.\n Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nHigh sensitivity to alcohol and small sensitivity to Benzine\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n750\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n1\n\n\n-\n\n\n8\n\n\nM\u03a9\n\n\n\n\n\n\nScope\n\n\nDetecting Concentration\n\n\n0.05\n\n\n-\n\n\n10\n\n\nmg/L\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nAlcohol checker.\n\n\nBreathalyser.\n\n\nToys.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-3 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\uf0c1\n\n\n\n\nConnect the Grove - Gas Sensor(MQ3) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\uf0c1\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\nsensor_volt = \n);\n  Serial.print(sensor_volt);\n  Serial.println(\nV\n);\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\uf0c1\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ3 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in Alcohol\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x \n 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/60.0; // The ratio of RS/R0 is 60 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 0.1mg/L and the maximum is 10mg/L. However, we can\nt provide a formula because the relation between ratio and concentration is nonlinear.But also, we can convert mg/L to ppm, it\ns may convenient for us to watch the value.\n\n\n\n\n\n\nResources\n\uf0c1\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat\ns LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-3 Datasheet", 
            "title": "Grove - Gas Sensor(MQ3)"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/#features", 
            "text": "High sensitivity to alcohol and small sensitivity to Benzine  Stable and long life  Fast response and High sensitivity", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/#specification", 
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  750  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33  -  \u03a9    Rs  Sensing Resistance  1  -  8  M\u03a9    Scope  Detecting Concentration  0.05  -  10  mg/L", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/#application-ideas", 
            "text": "Alcohol checker.  Breathalyser.  Toys.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/#hardware-overview", 
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-3 sensor, please refer to the data-sheet provided in  Resources  section.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/#getting-started", 
            "text": "Connect the Grove - Gas Sensor(MQ3) to A0 port as shown in the picture above.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/#gas-detection-basic-example", 
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print( sensor_volt =  );\n  Serial.print(sensor_volt);\n  Serial.println( V );\n  delay(1000);\n}", 
            "title": "Gas Detection\u00a0: Basic Example"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/#measurement-approximation", 
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ3 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in Alcohol\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x   100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/60.0; // The ratio of RS/R0 is 60 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 0.1mg/L and the maximum is 10mg/L. However, we can t provide a formula because the relation between ratio and concentration is nonlinear.But also, we can convert mg/L to ppm, it s may convenient for us to watch the value.", 
            "title": "Measurement\u00a0: Approximation"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ3/#resources", 
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What s LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-3 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/", 
            "text": "The Grove - Gas Sensor(MQ5) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nH2, LPG, CH4, CO, Alcohol\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n800\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n31\u00b110%\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n10\n\n\n-\n\n\n60\n\n\nk\u03a9\n\n\n\n\n\n\nScope\n\n\nDetecting Concentration\n\n\n200\n\n\n-\n\n\n10000\n\n\nppm\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-5 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\uf0c1\n\n\n\n\nConnect the Grove - Gas Sensor(MQ5) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\uf0c1\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\n\n\nNote\n\nYou need an extra tool to find a certain threshold for various air condition. And then set the threshold in code.\n\n\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\nsensor_volt = \n);\n  Serial.print(sensor_volt);\n  Serial.println(\nV\n);\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\uf0c1\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ5 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x \n 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/6.5; // The ratio of RS/R0 is 6.5 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can\nt provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\uf0c1\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat\ns LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-5 Datasheet", 
            "title": "Grove - Gas Sensor(MQ5)"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/#features", 
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/#specification", 
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  800  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  31\u00b110%  -  \u03a9    Rs  Sensing Resistance  10  -  60  k\u03a9    Scope  Detecting Concentration  200  -  10000  ppm", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/#application-ideas", 
            "text": "Gas leakage detection.  Toys.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/#hardware-overview", 
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-5 sensor, please refer to the data-sheet provided in  Resources  section.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/#getting-started", 
            "text": "Connect the Grove - Gas Sensor(MQ5) to A0 port as shown in the picture above.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/#gas-detection-basic-example", 
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.   Note \nYou need an extra tool to find a certain threshold for various air condition. And then set the threshold in code.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print( sensor_volt =  );\n  Serial.print(sensor_volt);\n  Serial.println( V );\n  delay(1000);\n}", 
            "title": "Gas Detection\u00a0: Basic Example"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/#measurement-approximation", 
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ5 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x   100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/6.5; // The ratio of RS/R0 is 6.5 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can t provide a formula because the relation between ratio and concentration is nonlinear.", 
            "title": "Measurement\u00a0: Approximation"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ5/#resources", 
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What s LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-5 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/", 
            "text": "The Grove - Gas Sensor(MQ9) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nLPG, CO, CH4\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n340\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\u03a9\u00b15%\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n2\n\n\n-\n\n\n20000\n\n\n\u03a9\n\n\n\n\n\n\nCO/CH4/LPG Scope\n\n\nDetecting Concentration\n\n\n200\n\n\n-\n\n\n1000/10000/10000\n\n\nppm\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-9 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\uf0c1\n\n\n\n\nConnect the Grove - Gas Sensor(MQ9) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\uf0c1\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\nsensor_volt = \n);\n  Serial.print(sensor_volt);\n  Serial.println(\nV\n);\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\uf0c1\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ9 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in LPG\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x \n 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.9; // The ratio of RS/R0 is 9.9 in LPG gas from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can\nt provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\uf0c1\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat\ns LEL\n\n\n\n\nSchematic\n\uf0c1\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-9 Datasheet", 
            "title": "Grove - Gas Sensor(MQ9)"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#features", 
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#specification", 
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  340  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33\u03a9\u00b15%  -  \u03a9    Rs  Sensing Resistance  2  -  20000  \u03a9    CO/CH4/LPG Scope  Detecting Concentration  200  -  1000/10000/10000  ppm", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#application-ideas", 
            "text": "Gas leakage detection.  Toys.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#hardware-overview", 
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-9 sensor, please refer to the data-sheet provided in  Resources  section.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#getting-started", 
            "text": "Connect the Grove - Gas Sensor(MQ9) to A0 port as shown in the picture above.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#gas-detection-basic-example", 
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print( sensor_volt =  );\n  Serial.print(sensor_volt);\n  Serial.println( V );\n  delay(1000);\n}", 
            "title": "Gas Detection\u00a0: Basic Example"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#measurement-approximation", 
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ9 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in LPG\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x   100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.9; // The ratio of RS/R0 is 9.9 in LPG gas from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can t provide a formula because the relation between ratio and concentration is nonlinear.", 
            "title": "Measurement\u00a0: Approximation"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#resources", 
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What s LEL", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Gas_Sensor-MQ9/#schematic", 
            "text": "Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-9 Datasheet", 
            "title": "Schematic"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/", 
            "text": "Grove-Gas Sensor (O2) is a kind of sensor to test the oxygen concentration in air, which is based on the principle of the electrochemical cell to the original work. You can know clearly the current oxygen concentration when you output voltage values proportional to the concentration of oxygen and refer to the oxygen concentration linear characteristic graph. It\ns very suitable for detecting oxygen concentration in the environment protection. Grove - Gas Sensor(O2) is an organic reaction module, it can provide a little current while putting it in the air, we don\nt need to provide an external power to it, and output voltage will change as time current changes. \n\n\n\n\nFeature\n\uf0c1\n\n\n\n\nHigh-precision\n\n\nHigh sensitivity\n\n\nWide linearity range\n\n\nStrong anti-interference ability\n\n\nExtraordinary reliability\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nItems\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nMeasurement Range\n\n\n0-25%\n\n\n\n\n\n\nDetect Life\n\n\ntwo years\n\n\n\n\n\n\nSensitivity\n\n\n0.05~0.15 mA(in air)\n\n\n\n\n\n\nTemperature Range\n\n\n-20 oC~50 oC\n\n\n\n\n\n\nPreheat Time\n\n\n20 minutes\n\n\n\n\n\n\n\n\nPlatform Support\n\uf0c1\n\n\n\n\n\n\n\n\nArduino\n\n\nWio\n\n\nBeagleBone\n\n\nRaspberry Pi\n\n\nLinkIt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\nNote\n\n\nThis chapter is based on Win10 and Arduino IDE 1.6.9\n\n\n\n\nThis an easy-to-use module, what you need to do is connect the signal pin (the YELLOW pin of Grove cable) to the ADC input of your controller. If there\ns no internal ADC in your controller, \nGrove - I2C ADC\n is recommend. \n\n\nHere we will show you how this Grove - Gas Sensor(O2) works via a simple demo. First of all, you need to prepare the below stuffs:\n\n\n\n\n\n\n\n\nSeeeduino V4\n\n\nGrove - Gas Sensor(O2)\n\n\nBase Shield\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\n\n\n\n\n\n\nConnection\n\uf0c1\n\n\nThanks to the benefit of Grove series modules, you don\nt need to make soldering or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have only one Grove module. \n\n\n\n\nGrove - Sound Sensor is an analog output module, we connect it to \nA0\n at this demo\n\n\n\n\n\n\nUpload the code to Arduino\n\uf0c1\n\n\nCopy the below code to Arduino IDE.\n\n\n// Grove - Gas Sensor(O2) test code\n// Note:\n// 1. It need about about 5-10 minutes to preheat the sensor\n// 2. modify VRefer if needed\n\nconst float VRefer = 3.3;       // voltage of adc reference\n\nconst int pinAdc   = A5;\n\nvoid setup() \n{\n    // put your setup code here, to run once:\n    Serial.begin(9600);\n    Serial.println(\nGrove - Gas Sensor Test Code...\n);\n}\n\nvoid loop() \n{\n    // put your main code here, to run repeatedly:\n    float Vout =0;\n    Serial.print(\nVout =\n);\n\n    Vout = readO2Vout();\n    Serial.print(Vout);\n    Serial.print(\n V, Concentration of O2 is \n);\n    Serial.println(readConcentration());\n    delay(500);\n}\n\nfloat readO2Vout()\n{\n    long sum = 0;\n    for(int i=0; i\n32; i++)\n    {\n        sum += analogRead(pinAdc);\n    }\n\n    sum \n= 5;\n\n    float MeasuredVout = sum * (VRefer / 1023.0);\n    return MeasuredVout;\n}\n\nfloat readConcentration()\n{\n    // Vout samples are with reference to 3.3V\n    float MeasuredVout = readO2Vout();\n\n    //float Concentration = FmultiMap(MeasuredVout, VoutArray,O2ConArray, 6);\n    //when its output voltage is 2.0V,\n    float Concentration = MeasuredVout * 0.21 / 2.0;\n    float Concentration_Percentage=Concentration*100;\n    return Concentration_Percentage;\n}\n\n\n\n\n\nThen choose the right Board and COM port, and then click on the Upload button, this process take few seconds. \n\n\nGet data\n\uf0c1\n\n\nOpen serial monitor of your Arduino IDE, and you will get the data now. \n\n\n\n\nWarning\n\n\nIt need about 20~30 minutes to preheat the sensor, or you will get a larger value.\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nME2-O2 Datasheet\n\n\nSchematic in Eagle File\n\n\nGithub Repository of this Document\n\n\n\n\nHelp us to make it better\n\uf0c1\n\n\nIt is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:\n\n\n\n\nReplace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.  \n\n\nReview and rewrite documents for hundreds of products to make them more understandable.\n\n\nInspected repair all the URL to make sure it can be linked to the right page.\n\n\n\n\nAlthough we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\nt forget to leave your email address if you need our reply, we will reply to you as soon as we can.\n\n\nBy the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Grove - Gas Sensor(O\u2082)"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#feature", 
            "text": "High-precision  High sensitivity  Wide linearity range  Strong anti-interference ability  Extraordinary reliability", 
            "title": "Feature"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#specification", 
            "text": "Items  Parameter      Measurement Range  0-25%    Detect Life  two years    Sensitivity  0.05~0.15 mA(in air)    Temperature Range  -20 oC~50 oC    Preheat Time  20 minutes", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#platform-support", 
            "text": "Arduino  Wio  BeagleBone  Raspberry Pi  LinkIt", 
            "title": "Platform Support"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#getting-started", 
            "text": "Note  This chapter is based on Win10 and Arduino IDE 1.6.9   This an easy-to-use module, what you need to do is connect the signal pin (the YELLOW pin of Grove cable) to the ADC input of your controller. If there s no internal ADC in your controller,  Grove - I2C ADC  is recommend.   Here we will show you how this Grove - Gas Sensor(O2) works via a simple demo. First of all, you need to prepare the below stuffs:     Seeeduino V4  Grove - Gas Sensor(O2)  Base Shield           Get ONE Now  Get ONE Now  Get ONE Now", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#connection", 
            "text": "Thanks to the benefit of Grove series modules, you don t need to make soldering or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have only one Grove module.    Grove - Sound Sensor is an analog output module, we connect it to  A0  at this demo", 
            "title": "Connection"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#upload-the-code-to-arduino", 
            "text": "Copy the below code to Arduino IDE.  // Grove - Gas Sensor(O2) test code\n// Note:\n// 1. It need about about 5-10 minutes to preheat the sensor\n// 2. modify VRefer if needed\n\nconst float VRefer = 3.3;       // voltage of adc reference\n\nconst int pinAdc   = A5;\n\nvoid setup() \n{\n    // put your setup code here, to run once:\n    Serial.begin(9600);\n    Serial.println( Grove - Gas Sensor Test Code... );\n}\n\nvoid loop() \n{\n    // put your main code here, to run repeatedly:\n    float Vout =0;\n    Serial.print( Vout = );\n\n    Vout = readO2Vout();\n    Serial.print(Vout);\n    Serial.print(  V, Concentration of O2 is  );\n    Serial.println(readConcentration());\n    delay(500);\n}\n\nfloat readO2Vout()\n{\n    long sum = 0;\n    for(int i=0; i 32; i++)\n    {\n        sum += analogRead(pinAdc);\n    }\n\n    sum  = 5;\n\n    float MeasuredVout = sum * (VRefer / 1023.0);\n    return MeasuredVout;\n}\n\nfloat readConcentration()\n{\n    // Vout samples are with reference to 3.3V\n    float MeasuredVout = readO2Vout();\n\n    //float Concentration = FmultiMap(MeasuredVout, VoutArray,O2ConArray, 6);\n    //when its output voltage is 2.0V,\n    float Concentration = MeasuredVout * 0.21 / 2.0;\n    float Concentration_Percentage=Concentration*100;\n    return Concentration_Percentage;\n}  Then choose the right Board and COM port, and then click on the Upload button, this process take few seconds.", 
            "title": "Upload the code to Arduino"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#get-data", 
            "text": "Open serial monitor of your Arduino IDE, and you will get the data now.    Warning  It need about 20~30 minutes to preheat the sensor, or you will get a larger value.", 
            "title": "Get data"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#resources", 
            "text": "ME2-O2 Datasheet  Schematic in Eagle File  Github Repository of this Document", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Gas_Sensor-O2/#help-us-to-make-it-better", 
            "text": "It is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:   Replace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.    Review and rewrite documents for hundreds of products to make them more understandable.  Inspected repair all the URL to make sure it can be linked to the right page.   Although we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don t forget to leave your email address if you need our reply, we will reply to you as soon as we can.  By the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Help us to make it better"
        }, 
        {
            "location": "/Grove-HCHO_Sensor/", 
            "text": "The Grove - HCHO Sensor is a semiconductor VOC gas sensor. Its design is based on WSP2110 whose conductivity changes with the concentration of VOC gas in air. Through the circuit, the conductivity can be converted to output signal that corresponding to the gas concentration. This sensor has a very high sensitivity and stability, it can detect the gas whose concentration is up to 1ppm. It\u2019s suitable for detecting formaldehyde, benzene, toluene and other volatile components. This product can be used to detect harmful gas in the home environment. Therefore, it\u2019s a good assistant for you to improve indoor environment quality of life.\n\n\n\n\n\n\nWarning\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nOperating Voltage: 5.0V \u00b1 0.3V\n\n\nTarget Gases: HCHO, Benzene,Toluene,Alcohol\n\n\nConcentration Range: 1~50 ppm\n\n\nSensor Resistance Value(Rs): 10K\u03a9-100K\u03a9(in 10ppm HCHO)\n\n\nSensitivity: Rs(in air)/Rs(10ppm HCHO)\u22655\n\n\n\n\nGetting Started\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThe Grove - HCHO Sensor can be used to detect VOCs, such as HCHO,toluene, benzene, alcohol. Here we take alcohol for an example to demonstrate how to use this sensor.\n\n\n\n\n// demo of Grove - HCHO Sensor\n\u00a0\nvoid setup()\n{\n    Serial.begin(9600);\n}\n\u00a0\nvoid loop()\n{\n    int sensorValue=analogRead(A0);\n    float Vol=sensorValue*4.95/1023;\n    Serial.print(\nVol = \n);\n    Serial.println(Vol);\n    delay(500);\n}\n\n\n\n\nAfter uploading the code, open the serial monitor to get the voltage(Vol) under normal condition.\n\n\n\n\nNow list out the formula describing the relationship of Vol and R0:\n\n\nR0=(Vc/Vol-1)\u00d7R1 (Vc=4.95V) \u2460\n\n\nThen put a bottle of alcohol near the sensor, and read again the sensor value:\n\n\n\n\nAnd we get the Rs:\n\n\nRs = (Vc/Vol-1)\u00d7R1 (Vc=4.95V) \u2461\n\n\nNow calculate Rs/R0. Here we get 0.285. Then refer to the sensitivity characteristic diagram below and find the alcohol concentration is about 5 ppm.\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket A0 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_hcho_sensor.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # The sensitivity can be adjusted by the onboard potentiometer\n\n    # Connect the Grove HCHO Sensor to analog port A0\n    # SIG,NC,VCC,GND\n    hcho_sensor = 0\n\n    grovepi.pinMode(hcho_sensor,\nINPUT\n)\n\n    # Vcc of the grove interface is normally 5v\n    grove_vcc = 5\n\n    while True:\n        try:\n            # Get sensor value\n            sensor_value = grovepi.analogRead(hcho_sensor)\n\n            # Calculate voltage\n            voltage = (float)(sensor_value * grove_vcc / 1024)\n\n            print \nsensor_value =\n, sensor_value, \n voltage =\n, voltage\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_hcho_sensor.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - HCHO Sensor Eagle File\n\n\nWSP2110 Datasheet (Chinese)\n\n\nWSP2110 Datasheet (English)", 
            "title": "Grove - HCHO Sensor"
        }, 
        {
            "location": "/Grove-HCHO_Sensor/#specifications", 
            "text": "Operating Voltage: 5.0V \u00b1 0.3V  Target Gases: HCHO, Benzene,Toluene,Alcohol  Concentration Range: 1~50 ppm  Sensor Resistance Value(Rs): 10K\u03a9-100K\u03a9(in 10ppm HCHO)  Sensitivity: Rs(in air)/Rs(10ppm HCHO)\u22655", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-HCHO_Sensor/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-HCHO_Sensor/#with-arduino", 
            "text": "The Grove - HCHO Sensor can be used to detect VOCs, such as HCHO,toluene, benzene, alcohol. Here we take alcohol for an example to demonstrate how to use this sensor.   // demo of Grove - HCHO Sensor\n\u00a0\nvoid setup()\n{\n    Serial.begin(9600);\n}\n\u00a0\nvoid loop()\n{\n    int sensorValue=analogRead(A0);\n    float Vol=sensorValue*4.95/1023;\n    Serial.print( Vol =  );\n    Serial.println(Vol);\n    delay(500);\n}  After uploading the code, open the serial monitor to get the voltage(Vol) under normal condition.   Now list out the formula describing the relationship of Vol and R0:  R0=(Vc/Vol-1)\u00d7R1 (Vc=4.95V) \u2460  Then put a bottle of alcohol near the sensor, and read again the sensor value:   And we get the Rs:  Rs = (Vc/Vol-1)\u00d7R1 (Vc=4.95V) \u2461  Now calculate Rs/R0. Here we get 0.285. Then refer to the sensitivity characteristic diagram below and find the alcohol concentration is about 5 ppm.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-HCHO_Sensor/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket A0 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_hcho_sensor.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # The sensitivity can be adjusted by the onboard potentiometer\n\n    # Connect the Grove HCHO Sensor to analog port A0\n    # SIG,NC,VCC,GND\n    hcho_sensor = 0\n\n    grovepi.pinMode(hcho_sensor, INPUT )\n\n    # Vcc of the grove interface is normally 5v\n    grove_vcc = 5\n\n    while True:\n        try:\n            # Get sensor value\n            sensor_value = grovepi.analogRead(hcho_sensor)\n\n            # Calculate voltage\n            voltage = (float)(sensor_value * grove_vcc / 1024)\n\n            print  sensor_value = , sensor_value,   voltage = , voltage\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_hcho_sensor.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-HCHO_Sensor/#resources", 
            "text": "Grove - HCHO Sensor Eagle File  WSP2110 Datasheet (Chinese)  WSP2110 Datasheet (English)", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Hall_Sensor/", 
            "text": "The Hall sensor is based on Hall Effect, which is the production of a voltage difference across an electrical conductor, transverse to an electric current in the conductor and a magnetic field perpendicular to the current. There is a continuous-time switch on this Grove. The output of these devices switches low (turns on) when a magnetic field (south polarity) perpendicular to the Hall sensor exceeds the operate point threshold BOP, and it switches high (turn off) when the magnetic field disappears. The twig can be used to measure RPM.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv0.9b\n\n\nInitial public release\n\n\n3,Oct,2011\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove Compatible Interface\n\n\n400ns transition period for rise and fall.\n\n\nContinuous-time hall effect sensor\n\n\nReverse battery protection\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nSupply Voltage\n\n\n3.8\n\n\n5.0\n\n\n24\n\n\nV\n\n\n\n\n\n\nSupply Current\n\n\n4.1\n\n\n-\n\n\n24\n\n\nmA\n\n\n\n\n\n\nOperating Temperature\n\n\n-40\n\n\n-\n\n\n85\n\n\n\u00baC\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nRPM meter.\n\n\nSimple dc motor.\n\n\n\n\nGetting Started\n\uf0c1\n\n\nThe Hall Sensor is used by utilizing the external interrupts available on the arduino/seeeduino. In this example we are using interrupt 0, found on digital pin 2. For other interrupts, see the \nattachInterrupt()\n.\n\n\n\n\nConnect the Hall Sensor to Digital port 2 of the \nGrove - Base Shield\n using a 4 pin cable and connect Grove-LED to Digital Port 4.\n\n\nThen connect Arduino to PC by using a USB cable.\n\n\nDownload the \nHall Sensor Code\n\n\nOpen one of two code. For example Demo \nMagnetControlLED\n\n\n\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n\n\nWhen a magnet whose south pole is facing up is approaching to the onboard sensor, the LED will be turned on. Otherwise, the LED will be turned off.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-Hall Sensor Eagle File\n\n\nHall Sensor Demo Code\n\n\nA1101 datasheet", 
            "title": "Grove - Hall Sensor"
        }, 
        {
            "location": "/Grove-Hall_Sensor/#version-tracker", 
            "text": "Revision  Descriptions  Release      v0.9b  Initial public release  3,Oct,2011", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Grove-Hall_Sensor/#features", 
            "text": "Grove Compatible Interface  400ns transition period for rise and fall.  Continuous-time hall effect sensor  Reverse battery protection", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Hall_Sensor/#specifications", 
            "text": "Item  Min  Typical  Max  Unit      Supply Voltage  3.8  5.0  24  V    Supply Current  4.1  -  24  mA    Operating Temperature  -40  -  85  \u00baC", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Hall_Sensor/#application-ideas", 
            "text": "RPM meter.  Simple dc motor.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Hall_Sensor/#getting-started", 
            "text": "The Hall Sensor is used by utilizing the external interrupts available on the arduino/seeeduino. In this example we are using interrupt 0, found on digital pin 2. For other interrupts, see the  attachInterrupt() .   Connect the Hall Sensor to Digital port 2 of the  Grove - Base Shield  using a 4 pin cable and connect Grove-LED to Digital Port 4.  Then connect Arduino to PC by using a USB cable.  Download the  Hall Sensor Code  Open one of two code. For example Demo  MagnetControlLED     Upload the code, Please click  here  if you do not know how to upload.  When a magnet whose south pole is facing up is approaching to the onboard sensor, the LED will be turned on. Otherwise, the LED will be turned off.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Hall_Sensor/#resources", 
            "text": "Grove-Hall Sensor Eagle File  Hall Sensor Demo Code  A1101 datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-High_Temperature_Sensor/", 
            "text": "Thermocouples are very sensitive devices. It requires a good amplifier with cold-junction compensation. The Grove - High Temperatire Sensor uses a K-Type themocouple and a thermocouple amplifier that measures ambient temperature using thermistor for cold-junction compensation. The detectable range of this Sensor is -50-600\u00b0C , and the accuracy is \u00b1(2.0% + 2\u00b0C)\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nVoltage\uff1a3.3 ~ 5V\n\n\nMax power rating at 25\u2103 \uff1a300mW\n\n\nOperating temperature range\uff1a-40 ~ +125 \u2103\n\n\nThe temperature measurement range is (-50 ~ +600\u2103)\n\n\nAmplifier output voltage range (0 ~ 3.3 V) mv\n\n\nCold junction compensation (environment temperature measurement)\n\n\nThermocouple temperature measurement accuracy of + / - 2.0% (+ 2 \u2103)\n\n\n\n\nGetting Started\n\uf0c1\n\n\nHere is an example to show you how to read temperature information from the sensor.\n\n\nWe need a Seeeduino V3.0 and a Grove - High Temperature Sensor.\n\n\nHardware Installation\n\uf0c1\n\n\nA4 and A5 are the I2C lines of Seeduino. Plug the sensor to the I2C port of Seeeduino to read data.\n\n\nDownload Code and Upload\n\uf0c1\n\n\nYou can download the library from \nhere\n\n\nThen extract the library to the Library folder of Arduino, open the demo in examples folder.\n\n\nThen upload it to your Seeeduino.\n\n\nOpen Serial Monitor and Get Data\n\uf0c1\n\n\nThen, open your Serial Monitor, you can find the temperature in Celsius here.\n\n\n\n\nK type thermocouple indexing table\n\uf0c1\n\n\nAs a reference, the following is K type thermocouple indexing table.\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - High Temperature Sensor PDF\n\n\nGrove - High Temperature Sensor Eagle File\n\n\nHigh Temperature Sensor Library\n\n\nDatasheet OPA333 PDF\n\n\nDatasheet LMV358 PDF", 
            "title": "Grove - High Temperature Sensor"
        }, 
        {
            "location": "/Grove-High_Temperature_Sensor/#specifications", 
            "text": "Voltage\uff1a3.3 ~ 5V  Max power rating at 25\u2103 \uff1a300mW  Operating temperature range\uff1a-40 ~ +125 \u2103  The temperature measurement range is (-50 ~ +600\u2103)  Amplifier output voltage range (0 ~ 3.3 V) mv  Cold junction compensation (environment temperature measurement)  Thermocouple temperature measurement accuracy of + / - 2.0% (+ 2 \u2103)", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-High_Temperature_Sensor/#getting-started", 
            "text": "Here is an example to show you how to read temperature information from the sensor.  We need a Seeeduino V3.0 and a Grove - High Temperature Sensor.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-High_Temperature_Sensor/#hardware-installation", 
            "text": "A4 and A5 are the I2C lines of Seeduino. Plug the sensor to the I2C port of Seeeduino to read data.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-High_Temperature_Sensor/#download-code-and-upload", 
            "text": "You can download the library from  here  Then extract the library to the Library folder of Arduino, open the demo in examples folder.  Then upload it to your Seeeduino.", 
            "title": "Download Code and Upload"
        }, 
        {
            "location": "/Grove-High_Temperature_Sensor/#open-serial-monitor-and-get-data", 
            "text": "Then, open your Serial Monitor, you can find the temperature in Celsius here.", 
            "title": "Open Serial Monitor and Get Data"
        }, 
        {
            "location": "/Grove-High_Temperature_Sensor/#k-type-thermocouple-indexing-table", 
            "text": "As a reference, the following is K type thermocouple indexing table.", 
            "title": "K type thermocouple indexing table"
        }, 
        {
            "location": "/Grove-High_Temperature_Sensor/#resources", 
            "text": "Grove - High Temperature Sensor PDF  Grove - High Temperature Sensor Eagle File  High Temperature Sensor Library  Datasheet OPA333 PDF  Datasheet LMV358 PDF", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/", 
            "text": "This module is based on the color sensor TCS3414CS with digital output I2C. Based on the 8*2 array of filtered photodiodes and 16-bit analog-to-digital converters, you can measure the color chromaticity of ambient light or the color of objects. Of the 16 photodiodes, 4 have red filters, 4 have green filters, 4 have blue filters and 4 have no filter(clear). With the synchronization input pin, an external pulsed light source can provide precise synchronous conversion control.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible interface\n\n\n16-Bit digital output with I2C\n\n\nSYNC Input Synchronizes Integration Cycle to Modulated Light Sources\n\n\nOperating temperature range -40\u00b0C to 85\u00b0C\n\n\nProgrammable interrupt function with User-Defined Upper and lower threshold settings\n\n\nRoHS Compliant\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue/Range\n\n\n\n\n\n\n\n\n\n\nPCB Size\n\n\n2.0 cm * 4.0 cm\n\n\n\n\n\n\nInterface\n\n\n2.0mm pitch pin header\n\n\n\n\n\n\nVCC\n\n\n3.3 - 6.0 V\n\n\n\n\n\n\nI2C Speed\n\n\n400 kHz\n\n\n\n\n\n\n\n\nPlatforms Supported\n\uf0c1\n\n\nArduino\n\uf0c1\n\n\n\n\nGetting Started\n\uf0c1\n\n\nFollowing documents help in getting the user started with Grove.\n\n\n\n\nPreface - Getting Started\n\n\nto Grove\n\n\n\n\nHardware Connections\n\uf0c1\n\n\nGrove products have an eco system and all have the same connector which can plug onto the \nBase Shield\n. Connect this module to the I2C port of Base Shield. However, you can also connect Grove - I2C Color Sensor to Arduino without Base Shield by jumper wires.\n\n\n\n\n\n\n\n\nArduino UNO\n\n\nGrove - I2C Color Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nSDA\n\n\nSDA\n\n\n\n\n\n\nSCL\n\n\nSCL\n\n\n\n\n\n\n\n\nSoftware Installation\n\uf0c1\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino/Arduino\n\n\nDemos\n\uf0c1\n\n\nThis module can be used to detect the color of light source or the color of objects. When used to detect the color of the light source, the led switch should be turned off, and the light source should shine the sensor directly. When used to detect the color of things, the led should be on and you should put the object on the top of the enclosure closely. The theory of sensing the color of objects is Reflective Sensing Theory. Like the picture below.\n\n\n\n\nColor Sensor Library\n\uf0c1\n\n\nWe have created a library to help you start playing quickly with the Seeeduino/Arduino, in this section we\nll show you how to set up the library.\n\n\nSetup\n\uf0c1\n\n\n\n\nDownload the \nlibrary code as a zip file\n from the Grove_I2C_Color_Sensor github page.\n\n\nUnzip the downloaded file into your \u2026/arduino/libraries.\n\n\nRename the unzipped folder \nColor_Sensor\n\n\nStart the Arduino IDE (or restart if it is open).\n\n\n\n\nDescription of function\n\uf0c1\n\n\nThis is the most important/useful function in the library, we invite you to look at the .h and .cpp files yourself to see all the functions available.\n\n\nRead RGB data through the library function\n\uf0c1\n\n\nreadRGB(int *red, int *green, int *blue)\n\n\n\n\nred:\n The variable address to save R.\n\n\ngreen:\n The variable address to save G.\n\n\nblue:\n The variable address to save B.\n\n\n\n\nvoid loop()\n{\n    int red, green, blue;\n    GroveColorSensor colorSensor;\n    colorSensor.ledStatus = 1;            // When turn on the color sensor LED, ledStatus = 1; When turn off the color sensor LED, ledStatus = 0.\n    while(1)\n    {\n        colorSensor.readRGB(\nred, \ngreen, \nblue);    //Read RGB values to variables.\n        delay(300);\n        Serial.print(\nThe RGB value are: RGB( \n);\n        Serial.print(red,DEC);\n        Serial.print(\n, \n);\n        Serial.print(green,DEC);\n        Serial.print(\n, \n);\n        Serial.print(blue,DEC);\n        Serial.println(\n )\n);\n        colorSensor.clearInterrupt();\n    }\n}\n\n\n\n\nColor Sensor Examples/Applications\n\uf0c1\n\n\nThis example shows how to use features of Grove - I2C Color Sensor and display the detected color with a \nChainable RGB LED Grove\n.\n\n\n\n\nNote\n\nIf you haven't downloaded  \nGrove-Chainable RGB LED library\n to your Arduino IDE before, please download and set up the library first.\n\n\n\n\n\n\nOpen File-\nExamples-\nColor_Sensor-\nexample-\nColorSensorWithRGB-LED sketch for a complete example, or copy and paste code below to a new Arduino sketch.\n\n\n\n\nDescription\n: This example can measure the color chromaticity of ambient light or the color of objects, and via Chainable RGB LED Grove, display the detected color.\n\n\nYou also can use other display modules to display the detected color by Grove - I2C Color Sensor.\n\n\n#include \nWire.h\n\n#include \nGroveColorSensor.h\n\n#include \nChainableLED.h\n\n\u00a0\n#define CLK_PIN   7\n#define DATA_PIN  8\n#define NUM_LEDS  1            //The number of Chainable RGB LED\n\u00a0\nChainableLED leds(CLK_PIN, DATA_PIN, NUM_LEDS);\n\u00a0\nvoid setup()\n{\n    Serial.begin(9600);\n    Wire.begin();\n}\n\u00a0\nvoid loop()\n{\n    int red, green, blue;\n    GroveColorSensor colorSensor;\n    colorSensor.ledStatus = 1;            // When turn on the color sensor LED, ledStatus = 1; When turn off the color sensor LED, ledStatus = 0.\n    while(1)\n    {\n        colorSensor.readRGB(\nred, \ngreen, \nblue);    //Read RGB values to variables.\n        delay(300);\n        Serial.print(\nThe RGB value are: RGB( \n);\n        Serial.print(red,DEC);\n        Serial.print(\n, \n);\n        Serial.print(green,DEC);\n        Serial.print(\n, \n);\n        Serial.print(blue,DEC);\n        Serial.println(\n )\n);\n        colorSensor.clearInterrupt();\n        for(int i = 0; i\nNUM_LEDS; i++)\n        {\n            leds.setColorRGB(i, red, green, blue);\n        }\n    }\n}\n\n\n\n\n\n\nUpload the code to the development board.\n\n\nThen Grove_-_Chainable_RGB_LED would display the color which is detected.\n\n\n\n\nOther Reference\n\uf0c1\n\n\nThis module is based on the color sensor TCS3414CS. The TCS3414CS digital color sensor returns data from four channels: red(R), green(G), blue(B) and clear(C)(non-filtered). The response from the red, green and blue channels (RGB) can be used to determine a particular source\u2019s chromaticity coordinates (x, y). These standards are set by the Commission Internationale de l\u2019Eclairage (CIE). The CIE is the main international organization concerned with color and color measurement.In order to acquire the color of a given object using TCS3414CS, we must first map the sensor response (RGB) to the CIE tristimulus values (XYZ). It is then necessary to calculate the chromaticity coordinates (x, y).\n\n\n\n\nChromaticity Calculation Process Overview\n\n\nThe equations to do the transformation:\n\n\n\n\nTransformation Equations\n\n\n\n\nWhen we get coordinates (x, y), please reference the below figure so as to get the recommended color.\n\n\n\n\n \n\n\nResources\n\uf0c1\n\n\n\n\nLibrary Grove - I2C Color Sensor\n\n\nGrove-I2C Color Sensor Eagle File\n\n\nTCS3414-A Datasheet", 
            "title": "Grove - I2C Color Sensor"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#features", 
            "text": "Grove compatible interface  16-Bit digital output with I2C  SYNC Input Synchronizes Integration Cycle to Modulated Light Sources  Operating temperature range -40\u00b0C to 85\u00b0C  Programmable interrupt function with User-Defined Upper and lower threshold settings  RoHS Compliant", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#specifications", 
            "text": "Parameter  Value/Range      PCB Size  2.0 cm * 4.0 cm    Interface  2.0mm pitch pin header    VCC  3.3 - 6.0 V    I2C Speed  400 kHz", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#platforms-supported", 
            "text": "", 
            "title": "Platforms Supported"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#arduino", 
            "text": "", 
            "title": "Arduino"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#getting-started", 
            "text": "Following documents help in getting the user started with Grove.   Preface - Getting Started  to Grove", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#hardware-connections", 
            "text": "Grove products have an eco system and all have the same connector which can plug onto the  Base Shield . Connect this module to the I2C port of Base Shield. However, you can also connect Grove - I2C Color Sensor to Arduino without Base Shield by jumper wires.     Arduino UNO  Grove - I2C Color Sensor      5V  VCC    GND  GND    SDA  SDA    SCL  SCL", 
            "title": "Hardware Connections"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#software-installation", 
            "text": "Download Arduino and install Arduino driver  Getting Started with Seeeduino/Arduino", 
            "title": "Software Installation"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#demos", 
            "text": "This module can be used to detect the color of light source or the color of objects. When used to detect the color of the light source, the led switch should be turned off, and the light source should shine the sensor directly. When used to detect the color of things, the led should be on and you should put the object on the top of the enclosure closely. The theory of sensing the color of objects is Reflective Sensing Theory. Like the picture below.", 
            "title": "Demos"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#color-sensor-library", 
            "text": "We have created a library to help you start playing quickly with the Seeeduino/Arduino, in this section we ll show you how to set up the library.", 
            "title": "Color Sensor Library"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#setup", 
            "text": "Download the  library code as a zip file  from the Grove_I2C_Color_Sensor github page.  Unzip the downloaded file into your \u2026/arduino/libraries.  Rename the unzipped folder  Color_Sensor  Start the Arduino IDE (or restart if it is open).", 
            "title": "Setup"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#description-of-function", 
            "text": "This is the most important/useful function in the library, we invite you to look at the .h and .cpp files yourself to see all the functions available.", 
            "title": "Description of function"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#read-rgb-data-through-the-library-function", 
            "text": "readRGB(int *red, int *green, int *blue)   red:  The variable address to save R.  green:  The variable address to save G.  blue:  The variable address to save B.   void loop()\n{\n    int red, green, blue;\n    GroveColorSensor colorSensor;\n    colorSensor.ledStatus = 1;            // When turn on the color sensor LED, ledStatus = 1; When turn off the color sensor LED, ledStatus = 0.\n    while(1)\n    {\n        colorSensor.readRGB( red,  green,  blue);    //Read RGB values to variables.\n        delay(300);\n        Serial.print( The RGB value are: RGB(  );\n        Serial.print(red,DEC);\n        Serial.print( ,  );\n        Serial.print(green,DEC);\n        Serial.print( ,  );\n        Serial.print(blue,DEC);\n        Serial.println(  ) );\n        colorSensor.clearInterrupt();\n    }\n}", 
            "title": "Read RGB data through the library function"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#color-sensor-examplesapplications", 
            "text": "This example shows how to use features of Grove - I2C Color Sensor and display the detected color with a  Chainable RGB LED Grove .   Note \nIf you haven't downloaded   Grove-Chainable RGB LED library  to your Arduino IDE before, please download and set up the library first.   Open File- Examples- Color_Sensor- example- ColorSensorWithRGB-LED sketch for a complete example, or copy and paste code below to a new Arduino sketch.   Description : This example can measure the color chromaticity of ambient light or the color of objects, and via Chainable RGB LED Grove, display the detected color.  You also can use other display modules to display the detected color by Grove - I2C Color Sensor.  #include  Wire.h \n#include  GroveColorSensor.h \n#include  ChainableLED.h \n\u00a0\n#define CLK_PIN   7\n#define DATA_PIN  8\n#define NUM_LEDS  1            //The number of Chainable RGB LED\n\u00a0\nChainableLED leds(CLK_PIN, DATA_PIN, NUM_LEDS);\n\u00a0\nvoid setup()\n{\n    Serial.begin(9600);\n    Wire.begin();\n}\n\u00a0\nvoid loop()\n{\n    int red, green, blue;\n    GroveColorSensor colorSensor;\n    colorSensor.ledStatus = 1;            // When turn on the color sensor LED, ledStatus = 1; When turn off the color sensor LED, ledStatus = 0.\n    while(1)\n    {\n        colorSensor.readRGB( red,  green,  blue);    //Read RGB values to variables.\n        delay(300);\n        Serial.print( The RGB value are: RGB(  );\n        Serial.print(red,DEC);\n        Serial.print( ,  );\n        Serial.print(green,DEC);\n        Serial.print( ,  );\n        Serial.print(blue,DEC);\n        Serial.println(  ) );\n        colorSensor.clearInterrupt();\n        for(int i = 0; i NUM_LEDS; i++)\n        {\n            leds.setColorRGB(i, red, green, blue);\n        }\n    }\n}   Upload the code to the development board.  Then Grove_-_Chainable_RGB_LED would display the color which is detected.", 
            "title": "Color Sensor Examples/Applications"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#other-reference", 
            "text": "This module is based on the color sensor TCS3414CS. The TCS3414CS digital color sensor returns data from four channels: red(R), green(G), blue(B) and clear(C)(non-filtered). The response from the red, green and blue channels (RGB) can be used to determine a particular source\u2019s chromaticity coordinates (x, y). These standards are set by the Commission Internationale de l\u2019Eclairage (CIE). The CIE is the main international organization concerned with color and color measurement.In order to acquire the color of a given object using TCS3414CS, we must first map the sensor response (RGB) to the CIE tristimulus values (XYZ). It is then necessary to calculate the chromaticity coordinates (x, y).   Chromaticity Calculation Process Overview  The equations to do the transformation:   Transformation Equations   When we get coordinates (x, y), please reference the below figure so as to get the recommended color.", 
            "title": "Other Reference"
        }, 
        {
            "location": "/Grove-I2C_Color_Sensor/#resources", 
            "text": "Library Grove - I2C Color Sensor  Grove-I2C Color Sensor Eagle File  TCS3414-A Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-I2C_Touch_Sensor/", 
            "text": "The I2C Touch Sensor is based on the Proximity Capacitive Touch Sensor Controller from FreeScale - MPR121. It detects the touch or proximity of human fingers. This sensor includes a Touch Sensor controller and 4 finger feelers. One can insert the connectors of feelers into base of Sensor controller, and start sensing the touch. \n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue/Range\n\n\n\n\n\n\n\n\n\n\nOperating voltage\n\n\n3~5.5V\n\n\n\n\n\n\nStandby Mode Current\n\n\n2\u03bcA\n\n\n\n\n\n\nTouch Channels\n\n\n12 (Including 4 with Touch feelers)\n\n\n\n\n\n\nCommunicating Protocol\n\n\nI2C\n\n\n\n\n\n\nI2C Address\n\n\n0x5A - 0x5D\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nThere are 12 electrodes CH0-CH11. CH0-CH3 are connected to 4 Touch feelers.\n\n\nThe CH4-CH11 are for customer expanding the function. If you need more, you can make the feelers by yourself.\n\n\nThe wires of feelers are twisted to reduce the impact of environment. The black(ground) wire can be cut off if high sensitivity is needed.\n\n\nThe INT pin has to be led out if customers want to use the interrupt pin of MPR121.\n\n\nGetting Started\n\uf0c1\n\n\nGrove - Help\n\uf0c1\n\n\nFollowing documents help in getting the user started with Grove.\n\n\n\n\nPreface - Getting Started\n\n\nto Grove\n\n\n\n\n\n\nNote\n\nSince each electrode needs to be auto-configured by the MPR121 during power up and there is no power reset on the touch sensor controller, everytime you insert or remove a feeler, you need to reset the power of Seeeduino.\n\n\n\n\nThe feelers can also feel the human being fingers with something between, that\ns to say, you do not need to touch the feelers with your fingers indeed.\n\n\n\n\n\n\nWith a paperboard about 3 mm thick, the feeler can feel the touch of fingers, makes it a good solution for many applications.\n\n\nResources\n\uf0c1\n\n\n\n\nI2C Touch Sensor Library\n\n\nI2C Touch Sensor eagle files(v1.1).zip\n\n\nI2C Touch Sensor PDF\n\n\nHow to detect finger touch?\n\n\nI2C Touch Sensor Datasheet", 
            "title": "Grove - I2C Touch Sensor"
        }, 
        {
            "location": "/Grove-I2C_Touch_Sensor/#specifications", 
            "text": "Parameter  Value/Range      Operating voltage  3~5.5V    Standby Mode Current  2\u03bcA    Touch Channels  12 (Including 4 with Touch feelers)    Communicating Protocol  I2C    I2C Address  0x5A - 0x5D", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-I2C_Touch_Sensor/#hardware-overview", 
            "text": "There are 12 electrodes CH0-CH11. CH0-CH3 are connected to 4 Touch feelers.  The CH4-CH11 are for customer expanding the function. If you need more, you can make the feelers by yourself.  The wires of feelers are twisted to reduce the impact of environment. The black(ground) wire can be cut off if high sensitivity is needed.  The INT pin has to be led out if customers want to use the interrupt pin of MPR121.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-I2C_Touch_Sensor/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-I2C_Touch_Sensor/#grove-help", 
            "text": "Following documents help in getting the user started with Grove.   Preface - Getting Started  to Grove    Note \nSince each electrode needs to be auto-configured by the MPR121 during power up and there is no power reset on the touch sensor controller, everytime you insert or remove a feeler, you need to reset the power of Seeeduino.  The feelers can also feel the human being fingers with something between, that s to say, you do not need to touch the feelers with your fingers indeed.    With a paperboard about 3 mm thick, the feeler can feel the touch of fingers, makes it a good solution for many applications.", 
            "title": "Grove - Help"
        }, 
        {
            "location": "/Grove-I2C_Touch_Sensor/#resources", 
            "text": "I2C Touch Sensor Library  I2C Touch Sensor eagle files(v1.1).zip  I2C Touch Sensor PDF  How to detect finger touch?  I2C Touch Sensor Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-IMU_10DOF/", 
            "text": "Grove - IMU 10DOF is a combination of \nGrove - IMU 9DOF\n and \nGrove - Barometer Sensor (BMP180)\n. This module is base on MPU-9250 and BMP180, the MPU-9250 is a 9-axis MotionTracking device that combines a 3-axis gyroscope, 3-axis accelerometer, 3-axis magnetometer and a Digital Motion Processor(DMP), and BMP180 is a high precision, ultra-low power digital pressure sensors for consumer applications. This module is very suitable for the application of smartphones, tablets and wearable devices.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nI2C interface\n\n\nMPU-9250 I2C address selectable\n\n\nLow Power Consumption\n\n\n400kHz Fast Mode I2C for communicating with all registers\n\n\nDigital-output X-, Y-, and Z-Axis angular rate sensors (gyroscopes) with a user-programmable full-scale range of \u00b1250, \u00b1500, \u00b11000, and \u00b12000\u00b0/sec\n\n\nDigital-output 3-Axis accelerometer with a programmable full scale range of \u00b12g, \u00b14g, \u00b18g and \u00b116g\n\n\nDigital-output magnetometer with a full scale range of \u00b14800uT\n\n\nDigital-output barometer with range of 300 ~ 1100hPa(+9000m ~ -500m relating to sea level)\n\n\nDimensions: 25.43mm x 20.35mm\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n1\uff1aMPU-9250 I2C address select Pad, default connected \na\n and \nb\n address is 0x68, if connect \nb\n and \nc\n address is 0x69\n\n\n2\uff1aMPU-9250 interrupt pin, the interrupt should be configured, available interrupt sources are: motion detection, fifo overflow, data ready, i2c master error\n\n\n\n\nUsage\n\uf0c1\n\n\nWe will provide an example here to show you how to use this sensor.\n\n\nHardware Installation\n\uf0c1\n\n\n\n\nSoftware Setup\n\uf0c1\n\n\n\n\nDownload the library from \nhttps://github.com/Seeed-Studio/IMU_10DOF\n.\n\n\nUnzip it into the libraries file of Arduino IDE by the path.\n\n\nOpen the code directly by the path: File -\n Example -\n IMU_10DOF_Test.\n\n\nUpload the code. Note that you should select the correct board type and COM port.\n\n\n\n\nYou can see:\n\n\n\nOrientation of Axes\n\nThe diagram below shows the orientation of the axes of sensitivity and the polarity of rotation.\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - IMU 10DOF v1.0 eagle file\n\n\nGrove - IMU 10DOF v1.0 schematics pdf file\n\n\nGrove - IMU 10DOF v1.1 eagle file\n\n\nGet library from github\n\n\nBMP180 datasheet\n\n\nMPU-9250 datasheet", 
            "title": "Grove - IMU 10DOF"
        }, 
        {
            "location": "/Grove-IMU_10DOF/#specifications", 
            "text": "I2C interface  MPU-9250 I2C address selectable  Low Power Consumption  400kHz Fast Mode I2C for communicating with all registers  Digital-output X-, Y-, and Z-Axis angular rate sensors (gyroscopes) with a user-programmable full-scale range of \u00b1250, \u00b1500, \u00b11000, and \u00b12000\u00b0/sec  Digital-output 3-Axis accelerometer with a programmable full scale range of \u00b12g, \u00b14g, \u00b18g and \u00b116g  Digital-output magnetometer with a full scale range of \u00b14800uT  Digital-output barometer with range of 300 ~ 1100hPa(+9000m ~ -500m relating to sea level)  Dimensions: 25.43mm x 20.35mm", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-IMU_10DOF/#hardware-overview", 
            "text": "1\uff1aMPU-9250 I2C address select Pad, default connected  a  and  b  address is 0x68, if connect  b  and  c  address is 0x69  2\uff1aMPU-9250 interrupt pin, the interrupt should be configured, available interrupt sources are: motion detection, fifo overflow, data ready, i2c master error", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-IMU_10DOF/#usage", 
            "text": "We will provide an example here to show you how to use this sensor.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-IMU_10DOF/#hardware-installation", 
            "text": "", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-IMU_10DOF/#software-setup", 
            "text": "Download the library from  https://github.com/Seeed-Studio/IMU_10DOF .  Unzip it into the libraries file of Arduino IDE by the path.  Open the code directly by the path: File -  Example -  IMU_10DOF_Test.  Upload the code. Note that you should select the correct board type and COM port.   You can see:  Orientation of Axes \nThe diagram below shows the orientation of the axes of sensitivity and the polarity of rotation.", 
            "title": "Software Setup"
        }, 
        {
            "location": "/Grove-IMU_10DOF/#resources", 
            "text": "Grove - IMU 10DOF v1.0 eagle file  Grove - IMU 10DOF v1.0 schematics pdf file  Grove - IMU 10DOF v1.1 eagle file  Get library from github  BMP180 datasheet  MPU-9250 datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-IMU_9DOF_v2.0/", 
            "text": "Grove - IMU 9DOF v2.0 is an upgraded version of \nGrove - IMU 9DOF v1.0\n and it is a high performance 9-axis motion tracking module, which is based on MPU-9250. The MPU-9250 is an integrated 9-axis motion tracking device designed for the low power, low cost, and high performance requirements of consumer electronics equipment including smartphones, tablets and wearable sensors. MPU-9150 features three 16-bit ADC for digitizing the gyroscope outputs and three 16-bit ADCs for digitizing the accelerometer outputs and three 16-bit ADCs for digitizing the magnetometer outputs.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nI2C/SPI interface\n\n\nAuxiliary I2C\n\n\nLow Power Consumption\n\n\n400kHz Fast Mode I2C for communicating with all registers\n\n\nDigital-output 3-Axis angular rate sensors (gyroscopes) with a user-programmable full-scale range of \u00b1250, \u00b1500, \u00b11000, and \u00b12000\u00b0/sec\n\n\nDigital-output 3-Axis accelerometer with a programmable full scale range of \u00b12g, \u00b14g, \u00b18g and \u00b116g\n\n\nDigital-output 3-Axis accelerometer with a full scale measurement range is \u00b14800\u03bcT\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\u2460 - Grove interface,connect to I2C\n\n\n\u2461 - I2C or SPI select pad(default is I2C), if want to use SPI, disconnect this pad\n\n\n\u2462 - Address select pad, default connected b and c address is 0x68, if connect b and a address is 0x69, if want to use SPI, disconnect this pad to either side.\n\n\n\u2463 - SPI Interface\n\n\n\u2464 - Auxiliary I2C master serial data\n\n\n\u2465 - Auxiliary I2C master serial clock\n\n\n\u2466 - Interrupt digital output\n\n\nUsage\n\uf0c1\n\n\nBased on library,we can display value of Accel\nGyro\nMagnet on serial monitor. Now let\ns show how to use the module.\n\n\nHardware Installation\n\uf0c1\n\n\nHardware installation is very easy, because there\ns an I2C Grove in Seeeduino, so what we need to do is connect it to I2C Grove via a Grove cable.\n\n\n\n\nSoftware Part\n\uf0c1\n\n\n\n\nDownload the \nlibrary\n.\n\n\nUnzip libraries into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.\n\n\nUnzip IMU_9D0F_Demo file into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.\n\n\nOpen the code directly by the path: File -\n Example -\n Grove_IMU_9DOF_9250\n\n\nUpload the code. Note that you should select the correct board type and COM port.\n\n\nYou can see\u00a0:\n\n\n\n\n\n\nIn static state\uff0cthe z-Axis output value is about 0.98g\uff0cso you can refer to this to test if your sensor can work normally.\n\n\nOrientation of Axes\n\n\nThe diagram below shows the orientation of the axes of sensitivity and the polarity of rotation.Note the pin 1 identifier (\u2022) in the figure.\n\n\n\n\nOrientation of Axes of Sensitivity and Polarity of Rotation for Accelerometer and Gyroscope\n\n\n\n\nOrientation of Axes of Sensitivity for Compass\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - IMU 9DOF v2.0 Eagle File\n\n\nMPU-9250 datashet\n\n\nMPU-9250 Register Map\n\n\nGrove - IMU 9DOF v2.0 library", 
            "title": "Grove - IMU 9DOF v2.0"
        }, 
        {
            "location": "/Grove-IMU_9DOF_v2.0/#specifications", 
            "text": "I2C/SPI interface  Auxiliary I2C  Low Power Consumption  400kHz Fast Mode I2C for communicating with all registers  Digital-output 3-Axis angular rate sensors (gyroscopes) with a user-programmable full-scale range of \u00b1250, \u00b1500, \u00b11000, and \u00b12000\u00b0/sec  Digital-output 3-Axis accelerometer with a programmable full scale range of \u00b12g, \u00b14g, \u00b18g and \u00b116g  Digital-output 3-Axis accelerometer with a full scale measurement range is \u00b14800\u03bcT", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-IMU_9DOF_v2.0/#hardware-overview", 
            "text": "\u2460 - Grove interface,connect to I2C  \u2461 - I2C or SPI select pad(default is I2C), if want to use SPI, disconnect this pad  \u2462 - Address select pad, default connected b and c address is 0x68, if connect b and a address is 0x69, if want to use SPI, disconnect this pad to either side.  \u2463 - SPI Interface  \u2464 - Auxiliary I2C master serial data  \u2465 - Auxiliary I2C master serial clock  \u2466 - Interrupt digital output", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-IMU_9DOF_v2.0/#usage", 
            "text": "Based on library,we can display value of Accel Gyro Magnet on serial monitor. Now let s show how to use the module.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-IMU_9DOF_v2.0/#hardware-installation", 
            "text": "Hardware installation is very easy, because there s an I2C Grove in Seeeduino, so what we need to do is connect it to I2C Grove via a Grove cable.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-IMU_9DOF_v2.0/#software-part", 
            "text": "Download the  library .  Unzip libraries into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.  Unzip IMU_9D0F_Demo file into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.  Open the code directly by the path: File -  Example -  Grove_IMU_9DOF_9250  Upload the code. Note that you should select the correct board type and COM port.  You can see\u00a0:    In static state\uff0cthe z-Axis output value is about 0.98g\uff0cso you can refer to this to test if your sensor can work normally.  Orientation of Axes  The diagram below shows the orientation of the axes of sensitivity and the polarity of rotation.Note the pin 1 identifier (\u2022) in the figure.   Orientation of Axes of Sensitivity and Polarity of Rotation for Accelerometer and Gyroscope   Orientation of Axes of Sensitivity for Compass", 
            "title": "Software Part"
        }, 
        {
            "location": "/Grove-IMU_9DOF_v2.0/#resources", 
            "text": "Grove - IMU 9DOF v2.0 Eagle File  MPU-9250 datashet  MPU-9250 Register Map  Grove - IMU 9DOF v2.0 library", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/", 
            "text": "Grove - IR Distance Interrupter\n is used to detect any object blocking the path of light. The module consists of an IR LED and a photosensor (phototransistor) pair. The light emitted by the IR LED gets reflected by any object placed in front of the sensor and this reflection is detected by the photosensor(phototransistor). Any white (or lighter) colored surface reflects more than black (or darker) colored surface.\n\n\nWhen the reflected light is detected, it produces \nDigital HIGH\n (or Binary \n1\n) output on the \nSIG\n pin. The on-board LED indicator will also glow. If no reflection is detected or if the object is too far from the sensor, the output on the \nSIG\n pin stays at \nDigital LOW\n (Binary \n0\n). The on-board LED indicator will be off as well. The detectable range of this sensor is 7.5\u201340 cm. The module incorporates a Rail-to-Rail Operational Amplifier to amplify the output of phototransistor. There is a potentiometer which can be used to adjust the gain of the amplifier, that is, sensitivity of detection.\n\n\nWith this sensor, you can build the following (but not limited to) applications: \nline following robots, optical encoders\n and \nobject counting applications\n.\n\n\n\n\n\n\nNote\n\nThis product is mildly sensitive to non-IR radiations also and hence any bright light on photosensor impairs or disturbs IR light detection.\n\n\n\n\n\n\nTip\n\nThe instructions to use this product are same as \nGrove - Infrared Reflective Sensor's\n. You can use this product directly if you have used Grove - Infrared Reflective Sensor.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nProduct version\n\n\nRelease date\n\n\nSupport status\n\n\n\n\n\n\n\n\n\n\nVersions older than v1.2\n\n\nJune 2012\u200e\n\n\nNot supported\n\n\n\n\n\n\nGrove - IR Distance Interrupter v1.2(current version)\n\n\nApril 2016\n\n\nSupported\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible and easy to use\n\n\nHighly sensitive and reliable\n\n\nLonger detectable distance\n\n\nAdjustable sensitivity for various occasions\n\n\nMore durable\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating voltage(V)\n\n\n3.3 or 5 Volts\n\n\n\n\n\n\nOperating current(mA)\n\n\nMaximum: 20 mA\n\n\n\n\n\n\nEffective detectable distance\n\n\n7.5\u201340 cm\n\n\n\n\n\n\nReflective photosensor\n\n\ndatasheet\n\n\n\n\n\n\nOutput operational amplifiers\n\n\ndatasheet\n\n\n\n\n\n\nWeight\n\n\n2.5 g(for the module), 8.5 g(for all single package)\n\n\n\n\n\n\n\n\nPlatforms supported\n\uf0c1\n\n\n\n\n\n\n\n\nSeeeduino/Arduino\n\n\nRaspberry Pi\n\n\nBeagleBone\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform. But, you will need additional Grove Shield like Grove - Base shield v2 board.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nRPR-359F Reflective photosensor\n, Highly sensitive reflective photosensor.\n\n\nLM393 operational amplifier\n, rail-to-rail operational amplifier.\n\n\nLED Indicator\n, The LED will turn on when the received infrared light intensity exceeds a preset level.\n\n\nLight sensitivity adjusting potentiometer\n , adjust the sensitivity of reflective photosensor to light.\n\n\n\n\nPackage includes\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Infrared Reflective Sensor\n\n\n1 piece\n\n\n\n\n\n\nGrove cable\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nLet us see how to implement few basic applications with this module:\n\n\nWith Arduino\n\uf0c1\n\n\nMaterial required\n\uf0c1\n\n\n\n\nGrove - IR Distance Interrupter v1.2 \u00d7 1\n\n\nArduino UNO (other models also are fine) \u00d7 1\n\n\nGrove cable\n \u00d7 1\n\n\nGrove - Base Shield\n \u00d7 1\n\n\n\n\nConnections\n\uf0c1\n\n\n1.Connect Grove - IR Distance Interrupter v1.2 to Arduino UNO with Grove cable.\n\n\n2.Place and hold the Reflective photosensor towards white(or light) colored surface.\n\n\n\n\n3.Adjust the potentiometer with a screwdriver to change the sensitivity of reflective photosensor, until the LED indicator glows. As your rotate clockwise, the reflective photosensor will be more sensitive to light. \n\n\n\n\nNote\n\nUse a proper screw-driver to adjust the tiny potentiometer. Applying heavy pressure or frequent adjustments might damage the wiper of the potentiometer.\n\n\n\n\n\n\n\n\n4.Create an Arduino sketch and copy the below code into it.\n\n\nvoid setup()  {\n  Serial.begin(9600);\n  pinMode(6,INPUT);\n}\nvoid loop()  {\n  while(1)  {\n    delay(500);\n    if(digitalRead(6)==LOW)  {\n      Serial.println(\nSomebody is here.\n);\n    }\n    else  {\n      Serial.println(\nNobody.\n);\n    }\n  }\n}\n\n\n\n\n5.Upload the code. If you do not know how to upload a Arduino sketch, please visit \nhttps://www.arduino.cc/en/Guide/Windows\n for Windows user or \nhttps://www.arduino.cc/en/Guide/MacOSX\n for Mac user. You can see the result as below.\n\n\n6.When the path of light is blocked by some object, you would see \nSomebody is here.\n in Serial Terminal else you will see \nNobody.\n\n\nWith Raspberry Pi\n\uf0c1\n\n\nMaterial required\n\uf0c1\n\n\n\n\nRaspberry Pi (other models also are fine) \u00d7 1\n\n\nGrovePi\n or \nGrovepi+\n \u00d7 1\n\n\nGrove cable\n \u00d7 1\n\n\n\n\nHardware Connections and Software Work\n\uf0c1\n\n\n1.You should have a Raspberry Pi and a GrovePi or GrovePi+. In this demo, we use GrovePi.\n\n\n2.We assume you have built the development environment successful. If not, follow \nthis tutorial\n.\n\n\n3.Connection: \n\n\nPlug Grove - IR Distance Interrupter into port D4 on GrovePi with \nGrove cable\n.\n\n\n4.Navigate to the demos\n directory, run the following command in a terminal.\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\nRun the command in a terminal:\n\n\n    nano grove\\_infrared\\_distance\\_interrupt.py\n\n\n\n\nCopy and save the following code into it.\n\n\nimport time\nimport grovepi\n\u00a0\n# Connect the Grove Infrared Distance Interrupt Sensor to digital port D4\n# SIG,NC,VCC,GND\nsensor = 4\n\u00a0\ngrovepi.pinMode(sensor,\nINPUT\n)\n\u00a0\nwhile True:\n    try:\n        # Sensor returns LOW and onboard LED lights up when the\n        # received infrared light intensity exceeds the calibrated level\n        if grovepi.digitalRead(sensor) == 0:\n            print \nfound something\n\n        else:\n            print \nnothing\n\n\u00a0\n        time.sleep(.5)\n\u00a0\n    except IOError:\n        print \nError\n\n\n\n\n\n5.Run the demo, run following command in terminal.\n\n\n    sudo python grove\\_infrared\\_distance\\_interrupt.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - IR Distance Interrupter v1.2 Eagle file\n\n\nReflective Photosensor Datasheet\n\n\nLM393 Datasheet\n\n\nLMV358 Datasheet\n\n\nInfrared Reflective Sensor Source Files\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - IR Distance Interrupter v1.2"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#version-tracker", 
            "text": "Product version  Release date  Support status      Versions older than v1.2  June 2012\u200e  Not supported    Grove - IR Distance Interrupter v1.2(current version)  April 2016  Supported", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#features", 
            "text": "Grove compatible and easy to use  Highly sensitive and reliable  Longer detectable distance  Adjustable sensitivity for various occasions  More durable", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#specifications", 
            "text": "Parameter  Value      Operating voltage(V)  3.3 or 5 Volts    Operating current(mA)  Maximum: 20 mA    Effective detectable distance  7.5\u201340 cm    Reflective photosensor  datasheet    Output operational amplifiers  datasheet    Weight  2.5 g(for the module), 8.5 g(for all single package)", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#platforms-supported", 
            "text": "Seeeduino/Arduino  Raspberry Pi  BeagleBone  LinkIt ONE              Note \nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform. But, you will need additional Grove Shield like Grove - Base shield v2 board.", 
            "title": "Platforms supported"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#hardware-overview", 
            "text": "RPR-359F Reflective photosensor , Highly sensitive reflective photosensor.  LM393 operational amplifier , rail-to-rail operational amplifier.  LED Indicator , The LED will turn on when the received infrared light intensity exceeds a preset level.  Light sensitivity adjusting potentiometer  , adjust the sensitivity of reflective photosensor to light.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#package-includes", 
            "text": "Parts name  Quantity      Grove - Infrared Reflective Sensor  1 piece    Grove cable  1 piece", 
            "title": "Package includes"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#getting-started", 
            "text": "Let us see how to implement few basic applications with this module:", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#with-arduino", 
            "text": "", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#material-required", 
            "text": "Grove - IR Distance Interrupter v1.2 \u00d7 1  Arduino UNO (other models also are fine) \u00d7 1  Grove cable  \u00d7 1  Grove - Base Shield  \u00d7 1", 
            "title": "Material required"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#connections", 
            "text": "1.Connect Grove - IR Distance Interrupter v1.2 to Arduino UNO with Grove cable.  2.Place and hold the Reflective photosensor towards white(or light) colored surface.   3.Adjust the potentiometer with a screwdriver to change the sensitivity of reflective photosensor, until the LED indicator glows. As your rotate clockwise, the reflective photosensor will be more sensitive to light.    Note \nUse a proper screw-driver to adjust the tiny potentiometer. Applying heavy pressure or frequent adjustments might damage the wiper of the potentiometer.    4.Create an Arduino sketch and copy the below code into it.  void setup()  {\n  Serial.begin(9600);\n  pinMode(6,INPUT);\n}\nvoid loop()  {\n  while(1)  {\n    delay(500);\n    if(digitalRead(6)==LOW)  {\n      Serial.println( Somebody is here. );\n    }\n    else  {\n      Serial.println( Nobody. );\n    }\n  }\n}  5.Upload the code. If you do not know how to upload a Arduino sketch, please visit  https://www.arduino.cc/en/Guide/Windows  for Windows user or  https://www.arduino.cc/en/Guide/MacOSX  for Mac user. You can see the result as below.  6.When the path of light is blocked by some object, you would see  Somebody is here.  in Serial Terminal else you will see  Nobody.", 
            "title": "Connections"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#with-raspberry-pi", 
            "text": "", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#material-required_1", 
            "text": "Raspberry Pi (other models also are fine) \u00d7 1  GrovePi  or  Grovepi+  \u00d7 1  Grove cable  \u00d7 1", 
            "title": "Material required"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#hardware-connections-and-software-work", 
            "text": "1.You should have a Raspberry Pi and a GrovePi or GrovePi+. In this demo, we use GrovePi.  2.We assume you have built the development environment successful. If not, follow  this tutorial .  3.Connection:   Plug Grove - IR Distance Interrupter into port D4 on GrovePi with  Grove cable .  4.Navigate to the demos  directory, run the following command in a terminal.      cd yourpath/GrovePi/Software/Python/  Run the command in a terminal:      nano grove\\_infrared\\_distance\\_interrupt.py  Copy and save the following code into it.  import time\nimport grovepi\n\u00a0\n# Connect the Grove Infrared Distance Interrupt Sensor to digital port D4\n# SIG,NC,VCC,GND\nsensor = 4\n\u00a0\ngrovepi.pinMode(sensor, INPUT )\n\u00a0\nwhile True:\n    try:\n        # Sensor returns LOW and onboard LED lights up when the\n        # received infrared light intensity exceeds the calibrated level\n        if grovepi.digitalRead(sensor) == 0:\n            print  found something \n        else:\n            print  nothing \n\u00a0\n        time.sleep(.5)\n\u00a0\n    except IOError:\n        print  Error   5.Run the demo, run following command in terminal.      sudo python grove\\_infrared\\_distance\\_interrupt.py", 
            "title": "Hardware Connections and Software Work"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#resources", 
            "text": "Grove - IR Distance Interrupter v1.2 Eagle file  Reflective Photosensor Datasheet  LM393 Datasheet  LMV358 Datasheet  Infrared Reflective Sensor Source Files", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-IR_Distance_Interrupter_v1.2/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/", 
            "text": "The Infrared Receiver is used to receive infrared signals and also used for remote control detection. There is an IR detector on the Infrared Receiver which is used to get the infrared light emitted by the Infrared Emitter. The IR detector have a demodulator inside that looks for modulated IR at 38 KHz. The Infrared Receiver can receive signals well within 10 meters. If more than 10 meters , the receiver may not get the signals. We often use the two Groves-the Infrared Receiver and the \nGrove - Infrared Emitter\n to work together.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nVoltage: 3.3-5V\n\n\nDistance: 10m\n\n\n\n\nDemonstration\n\uf0c1\n\n\nWe will use Grove-Infrared Receiver and Grove - Infrared Emitter in this demonstration. The Infrared Receiver will receive the data that the Grove - Infrared Emitter sends.\n\n\n\n\nConnect the Grove - Infrared Emitter to D3.\n\n\nConnect the Grove - Infrared Receiver to D2.\n\n\n\n\nWith Arduino/Seeeduino\n\uf0c1\n\n\nSuggest Reading for Starter\n\uf0c1\n\n\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\n\n\n\n\nGetting Started with Seeeduino/Arduino\n\n\n\n\n\n\nIRSendRev Library\n\uf0c1\n\n\nWe have created a library to help you start playing quickly with the Seeeduino/Arduino, in this section we\nll show you how to set up the library.\n\n\nSetup\n\uf0c1\n\n\n\n\nDownload the [library code as a zip file] (https://github.com/Seeed-Studio/IRSendRev) from the IRSendRev github page.\n\n\nUnzip the downloaded file into your \u2026/arduino/libraries.\n\n\nRename the unzipped folder \nIRSendRev\n\n\nStart the Arduino IDE (or restart if it is open).\n\n\n\n\nInfrared Receiver Examples/Applications\n\uf0c1\n\n\nThese examples are going to show you how to use features of Grove - Infrared Receiver. You can use Infrared Receiver in combination with Grove - Infrared Emitter. Connect the IR receiver pins to D2 for this demo.\n\n\nReceiver\n\uf0c1\n\n\n\n\nOpen File-\nExamples-\nIRSendRev-\nexample-\nrecv sketch for a complete example, or copy and paste code below to a new Arduino sketch.\n\n\n\n\nDescription\n: \nThis example connect the IR receiver pins to D2 for this demo. You can see the remote control\ns infrared data that received through a serial port terminal, then write the received infrared data into send.ino and upload to the board with Infrared Emitter Grove, so you can send the same data with remote control\ns button.\n\n\nApplication\n: \nYou can note the remote control\ns infrared data down through Infrared Receiver, then send the same data through Infrared Emitter in some cases, such as open the fan switch when indoor temperature is greater than 26 degrees.\n\n\n#include \nIRSendRev.h\n\n\u00a0\n#define BIT_LEN         0\n#define BIT_START_H     1\n#define BIT_START_L     2\n#define BIT_DATA_H      3\n#define BIT_DATA_L      4\n#define BIT_DATA_LEN    5\n#define BIT_DATA        6\n\u00a0\nconst int pinRecv = 2;              // ir receiver connect to D2\n\u00a0\nvoid setup()\n{\n    Serial.begin(115200);\n    IR.Init(pinRecv);\n    Serial.println(\ninit over\n);\n}\n\u00a0\nunsigned char dta[20];\n\u00a0\nvoid loop()\n{\n    if(IR.IsDta())                  // get IR data\n    {\n        IR.Recv(dta);               // receive data to dta\n\u00a0\n        Serial.println(\n+------------------------------------------------------+\n);\n        Serial.print(\nLEN = \n);\n        Serial.println(dta[BIT_LEN]);\n        Serial.print(\nSTART_H: \n);\n        Serial.print(dta[BIT_START_H]);\n        Serial.print(\n\\tSTART_L: \n);\n        Serial.println(dta[BIT_START_L]);\n\u00a0\n        Serial.print(\nDATA_H: \n);\n        Serial.print(dta[BIT_DATA_H]);\n        Serial.print(\n\\tDATA_L: \n);\n        Serial.println(dta[BIT_DATA_L]);\n\u00a0\n        Serial.print(\n\\r\\nDATA_LEN = \n);\n        Serial.println(dta[BIT_DATA_LEN]);\n\u00a0\n        Serial.print(\nDATA: \n);\n        for(int i=0; i\ndta[BIT_DATA_LEN]; i++)\n        {\n            Serial.print(\n0x\n);\n            Serial.print(dta[i+BIT_DATA], HEX);\n            Serial.print(\n\\t\n);\n        }\n        Serial.println();\n\u00a0\n        Serial.print(\nDATA: \n);\n        for(int i=0; i\ndta[BIT_DATA_LEN]; i++)\n        {\n            Serial.print(dta[i+BIT_DATA], DEC);\n            Serial.print(\n\\t\n);\n        }\n        Serial.println();\n        Serial.println(\n+------------------------------------------------------+\\r\\n\\r\\n\n);\n    }\n}\n\n\n\n\n\n\nUpload the code to the development board.\n\n\nOpen the serial monitor window and wait for the input.\n\n\nUsing IR remote control sending data\n(This example uses MIDEA Company\ns IR remote control of fans, and press the open/close key.)\n.\n\n\nYou can see the information below.\n\n\n\n\n\n\nEmitter\n\uf0c1\n\n\n\n\nOpen File-\nExamples-\nIRSendRev-\nexample-\nsend sketch for a complete example, or copy and paste code below to a new Arduino sketch.\n\n\n\n\nDescription\n: \nConnect the IR send pins to D3 for this demo. You can see the remote control\ns infrared data that received through Infrared Receiver, such as the example above. Then write the received infrared data into this example and upload to the board with Infrared Emitter Grove, so you can send the same data with remote control\ns button.\n\n\nApplication\n: \nYou can note the remote control\ns infrared data down through Infrared Receiver, then send the same data through Infrared Emitter in some cases, such as open the fan switch when indoor temperature is greater than 26 degrees.\n\n\n\n\nNote\n\nYou must connect the IR send pins to D3 for this demo.\n\n\n\n\n#include \nIRSendRev.h\n\n\u00a0\n#define BIT_LEN         0\n#define BIT_START_H     1\n#define BIT_START_L     2\n#define BIT_DATA_H      3\n#define BIT_DATA_L      4\n#define BIT_DATA_LEN    5\n#define BIT_DATA        6\n\u00a0\nconst int ir_freq = 38;                 // 38k\n\u00a0\nunsigned char dtaSend[20];\n\u00a0\nvoid dtaInit()\n{\n    dtaSend[BIT_LEN]        = 11;          // all data that needs to be sent\n    dtaSend[BIT_START_H]    = 180;         // the logic high duration of \nStart\n\n    dtaSend[BIT_START_L]    = 91;          // the logic low duration of \nStart\n\n    dtaSend[BIT_DATA_H]     = 11;          // the logic \nlong\n duration in the communication\n    dtaSend[BIT_DATA_L]     = 33;          // the logic \nshort\n duration in the communication\n\u00a0\n    dtaSend[BIT_DATA_LEN]   = 6;           // Number of data which will sent. If the number is other, you should increase or reduce dtaSend[BIT_DATA+x].\n\u00a0\n    dtaSend[BIT_DATA+0]     = 128;           // data that will sent\n    dtaSend[BIT_DATA+1]     = 127;\n    dtaSend[BIT_DATA+2]     = 192;\n    dtaSend[BIT_DATA+3]     = 63;\n    dtaSend[BIT_DATA+4]     = 192;\n    dtaSend[BIT_DATA+5]     = 63;\n}\n\u00a0\nvoid setup()\n{\n    dtaInit();\n}\n\u00a0\nvoid loop()\n{\n    IR.Send(dtaSend, 38);\n\u00a0\n    delay(2000);\n}\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Infrared Receiver eagle files\n\n\nIR Send and Receiver Library\n\n\nIR Receive Library for LinkIt ONE\n\n\nTSOP282 Datasheet", 
            "title": "Grove - Infrared Receiver"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#specifications", 
            "text": "Voltage: 3.3-5V  Distance: 10m", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#demonstration", 
            "text": "We will use Grove-Infrared Receiver and Grove - Infrared Emitter in this demonstration. The Infrared Receiver will receive the data that the Grove - Infrared Emitter sends.   Connect the Grove - Infrared Emitter to D3.  Connect the Grove - Infrared Receiver to D2.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#with-arduinoseeeduino", 
            "text": "", 
            "title": "With Arduino/Seeeduino"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#suggest-reading-for-starter", 
            "text": "Download Arduino and install Arduino driver    Getting Started with Seeeduino/Arduino", 
            "title": "Suggest Reading for Starter"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#irsendrev-library", 
            "text": "We have created a library to help you start playing quickly with the Seeeduino/Arduino, in this section we ll show you how to set up the library.", 
            "title": "IRSendRev Library"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#setup", 
            "text": "Download the [library code as a zip file] (https://github.com/Seeed-Studio/IRSendRev) from the IRSendRev github page.  Unzip the downloaded file into your \u2026/arduino/libraries.  Rename the unzipped folder  IRSendRev  Start the Arduino IDE (or restart if it is open).", 
            "title": "Setup"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#infrared-receiver-examplesapplications", 
            "text": "These examples are going to show you how to use features of Grove - Infrared Receiver. You can use Infrared Receiver in combination with Grove - Infrared Emitter. Connect the IR receiver pins to D2 for this demo.", 
            "title": "Infrared Receiver Examples/Applications"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#receiver", 
            "text": "Open File- Examples- IRSendRev- example- recv sketch for a complete example, or copy and paste code below to a new Arduino sketch.   Description : \nThis example connect the IR receiver pins to D2 for this demo. You can see the remote control s infrared data that received through a serial port terminal, then write the received infrared data into send.ino and upload to the board with Infrared Emitter Grove, so you can send the same data with remote control s button.  Application : \nYou can note the remote control s infrared data down through Infrared Receiver, then send the same data through Infrared Emitter in some cases, such as open the fan switch when indoor temperature is greater than 26 degrees.  #include  IRSendRev.h \n\u00a0\n#define BIT_LEN         0\n#define BIT_START_H     1\n#define BIT_START_L     2\n#define BIT_DATA_H      3\n#define BIT_DATA_L      4\n#define BIT_DATA_LEN    5\n#define BIT_DATA        6\n\u00a0\nconst int pinRecv = 2;              // ir receiver connect to D2\n\u00a0\nvoid setup()\n{\n    Serial.begin(115200);\n    IR.Init(pinRecv);\n    Serial.println( init over );\n}\n\u00a0\nunsigned char dta[20];\n\u00a0\nvoid loop()\n{\n    if(IR.IsDta())                  // get IR data\n    {\n        IR.Recv(dta);               // receive data to dta\n\u00a0\n        Serial.println( +------------------------------------------------------+ );\n        Serial.print( LEN =  );\n        Serial.println(dta[BIT_LEN]);\n        Serial.print( START_H:  );\n        Serial.print(dta[BIT_START_H]);\n        Serial.print( \\tSTART_L:  );\n        Serial.println(dta[BIT_START_L]);\n\u00a0\n        Serial.print( DATA_H:  );\n        Serial.print(dta[BIT_DATA_H]);\n        Serial.print( \\tDATA_L:  );\n        Serial.println(dta[BIT_DATA_L]);\n\u00a0\n        Serial.print( \\r\\nDATA_LEN =  );\n        Serial.println(dta[BIT_DATA_LEN]);\n\u00a0\n        Serial.print( DATA:  );\n        for(int i=0; i dta[BIT_DATA_LEN]; i++)\n        {\n            Serial.print( 0x );\n            Serial.print(dta[i+BIT_DATA], HEX);\n            Serial.print( \\t );\n        }\n        Serial.println();\n\u00a0\n        Serial.print( DATA:  );\n        for(int i=0; i dta[BIT_DATA_LEN]; i++)\n        {\n            Serial.print(dta[i+BIT_DATA], DEC);\n            Serial.print( \\t );\n        }\n        Serial.println();\n        Serial.println( +------------------------------------------------------+\\r\\n\\r\\n );\n    }\n}   Upload the code to the development board.  Open the serial monitor window and wait for the input.  Using IR remote control sending data (This example uses MIDEA Company s IR remote control of fans, and press the open/close key.) .  You can see the information below.", 
            "title": "Receiver"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#emitter", 
            "text": "Open File- Examples- IRSendRev- example- send sketch for a complete example, or copy and paste code below to a new Arduino sketch.   Description : \nConnect the IR send pins to D3 for this demo. You can see the remote control s infrared data that received through Infrared Receiver, such as the example above. Then write the received infrared data into this example and upload to the board with Infrared Emitter Grove, so you can send the same data with remote control s button.  Application : \nYou can note the remote control s infrared data down through Infrared Receiver, then send the same data through Infrared Emitter in some cases, such as open the fan switch when indoor temperature is greater than 26 degrees.   Note \nYou must connect the IR send pins to D3 for this demo.  #include  IRSendRev.h \n\u00a0\n#define BIT_LEN         0\n#define BIT_START_H     1\n#define BIT_START_L     2\n#define BIT_DATA_H      3\n#define BIT_DATA_L      4\n#define BIT_DATA_LEN    5\n#define BIT_DATA        6\n\u00a0\nconst int ir_freq = 38;                 // 38k\n\u00a0\nunsigned char dtaSend[20];\n\u00a0\nvoid dtaInit()\n{\n    dtaSend[BIT_LEN]        = 11;          // all data that needs to be sent\n    dtaSend[BIT_START_H]    = 180;         // the logic high duration of  Start \n    dtaSend[BIT_START_L]    = 91;          // the logic low duration of  Start \n    dtaSend[BIT_DATA_H]     = 11;          // the logic  long  duration in the communication\n    dtaSend[BIT_DATA_L]     = 33;          // the logic  short  duration in the communication\n\u00a0\n    dtaSend[BIT_DATA_LEN]   = 6;           // Number of data which will sent. If the number is other, you should increase or reduce dtaSend[BIT_DATA+x].\n\u00a0\n    dtaSend[BIT_DATA+0]     = 128;           // data that will sent\n    dtaSend[BIT_DATA+1]     = 127;\n    dtaSend[BIT_DATA+2]     = 192;\n    dtaSend[BIT_DATA+3]     = 63;\n    dtaSend[BIT_DATA+4]     = 192;\n    dtaSend[BIT_DATA+5]     = 63;\n}\n\u00a0\nvoid setup()\n{\n    dtaInit();\n}\n\u00a0\nvoid loop()\n{\n    IR.Send(dtaSend, 38);\n\u00a0\n    delay(2000);\n}", 
            "title": "Emitter"
        }, 
        {
            "location": "/Grove-Infrared_Receiver/#resources", 
            "text": "Grove - Infrared Receiver eagle files  IR Send and Receiver Library  IR Receive Library for LinkIt ONE  TSOP282 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/", 
            "text": "Grove - Infrared Reflective Sensor\n is used to detect the presence of an object within a specific range. The sensor consists of an IR LED and a photosensor (phototransistor) pair. The light emitted by the IR LED gets reflected by any object placed in front of the sensor and this reflection is detected by the photosensor(phototransistor). Any white (or lighter) colored surface reflects more than black (or darker) colored surface.\n\n\nWhen the reflected light is detected, it produces \nDigital HIGH\n (or Binary \n1\n) output on the \nSIG\n pin. The on-board LED indicator will also glow. If no reflection is detected or if the object is too far from the sensor, the output on the \nSIG\n pin stays at \nDigital LOW\n (Binary \n0\n). The on-board LED indicator will be off as well. The detectable range of this sensor is 4\u201316 mm. The module incorporates a Rail-to-Rail Operational Amplifier to amplify the output of phototransistor. There is a potentiometer which can be used to adjust the gain of the amplifier, that is, sensitivity of detection.\n\n\nWith this sensor, you can build the following (but not limited to) applications: \nline following robots\n, \noptical encoders\n and \nobject counting applications\n.\n\n\n\n\n\n\nCaution\n\nThis product is also mildly sensitive to non-IR radiations and hence any bright light on photosensor impairs or disturbs IR light detection.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nProduct version\n\n\nRelease date\n\n\nSupport status\n\n\n\n\n\n\n\n\n\n\nVersions older than v1.2\n\n\nJune 2012\u200e\n\n\nNot supported\n\n\n\n\n\n\nVersion 1.2(current version)\n\n\nApril 2016\n\n\nSupported\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible and easy to use\n\n\nHighly sensitive and reliable\n\n\nSmall footprint\n\n\nAdjustable sensitivity for different occasions\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating voltage(V)\n\n\n4.5\u20135.5V\n\n\n\n\n\n\nOperating current(mA)\n\n\n14.69\u201315.35 mA\n\n\n\n\n\n\nEffective detectable distance\n\n\n0.5\u20134.5 cm\n\n\n\n\n\n\nResponse time\n\n\n10 \u03bcs\n\n\n\n\n\n\nPhototransistor: Peak sensitivity wavelength\n\n\n800 nm\n\n\n\n\n\n\nIR LED: Peak light emitting wavelength\n\n\n940 nm\n\n\n\n\n\n\nReflective photosensor\n\n\ndatasheet\n\n\n\n\n\n\nOutput operational amplifiers\n\n\ndatasheet\n\n\n\n\n\n\nWeight\n\n\n4 g\n\n\n\n\n\n\n\n\nPlatforms Supported\n\uf0c1\n\n\n\n\n\n\n\n\nArduino\n\n\nRaspberry Pi\n\n\nBeagleBone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-\n\n\nUsing \nGrovePi\n\n\nOnly with \nGrove Base Cape for Beaglebone\n\n\n\n\n\n\n\n\n\n\nNote\n\nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform. But, you will need additional Grove Shield like Grove - Base shield v2 board.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nRPR220 Reflective photosensor\n, Highly sensitive reflective photosensor.\n\n\nLMV358\n, rail-to-rail operational amplifier.\n\n\nLED Indicator\n, The LED will switch on when the received infrared light intensity exceeds a preset level.\n\n\nLight sensitivity adjustment potentiometer\n , adjust the sensitivity of photosensor to light.\n\n\n\n\nPackage includes\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Infrared Reflective Sensor\n\n\n1 piece\n\n\n\n\n\n\nGrove cable\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nLet us see how to implement few basic applications with this module:\n\n\nWith Arduino\n\uf0c1\n\n\nMaterials required\n\uf0c1\n\n\n\n\nGrove - Infrared Reflective Sensor \u00d7 1\n\n\nArduino UNO (other compatible boards) \u00d7 1\n\n\nGrove cable\n \u00d7 1\n\n\nGrove - Base Shield \u00d7 1\n\n\n\n\nLine Following\n\uf0c1\n\n\nThis sensor can be used to help a robotic car follow a black line.\n\n\n1.Adjusting\n\n\nPlace the sensor such that there is 12mm between reflective photosensor and white (or light) colored surface.\n\n\n\n\n2.Adjust the potentiometer with a screwdriver to change the sensitivity of reflective photosensor, until the LED indicator glows. As your rotate clockwise, the reflective photosensor will be more sensitive to light. \n\n\n\n\nNote\n\nUse a proper screw-driver to adjust the tiny potentiometer. Applying heavy pressure or frequent adjustments might damage the wiper of the potentiometer.\n\n\n\n\n\n\n3.By maintaining the vertical distance, move the sensor horizontally above the black line. The indicator LED must go off over the black line. If it is still on, adjust the potentiometer until it is off.\n\n\n\n\n\n\nRotary Speed Detection\n\uf0c1\n\n\nLet us implement simple optical encoder to detect the speed of a motor\n\n\n1.Connect the Infrared Reflective Sensor to the D2 port of Grove - Base Shield like this:\n\n\n\n\n2.Attach a round, white paper plate (with a black line marked on it) to the motor. Place the sensor near this rotatory encoder. Run the motor.\n\n\n\n\n\n\n3.Download the library \nArduino timer1 \nlibrary\n and add it into the libraries file of Arduino IDE. A \nguide\n about how to run our demo code.\n\n\n4.Upload the demo code to your Arduino/Seeeduino.\n\n\nunsigned int counter=0;\nvoid blink()\n{\n  counter++;\n} \nvoid timerIsr()\n{\n  Timer1.detachInterrupt();  //disable the timer1\n  Serial.print(\nThe speed of the motor: \n); \n  Serial.print(counter,DEC);  \n  Serial.println(\nround/s\n); \n  counter=0;  \n  Timer1.attachInterrupt( timerIsr );  //enable the timer1\n}\nvoid setup() \n{\n  Serial.begin(9600);\n  Timer1.initialize(1000000); // set a timer of length 1sec\n  attachInterrupt(0, blink, RISING);  //INT0\n  Timer1.attachInterrupt( timerIsr ); // attach the service routine here\n} \nvoid loop()\n{\n  ;  //do nothing\n}\n\n\n\n\n5.Open the Serial Monitor to read the data.\n\n\n\n\n\n\nWith Raspberry Pi\n\uf0c1\n\n\nMaterial required\n\uf0c1\n\n\n\n\nRaspberry Pi (other models also are fine) \u00d7 1\n\n\nGrovepi\n or \nGrovepi+\n \u00d7 1\n\n\nGrove cable\n \u00d7 1\n\n\n\n\nHardware Connections and Software Work\n\uf0c1\n\n\n1.You should have a Raspberry Pi and a GrovePi or GrovePi+. In this demo, we use GrovePi.\n\n\n2.We assume you have built the development environment successfully. If not, follow \nthis tutorial\n.\n\n\n3.Connection: Plug Grove - Infrared Reflective Sensor into port D4 on GrovePi with \nGrove cable\n.\n\n\n4.Navigate to the demos\n directory, run the following command in a terminal.\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\nRun the command in a terminal.\n\n\n    nano grove\\_infrared\\_reflective\\_sensor.py\n\n\n\n\nCopy and save the following code into it.\n\n\nimport time\nimport grovepi\n\u00a0\n# Connect the Grove Infrared Reflective Sensor to digital port D4\n# SIG,NC,VCC,GND\nsensor = 4\n\u00a0\ngrovepi.pinMode(sensor,\nINPUT\n)\n\u00a0\nwhile True:\n    try:\n        # Sensor returns HIGH on a black surface and LOW on a white surface\n        if grovepi.digitalRead(sensor) == 1:\n            print \nblack surface detected\n\n        else:\n            print \nwhite surface detected\n\n\u00a0\n        time.sleep(.5)\n\u00a0\n    except IOError:\n        print \nError\n\n\n\n\n\n5.To run the demo, execute the following command in terminal:\n\n\n    sudo python grove\\_infrared\\_reflective\\_sensor.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-Infrared Reflective Sensor Eagle Files\n\n\nArduino Timer1 Library\n\n\nRPR220 Datasheet\n\n\nDatasheet\n\n\nSchematic file of version 1.0 for this product\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Infrared Reflective Sensor"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#version-tracker", 
            "text": "Product version  Release date  Support status      Versions older than v1.2  June 2012\u200e  Not supported    Version 1.2(current version)  April 2016  Supported", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#features", 
            "text": "Grove compatible and easy to use  Highly sensitive and reliable  Small footprint  Adjustable sensitivity for different occasions", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#specifications", 
            "text": "Parameter  Value      Operating voltage(V)  4.5\u20135.5V    Operating current(mA)  14.69\u201315.35 mA    Effective detectable distance  0.5\u20134.5 cm    Response time  10 \u03bcs    Phototransistor: Peak sensitivity wavelength  800 nm    IR LED: Peak light emitting wavelength  940 nm    Reflective photosensor  datasheet    Output operational amplifiers  datasheet    Weight  4 g", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#platforms-supported", 
            "text": "Arduino  Raspberry Pi  BeagleBone           -  Using  GrovePi  Only with  Grove Base Cape for Beaglebone      Note \nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform. But, you will need additional Grove Shield like Grove - Base shield v2 board.", 
            "title": "Platforms Supported"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#hardware-overview", 
            "text": "RPR220 Reflective photosensor , Highly sensitive reflective photosensor.  LMV358 , rail-to-rail operational amplifier.  LED Indicator , The LED will switch on when the received infrared light intensity exceeds a preset level.  Light sensitivity adjustment potentiometer  , adjust the sensitivity of photosensor to light.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#package-includes", 
            "text": "Parts name  Quantity      Grove - Infrared Reflective Sensor  1 piece    Grove cable  1 piece", 
            "title": "Package includes"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#getting-started", 
            "text": "Let us see how to implement few basic applications with this module:", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#with-arduino", 
            "text": "", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#materials-required", 
            "text": "Grove - Infrared Reflective Sensor \u00d7 1  Arduino UNO (other compatible boards) \u00d7 1  Grove cable  \u00d7 1  Grove - Base Shield \u00d7 1", 
            "title": "Materials required"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#line-following", 
            "text": "This sensor can be used to help a robotic car follow a black line.  1.Adjusting  Place the sensor such that there is 12mm between reflective photosensor and white (or light) colored surface.   2.Adjust the potentiometer with a screwdriver to change the sensitivity of reflective photosensor, until the LED indicator glows. As your rotate clockwise, the reflective photosensor will be more sensitive to light.    Note \nUse a proper screw-driver to adjust the tiny potentiometer. Applying heavy pressure or frequent adjustments might damage the wiper of the potentiometer.   3.By maintaining the vertical distance, move the sensor horizontally above the black line. The indicator LED must go off over the black line. If it is still on, adjust the potentiometer until it is off.", 
            "title": "Line Following"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#rotary-speed-detection", 
            "text": "Let us implement simple optical encoder to detect the speed of a motor  1.Connect the Infrared Reflective Sensor to the D2 port of Grove - Base Shield like this:   2.Attach a round, white paper plate (with a black line marked on it) to the motor. Place the sensor near this rotatory encoder. Run the motor.    3.Download the library  Arduino timer1  library  and add it into the libraries file of Arduino IDE. A  guide  about how to run our demo code.  4.Upload the demo code to your Arduino/Seeeduino.  unsigned int counter=0;\nvoid blink()\n{\n  counter++;\n} \nvoid timerIsr()\n{\n  Timer1.detachInterrupt();  //disable the timer1\n  Serial.print( The speed of the motor:  ); \n  Serial.print(counter,DEC);  \n  Serial.println( round/s ); \n  counter=0;  \n  Timer1.attachInterrupt( timerIsr );  //enable the timer1\n}\nvoid setup() \n{\n  Serial.begin(9600);\n  Timer1.initialize(1000000); // set a timer of length 1sec\n  attachInterrupt(0, blink, RISING);  //INT0\n  Timer1.attachInterrupt( timerIsr ); // attach the service routine here\n} \nvoid loop()\n{\n  ;  //do nothing\n}  5.Open the Serial Monitor to read the data.", 
            "title": "Rotary Speed Detection"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#with-raspberry-pi", 
            "text": "", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#material-required", 
            "text": "Raspberry Pi (other models also are fine) \u00d7 1  Grovepi  or  Grovepi+  \u00d7 1  Grove cable  \u00d7 1", 
            "title": "Material required"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#hardware-connections-and-software-work", 
            "text": "1.You should have a Raspberry Pi and a GrovePi or GrovePi+. In this demo, we use GrovePi.  2.We assume you have built the development environment successfully. If not, follow  this tutorial .  3.Connection: Plug Grove - Infrared Reflective Sensor into port D4 on GrovePi with  Grove cable .  4.Navigate to the demos  directory, run the following command in a terminal.      cd yourpath/GrovePi/Software/Python/  Run the command in a terminal.      nano grove\\_infrared\\_reflective\\_sensor.py  Copy and save the following code into it.  import time\nimport grovepi\n\u00a0\n# Connect the Grove Infrared Reflective Sensor to digital port D4\n# SIG,NC,VCC,GND\nsensor = 4\n\u00a0\ngrovepi.pinMode(sensor, INPUT )\n\u00a0\nwhile True:\n    try:\n        # Sensor returns HIGH on a black surface and LOW on a white surface\n        if grovepi.digitalRead(sensor) == 1:\n            print  black surface detected \n        else:\n            print  white surface detected \n\u00a0\n        time.sleep(.5)\n\u00a0\n    except IOError:\n        print  Error   5.To run the demo, execute the following command in terminal:      sudo python grove\\_infrared\\_reflective\\_sensor.py", 
            "title": "Hardware Connections and Software Work"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#resources", 
            "text": "Grove-Infrared Reflective Sensor Eagle Files  Arduino Timer1 Library  RPR220 Datasheet  Datasheet  Schematic file of version 1.0 for this product", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Infrared_Reflective_Sensor/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Infrared_Temperature_Sensor/", 
            "text": "The Infrared temperature sensor is a non-contact temperature measure model. It is composed of 116 elements of thermocouple in series on a floating micro-membrane, the black Surface of the sensor is good to absorb the incident thermal infrared radiation, which might trigger a voltage response at output. This sensor outputs an analog voltage (0~1.1V) according to target temperature.\n\n\nOld version: v0.92.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nVoltage: 3-5V\n\n\nMeasuring Current Supply: 160-200 uA\n\n\nMeasuring Range: -10~100\u00b0C\n\n\nHolding Time: 2S\n\n\nOperating Temperature: -10~80 \u00b0C\n\n\nStorage Temperature: -35-80 \u00b0C\n\n\n\n\nDemonstration\n\uf0c1\n\n\nThe following sketch demonstrates a simple application of measure the measure the surrounding temperature around the sensor and the temperature of the target which is in front of the sensor. And print the result on the serial monitor.\n\n\n\n\nConnect this module to Seeeduino using Grove-Base Shield port A0 and A1.\n\n\nDownload the \nDemo Code\n and open it.\n\n\n\n\nBefore measuring temperature, you need simple setting. Following the instruction below before your test and you will gain a accurately result.\n\n\nStep 1: Regulate the sensor voltage\n\n\nAfter uploading the demo program, make the sensor in normal environment more than 5 minutes that make the sensor temperature the same as surrounding temperature. Then open the serial monitor to check the voltage which the sensor output. Ideally, when the ambient temperature is equal to the temperature sensor, the infrared sensor (TP-538U) output is 0V.We should regulate the reference voltage which offset at 0.5V by hardware. As shown below, the sensor voltage is 0.014V, we just need to change the offset_vol value as0.014 which you obtain from the serial monitor in program.\n\n\n \n\n\n\nStep 2: Regulate the sensor detected distance\n\n\nAccording to our experiment, the sensor\ns nominal measure distance is 9CM, but we can\u2019t ensure all sensor have the same character. So if you want to have accurate result, you need to regulate it with Ice and water mixture to measure the 0\u2103, and use boiled water to regulate the 100\u2103. After that, you can obtain the effective distance of the sensor.\n\n\nThe specific method for measuring is fill with ice and water in a dark container which has a flat surface. Waiting for the container drop to 0\u2103, keep the sensor 9CM between object, move the sensor forward or back and check the result, if output is 0\u2103, note down the distance value. The same method to check boiled water. When you gain a pair of value, make a deal with average calculation. You can begin to measure in a rated distance which you just obtained now.\n\n\nNow we can measure the surrounding temperature around the sensor. The sensor is apply in a nominal distance, you can have a try in other distance, but the distance-temperature diagram neither sensor\u2019s manufacturer nor we obtained, you can draw it follow the two instructions above. We reserve variable \ntemperature_range\n in demo code. We assume that the target distance is 3 cm, the coefficient which you measured may be 5 more or less. Wish you have a fun try.\n\n\n\n\nAdvanced application example:\n\n\n\n\n\n\nNote\n\n\n The demo code does not support Atmega168.\n\n\nIn order to gain a accurate measured, the distance(D) and target diament(S) rate D:S must less than 0.5.\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-Infrared Temperature Sensor V0.9 Eagle File\n\n\nGrove-Infrared Temperature Sensor V1.0 Eagle File\n\n\nOTP-538U Datasheet\n\n\nDemo Code\n\n\nInfrared Temperature Demo Code with SerialLCD\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Infrared Temperature Sensor"
        }, 
        {
            "location": "/Grove-Infrared_Temperature_Sensor/#specifications", 
            "text": "Voltage: 3-5V  Measuring Current Supply: 160-200 uA  Measuring Range: -10~100\u00b0C  Holding Time: 2S  Operating Temperature: -10~80 \u00b0C  Storage Temperature: -35-80 \u00b0C", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Infrared_Temperature_Sensor/#demonstration", 
            "text": "The following sketch demonstrates a simple application of measure the measure the surrounding temperature around the sensor and the temperature of the target which is in front of the sensor. And print the result on the serial monitor.   Connect this module to Seeeduino using Grove-Base Shield port A0 and A1.  Download the  Demo Code  and open it.   Before measuring temperature, you need simple setting. Following the instruction below before your test and you will gain a accurately result.  Step 1: Regulate the sensor voltage  After uploading the demo program, make the sensor in normal environment more than 5 minutes that make the sensor temperature the same as surrounding temperature. Then open the serial monitor to check the voltage which the sensor output. Ideally, when the ambient temperature is equal to the temperature sensor, the infrared sensor (TP-538U) output is 0V.We should regulate the reference voltage which offset at 0.5V by hardware. As shown below, the sensor voltage is 0.014V, we just need to change the offset_vol value as0.014 which you obtain from the serial monitor in program.     Step 2: Regulate the sensor detected distance  According to our experiment, the sensor s nominal measure distance is 9CM, but we can\u2019t ensure all sensor have the same character. So if you want to have accurate result, you need to regulate it with Ice and water mixture to measure the 0\u2103, and use boiled water to regulate the 100\u2103. After that, you can obtain the effective distance of the sensor.  The specific method for measuring is fill with ice and water in a dark container which has a flat surface. Waiting for the container drop to 0\u2103, keep the sensor 9CM between object, move the sensor forward or back and check the result, if output is 0\u2103, note down the distance value. The same method to check boiled water. When you gain a pair of value, make a deal with average calculation. You can begin to measure in a rated distance which you just obtained now.  Now we can measure the surrounding temperature around the sensor. The sensor is apply in a nominal distance, you can have a try in other distance, but the distance-temperature diagram neither sensor\u2019s manufacturer nor we obtained, you can draw it follow the two instructions above. We reserve variable  temperature_range  in demo code. We assume that the target distance is 3 cm, the coefficient which you measured may be 5 more or less. Wish you have a fun try.   Advanced application example:    Note   The demo code does not support Atmega168.  In order to gain a accurate measured, the distance(D) and target diament(S) rate D:S must less than 0.5.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Infrared_Temperature_Sensor/#resources", 
            "text": "Grove-Infrared Temperature Sensor V0.9 Eagle File  Grove-Infrared Temperature Sensor V1.0 Eagle File  OTP-538U Datasheet  Demo Code  Infrared Temperature Demo Code with SerialLCD", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Infrared_Temperature_Sensor/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Light_Sensor/", 
            "text": "Grove - Light Sensor\n\uf0c1\n\n\nIntroduction\n\uf0c1\n\n\n\n\nThe Grove - Light sensor a photo-resistor(light dependent resistor) to detect the intensity of light in the environment. The resistance of photo-resistor decreases when the intensity of light increases. A dual OpAmp chip LM358 on board produces voltage corresponding to intensity of light(i.e. based on resistance value). The output signal is analog value, the brighter the light, the larger the value.\n\n\nThis module can be used to build a light controlled switch i.e. switch off lights during day time and switch on lights during night time.\n\n\n\n\nWarning\n\n\nThe light sensor value only reflects the approximated trend of the intensity of light, it DOES NOT represent the exact Lumen.\n\n\n\n\nVersion Track\n\uf0c1\n\n\nThis document applies to the following version of products:\n\n\n\n\n\n\n\n\nVersion\n\n\nReleased Date\n\n\nHow to buy\n\n\n\n\n\n\n\n\n\n\nGrove - Light Sensor 1.0\n\n\nApr28, 2013\n\n\n\n\n\n\n\n\nGrove - Light Sensor(P)\n\n\n2014\n\n\n\n\n\n\n\n\nGrove - Light Sensor(P) V1.1\n\n\nAug, 2016\n\n\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n\n\nAnalog value output\n\n\nHigh reliability and sensibility\n\n\nSmall footprint\n\n\nRecognize wider spectrum\n\n\n\n\nPlatform Support\n\uf0c1\n\n\n\n\n\n\n\n\nArduino\n\n\nWio\n\n\nBeagleBone\n\n\nRaspberry Pi\n\n\nLinkIt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating voltage\n\n\n3~5V\n\n\n\n\n\n\nOperating current\n\n\n0.5~3 mA\n\n\n\n\n\n\nResponse time\n\n\n20-30 milliseconds\n\n\n\n\n\n\nPeak Wavelength\n\n\n540 nm\n\n\n\n\n\n\nWeight\n\n\n4 g\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\nNote\n\n\nThis part is besed on Grove - Light Sensor(P) V1.0.\n\n\n\n\nHere we will show you how this Grove - Light Sensor works via a simple demo. First of all, you need to prepare the below stuffs:\n\n\n\n\n\n\n\n\nSeeeduino V4\n\n\nGrove - Light Sensor\n\n\nGrove - LED Bar\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBase Shield\n\n\nmicro USB cable\n\n\nGrove cable\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\n\n\n\n\n\n\nConnection\n\uf0c1\n\n\nThanks to the benefit of Grove series module, you don\nt need to make soldering or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have 2 Grove modules.\n\n\n\n\nGrove - Light Sensor is an analog output module, we connect it to \nA0\n at this demo\n\n\nGrove - LED Bar is a digital input module with a 2-wire bus, we connect it to \nD2\n\n\n\n\n\n\nDownload sketch\n\uf0c1\n\n\nThere\ns a sketchbook for Seeeduino Stalker V3.1, which is consist of:\n\n\n\n\nExample of read raw value of the sensor\n\n\nExample of this getting started\n\n\nExample of the secret box demo\n\n\nLED Bar library\n\n\n\n\n\n\nDownload the sketch and put it at anywhere, open Arduino IDE, \nFile \n Reference\n, and copy the location path to \nSketchbook location\n, then click on OK. Reopen Arduino IDE, then the sketchbook is set.\n\n\nUpload the code to Arduino\n\uf0c1\n\n\nOpen Arduino IDE, \nFile \n Sketchbook \n GettingStarted\n to open the code for this part.\n\n\nThen choose the right Board and COM port, and then click on the Upload button, this process will take seconds. Then let\ns try to cover the light sensor with your hand, you will find LED Bar reduce its led.\n\n\nGet Raw Data\n\uf0c1\n\n\nIf you don\nt need a Grove - LED Bar, there\ns another example you can try, Open Arduino IDE, \nFile \n Sketchbook \n RawData\n to open the code, after uploaded the example to Seeeduino V4, click on \nSerial \n Plotter\n to get the changing curve of the sensor.\n\n\n\n\nProject: Secret Box\n\uf0c1\n\n\nHere we will show you a project made with Grove - Light Sensor - Secret Box. First you need a box, a paper box, wooden box, any box is ok. Put something in the box, because we named it secret box, that means we don\nt want anybody to open it, otherwise there will be an alarm to inform you.\n\n\nHere we use LinkIt ONE as the controller, which is an Arduino compatible board and consist of rich function. And you need things below:\n\n\n\n\nLinkIt ONE\n\n\nGrove - Light Sensor\n\n\nGrove - Base Shield\n\n\nA Sim Card\n\n\n\n\nLet\ns connect Grove - Light Sensor to A0 or Base Shield, and open Arduino IDE, \nFile \n Sketchbook \n SecretBox\n, what you need to do is upload the example to LinkIt ONE. Then someone open the box, the light will detect it, and send you a SMS.\n\n\nHave fun.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSketchbook for Light Sensor\n\n\nEagle File for Grove - Light Sensor V1.0\n\n\nEagle File for Grove - Light Sensor(P) V1.0\n\n\nEagle File for Grove - Light Sensor(P) V1.1\n\n\n\n\n=======\nHelp us to make it better\n\n\n\n\nThank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.\n\n\nIt is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:\n\n\n\n\nReplace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.\n\n\nReview and rewrite documents for hundreds of products to make them more understandable.\n\n\nInspected repair all the URL to make sure it can be linked to the right page.\n\n\n\n\nAlthough we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.\n\n\nBy the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Grove - Light Sensor"
        }, 
        {
            "location": "/Grove-Light_Sensor/#grove-light-sensor", 
            "text": "", 
            "title": "Grove - Light Sensor"
        }, 
        {
            "location": "/Grove-Light_Sensor/#introduction", 
            "text": "The Grove - Light sensor a photo-resistor(light dependent resistor) to detect the intensity of light in the environment. The resistance of photo-resistor decreases when the intensity of light increases. A dual OpAmp chip LM358 on board produces voltage corresponding to intensity of light(i.e. based on resistance value). The output signal is analog value, the brighter the light, the larger the value.  This module can be used to build a light controlled switch i.e. switch off lights during day time and switch on lights during night time.   Warning  The light sensor value only reflects the approximated trend of the intensity of light, it DOES NOT represent the exact Lumen.", 
            "title": "Introduction"
        }, 
        {
            "location": "/Grove-Light_Sensor/#version-track", 
            "text": "This document applies to the following version of products:     Version  Released Date  How to buy      Grove - Light Sensor 1.0  Apr28, 2013     Grove - Light Sensor(P)  2014     Grove - Light Sensor(P) V1.1  Aug, 2016", 
            "title": "Version Track"
        }, 
        {
            "location": "/Grove-Light_Sensor/#features", 
            "text": "Analog value output  High reliability and sensibility  Small footprint  Recognize wider spectrum", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Light_Sensor/#platform-support", 
            "text": "Arduino  Wio  BeagleBone  Raspberry Pi  LinkIt", 
            "title": "Platform Support"
        }, 
        {
            "location": "/Grove-Light_Sensor/#specification", 
            "text": "Item  Value      Operating voltage  3~5V    Operating current  0.5~3 mA    Response time  20-30 milliseconds    Peak Wavelength  540 nm    Weight  4 g", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-Light_Sensor/#getting-started", 
            "text": "Note  This part is besed on Grove - Light Sensor(P) V1.0.   Here we will show you how this Grove - Light Sensor works via a simple demo. First of all, you need to prepare the below stuffs:     Seeeduino V4  Grove - Light Sensor  Grove - LED Bar           Get ONE Now  Get ONE Now  Get ONE Now        Base Shield  micro USB cable  Grove cable           Get ONE Now  Get ONE Now  Get ONE Now", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Light_Sensor/#connection", 
            "text": "Thanks to the benefit of Grove series module, you don t need to make soldering or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have 2 Grove modules.   Grove - Light Sensor is an analog output module, we connect it to  A0  at this demo  Grove - LED Bar is a digital input module with a 2-wire bus, we connect it to  D2", 
            "title": "Connection"
        }, 
        {
            "location": "/Grove-Light_Sensor/#download-sketch", 
            "text": "There s a sketchbook for Seeeduino Stalker V3.1, which is consist of:   Example of read raw value of the sensor  Example of this getting started  Example of the secret box demo  LED Bar library    Download the sketch and put it at anywhere, open Arduino IDE,  File   Reference , and copy the location path to  Sketchbook location , then click on OK. Reopen Arduino IDE, then the sketchbook is set.", 
            "title": "Download sketch"
        }, 
        {
            "location": "/Grove-Light_Sensor/#upload-the-code-to-arduino", 
            "text": "Open Arduino IDE,  File   Sketchbook   GettingStarted  to open the code for this part.  Then choose the right Board and COM port, and then click on the Upload button, this process will take seconds. Then let s try to cover the light sensor with your hand, you will find LED Bar reduce its led.", 
            "title": "Upload the code to Arduino"
        }, 
        {
            "location": "/Grove-Light_Sensor/#get-raw-data", 
            "text": "If you don t need a Grove - LED Bar, there s another example you can try, Open Arduino IDE,  File   Sketchbook   RawData  to open the code, after uploaded the example to Seeeduino V4, click on  Serial   Plotter  to get the changing curve of the sensor.", 
            "title": "Get Raw Data"
        }, 
        {
            "location": "/Grove-Light_Sensor/#project-secret-box", 
            "text": "Here we will show you a project made with Grove - Light Sensor - Secret Box. First you need a box, a paper box, wooden box, any box is ok. Put something in the box, because we named it secret box, that means we don t want anybody to open it, otherwise there will be an alarm to inform you.  Here we use LinkIt ONE as the controller, which is an Arduino compatible board and consist of rich function. And you need things below:   LinkIt ONE  Grove - Light Sensor  Grove - Base Shield  A Sim Card   Let s connect Grove - Light Sensor to A0 or Base Shield, and open Arduino IDE,  File   Sketchbook   SecretBox , what you need to do is upload the example to LinkIt ONE. Then someone open the box, the light will detect it, and send you a SMS.  Have fun.", 
            "title": "Project: Secret Box"
        }, 
        {
            "location": "/Grove-Light_Sensor/#resources", 
            "text": "Sketchbook for Light Sensor  Eagle File for Grove - Light Sensor V1.0  Eagle File for Grove - Light Sensor(P) V1.0  Eagle File for Grove - Light Sensor(P) V1.1   =======\nHelp us to make it better   Thank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.  It is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:   Replace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.  Review and rewrite documents for hundreds of products to make them more understandable.  Inspected repair all the URL to make sure it can be linked to the right page.   Although we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.  By the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Loudness_Sensor/", 
            "text": "The Grove - Loudness Sensor is designed to detect the loudness of environmental sound. Based on amplifier LM2904 and a built-in microphone, it amplifies and filters the high frequency signal that received from the microphone, and outputs a positive envelop. This will make for Arduino\u2019s signal acquisition. The output value depends on the level of sound input. In order to avoid unnecessary signal disturbances, input signal will go through two times\u2019 filtering inside the module. Lastly, there is a screw potentiometer that enables manual adjustments to the output gain.\n\n\nPrevious Version: v0.9b\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nVoltage \uff1a3.5~10 VDC\n\n\nWorking Frequency \uff1a50~2000 Hz\n\n\nSensitivity\u00a0: -48~66 dB\n\n\nSignal-to-noise Ratio\u00a0: \n58 dB\n\n\nOutput Signal range\u00a0: Analog Signal (0-1023)\n\n\n\n\nDemonstration\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThis module uses the chip LM2904 to amplify the electronic signal produced by the mini microphone. At last, you\u2019ll get the analog-to-digital conversion value. Let\ns try to read the output value.\n\n\n\n\nAs the picture on the below indicates, the Loudness sensor is connected to analog port A0 of the \nGrove - Base Shield\n.\n\n\n\n\n\n\n\n\nConnect Arduino/Seeeduino to PC by using a USB cable.\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\n    int val;\n    void setup()\n    {\n        Serial.begin(9600);\n    }\n\n    void loop()\n    {\n        analogRead(0);\n        delay(10);\n        val = analogRead(0);\n        Serial.println(val);\n        delay(200);\n    }\n\n\n\n\n\n\nUpload the code.\n\n\nThen open the serial monitor to observe the output results. There will be a significant change when blow to the sensor.\n\n\n\n\n\n\nThe blue line is the original signal from microphone and the yellow is the sig pin of Loudness Sensor. It is the original signal envelope that the module outputs. Here is the test screenshot from the oscilloscope.\n\n\nBlowing to the sensor:\n\n\n\n\nSpeaking to the sensor\uff1a\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket A0 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_loudness_sensor.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Loudness Sensor to analog port A0\n    # SIG,NC,VCC,GND\n    loudness_sensor = 0\n\n    while True:\n        try:\n            # Read the sound level\n            sensor_value = grovepi.analogRead(loudness_sensor)\n\n            print \nsensor_value =\n, sensor_value\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_loudness_sensor.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Loudness Sensor Eagle File\n\n\nGrove - loudness sensor pdf\n\n\nLM2904DR Datasheet\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Loudness Sensor"
        }, 
        {
            "location": "/Grove-Loudness_Sensor/#specifications", 
            "text": "Voltage \uff1a3.5~10 VDC  Working Frequency \uff1a50~2000 Hz  Sensitivity\u00a0: -48~66 dB  Signal-to-noise Ratio\u00a0:  58 dB  Output Signal range\u00a0: Analog Signal (0-1023)", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Loudness_Sensor/#demonstration", 
            "text": "", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Loudness_Sensor/#with-arduino", 
            "text": "This module uses the chip LM2904 to amplify the electronic signal produced by the mini microphone. At last, you\u2019ll get the analog-to-digital conversion value. Let s try to read the output value.   As the picture on the below indicates, the Loudness sensor is connected to analog port A0 of the  Grove - Base Shield .     Connect Arduino/Seeeduino to PC by using a USB cable.  Copy and paste code below to a new Arduino sketch.       int val;\n    void setup()\n    {\n        Serial.begin(9600);\n    }\n\n    void loop()\n    {\n        analogRead(0);\n        delay(10);\n        val = analogRead(0);\n        Serial.println(val);\n        delay(200);\n    }   Upload the code.  Then open the serial monitor to observe the output results. There will be a significant change when blow to the sensor.    The blue line is the original signal from microphone and the yellow is the sig pin of Loudness Sensor. It is the original signal envelope that the module outputs. Here is the test screenshot from the oscilloscope.  Blowing to the sensor:   Speaking to the sensor\uff1a", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Loudness_Sensor/#with-raspberry-pi", 
            "text": "1.You should have a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket A0 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_loudness_sensor.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Loudness Sensor to analog port A0\n    # SIG,NC,VCC,GND\n    loudness_sensor = 0\n\n    while True:\n        try:\n            # Read the sound level\n            sensor_value = grovepi.analogRead(loudness_sensor)\n\n            print  sensor_value = , sensor_value\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_loudness_sensor.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Loudness_Sensor/#resources", 
            "text": "Grove - Loudness Sensor Eagle File  Grove - loudness sensor pdf  LM2904DR Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Loudness_Sensor/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Luminance_Sensor/", 
            "text": "Grove - Luminance Sensor detects the intensity of the ambient light on a surface area. It uses \nAPDS-9002\n analog output ambient light photo sensor. This has responsivity closer to human eye.\n\n\nThis Luminance Sensor can be used in application which requires automatic light adjustment in residential or commercial lighting.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nVcc\n\n\n2.4V ~ 5.5V\n\n\n\n\n\n\nLinear output range\n\n\n0.0 ~ 2.3V\n\n\n\n\n\n\nLuminance measurement range\n\n\n0 ~ 1000 Lux\n\n\n\n\n\n\n\n\nDemonstration\n\uf0c1\n\n\nHookup Grove Luminance sensor with Seeduino Lotus\n\n\n1.Plug the Grove-Luminance sensor to the A0 port of Seeeduino Lotus with a Grove connector.\n\n\n\n\n2.Copy the following code in an arduino sketch.\n\n\n    float VoutArray[] =  { 0.0011498,  0.0033908,   0.011498, 0.041803,0.15199,     0.53367, 1.3689,   1.9068,  2.3};\n    float  LuxArray[] =  { 1.0108,     3.1201,  9.8051,   27.43,   69.545,   232.67,  645.11,   73.52,  1000};\n\n\n\n    void setup() {\n      // put your setup code here, to run once:\n      Serial.begin(9600);\n\n    }\n\n    void loop() {\n      // put your main code here, to run repeatedly:\n\n      Serial.print(\nVout =\n);\n      Serial.print(readAPDS9002Vout(A0));\n      Serial.print(\n V,Luminance =\n);\n      Serial.print(readLuminance(A0));\n      Serial.println(\nLux\n);\n      delay(500);\n\n    }\n\n    float readAPDS9002Vout(uint8_t analogpin)\n    {\n        // MeasuredVout = ADC Value * (Vcc / 1023) * (3 / Vcc)\n        // Vout samples are with reference to 3V Vcc\n        // The above expression is simplified by cancelling out Vcc \n        float MeasuredVout = analogRead(A0) * (3.0 / 1023.0);\n        //Above 2.3V , the sensor value is saturated\n\n        return MeasuredVout;\n\n    }\n\n    float readLuminance(uint8_t analogpin)\n    {\n\n        // MeasuredVout = ADC Value * (Vcc / 1023) * (3 / Vcc)\n        // Vout samples are with reference to 3V Vcc\n        // The above expression is simplified by cancelling out Vcc \n        float MeasuredVout = analogRead(A0) * (3.0 / 1023.0);   \n        float Luminance = FmultiMap(MeasuredVout, VoutArray, LuxArray, 9);\n\n        /**************************************************************************\n\n        The Luminance in Lux is calculated based on APDS9002 datasheet -- \n Graph 1 \n        ( Output voltage vs. luminance at different load resistor)\n        The load resistor is 1k in this board. Vout is referenced to 3V Vcc.\n\n        The data from the graph is extracted using WebPlotDigitizer \n        http://arohatgi.info/WebPlotDigitizer/app/\n\n        VoutArray[] and LuxArray[] are these extracted data. Using MultiMap, the data\n        is interpolated to get the Luminance in Lux.\n\n        This implementation uses floating point arithmetic and hence will consume \n        more flash, RAM and time.\n\n        The Luminance in Lux is an approximation and depends on the accuracy of\n        Graph 1 used.\n\n        ***************************************************************************/\n\n        return Luminance;\n    }\n\n\n    //This code uses MultiMap implementation from http://playground.arduino.cc/Main/MultiMap\n\n    float FmultiMap(float val, float * _in, float * _out, uint8_t size)\n    {\n      // take care the value is within range\n      // val = constrain(val, _in[0], _in[size-1]);\n      if (val \n= _in[0]) return _out[0];\n      if (val \n= _in[size-1]) return _out[size-1];\n\n      // search right interval\n      uint8_t pos = 1;  // _in[0] allready tested\n      while(val \n _in[pos]) pos++;\n\n      // this will handle all exact \npoints\n in the _in array\n      if (val == _in[pos]) return _out[pos];\n\n      // interpolate in the right segment for the rest\n      return (val - _in[pos-1]) * (_out[pos] - _out[pos-1]) / (_in[pos] - _in[pos-1]) + _out[pos-1];\n    }\n\n\n\n\n3.Upload the code to seeeduino lotus.\n\n\n4.Hold the Grove Luminance sensor under a light source or in a place where lux has to be detected.\n\n\n5.Open the serial monitor.\n\n\n\n\n6.The Vout and Lux are displayed in the serial monitor.\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-Luminance Sensor Demo code\n\n\nGrove-Luminance Sensor eagle file\n\n\nGrove-Luminance Sensor Schematic (PDF)\n\n\nAPDS-900 Datasheet\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Luminance Sensor"
        }, 
        {
            "location": "/Grove-Luminance_Sensor/#specifications", 
            "text": "Parameter  Value      Vcc  2.4V ~ 5.5V    Linear output range  0.0 ~ 2.3V    Luminance measurement range  0 ~ 1000 Lux", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Luminance_Sensor/#demonstration", 
            "text": "Hookup Grove Luminance sensor with Seeduino Lotus  1.Plug the Grove-Luminance sensor to the A0 port of Seeeduino Lotus with a Grove connector.   2.Copy the following code in an arduino sketch.      float VoutArray[] =  { 0.0011498,  0.0033908,   0.011498, 0.041803,0.15199,     0.53367, 1.3689,   1.9068,  2.3};\n    float  LuxArray[] =  { 1.0108,     3.1201,  9.8051,   27.43,   69.545,   232.67,  645.11,   73.52,  1000};\n\n\n\n    void setup() {\n      // put your setup code here, to run once:\n      Serial.begin(9600);\n\n    }\n\n    void loop() {\n      // put your main code here, to run repeatedly:\n\n      Serial.print( Vout = );\n      Serial.print(readAPDS9002Vout(A0));\n      Serial.print(  V,Luminance = );\n      Serial.print(readLuminance(A0));\n      Serial.println( Lux );\n      delay(500);\n\n    }\n\n    float readAPDS9002Vout(uint8_t analogpin)\n    {\n        // MeasuredVout = ADC Value * (Vcc / 1023) * (3 / Vcc)\n        // Vout samples are with reference to 3V Vcc\n        // The above expression is simplified by cancelling out Vcc \n        float MeasuredVout = analogRead(A0) * (3.0 / 1023.0);\n        //Above 2.3V , the sensor value is saturated\n\n        return MeasuredVout;\n\n    }\n\n    float readLuminance(uint8_t analogpin)\n    {\n\n        // MeasuredVout = ADC Value * (Vcc / 1023) * (3 / Vcc)\n        // Vout samples are with reference to 3V Vcc\n        // The above expression is simplified by cancelling out Vcc \n        float MeasuredVout = analogRead(A0) * (3.0 / 1023.0);   \n        float Luminance = FmultiMap(MeasuredVout, VoutArray, LuxArray, 9);\n\n        /**************************************************************************\n\n        The Luminance in Lux is calculated based on APDS9002 datasheet --   Graph 1 \n        ( Output voltage vs. luminance at different load resistor)\n        The load resistor is 1k in this board. Vout is referenced to 3V Vcc.\n\n        The data from the graph is extracted using WebPlotDigitizer \n        http://arohatgi.info/WebPlotDigitizer/app/\n\n        VoutArray[] and LuxArray[] are these extracted data. Using MultiMap, the data\n        is interpolated to get the Luminance in Lux.\n\n        This implementation uses floating point arithmetic and hence will consume \n        more flash, RAM and time.\n\n        The Luminance in Lux is an approximation and depends on the accuracy of\n        Graph 1 used.\n\n        ***************************************************************************/\n\n        return Luminance;\n    }\n\n\n    //This code uses MultiMap implementation from http://playground.arduino.cc/Main/MultiMap\n\n    float FmultiMap(float val, float * _in, float * _out, uint8_t size)\n    {\n      // take care the value is within range\n      // val = constrain(val, _in[0], _in[size-1]);\n      if (val  = _in[0]) return _out[0];\n      if (val  = _in[size-1]) return _out[size-1];\n\n      // search right interval\n      uint8_t pos = 1;  // _in[0] allready tested\n      while(val   _in[pos]) pos++;\n\n      // this will handle all exact  points  in the _in array\n      if (val == _in[pos]) return _out[pos];\n\n      // interpolate in the right segment for the rest\n      return (val - _in[pos-1]) * (_out[pos] - _out[pos-1]) / (_in[pos] - _in[pos-1]) + _out[pos-1];\n    }  3.Upload the code to seeeduino lotus.  4.Hold the Grove Luminance sensor under a light source or in a place where lux has to be detected.  5.Open the serial monitor.   6.The Vout and Lux are displayed in the serial monitor.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Luminance_Sensor/#resources", 
            "text": "Grove-Luminance Sensor Demo code  Grove-Luminance Sensor eagle file  Grove-Luminance Sensor Schematic (PDF)  APDS-900 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Luminance_Sensor/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/", 
            "text": "This is a Grove interface compatible Magnetic switch module. It is based on encapsulated dry reed switch CT10. CT10 is single-pole, single throw (SPST) type, having normally open ruthenium contacts. The sensor is a double-ended type and may be actuated with an electromagnet, a permanent magnet or a combination of both. The magnetic switch is a wonderful tool for designers who would like to turn a circuit on and off based on proximity.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible interface\n\n\n2.0cm x 2.0cm Grove module\n\n\nMinimum external parts\n\n\n10W rating\n\n\nRugged encapsulation\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nProximity Sensor\n\n\nSecurity Alarm Sensor\n\n\nLevel Sensor\n\n\nFlow Sensor\n\n\nPulse Counter\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItems\n\n\n\n\nMin\n\n\n\n\nNorm\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n4.75\n\n\n\n\n5.0\n\n\n\n\n5.25\n\n\n\n\nV\n\n\n\n\n\n\n\n\nSwitched Power\n\n\n\n\n10\n\n\n\n\nW\n\n\n\n\n\n\n\n\nSwitched Voltage AC,RMS value(max)\n\n\n\n\n\n 140\n\n\n\n\nV\n\n\n\n\n\n\n\n\nSwitched Current DC\n\n\n\n\n\n 500\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nCarry Current DC\n\n\n\n\n\n 0.5\n\n\n\n\nA\n\n\n\n\n\n\n\n\nContact Resistance\n\n\n\n\n\n200\n\n\n\n\nm\u03a9\n\n\n\n\n\n\n\n\nInsulation Resistance\n\n\n\n\n\n10\n6\n\n\n\n\n\nM\u03a9\n\n\n\n\n\n\n\n\nOperating Temperature\n\n\n\n\n-40\n\n\n\n\n-\n\n\n\n\n125\n\n\n\n\n\u2103\n\n\n\n\n\n\n\n\nOperate Range\n\n\n\n\n10\n\n\n\n\n-\n\n\n\n\n40\n\n\n\n\nAT\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThe SIG pin of the module output LOW normally. When a magnet approaches the switch, the magnetic switch close and the SIG pin output HIGH.\n\n\nThe following sketch demonstrates a simple application of using the Magnetic switch to control the led. When you put a magnet that has enough magnetic power close to the module, the switch is closed .Then the SIG pin out put a high voltage. You can use this to control the led.\n\n\nAs the picture on the below indicates, the Magnetic switch is connected to digital port 9 of the \nGrove - Base Shield\n and the LED is connected to digital port 13. When a Magnet approaches the switch, the SIG pin outputs a High voltage. Then the LED lights up. The hardware installation is as follows:\n\n\n\n\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\n    /*******************************************************************************/\n\n    /*macro definitions of magnetic pin and LED pin*/\n    #define MAGNECTIC_SWITCH 9\n    #define LED 13//the on board LED of the Arduino or Seeeduino\n\n    void setup()\n    {\n        pinsInit();\n    }\n\n    void loop() \n    {\n        if(isNearMagnet())//if the magnetic switch is near the magnet?\n        {\n            turnOnLED();\n        }\n        else\n        {\n            turnOffLED();\n        }\n    }\n    void pinsInit()\n    {\n        pinMode(MAGNECTIC_SWITCH, INPUT);\n        pinMode(LED,OUTPUT);\n    }\n\n    /*If the magnetic switch is near the magnet, it will return ture, */\n    /*otherwise it will return false                                */\n    boolean isNearMagnet()\n    {\n        int sensorValue = digitalRead(MAGNECTIC_SWITCH);\n        if(sensorValue == HIGH)//if the sensor value is HIGH?\n        {\n            return true;//yes,return ture\n        }\n        else\n        {\n            return false;//no,return false\n        }\n    }\n    void turnOnLED()\n    {\n        digitalWrite(LED,HIGH);\n    }\n    void turnOffLED()\n    {\n        digitalWrite(LED,LOW);\n    }\n\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n\n\nThen the LED light when there is Magnetic approaches the switch. Have a try!\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the Magnet Switch to grovepi socket D3 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code (this demo has the same usage with tilt switch)\n\n\n\n\n    nano grovepi_tilt_switch.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Tilt Switch to digital port D3\n    # SIG,NC,VCC,GND\n    tilt_switch = 3\n\n    grovepi.pinMode(tilt_switch,\nINPUT\n)\n\n    while True:\n        try:\n            print grovepi.digitalRead(tilt_switch)\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_tilt_switch.py\n\n\n\n\n6.Result\n\n\nPut a magnet upon the sensor, the SIG pin will output HIGH.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-Magnetic Switch v0.9 Eagle File\n\n\nCT10 Datasheet\n\n\nGrove-Magnetic Switch v1.3 Eagle File\n\n\nGrove-Magnetic Switch v1.3 PDF File\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Magnetic Switch"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/#features", 
            "text": "Grove compatible interface  2.0cm x 2.0cm Grove module  Minimum external parts  10W rating  Rugged encapsulation", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/#application-ideas", 
            "text": "Proximity Sensor  Security Alarm Sensor  Level Sensor  Flow Sensor  Pulse Counter", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/#specifications", 
            "text": "Items  \nMin  \nNorm  \nMax  \nUnit    \nWorking Voltage  \n4.75  \n5.0  \n5.25  \nV    \nSwitched Power  \n10  \nW    \nSwitched Voltage AC,RMS value(max)    140  \nV    \nSwitched Current DC    500  \nmA    \nCarry Current DC    0.5  \nA    \nContact Resistance   200  \nm\u03a9    \nInsulation Resistance   10 6   \nM\u03a9    \nOperating Temperature  \n-40  \n-  \n125  \n\u2103    \nOperate Range  \n10  \n-  \n40  \nAT", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/#with-arduino", 
            "text": "The SIG pin of the module output LOW normally. When a magnet approaches the switch, the magnetic switch close and the SIG pin output HIGH.  The following sketch demonstrates a simple application of using the Magnetic switch to control the led. When you put a magnet that has enough magnetic power close to the module, the switch is closed .Then the SIG pin out put a high voltage. You can use this to control the led.  As the picture on the below indicates, the Magnetic switch is connected to digital port 9 of the  Grove - Base Shield  and the LED is connected to digital port 13. When a Magnet approaches the switch, the SIG pin outputs a High voltage. Then the LED lights up. The hardware installation is as follows:    Copy and paste code below to a new Arduino sketch.       /*******************************************************************************/\n\n    /*macro definitions of magnetic pin and LED pin*/\n    #define MAGNECTIC_SWITCH 9\n    #define LED 13//the on board LED of the Arduino or Seeeduino\n\n    void setup()\n    {\n        pinsInit();\n    }\n\n    void loop() \n    {\n        if(isNearMagnet())//if the magnetic switch is near the magnet?\n        {\n            turnOnLED();\n        }\n        else\n        {\n            turnOffLED();\n        }\n    }\n    void pinsInit()\n    {\n        pinMode(MAGNECTIC_SWITCH, INPUT);\n        pinMode(LED,OUTPUT);\n    }\n\n    /*If the magnetic switch is near the magnet, it will return ture, */\n    /*otherwise it will return false                                */\n    boolean isNearMagnet()\n    {\n        int sensorValue = digitalRead(MAGNECTIC_SWITCH);\n        if(sensorValue == HIGH)//if the sensor value is HIGH?\n        {\n            return true;//yes,return ture\n        }\n        else\n        {\n            return false;//no,return false\n        }\n    }\n    void turnOnLED()\n    {\n        digitalWrite(LED,HIGH);\n    }\n    void turnOffLED()\n    {\n        digitalWrite(LED,LOW);\n    }   Upload the code, Please click  here  if you do not know how to upload.  Then the LED light when there is Magnetic approaches the switch. Have a try!", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/#with-raspberry-pi", 
            "text": "1.You should have a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the Magnet Switch to grovepi socket D3 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code (this demo has the same usage with tilt switch)       nano grovepi_tilt_switch.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Tilt Switch to digital port D3\n    # SIG,NC,VCC,GND\n    tilt_switch = 3\n\n    grovepi.pinMode(tilt_switch, INPUT )\n\n    while True:\n        try:\n            print grovepi.digitalRead(tilt_switch)\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_tilt_switch.py  6.Result  Put a magnet upon the sensor, the SIG pin will output HIGH.", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/#resources", 
            "text": "Grove-Magnetic Switch v0.9 Eagle File  CT10 Datasheet  Grove-Magnetic Switch v1.3 Eagle File  Grove-Magnetic Switch v1.3 PDF File", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Magnetic_Switch/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/", 
            "text": "Grove - Mini Track ball will give an easy access to prototyping a practical motion-tracking function module for your applications. It has implanted 360\u00b0 detection and click detection with high accuracy and quick response. With chips \nSTM32F103C8T6\n and \nAN48841B\n inside, you can turn plenty of your ideas into tangible things. It is also standardized with Grove interface which will save you a lot of work in the prototyping process.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n360\u00b0 and quick detection.\n\n\nTranslucent click Button.\n\n\nStandardized with Grove interface.\n\n\nPowerful MCU for you to enrich your applications.\n\n\n\n\nApplication ideas\n\uf0c1\n\n\n\n\nTracking module for a gamepad.\n\n\nTracking module for a haptic controller.\n\n\nTracking module for toys.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating voltage\n\n\n3.3V~5.5V (typical at 5V)\n\n\n\n\n\n\nOperating current\n\n\n28 mA (maximum operating current: 40 mA)\n\n\n\n\n\n\nOperating temperature range\n\n\n-25 ~ 75 \u2103\n\n\n\n\n\n\nMCU frequency\n\n\n64 MHz\n\n\n\n\n\n\nOperating frequency\n\n\n105\u00b15kHz\n\n\n\n\n\n\nHall effect filed strength range\n\n\n(0.5) ~ (8) mT\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nGrove interface\n \n\nConnect main control board such as \nSeeeduino\n board with Grove - Mini Track Ball.\n\n\nMCU (STM32F103C8T6)\n \n\nMicrocontroller.\n\n\nTrack ball\n \n\nInterface to control motions.\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Mini Track Ball\n\n\n1PC\n\n\n\n\n\n\nGrove wire\n\n\n1PC\n\n\n\n\n\n\n\n\nGet started\n\uf0c1\n\n\nMaterial required\n\uf0c1\n\n\nSeeeduino x 1\n\n\nGrove - Wire x 1\n\n\n\n\nTip\n\nYou can use \nGrove - Base Shield v2\n to make connection work easy.\n\n\n\n\nPreparations\n\uf0c1\n\n\nRefer to the following guides to build an appropriate IDE:\n\n\n\n\nNote\n\nWe have used Seeeduino in this case.\n\n\n\n\nGetting Started on Windows\n\n\nGetting Started on Mac OS X\n\n\nHardware connections\n\uf0c1\n\n\n\n\nDownload sample code\n\uf0c1\n\n\n1.You can \ndownload\n the sample code.\n\n\n2.Decompress the downloaded ZIP file.\n\n\n3.Open the file \nGrove_-_Mini_Track_ball_test.ino\n\n\n4.Flash (or upload) your code into Seeeduino board. if uploading process is done, to open Serial Monitor window, Click \nSerial Monitor\n under menu \nTool\n.\n\n\n\n\nNote\n\nMake sure you have selected the right \nBoard\n and \nPort\n under the \nTool\n menu.\n\n\n\n\n5.LED indicator under tracking ball will light on in different mode which will last around 50 seconds\n\n\n6.After that you can rotate or \nclick\n the track ball to get information of its trace.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic in Eagle\n\n\nSchematic in PDF format\n\n\nSTM32F103C8T6 Datasheet\n\n\nAN48841B Datasheet\n\n\nLibrary file in Github\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Mini Track Ball"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#features", 
            "text": "360\u00b0 and quick detection.  Translucent click Button.  Standardized with Grove interface.  Powerful MCU for you to enrich your applications.", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#application-ideas", 
            "text": "Tracking module for a gamepad.  Tracking module for a haptic controller.  Tracking module for toys.", 
            "title": "Application ideas"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#specifications", 
            "text": "Parameter  Value      Operating voltage  3.3V~5.5V (typical at 5V)    Operating current  28 mA (maximum operating current: 40 mA)    Operating temperature range  -25 ~ 75 \u2103    MCU frequency  64 MHz    Operating frequency  105\u00b15kHz    Hall effect filed strength range  (0.5) ~ (8) mT", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#hardware-overview", 
            "text": "Grove interface   \nConnect main control board such as  Seeeduino  board with Grove - Mini Track Ball.  MCU (STM32F103C8T6)   \nMicrocontroller.  Track ball   \nInterface to control motions.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#parts-list", 
            "text": "Parts name  Quantity      Grove - Mini Track Ball  1PC    Grove wire  1PC", 
            "title": "Parts list"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#get-started", 
            "text": "", 
            "title": "Get started"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#material-required", 
            "text": "Seeeduino x 1  Grove - Wire x 1   Tip \nYou can use  Grove - Base Shield v2  to make connection work easy.", 
            "title": "Material required"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#preparations", 
            "text": "Refer to the following guides to build an appropriate IDE:   Note \nWe have used Seeeduino in this case.  Getting Started on Windows  Getting Started on Mac OS X", 
            "title": "Preparations"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#hardware-connections", 
            "text": "", 
            "title": "Hardware connections"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#download-sample-code", 
            "text": "1.You can  download  the sample code.  2.Decompress the downloaded ZIP file.  3.Open the file  Grove_-_Mini_Track_ball_test.ino  4.Flash (or upload) your code into Seeeduino board. if uploading process is done, to open Serial Monitor window, Click  Serial Monitor  under menu  Tool .   Note \nMake sure you have selected the right  Board  and  Port  under the  Tool  menu.  5.LED indicator under tracking ball will light on in different mode which will last around 50 seconds  6.After that you can rotate or  click  the track ball to get information of its trace.", 
            "title": "Download sample code"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#resources", 
            "text": "Schematic in Eagle  Schematic in PDF format  STM32F103C8T6 Datasheet  AN48841B Datasheet  Library file in Github", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Mini_Track_Ball/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/", 
            "text": "Grove - Mouse Encoder is a type of mechanical incremental rotary encoder with feedback data of rotary direction and rotary speed\n[1]\n. It features standard Grove interface that will save your lots of work in wiring and programming. Also, it is well adapted to heavy duty and a harsh environment. This product can be applied in toys, robots, and consumer input devices.\n\n\n\n\n\n\nNote\n\nThe rotating speed is designed to be less 1000 rad/min(radian per minute).\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nVersatile for different environment.\n\n\nWell adapted for heavy duty and harsh environment.\n\n\nWith detents and a nice feel.\n\n\nStandard Grove interface for easier programming and wiring.\n\n\nAccurate and reliable.\n\n\n\n\nApplications\n\uf0c1\n\n\nIt is versatile for different applications in harsh environment such as toys, robotics and consumer input devices.\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nMin.\n\n\nTypical\n\n\nMax.\n\n\n\n\n\n\n\n\n\n\nOperating voltage(V)\n\n\n\n\n3.3\n\n\n5.5\n\n\n\n\n\n\nOperating current(mA)\n\n\n\n\n10\n\n\n13\n\n\n\n\n\n\nDuty(constant speed)\n\n\n\n\n50%\n\n\n\n\n\n\n\n\nPhase difference(constant speed)\n\n\n\n\n\u03c0/4\n\n\n\n\n\n\n\n\nPulse per circle\n\n\n\n\n12\n\n\n\n\n\n\n\n\n\n\n\n\nNotes\n\n\nThere is no knob included in product list. Because we think it will make this encoder more versatile for different environments.\n\n\nYou can find \ndimensions\n file in PDF format, and you can customize a knob according to the dimensions.\n\n\n\n\n\n\n\nTip\n\nYou can just use a suitable hexagonal screwdriver bit if you only are building a prototype for your project.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nGrove interface\n \n\nConnect main control board such as \nSeeeduino\n board with driver board.\n\n\nHexagonal opening\n \n\nAn opening you pass a knob through.\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Mouse Encoder(no knob included)\n\n\n1 PC\n\n\n\n\n\n\nGrove - Universal Cable\n\n\n1 PC\n\n\n\n\n\n\n\n\nGet started\n\uf0c1\n\n\nThis section will show you how to build an IDE environment for building applications with Grove - Mouse Encoder.\n\n\nRefer to \nSeeeduino V4.2\n(It is exchangeable with Arduino board) for how to build a complete an IDE for your applications, or read \nArduino guide\n if you use Arduino original board.\n\n\n\n\nNotes\n\n\nDuty circle will be bigger if the speed of rotating is slow.\n\n\nThe pulse width (PW) will not be the same if rotating speed is not constant.\n\n\nThe rotating speed is supposed to be low than 1000 rad/min or it will lead to narrow output PW or cause damage to this encoder.\n\n\nThe output voltage will be uncertain (high or low voltage) for no rotating circumstance since the position of pulse inside this encoder is not certain.\n\n\n\n\n\nBasic demo\n\uf0c1\n\n\nThis demo shows how to detect position and detect direction.\n\n\nMaterial required\n\uf0c1\n\n\n\n\nSeeeduino V4.2\n\n\nBase shield V2.0\n\n\nUSB cable (type A to micro type B)\n\n\n\n\nConnections\n\uf0c1\n\n\nConnect materials as shown below:\n\n\n\n\nCode\n\uf0c1\n\n\n/* Read Quadrature Encoder\n* Connect Encoder to Pins encoder0PinA, encoder0PinB, and +5V.\n*\n* Sketch by max wolf / www.meso.net\n* v. 0.1 - very basic functions - mw 20061220\n*\n*/  \n\u00a0\n\u00a0\nint val; \nint encoder0PinA = 3;\nint encoder0PinB = 4;\nint encoder0Pos = 0;\nint encoder0PinALast = LOW;\nint n = LOW;\n\u00a0\nvoid setup() { \n    pinMode (encoder0PinA,INPUT);\n    pinMode (encoder0PinB,INPUT);\n    Serial.begin (115200);\n} \n\u00a0\nvoid loop() { \n    n = digitalRead(encoder0PinA);\n    if ((encoder0PinALast == LOW) \n (n == HIGH)) {\n        if (digitalRead(encoder0PinB) == LOW) {\n            encoder0Pos--;\n        } else {\n            encoder0Pos++;\n        }\n        Serial.println(encoder0Pos);\n        Serial.println (\n/\n);\n    } \n    encoder0PinALast = n;\n}\n\n\n\n\n\n\nCopy the code and flash it into the controller board.\n\n\nOpen monitor window.\n\n\nTurn the screwdriver bit to left or left to see what will happen.\n\n\n\n\nThe output:\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic files\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Mouse Encoder"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#features", 
            "text": "Versatile for different environment.  Well adapted for heavy duty and harsh environment.  With detents and a nice feel.  Standard Grove interface for easier programming and wiring.  Accurate and reliable.", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#applications", 
            "text": "It is versatile for different applications in harsh environment such as toys, robotics and consumer input devices.", 
            "title": "Applications"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#specifications", 
            "text": "Item  Min.  Typical  Max.      Operating voltage(V)   3.3  5.5    Operating current(mA)   10  13    Duty(constant speed)   50%     Phase difference(constant speed)   \u03c0/4     Pulse per circle   12       Notes  There is no knob included in product list. Because we think it will make this encoder more versatile for different environments.  You can find  dimensions  file in PDF format, and you can customize a knob according to the dimensions.    Tip \nYou can just use a suitable hexagonal screwdriver bit if you only are building a prototype for your project.", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#hardware-overview", 
            "text": "Grove interface   \nConnect main control board such as  Seeeduino  board with driver board.  Hexagonal opening   \nAn opening you pass a knob through.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#parts-list", 
            "text": "Parts name  Quantity      Grove - Mouse Encoder(no knob included)  1 PC    Grove - Universal Cable  1 PC", 
            "title": "Parts list"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#get-started", 
            "text": "This section will show you how to build an IDE environment for building applications with Grove - Mouse Encoder.  Refer to  Seeeduino V4.2 (It is exchangeable with Arduino board) for how to build a complete an IDE for your applications, or read  Arduino guide  if you use Arduino original board.   Notes  Duty circle will be bigger if the speed of rotating is slow.  The pulse width (PW) will not be the same if rotating speed is not constant.  The rotating speed is supposed to be low than 1000 rad/min or it will lead to narrow output PW or cause damage to this encoder.  The output voltage will be uncertain (high or low voltage) for no rotating circumstance since the position of pulse inside this encoder is not certain.", 
            "title": "Get started"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#basic-demo", 
            "text": "This demo shows how to detect position and detect direction.", 
            "title": "Basic demo"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#material-required", 
            "text": "Seeeduino V4.2  Base shield V2.0  USB cable (type A to micro type B)", 
            "title": "Material required"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#connections", 
            "text": "Connect materials as shown below:", 
            "title": "Connections"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#code", 
            "text": "/* Read Quadrature Encoder\n* Connect Encoder to Pins encoder0PinA, encoder0PinB, and +5V.\n*\n* Sketch by max wolf / www.meso.net\n* v. 0.1 - very basic functions - mw 20061220\n*\n*/  \n\u00a0\n\u00a0\nint val; \nint encoder0PinA = 3;\nint encoder0PinB = 4;\nint encoder0Pos = 0;\nint encoder0PinALast = LOW;\nint n = LOW;\n\u00a0\nvoid setup() { \n    pinMode (encoder0PinA,INPUT);\n    pinMode (encoder0PinB,INPUT);\n    Serial.begin (115200);\n} \n\u00a0\nvoid loop() { \n    n = digitalRead(encoder0PinA);\n    if ((encoder0PinALast == LOW)   (n == HIGH)) {\n        if (digitalRead(encoder0PinB) == LOW) {\n            encoder0Pos--;\n        } else {\n            encoder0Pos++;\n        }\n        Serial.println(encoder0Pos);\n        Serial.println ( / );\n    } \n    encoder0PinALast = n;\n}   Copy the code and flash it into the controller board.  Open monitor window.  Turn the screwdriver bit to left or left to see what will happen.   The output:", 
            "title": "Code"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#resources", 
            "text": "Schematic files", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Mouse_Encoder/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/", 
            "text": "Grove \u2013 Multichannel Gas sensor is a environment detecting sensor with a built in MiCS-6814 which can detect many unhealthful gases, and three gases can be measured simultaneously due to its multi channels, so it can help you to monitor the concentration which more than one gas.\n\n\nThis sensor belongs to \nGrove system\n, and you can plug it onto the \nBase shield\n and work with Arduino directly without any jumper wires. The interface of it is I2C, so plug it onto the I2C port of Base shield, then you can start to work it.\n\n\n\n\nCaution\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nBefore usage\n\uf0c1\n\n\nRelated Reading\n\uf0c1\n\n\nWe suggest you to read those knowledge before using the Gas sensor, it\nll help you to learn more about Arduino and our products, and also it\nll let you to use open souse hardware more easier.\n\n\n\n\nGetting Started with Arduino\n\n\nWhat is Grove system\n\n\nWhy i need a Base shield?\n\n\n\n\nAfter reading that you will know how to use Base shield with Grove products to work well with Arduino. Let\ns start it\u00a0!\n\n\nTo be prepared\n\uf0c1\n\n\nThis tutorial will include some necessary products:\n\n\n\n\nArduino UNO R3\n or \nSeeeduino v4\n\n\nBase Shield\n\n\nGrove - Multichannel Gas Sensor\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\n\n\nFour pins are pointed out from the figure above\n\n\n\n\n\n\n\n\nPin Label\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nGND\n\n\nConnect to ground\n\n\n\n\n\n\nVCC\n\n\nPower supply: 3.3V - 5V\n\n\n\n\n\n\nSDA\n\n\nI2C data\n\n\n\n\n\n\nSCL\n\n\nI2C clock\n\n\n\n\n\n\n\n\nThe power supply is between 3.3V and 5V, so this sensor can be compatible with a micro-controller whose output voltage is 3.3V.\n\n\nFeatures\n\uf0c1\n\n\n\n\nThree fully independent sensing elements on one package\n\n\nBuilt with ATmega168PA\n\n\nI2C interface with programmable address\n\n\nHeating power can be shut down for low power\n\n\nDetectable gases\n\n\nCarbon monoxide CO 1 \u2013 1000ppm\n\n\nNitrogen dioxide NO2 0.05 \u2013 10ppm\n\n\nEthanol C2H6OH 10 \u2013 500ppm\n\n\nHydrogen H2 1 \u2013 1000ppm\n\n\nAmmonia NH3 1 \u2013 500ppm\n\n\nMethane CH4 \n1000ppm\n\n\nPropane C3H8 \n1000ppm\n\n\nIso-butane C4H10 \n1000ppm\n\n\n\n\n\n\n\n\nBlock Diagram\n\uf0c1\n\n\n\n\nElectrical Characteristics\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nCondition\n\n\nMin.\n\n\nTyp.\n\n\nMax.\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVoltage\n\n\n-\n\n\n3.1\n\n\n3.3\n\n\n5.25\n\n\nV\n\n\n\n\n\n\nRipple\n\n\n@Max Power\n\n\n-\n\n\n80\n\n\n100\n\n\nmV\n\n\n\n\n\n\nHeating Power\n\n\n-\n\n\n-\n\n\n-\n\n\n88\n\n\nmW\n\n\n\n\n\n\nMax Power\n\n\n-\n\n\n-\n\n\n-\n\n\n150\n\n\nmW\n\n\n\n\n\n\nADC Precision\n\n\n-\n\n\n-\n\n\n10\n\n\n-\n\n\nBits\n\n\n\n\n\n\nI2C Rate\n\n\n-\n\n\n-\n\n\n100\n\n\n400\n\n\nkHz\n\n\n\n\n\n\nVIL\n\n\n@I2C\n\n\n-0.5\n\n\n-\n\n\n0.99\n\n\nV\n\n\n\n\n\n\nVIH\n\n\n@I2C\n\n\n2.31\n\n\n-\n\n\n5.25\n\n\nV\n\n\n\n\n\n\n\n\nPerformance RED sensor\n\uf0c1\n\n\n\n\n\n\n\n\nCharacteristic RED sensor\n\n\nSymbol\n\n\nTyp\n\n\nMin\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nSensing resistance in air\n\n\nR0\n\n\n-\n\n\n100\n\n\n1500\n\n\nk\u03a9\n\n\n\n\n\n\nTypical CO detection range\n\n\nFS\n\n\n-\n\n\n1\n\n\n1000\n\n\nppm\n\n\n\n\n\n\nSensitivity factor\n\n\nSR\n\n\n-\n\n\n1.2\n\n\n50\n\n\n-\n\n\n\n\n\n\n\n\n\n\nPerformance OX sensor\n\uf0c1\n\n\n\n\n\n\n\n\nCharacteristic OX sensor\n\n\nSymbol\n\n\nTyp\n\n\nMin\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nSensing resistance in air\n\n\nR0\n\n\n-\n\n\n0.8\n\n\n20\n\n\nk\u03a9\n\n\n\n\n\n\nTypical NO2 detection range\n\n\nFS\n\n\n-\n\n\n0.05\n\n\n10\n\n\nppm\n\n\n\n\n\n\nSensitivity factor\n\n\nSR\n\n\n-\n\n\n2\n\n\n-\n\n\n-\n\n\n\n\n\n\n\n\n\n\nPerformance NH3 sensor\n\uf0c1\n\n\n\n\n\n\n\n\nCharacteristic NH3 sensor\n\n\nSymbol\n\n\nTyp\n\n\nMin\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nSensing resistance in air\n\n\nR0\n\n\n-\n\n\n10\n\n\n1500\n\n\nk\u03a9\n\n\n\n\n\n\nTypical NH3 detection range\n\n\nFS\n\n\n-\n\n\n1\n\n\n300\n\n\nppm\n\n\n\n\n\n\nSensitivity factor\n\n\nSR\n\n\n-\n\n\n1.5\n\n\n15\n\n\n-\n\n\n\n\n\n\n\n\n\n\nFirmware and library\n\uf0c1\n\n\nFirmware\n\uf0c1\n\n\nThis grove module has an ATmega168 MCU which is flashed with a factory firmware. The firmware does the following:\n\n\n\n\nControls the power on and off for heating circuit and indicator LED\n\n\nListens to the command that make the module do the calibration - the calibration will sample the resistance of the MEMS core of this sensor which will be used as the reference, so please perform calibration in a fresh air condition\n\n\nListens to commands that get resistance value of one of the three sensor core which will be used to calculate the concentration of a specific gas\n\n\nListens to the command that changing the I2C address of this module - at most time, you do not need to do this except that the I2C address of this module (0x04) conflicts with another slave module.\n\n\n\n\n\n\nNote\n\nThe calibration has been done before the modules leave the factory. If you want to recalibrate, please do make sure that the air condition is fresh.\n\n\n\n\nLibrary\n\uf0c1\n\n\nThe library reads resistance values from the module and calculate the concentration of gas. One thing must be noticed is, the readings of this sensor are not supposed to be used to distinguish the type of gases, but to measure the concentration of a specific gas which is known to be that kind of gas.\n\n\nThe cores of this sensor are more sensitive to CO, NO2 and NH3, the precision of measurement for other gases would be worse.\n\n\n\n\nNote\n\nThe doCalibrate() function will take 8 seconds before it returns, as said above, at most time you don't need to recalibrate the sensor.\n\n\n\n\nDemonstration\n\uf0c1\n\n\nHardware Installation:\n\n\n1.Connect Grove - Multichannel Gas Sensor to Seeeduino.\n\n\n\n\nUpload Code:\n\n\n2.Download \nArduino Library \n Grove/Xadow firmware\n and install it to Arduino Library.\n\n\n3.Open the code directly by the path:File -\n Example -\n Mutichannel_Gas_Sensor-\n ReadSensorValue_Grove.\n\n\nThe code of ReadSensorValue_Grove is given below.\n\n\n    /*\n        This is a demo to test MutichannelGasSensor library\n        This code is running on Xadow-mainboard, and the I2C slave is Xadow-MutichannelGasSensor\n        There is a ATmega168PA on Xadow-MutichannelGasSensor, it get sensors output and feed back to master.\n        the data is raw ADC value, algorithm should be realized on master.\n\n        please feel free to write email to me if there is any question \n\n        Jacky Zhang, Embedded Software Engineer\n        qi.zhang@seeed.cc\n        17,mar,2015\n    */\n\n\n    #include \nWire.h\n\n    #include \nMutichannelGasSensor.h\n\n\n    void setup()\n    {\n        Serial.begin(9600);  // start serial for output\n        Serial.println(\npower on!\n);\n\n        mutichannelGasSensor.begin(0x04);//the default I2C address of the slave is 0x04\n        //mutichannelGasSensor.changeI2cAddr(0x10);\n        //mutichannelGasSensor.doCalibrate();\n        //delay(8000);\n        while(mutichannelGasSensor.readR0() \n 0)\n        {\n            Serial.println(\nsensors init error!!\n);\n            delay(1000);\n        }\n        Serial.print(\nRes0[0]: \n);\n        Serial.println(mutichannelGasSensor.res0[0]);\n        Serial.print(\nRes0[1]: \n);\n        Serial.println(mutichannelGasSensor.res0[1]);\n        Serial.print(\nRes0[2]: \n);\n        Serial.println(mutichannelGasSensor.res0[2]);\n        mutichannelGasSensor.powerOn();\n    }\n\n    void loop()\n    {\n        mutichannelGasSensor.readR();\n        Serial.print(\nRes[0]: \n);\n        Serial.println(mutichannelGasSensor.res[0]);\n        Serial.print(\nRes[1]: \n);\n        Serial.println(mutichannelGasSensor.res[1]);\n        Serial.print(\nRes[2]: \n);\n        Serial.println(mutichannelGasSensor.res[2]);\n\n        mutichannelGasSensor.calcGas();\n        Serial.print(\nNH3: \n);\n        Serial.print(mutichannelGasSensor.density_nh3);\n        Serial.println(\nppm\n);\n        Serial.print(\nCO: \n);\n        Serial.print(mutichannelGasSensor.density_co);\n        Serial.println(\nppm\n);\n        Serial.print(\nNO2: \n);\n        Serial.print(mutichannelGasSensor.density_no2);\n        Serial.println(\nppm\n);\n\n        delay(1000);\n        Serial.println(\n...\n);\n    }\n\n\n\n\n4.Upload the code. Remember to select Seeeduino Uno from the Tools | Board menu of the Arduino environment, and select the correct serial port Arduino is using.\n\n\nBy opening the serial monitor, you can see the raw data read from sensor.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Multichannel Gas Sensor v1.0 sch\n\n\nGrove - Multichannel Gas Sensor eagle files\n\n\nArduino Library \n Grove/Xadow firmware\n\n\nMiCS-6814 Datasheet\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Multichannel Gas Sensor"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#before-usage", 
            "text": "", 
            "title": "Before usage"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#related-reading", 
            "text": "We suggest you to read those knowledge before using the Gas sensor, it ll help you to learn more about Arduino and our products, and also it ll let you to use open souse hardware more easier.   Getting Started with Arduino  What is Grove system  Why i need a Base shield?   After reading that you will know how to use Base shield with Grove products to work well with Arduino. Let s start it\u00a0!", 
            "title": "Related Reading"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#to-be-prepared", 
            "text": "This tutorial will include some necessary products:   Arduino UNO R3  or  Seeeduino v4  Base Shield  Grove - Multichannel Gas Sensor", 
            "title": "To be prepared"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#hardware-overview", 
            "text": "Four pins are pointed out from the figure above     Pin Label  Description      GND  Connect to ground    VCC  Power supply: 3.3V - 5V    SDA  I2C data    SCL  I2C clock     The power supply is between 3.3V and 5V, so this sensor can be compatible with a micro-controller whose output voltage is 3.3V.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#features", 
            "text": "Three fully independent sensing elements on one package  Built with ATmega168PA  I2C interface with programmable address  Heating power can be shut down for low power  Detectable gases  Carbon monoxide CO 1 \u2013 1000ppm  Nitrogen dioxide NO2 0.05 \u2013 10ppm  Ethanol C2H6OH 10 \u2013 500ppm  Hydrogen H2 1 \u2013 1000ppm  Ammonia NH3 1 \u2013 500ppm  Methane CH4  1000ppm  Propane C3H8  1000ppm  Iso-butane C4H10  1000ppm", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#block-diagram", 
            "text": "", 
            "title": "Block Diagram"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#electrical-characteristics", 
            "text": "Item  Condition  Min.  Typ.  Max.  Unit      Voltage  -  3.1  3.3  5.25  V    Ripple  @Max Power  -  80  100  mV    Heating Power  -  -  -  88  mW    Max Power  -  -  -  150  mW    ADC Precision  -  -  10  -  Bits    I2C Rate  -  -  100  400  kHz    VIL  @I2C  -0.5  -  0.99  V    VIH  @I2C  2.31  -  5.25  V", 
            "title": "Electrical Characteristics"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#performance-red-sensor", 
            "text": "Characteristic RED sensor  Symbol  Typ  Min  Max  Unit      Sensing resistance in air  R0  -  100  1500  k\u03a9    Typical CO detection range  FS  -  1  1000  ppm    Sensitivity factor  SR  -  1.2  50  -", 
            "title": "Performance RED sensor"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#performance-ox-sensor", 
            "text": "Characteristic OX sensor  Symbol  Typ  Min  Max  Unit      Sensing resistance in air  R0  -  0.8  20  k\u03a9    Typical NO2 detection range  FS  -  0.05  10  ppm    Sensitivity factor  SR  -  2  -  -", 
            "title": "Performance OX sensor"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#performance-nh3-sensor", 
            "text": "Characteristic NH3 sensor  Symbol  Typ  Min  Max  Unit      Sensing resistance in air  R0  -  10  1500  k\u03a9    Typical NH3 detection range  FS  -  1  300  ppm    Sensitivity factor  SR  -  1.5  15  -", 
            "title": "Performance NH3 sensor"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#firmware-and-library", 
            "text": "", 
            "title": "Firmware and library"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#firmware", 
            "text": "This grove module has an ATmega168 MCU which is flashed with a factory firmware. The firmware does the following:   Controls the power on and off for heating circuit and indicator LED  Listens to the command that make the module do the calibration - the calibration will sample the resistance of the MEMS core of this sensor which will be used as the reference, so please perform calibration in a fresh air condition  Listens to commands that get resistance value of one of the three sensor core which will be used to calculate the concentration of a specific gas  Listens to the command that changing the I2C address of this module - at most time, you do not need to do this except that the I2C address of this module (0x04) conflicts with another slave module.    Note \nThe calibration has been done before the modules leave the factory. If you want to recalibrate, please do make sure that the air condition is fresh.", 
            "title": "Firmware"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#library", 
            "text": "The library reads resistance values from the module and calculate the concentration of gas. One thing must be noticed is, the readings of this sensor are not supposed to be used to distinguish the type of gases, but to measure the concentration of a specific gas which is known to be that kind of gas.  The cores of this sensor are more sensitive to CO, NO2 and NH3, the precision of measurement for other gases would be worse.   Note \nThe doCalibrate() function will take 8 seconds before it returns, as said above, at most time you don't need to recalibrate the sensor.", 
            "title": "Library"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#demonstration", 
            "text": "Hardware Installation:  1.Connect Grove - Multichannel Gas Sensor to Seeeduino.   Upload Code:  2.Download  Arduino Library   Grove/Xadow firmware  and install it to Arduino Library.  3.Open the code directly by the path:File -  Example -  Mutichannel_Gas_Sensor-  ReadSensorValue_Grove.  The code of ReadSensorValue_Grove is given below.      /*\n        This is a demo to test MutichannelGasSensor library\n        This code is running on Xadow-mainboard, and the I2C slave is Xadow-MutichannelGasSensor\n        There is a ATmega168PA on Xadow-MutichannelGasSensor, it get sensors output and feed back to master.\n        the data is raw ADC value, algorithm should be realized on master.\n\n        please feel free to write email to me if there is any question \n\n        Jacky Zhang, Embedded Software Engineer\n        qi.zhang@seeed.cc\n        17,mar,2015\n    */\n\n\n    #include  Wire.h \n    #include  MutichannelGasSensor.h \n\n    void setup()\n    {\n        Serial.begin(9600);  // start serial for output\n        Serial.println( power on! );\n\n        mutichannelGasSensor.begin(0x04);//the default I2C address of the slave is 0x04\n        //mutichannelGasSensor.changeI2cAddr(0x10);\n        //mutichannelGasSensor.doCalibrate();\n        //delay(8000);\n        while(mutichannelGasSensor.readR0()   0)\n        {\n            Serial.println( sensors init error!! );\n            delay(1000);\n        }\n        Serial.print( Res0[0]:  );\n        Serial.println(mutichannelGasSensor.res0[0]);\n        Serial.print( Res0[1]:  );\n        Serial.println(mutichannelGasSensor.res0[1]);\n        Serial.print( Res0[2]:  );\n        Serial.println(mutichannelGasSensor.res0[2]);\n        mutichannelGasSensor.powerOn();\n    }\n\n    void loop()\n    {\n        mutichannelGasSensor.readR();\n        Serial.print( Res[0]:  );\n        Serial.println(mutichannelGasSensor.res[0]);\n        Serial.print( Res[1]:  );\n        Serial.println(mutichannelGasSensor.res[1]);\n        Serial.print( Res[2]:  );\n        Serial.println(mutichannelGasSensor.res[2]);\n\n        mutichannelGasSensor.calcGas();\n        Serial.print( NH3:  );\n        Serial.print(mutichannelGasSensor.density_nh3);\n        Serial.println( ppm );\n        Serial.print( CO:  );\n        Serial.print(mutichannelGasSensor.density_co);\n        Serial.println( ppm );\n        Serial.print( NO2:  );\n        Serial.print(mutichannelGasSensor.density_no2);\n        Serial.println( ppm );\n\n        delay(1000);\n        Serial.println( ... );\n    }  4.Upload the code. Remember to select Seeeduino Uno from the Tools | Board menu of the Arduino environment, and select the correct serial port Arduino is using.  By opening the serial monitor, you can see the raw data read from sensor.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#resources", 
            "text": "Grove - Multichannel Gas Sensor v1.0 sch  Grove - Multichannel Gas Sensor eagle files  Arduino Library   Grove/Xadow firmware  MiCS-6814 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Multichannel_Gas_Sensor/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Piezo_Vibration_Sensor/", 
            "text": "Grove- Piezo Vibration Sensor is suitable for measurements of flexibility, vibration, impact and touch. The module is based on PZT film sensor LDT0-028. When the sensor moves back and forth, a certain voltage will be created by the voltage comparator inside of it. A wide dynamic range (0.001Hz~1000MHz) guarantees an excellent measuring performance. And, you can adjust its sensitivity by adjusting the on-board potentiometer with a screw.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nStandard grove socket\n\n\nWide dynamic range\uff1a0.1Hz~180Hz\n\n\nAdjustable sensitivity\n\n\nHigh receptivity for strong impact\n\n\n\n\nApplications\n\uf0c1\n\n\n\n\nVibration Sensing in Washing Machine\n\n\nLow Power Wakeup Switch\n\n\nLow Cost Vibration Sensing\n\n\nCar Alarms\n\n\nBody Movement\n\n\nSecurity Systems\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThe Grove - Piezo Vibration Sensor outputs a logic HIGH when vibration was detected. We can use any of Arduino pins to read the data. Here is an example of Piezo Vibration Sensor controlling LED. When the vibration was detected, this sensor outputs a logic high signal (the sensitivity can be changed by adjusting the potentiometer), an LED lights up.\n\n\n\n\nNote\n\nIt may output low level even though originally output high level when you increase the threshold voltage by clockwise adjusting the potentiometer.\n\n\n\n\n1.Connect the module to the Analog port 0 of base shield using the 4-pin grove cable and connect LED to Pin 12.\n\n\n2.Plug the Grove - Basic Shield into Arduino.\n\n\n3.Connect Arduino to PC by using a USB cable.\n\n\n4.Copy and paste code below to a new Arduino sketch. Please click \nhere\n if you do not know how to upload.\n\n\n    const int ledPin=12;\n    void setup() {\n      Serial.begin(9600);\n    pinMode(ledPin,OUTPUT);\n    } \n\n    void loop() {\n    int sensorValue = analogRead(A0);\n     Serial.println(sensorValue);\n     delay(1000);\n     if(sensorValue==1023)\n      {\n        digitalWrite(ledPin,HIGH);\n      }\n     else\n     {\n      digitalWrite(ledPin,LOW);\n      }\n    }\n\n\n\n\n5.Touch the piezo sensor to make it vibrate, of course, any way to make it vibrate would be OK too. The LED would be on when vibration detected. You can also Open the serial monitor to see the sensor outputs.\n\n\n\n\nYou can directly use a digital pin, take D5 of base shield as an example, and connect LED to Pin 12.\n\n\n    const int ledPin=12;\n    void setup() {\n      Serial.begin(9600);\n      pinMode(ledPin,OUTPUT);\n    } \n\n    void loop() {\n    int sensorState = digitalRead(5);\n     Serial.println(sensorState);\n     delay(1000);\n     if(sensorState == HIGH)\n      {\n        digitalWrite(ledPin,HIGH);\n      }\n     else\n     {\n      digitalWrite(ledPin,LOW);\n      }\n    }\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket A0 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_piezo_vibration_sensor.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Piezo Vibration Sensor to analog port A0\n    # OUT,NC,VCC,GND\n    piezo = 0\n\n    grovepi.pinMode(piezo,\nINPUT\n)\n\n    while True:\n        try:\n            # When vibration is detected, the sensor outputs a logic high signal\n            print grovepi.analogRead(piezo)\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_piezo_vibration_sensor.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Piezo Vibration Sensor Eagle File\n\n\nGrove - Piezo Vibration Sensor PDF File\n\n\nPiezo Vibration Sensor Datasheet", 
            "title": "Grove - Piezo Vibration Sensor"
        }, 
        {
            "location": "/Grove-Piezo_Vibration_Sensor/#features", 
            "text": "Standard grove socket  Wide dynamic range\uff1a0.1Hz~180Hz  Adjustable sensitivity  High receptivity for strong impact", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Piezo_Vibration_Sensor/#applications", 
            "text": "Vibration Sensing in Washing Machine  Low Power Wakeup Switch  Low Cost Vibration Sensing  Car Alarms  Body Movement  Security Systems", 
            "title": "Applications"
        }, 
        {
            "location": "/Grove-Piezo_Vibration_Sensor/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Piezo_Vibration_Sensor/#with-arduino", 
            "text": "The Grove - Piezo Vibration Sensor outputs a logic HIGH when vibration was detected. We can use any of Arduino pins to read the data. Here is an example of Piezo Vibration Sensor controlling LED. When the vibration was detected, this sensor outputs a logic high signal (the sensitivity can be changed by adjusting the potentiometer), an LED lights up.   Note \nIt may output low level even though originally output high level when you increase the threshold voltage by clockwise adjusting the potentiometer.  1.Connect the module to the Analog port 0 of base shield using the 4-pin grove cable and connect LED to Pin 12.  2.Plug the Grove - Basic Shield into Arduino.  3.Connect Arduino to PC by using a USB cable.  4.Copy and paste code below to a new Arduino sketch. Please click  here  if you do not know how to upload.      const int ledPin=12;\n    void setup() {\n      Serial.begin(9600);\n    pinMode(ledPin,OUTPUT);\n    } \n\n    void loop() {\n    int sensorValue = analogRead(A0);\n     Serial.println(sensorValue);\n     delay(1000);\n     if(sensorValue==1023)\n      {\n        digitalWrite(ledPin,HIGH);\n      }\n     else\n     {\n      digitalWrite(ledPin,LOW);\n      }\n    }  5.Touch the piezo sensor to make it vibrate, of course, any way to make it vibrate would be OK too. The LED would be on when vibration detected. You can also Open the serial monitor to see the sensor outputs.   You can directly use a digital pin, take D5 of base shield as an example, and connect LED to Pin 12.      const int ledPin=12;\n    void setup() {\n      Serial.begin(9600);\n      pinMode(ledPin,OUTPUT);\n    } \n\n    void loop() {\n    int sensorState = digitalRead(5);\n     Serial.println(sensorState);\n     delay(1000);\n     if(sensorState == HIGH)\n      {\n        digitalWrite(ledPin,HIGH);\n      }\n     else\n     {\n      digitalWrite(ledPin,LOW);\n      }\n    }", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Piezo_Vibration_Sensor/#with-raspberry-pi", 
            "text": "1.You should have a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket A0 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_piezo_vibration_sensor.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Piezo Vibration Sensor to analog port A0\n    # OUT,NC,VCC,GND\n    piezo = 0\n\n    grovepi.pinMode(piezo, INPUT )\n\n    while True:\n        try:\n            # When vibration is detected, the sensor outputs a logic high signal\n            print grovepi.analogRead(piezo)\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_piezo_vibration_sensor.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Piezo_Vibration_Sensor/#resources", 
            "text": "Grove - Piezo Vibration Sensor Eagle File  Grove - Piezo Vibration Sensor PDF File  Piezo Vibration Sensor Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/", 
            "text": "The Q Touch Sensor is a high sensitivity and high noise immunity touch input device. It is based on Atmel AT42QT1070. The AT42QT1070 modulates its bursts in a spread-spectrum fashion in order to heavily suppress the effects of external noise, and to suppress RF emissions. The QT1070 uses a dual-pulse method of acquisition. This provides greater noise immunity and eliminates the need for external sampling capacitors, allowing touch sensing using a single pin.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nOperating Voltage: 3 ~ 5.5V\n\n\nOperating Current @3.3V: 1mA\n\n\nTouch Keys: 7 Keys\u00a0; key0, key1, key2 are on the Grove PCB bottom side\n\n\nCommunicating Protocol: I2C\n\n\nI2C Address: 0x1B\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\u2460 - On board touch key0\n\n\n\u2461 - On board touch key1\n\n\n\u2462 - On board touch key2\n\n\n\u2463 - Touch key0 ~ key6 breakout\n\n\n\n\nThe recommended range for key capacitance Cx is 1 pF \u2013 30 pF. Larger values of Cx will give reduced sensitivity.\n\n\n\n\n\u2464 - GND\n\n\n\u2465 - Grove interface\n\n\nUsage\n\uf0c1\n\n\nDemo: Who touched my lychee?\n\n\nHave you ever heard of a lychee? Yes, it\ns a very famous fruit of south of China. If you have ever tasted, will love it.\n\n\nNow let us begin our demo. When you touch the hit pan (lychee),the LED will turn on.\n\n\nHardware Connections\n\uf0c1\n\n\n\n\nConnect the I2C of Grove-Q Touch Sensor to the I2C socket on the Grove Base Shield.\n\n\nConnect the Grove-LED to D3 (Digital Pin 3) on the Grove Base Shield.\n\n\nConnect Key0 (marked K0) on the Grove-Q Touch sensor to a Lychee (Alternatively, you could touch the open end of the cable with a finger while testing).\n\n\n\n\n\n\nSoftware Part\n\uf0c1\n\n\n\n\nDownload the \nQ Touch Library\n.\n\n\nUnzip it into the libraries folder of Arduino IDE, for example the path could be ..\\arduino-1.0.5\\libraries.\n\n\n\n\nExample 1\n\uf0c1\n\n\na. Open the example via Arduino Menu \nFile -\n Examples -\n Seeed_QTouch-master -\n Grove_QTouch_demoCode_v_1_0\n.\n\n\nb. Upload the code. Note that you should select the correct board type and COM port.\n\n\nc. On touching the Lychee, the LED would glow, as can be seen below.\n\n\n\n\nExample 2\n\uf0c1\n\n\na. Open the example via Arduino Menu \nFile -\n Examples -\n Seeed_QTouch-master -\n isTouch\n.\n\n\nb. Upload the code.\n\n\nc. Open the Serial Monitor.\n\n\nd. Touch and release the Lychee; The Serial Monitor would display the duration of touch as in the screenshot below.\n\n\n\n\nYou can try the \nCodebender\n widget below to upload the code as well.\n\n\n\n\n\nPlease open the Serial monitor below to view data.\n\n\n\n\n\nExample 3\n\uf0c1\n\n\na. Open the example via Arduino Menu \nFile -\n Examples -\n Seeed_QTouch-master -\n getTouchNumber\n.\n\n\nb. Upload the code.\n\n\nc. Open the Serial Monitor.\n\n\nd. On touching the Lychee, the Serial Monitor would display the Key that is connected, as in the screenshot below. One can connect the fruit to any other Key and verify.\n\n\n\n\nYou can try the \nCodebender\n widget below to upload the code as well.\n\n\n\n\n\nPlease open the Serial monitor below to view data.\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nQ Touch Library\n\n\nSchematic pdf\n\n\nEagle file\n\n\nAT42QT107 datasheet\n\n\nHow to detect finger touch?", 
            "title": "Grove - Q Touch Sensor"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#specifications", 
            "text": "Operating Voltage: 3 ~ 5.5V  Operating Current @3.3V: 1mA  Touch Keys: 7 Keys\u00a0; key0, key1, key2 are on the Grove PCB bottom side  Communicating Protocol: I2C  I2C Address: 0x1B", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#hardware-overview", 
            "text": "\u2460 - On board touch key0  \u2461 - On board touch key1  \u2462 - On board touch key2  \u2463 - Touch key0 ~ key6 breakout   The recommended range for key capacitance Cx is 1 pF \u2013 30 pF. Larger values of Cx will give reduced sensitivity.   \u2464 - GND  \u2465 - Grove interface", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#usage", 
            "text": "Demo: Who touched my lychee?  Have you ever heard of a lychee? Yes, it s a very famous fruit of south of China. If you have ever tasted, will love it.  Now let us begin our demo. When you touch the hit pan (lychee),the LED will turn on.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#hardware-connections", 
            "text": "Connect the I2C of Grove-Q Touch Sensor to the I2C socket on the Grove Base Shield.  Connect the Grove-LED to D3 (Digital Pin 3) on the Grove Base Shield.  Connect Key0 (marked K0) on the Grove-Q Touch sensor to a Lychee (Alternatively, you could touch the open end of the cable with a finger while testing).", 
            "title": "Hardware Connections"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#software-part", 
            "text": "Download the  Q Touch Library .  Unzip it into the libraries folder of Arduino IDE, for example the path could be ..\\arduino-1.0.5\\libraries.", 
            "title": "Software Part"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#example-1", 
            "text": "a. Open the example via Arduino Menu  File -  Examples -  Seeed_QTouch-master -  Grove_QTouch_demoCode_v_1_0 .  b. Upload the code. Note that you should select the correct board type and COM port.  c. On touching the Lychee, the LED would glow, as can be seen below.", 
            "title": "Example 1"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#example-2", 
            "text": "a. Open the example via Arduino Menu  File -  Examples -  Seeed_QTouch-master -  isTouch .  b. Upload the code.  c. Open the Serial Monitor.  d. Touch and release the Lychee; The Serial Monitor would display the duration of touch as in the screenshot below.   You can try the  Codebender  widget below to upload the code as well.   Please open the Serial monitor below to view data.", 
            "title": "Example 2"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#example-3", 
            "text": "a. Open the example via Arduino Menu  File -  Examples -  Seeed_QTouch-master -  getTouchNumber .  b. Upload the code.  c. Open the Serial Monitor.  d. On touching the Lychee, the Serial Monitor would display the Key that is connected, as in the screenshot below. One can connect the fruit to any other Key and verify.   You can try the  Codebender  widget below to upload the code as well.   Please open the Serial monitor below to view data.", 
            "title": "Example 3"
        }, 
        {
            "location": "/Grove-Q_Touch_Sensor/#resources", 
            "text": "Q Touch Library  Schematic pdf  Eagle file  AT42QT107 datasheet  How to detect finger touch?", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-RTC/", 
            "text": "The RTC module is based on the clock chip DS1307, which supports the I2C protocol. It utilizes a Lithium cell battery (CR1225). The clock/calendar provides seconds, minutes, hours, day, date, month, and year. The end of the month date is automatically adjusted for months with fewer than 31 days, including corrections for leap years. The clock operates in either the 24-hour or 12-hour format with AM/PM indicator. And it is valid up to 2100. In order to gain a robust performance, you must put a 3-Volt CR1225 lithium cell in the battery-holder. If you use the primary power only, the module may not work normally, because the crystal may not oscillate.\n\n\n\n\n\n\nNote\n\nThe battery is not included.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nPCB Size: 2.0cm*4.0cm\n\n\nInterface: 2.0mm pitch pin header\n\n\nIO Structure: SCL,SDA,VCC,GND\n\n\nROHS: YES\n\n\nVCC\uff1a3.3~5.5V\n\n\nLogic High Level Input \uff1a2.2~VCC+0.3 V\n\n\nLogic Low Level Input \uff1a-0.3~+0.8 V\n\n\nBattery Voltage\uff1a2.0~3.5 V\n\n\n\n\nDemonstration\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThe following sketch demonstrates a simple application of setting the time and reading it out.\n\n\n\n\nConnect the module to the I2C Interface of \nGrove- Base Shield\n.\n\n\nPlug Grove- Base Shield into Arduino.\n\n\nConnect Arduino to PC via a USB cable.\n\n\nDownload the \nRTC Library\n.\n\n\nUnzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries.\n\n\nOpen the code directly by the path:File -\n Example -\nRTC-\nSetTimeAndDisplay.\n\n\n\n\n    #include \nWire.h\n\n    #include \nDS1307.h\n\n\n    DS1307 clock;//define a object of DS1307 class\n    void setup()\n    {\n        Serial.begin(9600);\n        clock.begin();\n        clock.fillByYMD(2013,1,19);//Jan 19,2013\n        clock.fillByHMS(15,28,30);//15:28 30\n\n        clock.fillDayOfWeek(SAT);//Saturday\n        clock.setTime();//write time to the RTC chip\n    }\n    void loop()\n    {\n        printTime();\n    }\n    /*Function: Display time on the serial monitor*/\n    void printTime()\n    {\n        clock.getTime();\n        Serial.print(clock.hour, DEC);\n        Serial.print(\n:\n);\n        Serial.print(clock.minute, DEC);\n        Serial.print(\n:\n);\n        Serial.print(clock.second, DEC);\n        Serial.print(\n  \n);\n        Serial.print(clock.month, DEC);\n        Serial.print(\n/\n);\n        Serial.print(clock.dayOfMonth, DEC);\n        Serial.print(\n/\n);\n        Serial.print(clock.year+2000, DEC);\n        Serial.print(\n \n);\n        Serial.print(clock.dayOfMonth);\n        Serial.print(\n*\n);\n        switch (clock.dayOfWeek)// Friendly printout the weekday\n        {\n            case MON:\n              Serial.print(\nMON\n);\n              break;\n            case TUE:\n              Serial.print(\nTUE\n);\n              break;\n            case WED:\n              Serial.print(\nWED\n);\n              break;\n            case THU:\n              Serial.print(\nTHU\n);\n              break;\n            case FRI:\n              Serial.print(\nFRI\n);\n              break;\n            case SAT:\n              Serial.print(\nSAT\n);\n              break;\n            case SUN:\n              Serial.print(\nSUN\n);\n              break;\n        }\n        Serial.println(\n \n);\n    }\n\n\n\n\n\n\nSet the time. Put function arguments change to current date/time. The attention should be paid to the arguments format.\n\n\n\n\n        clock.fillByYMD(2013,1,19);//Jan 19,2013\n        clock.fillByHMS(15,28,30);//15:28 30\n\n        clock.fillDayOfWeek(SAT);//Saturday\n\n\n\n\n\n\nUpload the code.\n\n\nOpen the serial monitor to see the result.\n\n\n\n\n\n\nThe output time is changing like the clock.\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_i2c_rtc.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Real Time Clock to any I2C port eg. I2C-1\n    # Can be found at I2C address 0x68\n    # SCL,SDA,VCC,GND\n\n    while True:\n        try:\n            print grovepi.rtc_getTime()\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_i2c_rtc.py\n\n\n\n\n6.Result\n\n\n\n\n7.Use this demo to show the time in common\n\n\n    '''\n    /*\n     * Grove-RTC.py\n     * Demo for Raspberry Pi \n     *\n     * Copyright (c) 2014 seeed technology inc.\n     * Website   \u00a0: www.seeed.cc\n     * Author    \u00a0: Lambor\n     * Create Time: Nov 2014\n     * Change Log\u00a0:\n     *\n     * The MIT License (MIT)\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \nSoftware\n), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in\n     * all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     * THE SOFTWARE.\n     */\n    '''\n    #!/usr/bin/python\n    import time\n    import smbus\n\n\n    bus = smbus.SMBus(1)    # 0 = /dev/i2c-0 (port I2C0), 1 = /dev/i2c-1 (port I2C1)   \n\n    class DS1307():     \n        def __init__(self):\n            self.MON = 1\n            self.TUE = 2\n            self.WED = 3\n            self.THU = 4\n            self.FRI = 5\n            self.SAT = 6\n            self.SUN = 7\n            self.DS1307_I2C_ADDRESS = 0x68\n\n            print 'begin' \n\n        def decToBcd(self, val):\n            return ( (val/10*16) + (val%10) )\n\n        def bcdToDec(self,  val):\n            return ( (val/16*10) + (val%16) )\n\n        def begin(self, news):\n            print news\n\n        def startClock(self):   \n            bus.write_byte(self.DS1307_I2C_ADDRESS, 0x00)\n            self.second = bus.read_byte(self.DS1307_I2C_ADDRESS) \n 0x7f\n            bus.write_byte_data(self.DS1307_I2C_ADDRESS, 0x00, self.second)\n\n            print 'startClock..'\n\n        def stopClock(self):                        \n            bus.write_byte(self.DS1307_I2C_ADDRESS, 0x00)\n            self.second = bus.read_byte(self.DS1307_I2C_ADDRESS) | 0x80\n            bus.write_byte_data(self.DS1307_I2C_ADDRESS, 0x00, self.second)         \n\n            print 'stopClock..'\n\n        def setTime(self):\n            data = [self.decToBcd(self.second), self.decToBcd(self.minute), \\\n                    self.decToBcd(self.hour), self.decToBcd(self.dayOfWeek), \\\n                    self.decToBcd(self.dayOfMonth), self.decToBcd(self.month), \\\n                    self.decToBcd(self.year)]\n\n            bus.write_byte(self.DS1307_I2C_ADDRESS, 0x00)\n            bus.write_i2c_block_data(self.DS1307_I2C_ADDRESS,0x00,data)\n\n            print 'setTime..'\n\n        def getTime(self):\n            bus.write_byte(self.DS1307_I2C_ADDRESS, 0x00)\n            data = bus.read_i2c_block_data(self.DS1307_I2C_ADDRESS,0x00)\n            #A few of these need masks because certain bits are control bits\n            self.second = self.bcdToDec(data[0] \n 0x7f)\n            self.minute = self.bcdToDec(data[1])\n            self.hour = self.bcdToDec(data[2] \n 0x3f)  #Need to change this if 12 hour am/pm\n            self.dayOfWeek = self.bcdToDec(data[3])\n            self.dayOfMonth = self.bcdToDec(data[4])\n            self.month = self.bcdToDec(data[5])\n            self.year = self.bcdToDec(data[6])\n\n            print 'getTime..'\n\n        def fillByHMS(self, _hour,  _minute,  _second):\n            self.hour = _hour\n            self.minute = _minute\n            self.second = _second\n\n            print 'fillByHMS..'\n\n        def fillByYMD(self, _year,  _month,  _day):     \n            self.year = _year - 2000\n            self.month = _month;\n            self.dayOfMonth = _day\n\n            print 'fillByYMD..'\n\n        def fillDayOfWeek(self,  _dow):     \n            self.dayOfWeek = _dow\n\n            print 'fillDayOfWeek..'\n\n    if __name__ == \n__main__\n: \n        clock = DS1307()\n        clock.fillByYMD(2015,3,5)\n        clock.fillByHMS(12,42,30)\n        clock.fillDayOfWeek(clock.THU)  \n        clock.setTime()\n        while True:     \n            clock.getTime()\n            print clock.hour, \n:\n, clock.minute, \n:\n, \\\n                    clock.second, \n \n, clock.dayOfMonth, \n/\n, \\\n                    clock.month, \n/\n, clock.year,\n  \n, \nweekday\n, \\\n                    \n:\n, clock.dayOfWeek            \n            time.sleep(1)\n\n\n\n\n8.Create grove_rtc.py and copy codes above.\n\n\n9.Run the code\n\n\n    sudo python grove_rtc.py\n\n\n\n\n10.Result\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nReal Time Clock Eagle File\n\n\nGithub repository for RTC\n\n\nDS1307 Datasheet", 
            "title": "Grove - RTC"
        }, 
        {
            "location": "/Grove-RTC/#specifications", 
            "text": "PCB Size: 2.0cm*4.0cm  Interface: 2.0mm pitch pin header  IO Structure: SCL,SDA,VCC,GND  ROHS: YES  VCC\uff1a3.3~5.5V  Logic High Level Input \uff1a2.2~VCC+0.3 V  Logic Low Level Input \uff1a-0.3~+0.8 V  Battery Voltage\uff1a2.0~3.5 V", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-RTC/#demonstration", 
            "text": "", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-RTC/#with-arduino", 
            "text": "The following sketch demonstrates a simple application of setting the time and reading it out.   Connect the module to the I2C Interface of  Grove- Base Shield .  Plug Grove- Base Shield into Arduino.  Connect Arduino to PC via a USB cable.  Download the  RTC Library .  Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries.  Open the code directly by the path:File -  Example - RTC- SetTimeAndDisplay.       #include  Wire.h \n    #include  DS1307.h \n\n    DS1307 clock;//define a object of DS1307 class\n    void setup()\n    {\n        Serial.begin(9600);\n        clock.begin();\n        clock.fillByYMD(2013,1,19);//Jan 19,2013\n        clock.fillByHMS(15,28,30);//15:28 30 \n        clock.fillDayOfWeek(SAT);//Saturday\n        clock.setTime();//write time to the RTC chip\n    }\n    void loop()\n    {\n        printTime();\n    }\n    /*Function: Display time on the serial monitor*/\n    void printTime()\n    {\n        clock.getTime();\n        Serial.print(clock.hour, DEC);\n        Serial.print( : );\n        Serial.print(clock.minute, DEC);\n        Serial.print( : );\n        Serial.print(clock.second, DEC);\n        Serial.print(    );\n        Serial.print(clock.month, DEC);\n        Serial.print( / );\n        Serial.print(clock.dayOfMonth, DEC);\n        Serial.print( / );\n        Serial.print(clock.year+2000, DEC);\n        Serial.print(   );\n        Serial.print(clock.dayOfMonth);\n        Serial.print( * );\n        switch (clock.dayOfWeek)// Friendly printout the weekday\n        {\n            case MON:\n              Serial.print( MON );\n              break;\n            case TUE:\n              Serial.print( TUE );\n              break;\n            case WED:\n              Serial.print( WED );\n              break;\n            case THU:\n              Serial.print( THU );\n              break;\n            case FRI:\n              Serial.print( FRI );\n              break;\n            case SAT:\n              Serial.print( SAT );\n              break;\n            case SUN:\n              Serial.print( SUN );\n              break;\n        }\n        Serial.println(   );\n    }   Set the time. Put function arguments change to current date/time. The attention should be paid to the arguments format.           clock.fillByYMD(2013,1,19);//Jan 19,2013\n        clock.fillByHMS(15,28,30);//15:28 30 \n        clock.fillDayOfWeek(SAT);//Saturday   Upload the code.  Open the serial monitor to see the result.    The output time is changing like the clock.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-RTC/#with-raspberry-pi", 
            "text": "1.You should have a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_i2c_rtc.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Real Time Clock to any I2C port eg. I2C-1\n    # Can be found at I2C address 0x68\n    # SCL,SDA,VCC,GND\n\n    while True:\n        try:\n            print grovepi.rtc_getTime()\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_i2c_rtc.py  6.Result   7.Use this demo to show the time in common      '''\n    /*\n     * Grove-RTC.py\n     * Demo for Raspberry Pi \n     *\n     * Copyright (c) 2014 seeed technology inc.\n     * Website   \u00a0: www.seeed.cc\n     * Author    \u00a0: Lambor\n     * Create Time: Nov 2014\n     * Change Log\u00a0:\n     *\n     * The MIT License (MIT)\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the  Software ), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in\n     * all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     * THE SOFTWARE.\n     */\n    '''\n    #!/usr/bin/python\n    import time\n    import smbus\n\n\n    bus = smbus.SMBus(1)    # 0 = /dev/i2c-0 (port I2C0), 1 = /dev/i2c-1 (port I2C1)   \n\n    class DS1307():     \n        def __init__(self):\n            self.MON = 1\n            self.TUE = 2\n            self.WED = 3\n            self.THU = 4\n            self.FRI = 5\n            self.SAT = 6\n            self.SUN = 7\n            self.DS1307_I2C_ADDRESS = 0x68\n\n            print 'begin' \n\n        def decToBcd(self, val):\n            return ( (val/10*16) + (val%10) )\n\n        def bcdToDec(self,  val):\n            return ( (val/16*10) + (val%16) )\n\n        def begin(self, news):\n            print news\n\n        def startClock(self):   \n            bus.write_byte(self.DS1307_I2C_ADDRESS, 0x00)\n            self.second = bus.read_byte(self.DS1307_I2C_ADDRESS)   0x7f\n            bus.write_byte_data(self.DS1307_I2C_ADDRESS, 0x00, self.second)\n\n            print 'startClock..'\n\n        def stopClock(self):                        \n            bus.write_byte(self.DS1307_I2C_ADDRESS, 0x00)\n            self.second = bus.read_byte(self.DS1307_I2C_ADDRESS) | 0x80\n            bus.write_byte_data(self.DS1307_I2C_ADDRESS, 0x00, self.second)         \n\n            print 'stopClock..'\n\n        def setTime(self):\n            data = [self.decToBcd(self.second), self.decToBcd(self.minute), \\\n                    self.decToBcd(self.hour), self.decToBcd(self.dayOfWeek), \\\n                    self.decToBcd(self.dayOfMonth), self.decToBcd(self.month), \\\n                    self.decToBcd(self.year)]\n\n            bus.write_byte(self.DS1307_I2C_ADDRESS, 0x00)\n            bus.write_i2c_block_data(self.DS1307_I2C_ADDRESS,0x00,data)\n\n            print 'setTime..'\n\n        def getTime(self):\n            bus.write_byte(self.DS1307_I2C_ADDRESS, 0x00)\n            data = bus.read_i2c_block_data(self.DS1307_I2C_ADDRESS,0x00)\n            #A few of these need masks because certain bits are control bits\n            self.second = self.bcdToDec(data[0]   0x7f)\n            self.minute = self.bcdToDec(data[1])\n            self.hour = self.bcdToDec(data[2]   0x3f)  #Need to change this if 12 hour am/pm\n            self.dayOfWeek = self.bcdToDec(data[3])\n            self.dayOfMonth = self.bcdToDec(data[4])\n            self.month = self.bcdToDec(data[5])\n            self.year = self.bcdToDec(data[6])\n\n            print 'getTime..'\n\n        def fillByHMS(self, _hour,  _minute,  _second):\n            self.hour = _hour\n            self.minute = _minute\n            self.second = _second\n\n            print 'fillByHMS..'\n\n        def fillByYMD(self, _year,  _month,  _day):     \n            self.year = _year - 2000\n            self.month = _month;\n            self.dayOfMonth = _day\n\n            print 'fillByYMD..'\n\n        def fillDayOfWeek(self,  _dow):     \n            self.dayOfWeek = _dow\n\n            print 'fillDayOfWeek..'\n\n    if __name__ ==  __main__ : \n        clock = DS1307()\n        clock.fillByYMD(2015,3,5)\n        clock.fillByHMS(12,42,30)\n        clock.fillDayOfWeek(clock.THU)  \n        clock.setTime()\n        while True:     \n            clock.getTime()\n            print clock.hour,  : , clock.minute,  : , \\\n                    clock.second,    , clock.dayOfMonth,  / , \\\n                    clock.month,  / , clock.year,    ,  weekday , \\\n                     : , clock.dayOfWeek            \n            time.sleep(1)  8.Create grove_rtc.py and copy codes above.  9.Run the code      sudo python grove_rtc.py  10.Result", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-RTC/#resources", 
            "text": "Real Time Clock Eagle File  Github repository for RTC  DS1307 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/", 
            "text": "The Grove - Slide Potentiometer module incorporates a linear variable resistor with a maximum resistance of 10K\u03a9. When you move the slider from one side to the other, its output voltage will range from 0 V to the Vcc you apply. It connects to the other Grove modules through a standard 4-Pin \nGrove Cable\n. Three of the pins are connected to OUT (Pin 1), Vcc (Pin 3) and GND (Pin 4), while the fourth pin (Pin 2) is connected to a on-board green indicator LED. The LED is used to visually represent the resistance change on the potentiometer.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n30 mm long slide length\n\n\nLinear resistance taper\n\n\nGrove compatible\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\nHere are some projects for your reference.\n\n\n\n\n\n\n\n\nArduino BoomBox\n\n\nArduino BeatBox\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it NOW!\n\n\nMake it NOW!\n\n\n\n\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\n\n\n\n\nVoltage (DC)\n\n\n\n\n3.3V\n\n\n\n\n5.0V\n\n\n\n\n30V\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n-\n\n\n\n\n-\n\n\n\n\n30mA\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n24mm x60mm\n\n\n\n\n\n\n\n\nNet Weight\n\n\n\n\n8.6g\n\n\n\n\n\n\n\n\nRotational life\n\n\n\n\n\n15,000 cycles\n\n\n\n\n\n\n\n\nTotal resistance\n\n\n\n\n10K\u03a9\n\n\n\n\n\n\n\n\nStroke length\n\n\n\n\n30mm\n\n\n\n\n\n\n\n\nTotal resistance tolerance\n\n\n\n\n+/- 20%\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nAs an Adjustable Resistor\n\uf0c1\n\n\nAs shown below, the Grove - Slide Potentiometer can be used as a simple slide potentiometer in any MCU controlled or stand-alone project.\n\n\n\nStandalone\n\uf0c1\n\n\nFollow these steps to build a sample Grove circuit using this module but without using any microcontroller board:\n\n\n\n\nConnect the slide potentiometer module to the input side of your circuit (to the left of the power module). On the output side of the circuit, you may use a range of User Interface modules (Grove - Red LED, Grove - LED String Light, Grove - Mini Fan, Grove - Buzzer, Grove - Recorder etc.)\n\n\nPower up the circuit when complete.\n\n\n\n\nThe slide potentiometer module can now be used to trigger an output. For example:\n\n\n\n\nWhen used in conjunction with a Grove - Red LED output module, observe that the brightness of the LED increases as you move the slider from GND to Vcc. At Vcc, the resistance of the potentiometer is minimum and the LED burns the brightest. The same behavior can be seen when the slide potentiometer is used with the Grove - LED String Light module - the more voltage you apply by taking the slider towards the Vcc mark, the brighter the LED lights would become.\n\n\nSimilarly, you can use the slide potentiometer to vary the speed of your Grove - Mini Fan or the frequency with which your Grove - Buzzer module sounds\n\n\nThe slide potentiometer can also be used as an ON/OFF switch for any circuit. Take the slider to the Vcc position to switch it ON and move it down to GND to switch OFF a circuit.\n\n\n\n\n\n\n\n\nIn terms of choosing a power module, you can use either the Grove - USB Power module or the Grove - DC Jack Power module for building standalone Grove circuits.\n\n\nWith \nArduino\n\uf0c1\n\n\nAs a Voltage Divider\n\uf0c1\n\n\nFollow these simple steps to make the slide potentiometer module function as a voltage divider:\n\n\n1.When using the module in conjunction with an \nArduino\n or a \nSeeeduino\n, use the Grove - Base Shield and connect the Grove - Slide Potentiometer module to the shield using a designated Grove Interface (e.g. Analog Port 0 as shown below).\n\n\n\n\n2.Connect the board to PC using USB cable.\n\n\n3.Upload the following sample sketch.\n\n\nint adcPin = A0; // select the input pin for the potentiometer\nint ledPin = A1; // select the pin for the LED\nint adcIn = 0;   // variable to store the value coming from the sensor\nvoid setup()\n{\n    Serial.begin(9600); // init serial to 9600b/s\n    pinMode(ledPin, OUTPUT); // set ledPin to OUTPUT\n    Serial.println(\nSliding Potentiometer Test Code!!\n);\n}\nvoid loop()\n{\n    // read the value from the sensor:\n    adcIn = analogRead(adcPin);\n    if(adcIn \ngt;= 500) digitalWrite(ledPin,HIGH);  // if adc in \ngt; 500, led light\n    else digitalWrite(ledPin, LOW);\n    Serial.println(adcIn);\n    delay(100);\n}\n\n\n\n\n4.Open the serial monitor. You should see some data from ADC.\n\n\n\n\n5.Move the lever back and forth. The serial data will change correspondingly. When the output resistance exceeds a certain preset value, the on-board indicator LED will also light up.\n\n\nAs an HID Device\n\uf0c1\n\n\nSlide Potentiometer can be an effective Human Interface Device (HID) and can be used, for example, in the radio controller of a Radio Controlled toy car. The picture below shows two Slide Potentiometers on the control panel - one to control the speed of the left wheel, and the other to control the speed of the right wheel of the toy car respectively. Now you can change the speeds of both motors and see the behavior. You will see that if you make the right wheel spin faster than the left wheel, the car will turn rightwards, and if you make the left wheel spin faster than the right wheel, the car will turn leftwards.\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket A0 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_slide_potentiometer.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Slide Potentiometer to analog port A0\n    # OUT,LED,VCC,GND\n    slide = 0   # pin 1 (yellow wire)\n\n    # The device has an onboard LED accessible as pin 2 on port A0\n    # OUT,LED,VCC,GND\n    led = 1     # pin 2 (white wire)\n\n    grovepi.pinMode(slide,\nINPUT\n)\n    grovepi.pinMode(led,\nOUTPUT\n)\n    time.sleep(1)\n\n    while True:\n        try:\n            # Read sensor value from potentiometer\n            sensor_value = grovepi.analogRead(slide)\n\n            # Illuminate onboard LED\n            if sensor_value \n 500:\n                grovepi.digitalWrite(led,1)\n            else:\n                grovepi.digitalWrite(led,0)\n\n            print \nsensor_value =\n, sensor_value\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_slide_potentiometer.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSliding Potentiometer Eagle File\n\n\nSliding Potentiometer in PDF\n\n\nSliding Potentiometer datasheet", 
            "title": "Grove - Slide Potentiometer"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#features", 
            "text": "30 mm long slide length  Linear resistance taper  Grove compatible", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#application-ideas", 
            "text": "Here are some projects for your reference.     Arduino BoomBox  Arduino BeatBox          Make it NOW!  Make it NOW!", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax    \nVoltage (DC)  \n3.3V  \n5.0V  \n30V    \nCurrent  \n-  \n-  \n30mA    \nDimension  \n24mm x60mm    \nNet Weight  \n8.6g    \nRotational life   15,000 cycles    \nTotal resistance  \n10K\u03a9    \nStroke length  \n30mm    \nTotal resistance tolerance  \n+/- 20%", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#as-an-adjustable-resistor", 
            "text": "As shown below, the Grove - Slide Potentiometer can be used as a simple slide potentiometer in any MCU controlled or stand-alone project.", 
            "title": "As an Adjustable Resistor"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#standalone", 
            "text": "Follow these steps to build a sample Grove circuit using this module but without using any microcontroller board:   Connect the slide potentiometer module to the input side of your circuit (to the left of the power module). On the output side of the circuit, you may use a range of User Interface modules (Grove - Red LED, Grove - LED String Light, Grove - Mini Fan, Grove - Buzzer, Grove - Recorder etc.)  Power up the circuit when complete.   The slide potentiometer module can now be used to trigger an output. For example:   When used in conjunction with a Grove - Red LED output module, observe that the brightness of the LED increases as you move the slider from GND to Vcc. At Vcc, the resistance of the potentiometer is minimum and the LED burns the brightest. The same behavior can be seen when the slide potentiometer is used with the Grove - LED String Light module - the more voltage you apply by taking the slider towards the Vcc mark, the brighter the LED lights would become.  Similarly, you can use the slide potentiometer to vary the speed of your Grove - Mini Fan or the frequency with which your Grove - Buzzer module sounds  The slide potentiometer can also be used as an ON/OFF switch for any circuit. Take the slider to the Vcc position to switch it ON and move it down to GND to switch OFF a circuit.     In terms of choosing a power module, you can use either the Grove - USB Power module or the Grove - DC Jack Power module for building standalone Grove circuits.", 
            "title": "Standalone"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#with-arduino", 
            "text": "", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#as-a-voltage-divider", 
            "text": "Follow these simple steps to make the slide potentiometer module function as a voltage divider:  1.When using the module in conjunction with an  Arduino  or a  Seeeduino , use the Grove - Base Shield and connect the Grove - Slide Potentiometer module to the shield using a designated Grove Interface (e.g. Analog Port 0 as shown below).   2.Connect the board to PC using USB cable.  3.Upload the following sample sketch.  int adcPin = A0; // select the input pin for the potentiometer\nint ledPin = A1; // select the pin for the LED\nint adcIn = 0;   // variable to store the value coming from the sensor\nvoid setup()\n{\n    Serial.begin(9600); // init serial to 9600b/s\n    pinMode(ledPin, OUTPUT); // set ledPin to OUTPUT\n    Serial.println( Sliding Potentiometer Test Code!! );\n}\nvoid loop()\n{\n    // read the value from the sensor:\n    adcIn = analogRead(adcPin);\n    if(adcIn  gt;= 500) digitalWrite(ledPin,HIGH);  // if adc in  gt; 500, led light\n    else digitalWrite(ledPin, LOW);\n    Serial.println(adcIn);\n    delay(100);\n}  4.Open the serial monitor. You should see some data from ADC.   5.Move the lever back and forth. The serial data will change correspondingly. When the output resistance exceeds a certain preset value, the on-board indicator LED will also light up.", 
            "title": "As a Voltage Divider"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#as-an-hid-device", 
            "text": "Slide Potentiometer can be an effective Human Interface Device (HID) and can be used, for example, in the radio controller of a Radio Controlled toy car. The picture below shows two Slide Potentiometers on the control panel - one to control the speed of the left wheel, and the other to control the speed of the right wheel of the toy car respectively. Now you can change the speeds of both motors and see the behavior. You will see that if you make the right wheel spin faster than the left wheel, the car will turn rightwards, and if you make the left wheel spin faster than the right wheel, the car will turn leftwards.", 
            "title": "As an HID Device"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket A0 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_slide_potentiometer.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Slide Potentiometer to analog port A0\n    # OUT,LED,VCC,GND\n    slide = 0   # pin 1 (yellow wire)\n\n    # The device has an onboard LED accessible as pin 2 on port A0\n    # OUT,LED,VCC,GND\n    led = 1     # pin 2 (white wire)\n\n    grovepi.pinMode(slide, INPUT )\n    grovepi.pinMode(led, OUTPUT )\n    time.sleep(1)\n\n    while True:\n        try:\n            # Read sensor value from potentiometer\n            sensor_value = grovepi.analogRead(slide)\n\n            # Illuminate onboard LED\n            if sensor_value   500:\n                grovepi.digitalWrite(led,1)\n            else:\n                grovepi.digitalWrite(led,0)\n\n            print  sensor_value = , sensor_value\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_slide_potentiometer.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Slide_Potentiometer/#resources", 
            "text": "Sliding Potentiometer Eagle File  Sliding Potentiometer in PDF  Sliding Potentiometer datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Sound_Sensor/", 
            "text": "Grove - Sound Sensor can detect the sound strength of the environment. The main component of the module is a simple microphone, which is based on the LM358 amplifier and an electret microphone. This module\ns output is analog and can be easily sampled and tested by a Seeeduino. \n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nEasy to use \n\n\nProvides analog output signal\n\n\nEasily integrates with Logic modules on the input side of Grove circuits\n\n\nGrove System\n\n\n\n\n\n\nWarning\n\n\nThis sound sensor is to detect if there\ns sound surround or not, please don\nt use the module to collect sound signal. Such as you can use it to make a sound control lamp, but not as a recording device.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating Voltage Range\n\n\n3.3/5 V\n\n\n\n\n\n\nOperating Current(Vcc=5V)\n\n\n4~5 mA\n\n\n\n\n\n\nVoltage Gain(V=6V, f=1kHz)\n\n\n26 dB\n\n\n\n\n\n\nMicrophone sensitivity(1kHz)\n\n\n52-48 dB\n\n\n\n\n\n\nMicrophone Impedance\n\n\n2.2k Ohm\n\n\n\n\n\n\nMicrophone Frequency\n\n\n16-20 kHz\n\n\n\n\n\n\nMicrophone S/N Radio\n\n\n54 dB\n\n\n\n\n\n\n\n\nPlatform Support\n\uf0c1\n\n\n\n\n\n\n\n\nArduino\n\n\nWio\n\n\nBeagleBone\n\n\nRaspberry Pi\n\n\nLinkIt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\nNote\n\n\nThis chapter is based on Win10 and Arduino IDE 1.6.9\n\n\n\n\nThis an easy-to-use module, what you need to do is connect the signal pin (the YELLOW pin of Grove cable) to the ADC input of your controller. If there\ns no internal ADC in your controller, \nGrove - I2C ADC\n is recommend. \n\n\nHere we will show you how this Grove - Sound Sensor works via a simple demo. First of all, you need to prepare the below stuffs:\n\n\n\n\n\n\n\n\nSeeeduino V4\n\n\nGrove - Sound Sensor\n\n\nBase Shield\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\n\n\n\n\n\n\nConnection\n\uf0c1\n\n\nThanks to the benefit of Grove series modules, you don\nt need to make soldering or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have only one Grove module. \n\n\n\n\nGrove - Sound Sensor is an analog output module, we connect it to \nA0\n at this demo\n\n\n\n\n\n\nUpload the code to Arduino\n\uf0c1\n\n\nCopy the below code to Arduino IDE.\n\n\n// test code for Grove - Sound Sensor\n// loovee @ 2016-8-30\n\nconst int pinAdc = A0;\n\nvoid setup()\n{\n    Serial.begin(115200);\n    //Serial.println(\nGrove - Sound Sensor Test...\n);\n}\n\nvoid loop()\n{\n    long sum = 0;\n    for(int i=0; i\n32; i++)\n    {\n        sum += analogRead(pinAdc);\n    }\n\n    sum \n= 5;\n\n    Serial.println(sum);\n    delay(10);\n}\n\n\n\n\n\nThen choose the right Board and COM port, and then click on the Upload button, this process take few seconds. \n\n\nGet Raw Data\n\uf0c1\n\n\nHere let\ns click on \nSerial \n Plotter\n to get the changing curve of the sensor. Please make a noise to view the change of the value. \n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic in Eagle File\n\n\nGithub Page of this Document", 
            "title": "Grove - Sound Sensor"
        }, 
        {
            "location": "/Grove-Sound_Sensor/#features", 
            "text": "Easy to use   Provides analog output signal  Easily integrates with Logic modules on the input side of Grove circuits  Grove System    Warning  This sound sensor is to detect if there s sound surround or not, please don t use the module to collect sound signal. Such as you can use it to make a sound control lamp, but not as a recording device.", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Sound_Sensor/#specifications", 
            "text": "Item  Value      Operating Voltage Range  3.3/5 V    Operating Current(Vcc=5V)  4~5 mA    Voltage Gain(V=6V, f=1kHz)  26 dB    Microphone sensitivity(1kHz)  52-48 dB    Microphone Impedance  2.2k Ohm    Microphone Frequency  16-20 kHz    Microphone S/N Radio  54 dB", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Sound_Sensor/#platform-support", 
            "text": "Arduino  Wio  BeagleBone  Raspberry Pi  LinkIt", 
            "title": "Platform Support"
        }, 
        {
            "location": "/Grove-Sound_Sensor/#getting-started", 
            "text": "Note  This chapter is based on Win10 and Arduino IDE 1.6.9   This an easy-to-use module, what you need to do is connect the signal pin (the YELLOW pin of Grove cable) to the ADC input of your controller. If there s no internal ADC in your controller,  Grove - I2C ADC  is recommend.   Here we will show you how this Grove - Sound Sensor works via a simple demo. First of all, you need to prepare the below stuffs:     Seeeduino V4  Grove - Sound Sensor  Base Shield           Get ONE Now  Get ONE Now  Get ONE Now", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Sound_Sensor/#connection", 
            "text": "Thanks to the benefit of Grove series modules, you don t need to make soldering or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have only one Grove module.    Grove - Sound Sensor is an analog output module, we connect it to  A0  at this demo", 
            "title": "Connection"
        }, 
        {
            "location": "/Grove-Sound_Sensor/#upload-the-code-to-arduino", 
            "text": "Copy the below code to Arduino IDE.  // test code for Grove - Sound Sensor\n// loovee @ 2016-8-30\n\nconst int pinAdc = A0;\n\nvoid setup()\n{\n    Serial.begin(115200);\n    //Serial.println( Grove - Sound Sensor Test... );\n}\n\nvoid loop()\n{\n    long sum = 0;\n    for(int i=0; i 32; i++)\n    {\n        sum += analogRead(pinAdc);\n    }\n\n    sum  = 5;\n\n    Serial.println(sum);\n    delay(10);\n}  Then choose the right Board and COM port, and then click on the Upload button, this process take few seconds.", 
            "title": "Upload the code to Arduino"
        }, 
        {
            "location": "/Grove-Sound_Sensor/#get-raw-data", 
            "text": "Here let s click on  Serial   Plotter  to get the changing curve of the sensor. Please make a noise to view the change of the value.", 
            "title": "Get Raw Data"
        }, 
        {
            "location": "/Grove-Sound_Sensor/#resources", 
            "text": "Schematic in Eagle File  Github Page of this Document", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Switch-P/", 
            "text": "This Grove \u2013 Switch is a mini SPDT slide, great for \u201cON/OFF\u201d situations. It is such a reliable switch of great build quality that we adopt it on many of our boards. You should stock some for your Grove prototyping system.\n\n\nWhat does \u201cP\u201d mean? \u201cP\u201d is for \u201cpanel mount\u201d in this product.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove Interface\n\n\nEasy to use\n\n\nBasic Grove element\n\n\n\n\nUsage\n\uf0c1\n\n\nBelow is a simple example showing how to use a switch to turn on/off an LED.The working principle and use just the same as the \nGrove-Button\n.\n\n\n\n\nConnect the Grove-LED to the Digital 13 of Grove - Basic Shield and connect the Grove -Switch(P) to the Digital 2 of \nGrove-Base Shield\n with two Grove cables.\n\n\nPlug the Grove - Base Shield into Arduino and connect Arduino to PC by using a USB cable.\n\n\nCopy and paste code below to a new Arduino sketch. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n    // constants won't change. They're used here to \n    // set pin numbers:\n    const int switchPin = 2;     // the number of the pushbutton pin\n    const int ledPin =  13;      // the number of the LED pin\n\n    // variables will change:\n    int switchState = 0;         // variable for reading the pushbutton status\n\n    void setup() {\n      // initialize the LED pin as an output:\n      //pinMode(ledPin, OUTPUT);      \n      // initialize the switch pin as an input:\n      Serial.begin(9600);\n      pinMode(switchPin, INPUT);     \n    }\n    void loop(){\n      // read the state of the switch value:\n      switchState = digitalRead(switchPin);\n\n\n      if (switchState == HIGH) {     \n        // turn LED on:    \n       // digitalWrite(ledPin, HIGH);  \n       Serial.println(\nswitch high!\n);\n      } \n      else {\n        // turn LED off:\n       // digitalWrite(ledPin, LOW); \n       Serial.println(\nswitch low\n);\n      }\n    }\n\n\n\n\n\nAfter uploading the code, you can see the led will light up when the switch is at \nhigh\n side.\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Switch(P) Eagle File", 
            "title": "Grove - Switch(P)"
        }, 
        {
            "location": "/Grove-Switch-P/#features", 
            "text": "Grove Interface  Easy to use  Basic Grove element", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Switch-P/#usage", 
            "text": "Below is a simple example showing how to use a switch to turn on/off an LED.The working principle and use just the same as the  Grove-Button .   Connect the Grove-LED to the Digital 13 of Grove - Basic Shield and connect the Grove -Switch(P) to the Digital 2 of  Grove-Base Shield  with two Grove cables.  Plug the Grove - Base Shield into Arduino and connect Arduino to PC by using a USB cable.  Copy and paste code below to a new Arduino sketch. Please click  here  if you do not know how to upload.   \n    // constants won't change. They're used here to \n    // set pin numbers:\n    const int switchPin = 2;     // the number of the pushbutton pin\n    const int ledPin =  13;      // the number of the LED pin\n\n    // variables will change:\n    int switchState = 0;         // variable for reading the pushbutton status\n\n    void setup() {\n      // initialize the LED pin as an output:\n      //pinMode(ledPin, OUTPUT);      \n      // initialize the switch pin as an input:\n      Serial.begin(9600);\n      pinMode(switchPin, INPUT);     \n    }\n    void loop(){\n      // read the state of the switch value:\n      switchState = digitalRead(switchPin);\n\n\n      if (switchState == HIGH) {     \n        // turn LED on:    \n       // digitalWrite(ledPin, HIGH);  \n       Serial.println( switch high! );\n      } \n      else {\n        // turn LED off:\n       // digitalWrite(ledPin, LOW); \n       Serial.println( switch low );\n      }\n    }  After uploading the code, you can see the led will light up when the switch is at  high  side.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Switch-P/#resources", 
            "text": "Grove - Switch(P) Eagle File", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Touch_Sensor/", 
            "text": "Grove - Touch Sensor enables you to replace press with touch. It can detect the change in capacitance when a finger is near by. That means no matter your finger directly touches the pad or just stays close to the pad, Grove - Touch Sensor would outputs HIGH also.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nOperating Voltage: 2.0 - 5.5V\n\n\nOperating Current(Vcc=3V):1.5 - 3.0\u03bcA\n\n\nOperating Current(VDD=3V):3.5 - 7.0\u03bcA\n\n\nOutput Response Time: 60 - 220mS\n\n\nUsed Chipset: TTP223-BA6\n\n\n\n\nOption features\n\n\n\n\n\n\n\n\nAHLB\n\n\nTOG\n\n\nLPMB\n\n\nMOTB\n\n\nSLRFTB\n\n\nRST\n\n\nQ\n\n\nOPDO\n\n\n\n\n\n\n\n\n\n\nOutput Active High / Low\n\n\nToggle mode\n\n\nPower Mode\n\n\nMax. On Time\n\n\nSampling length\n\n\nRESET PIN\n\n\nCMOS Output\n\n\nOpen Drain Mode\n\n\n\n\n\n\nV\n\n\nV\n\n\n0\n\n\n1\n\n\n1\n\n\nX\n\n\nV\n\n\nX\n\n\n\n\n\n\nActive High\n\n\nDisabled\n\n\nLOW\n\n\nInfinite\n\n\n1.6 msec\n\n\nN/A\n\n\nPresent\n\n\nN/A\n\n\n\n\n\n\n\n\nDemonstration\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\n\nThis demo is going to show you how to turn on/off an LED.\n\n\nDemo Code:\n\n\nconst int TouchPin=9;\nconst int ledPin=12;\nvoid setup() {\npinMode(TouchPin, INPUT);\npinMode(ledPin,OUTPUT);\n} \n\u00a0\nvoid loop() {\nint sensorValue = digitalRead(TouchPin);\nif(sensorValue==1)\n{\ndigitalWrite(ledPin,HIGH);\n}\nelse\n{\ndigitalWrite(ledPin,LOW);\n}\n}\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n\n\nYou should have a raspberry pi and a grovepi or grovepi+.\n\n\nYou should have completed configuring the development environment, otherwise follow \nhere\n.\n\n\n\n\nConnection\n\n\n\n\nPlug the sensor to grovepi socket D4 by using a grove cable.\n\n\n\n\n\n\n\n\nNavigate to the demos\n directory:\n\n\n\n\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_touch_sensor.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Touch Sensor to digital port D4\n    # SIG,NC,VCC,GND\n    touch_sensor = 4\n\n    grovepi.pinMode(touch_sensor,\nINPUT\n)\n\n    while True:\n        try:\n            print grovepi.digitalRead(touch_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_touch_sensor.py\n\n\n\nResources\n\uf0c1\n\n\n\n\nEagle Files\n\n\nTTP223pdf\n\n\nhow to upload code", 
            "title": "Grove - Touch Sensor"
        }, 
        {
            "location": "/Grove-Touch_Sensor/#specifications", 
            "text": "Operating Voltage: 2.0 - 5.5V  Operating Current(Vcc=3V):1.5 - 3.0\u03bcA  Operating Current(VDD=3V):3.5 - 7.0\u03bcA  Output Response Time: 60 - 220mS  Used Chipset: TTP223-BA6   Option features     AHLB  TOG  LPMB  MOTB  SLRFTB  RST  Q  OPDO      Output Active High / Low  Toggle mode  Power Mode  Max. On Time  Sampling length  RESET PIN  CMOS Output  Open Drain Mode    V  V  0  1  1  X  V  X    Active High  Disabled  LOW  Infinite  1.6 msec  N/A  Present  N/A", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Touch_Sensor/#demonstration", 
            "text": "", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Touch_Sensor/#with-arduino", 
            "text": "This demo is going to show you how to turn on/off an LED.  Demo Code:  const int TouchPin=9;\nconst int ledPin=12;\nvoid setup() {\npinMode(TouchPin, INPUT);\npinMode(ledPin,OUTPUT);\n} \n\u00a0\nvoid loop() {\nint sensorValue = digitalRead(TouchPin);\nif(sensorValue==1)\n{\ndigitalWrite(ledPin,HIGH);\n}\nelse\n{\ndigitalWrite(ledPin,LOW);\n}\n}", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Touch_Sensor/#with-raspberry-pi", 
            "text": "You should have a raspberry pi and a grovepi or grovepi+.  You should have completed configuring the development environment, otherwise follow  here .   Connection   Plug the sensor to grovepi socket D4 by using a grove cable.     Navigate to the demos  directory:        cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_touch_sensor.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Touch Sensor to digital port D4\n    # SIG,NC,VCC,GND\n    touch_sensor = 4\n\n    grovepi.pinMode(touch_sensor, INPUT )\n\n    while True:\n        try:\n            print grovepi.digitalRead(touch_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_touch_sensor.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Touch_Sensor/#resources", 
            "text": "Eagle Files  TTP223pdf  how to upload code", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Water_Sensor/", 
            "text": "The Water Sensor module is part of the Grove system. It indicates whether the sensor is dry, damp or completely immersed in water by measuring conductivity. The sensor traces have a weak pull-up resistor of 1 M\u03a9. The resistor will pull the sensor trace value high until a drop of water shorts the sensor trace to the grounded trace. Believe it or not this circuit will work with the digital I/O pins of your Arduino or you can use it with the analog pins to detect the amount of water induced contact between the grounded and sensor traces.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible interface\n\n\nLow power consumption\n\n\n2.0cm x 2.0cm Grove module\n\n\nHigh sensitivity\n\n\n\n\nApplications Ideas\n\uf0c1\n\n\n\n\nRainfall detecting\n\n\nLiquid leakage\n\n\nTank overflow detector\n\n\n\n\n\n\nCaution\n\nThis device is for educational and hobby applications only. It is not intended to be used in applications where its malfunction could result in damage to property or human safety.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n4.75\n\n\n\n\n5.0\n\n\n\n\n5.25\n\n\n\n\nV\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n\n20\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nWorking Temperature\n\n\n\n\n10\n\n\n\n\n-\n\n\n\n\n30\n\n\n\n\n\u2103\n\n\n\n\n\n\n\n\nWorking Humidity (without condensation)\n\n\n\n\n10\n\n\n\n\n-\n\n\n\n\n90\n\n\n\n\n\u00a0%\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nConnect the module to the Basic board using any of the digital pin. You can gain the value of the signal pin. When there is water on the bare conducting wires, the value is LOW. Otherwise, it will be HIGH.\n\n\nThe following sketch demonstrates a simple application of using the Water sensor to control the buzzer. As the picture on the below indicates, the Water sensor is connected to digital port 8 of the \nGrove - Base Shield\n and the Buzzer is connected to digital port 12. When there is water on the bare conducting wires, the SIG pin output a LOW voltage. Then the Buzzer sounds. The hardware installation is as follows:\n\n\n\n\n\n\nThen connect Arduino to PC by using a USB cable.\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\n    /*macro definition of water sensor and the buzzer*/\n    #define WATER_SENSOR 8\n    #define BUZZER 12\n    void setup()\n    {\n        pins_init();\n    }\n    void loop()\n    {\n        if(isExposedToWater())\n            soundAlarm();\n    }\n    void pins_init()\n    {\n        pinMode(WATER_SENSOR, INPUT);\n        pinMode(BUZZER, OUTPUT);\n    }\n    /************************************************************************/\n    /*Function: When the sensor is exposed to the water, the buzzer sounds  */\n    /*          for 2 seconds.                                              */\n    void soundAlarm()\n    {\n        for(uint8_t i = 0;i \n 20;i ++)\n        {\n            digitalWrite(BUZZER, HIGH);\n            delay(50);\n            digitalWrite(BUZZER, LOW);\n            delay(50);\n        }\n    }\n    /************************************************************************/\n    /*Function: Determine whether the sensor is exposed to the water        */\n    /*Parameter:-void                                                       */\n    /*Return:   -boolean,if it is exposed to the water,it will return true. */\n    boolean isExposedToWater()\n    {\n        if(digitalRead(WATER_SENSOR) == LOW)\n            return true;\n        else return false;\n    }\n\n\n\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n\nThe buzzer sounds when the sensor is damp or completely immersed in water. Have a try!\n\n\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D2 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_water_sensor.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Water Sensor to digital port D2\n    # SIG,NC,VCC,GND\n    water_sensor = 2\n\n    grovepi.pinMode(water_sensor,\nINPUT\n)\n\n    while True:\n        try:\n            print grovepi.digitalRead(water_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_water_sensor.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nWater Sensor Eagle Files\n\n\nDemo code for Water Sensor", 
            "title": "Grove - Water Sensor"
        }, 
        {
            "location": "/Grove-Water_Sensor/#features", 
            "text": "Grove compatible interface  Low power consumption  2.0cm x 2.0cm Grove module  High sensitivity", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Water_Sensor/#applications-ideas", 
            "text": "Rainfall detecting  Liquid leakage  Tank overflow detector    Caution \nThis device is for educational and hobby applications only. It is not intended to be used in applications where its malfunction could result in damage to property or human safety.", 
            "title": "Applications Ideas"
        }, 
        {
            "location": "/Grove-Water_Sensor/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n4.75  \n5.0  \n5.25  \nV    \nCurrent   20  \nmA    \nWorking Temperature  \n10  \n-  \n30  \n\u2103    \nWorking Humidity (without condensation)  \n10  \n-  \n90  \n\u00a0%", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Water_Sensor/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Water_Sensor/#with-arduino", 
            "text": "Connect the module to the Basic board using any of the digital pin. You can gain the value of the signal pin. When there is water on the bare conducting wires, the value is LOW. Otherwise, it will be HIGH.  The following sketch demonstrates a simple application of using the Water sensor to control the buzzer. As the picture on the below indicates, the Water sensor is connected to digital port 8 of the  Grove - Base Shield  and the Buzzer is connected to digital port 12. When there is water on the bare conducting wires, the SIG pin output a LOW voltage. Then the Buzzer sounds. The hardware installation is as follows:    Then connect Arduino to PC by using a USB cable.  Copy and paste code below to a new Arduino sketch.       /*macro definition of water sensor and the buzzer*/\n    #define WATER_SENSOR 8\n    #define BUZZER 12\n    void setup()\n    {\n        pins_init();\n    }\n    void loop()\n    {\n        if(isExposedToWater())\n            soundAlarm();\n    }\n    void pins_init()\n    {\n        pinMode(WATER_SENSOR, INPUT);\n        pinMode(BUZZER, OUTPUT);\n    }\n    /************************************************************************/\n    /*Function: When the sensor is exposed to the water, the buzzer sounds  */\n    /*          for 2 seconds.                                              */\n    void soundAlarm()\n    {\n        for(uint8_t i = 0;i   20;i ++)\n        {\n            digitalWrite(BUZZER, HIGH);\n            delay(50);\n            digitalWrite(BUZZER, LOW);\n            delay(50);\n        }\n    }\n    /************************************************************************/\n    /*Function: Determine whether the sensor is exposed to the water        */\n    /*Parameter:-void                                                       */\n    /*Return:   -boolean,if it is exposed to the water,it will return true. */\n    boolean isExposedToWater()\n    {\n        if(digitalRead(WATER_SENSOR) == LOW)\n            return true;\n        else return false;\n    }    Upload the code, Please click  here  if you do not know how to upload.    The buzzer sounds when the sensor is damp or completely immersed in water. Have a try!", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Water_Sensor/#with-raspberry-pi", 
            "text": "1.You should have a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D2 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_water_sensor.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Water Sensor to digital port D2\n    # SIG,NC,VCC,GND\n    water_sensor = 2\n\n    grovepi.pinMode(water_sensor, INPUT )\n\n    while True:\n        try:\n            print grovepi.digitalRead(water_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_water_sensor.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Water_Sensor/#resources", 
            "text": "Water Sensor Eagle Files  Demo code for Water Sensor", 
            "title": "Resources"
        }, 
        {
            "location": "/Actuator/", 
            "text": "", 
            "title": "Actuator"
        }, 
        {
            "location": "/Grove-2-Coil_Latching_Relay/", 
            "text": "This module is based on 2-Coil Latching Relay. Contrast to the ordinary relay, this latching relay does not need continuous power to keep the state, only a rising/falling pulse is needed to change the work state. Even the power can be removed when the work state do not need to change, making this module especially suitable for low-power projects.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove Connector\n\n\nLow power consumption\n\n\nDual Switch\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n4.7\n\n\n\n\n5.0\n\n\n\n\n5.3\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nSet/Reset Voltage(Max)\n\n\n\n\n4.0\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCoil Resistance\n\n\n\n\n151\n\n\n\n\n167\n\n\n\n\n183\n\n\n\n\n\u03a9\n\n\n\n\n\n\n\n\nSwitching Voltage(Max)\n\n\n\n\n35VAC/35VDC\n\n\n\n\n/\n\n\n\n\n\n\n\n\nSwitching Current(Max)\n\n\n\n\n3\n\n\n\n\nA\n\n\n\n\n\n\n\n\nSet Time(Latching)\n\n\n\n\n4.5(max)\n\n\n\n\nms\n\n\n\n\n\n\n\n\nReset Time(Latching)\n\n\n\n\n3.5(max)\n\n\n\n\nms\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThe latching relay only draws power during the changing of state. A rising/falling voltage pulse on the signal pin changes it\ns working state. This is very useful in situations where energy efficiency is important, and also in situations where you need the relay to remember its state.\n\n\nLet\ns begin to use it.\n\n\n\n\nConnect the module to D3 port of \nGrove - Base Shield\n.\n\n\nThe relay hold in \nset\n status(Comm and NO connected) in default, when there is a rising edge on the SIG pin. It turns the \nreset\n state(Comm and NC connected). The reference code is shown below:\n\n\n\n\n    #define LatchingRelay 3\n    void setup()\n    {\n    pinMode(LatchingRelay,OUTPUT);\n\n    digitalWrite(LatchingRelay,LOW);\n    delay(1000);\n    digitalWrite(LatchingRelay,HIGH);\n    delay(1000);\n\n    }\n    void loop()\n    {\n\n    }\n\n\n\n\n\n\nThe relay hold in \nreset\n status(Comm and NC Connected), when there is a falling edge on the SIG pin. It turns the \nset\n state(Comm and NO connected). The reference code is shown below:\n\n\n\n\n    #define LatchingRelay 3\n    void setup()\n    {\n    pinMode(LatchingRelay,OUTPUT);\n\n    digitalWrite(3,HIGH);\n    delay(1000);\n    digitalWrite(3,LOW);\n    delay(1000);\n    }\n    void loop()\n    {\n\n    }\n\n\n\n\n\n\nThis module consumes little power when working state doesn\nt change. After setting the relay state, you do not need to supply power for the Latching Relay any more, which makes it especially low power consumption.\n\n\n\n\n\n\nNote\n\nRelay is on the \"reset\" status when being released from stock.\n\n\n\n\n\n\n\n\nNotes\n\n\n 1. The two-way relays are controlled at the same time.\n\n\n 2. The NO(NC) indicator will flash once when switch to \"set\"(\"reset\") status.\n\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D4 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_2_coil_latching_relay.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove 2-Coil Latching Relay to digital port D4\n    # SIG,NC,VCC,GND\n    relay = 4\n\n    grovepi.pinMode(relay,\nOUTPUT\n)\n\n    while True:\n        try:\n            # switch on for 5 seconds\n            grovepi.digitalWrite(relay,1)\n            print \non\n\n            time.sleep(5)\n\n            # switch off for 5 seconds\n            grovepi.digitalWrite(relay,0)\n            print \noff\n\n            time.sleep(5)\n\n        except KeyboardInterrupt:\n            grovepi.digitalWrite(relay,0)\n            break\n        except IOError:\n            print \nError\n\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_2_coil_latching_relay.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - 2-Coil Latching Relay Eagle File\n\n\nLatching_Relay_Datasheet", 
            "title": "Grove - 2-Coil Latching Relay"
        }, 
        {
            "location": "/Grove-2-Coil_Latching_Relay/#features", 
            "text": "Grove Connector  Low power consumption  Dual Switch", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-2-Coil_Latching_Relay/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n4.7  \n5.0  \n5.3  \nVDC    \nSet/Reset Voltage(Max)  \n4.0  \nVDC    \nCoil Resistance  \n151  \n167  \n183  \n\u03a9    \nSwitching Voltage(Max)  \n35VAC/35VDC  \n/    \nSwitching Current(Max)  \n3  \nA    \nSet Time(Latching)  \n4.5(max)  \nms    \nReset Time(Latching)  \n3.5(max)  \nms", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-2-Coil_Latching_Relay/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-2-Coil_Latching_Relay/#with-arduino", 
            "text": "The latching relay only draws power during the changing of state. A rising/falling voltage pulse on the signal pin changes it s working state. This is very useful in situations where energy efficiency is important, and also in situations where you need the relay to remember its state.  Let s begin to use it.   Connect the module to D3 port of  Grove - Base Shield .  The relay hold in  set  status(Comm and NO connected) in default, when there is a rising edge on the SIG pin. It turns the  reset  state(Comm and NC connected). The reference code is shown below:       #define LatchingRelay 3\n    void setup()\n    {\n    pinMode(LatchingRelay,OUTPUT);\n\n    digitalWrite(LatchingRelay,LOW);\n    delay(1000);\n    digitalWrite(LatchingRelay,HIGH);\n    delay(1000);\n\n    }\n    void loop()\n    {\n\n    }   The relay hold in  reset  status(Comm and NC Connected), when there is a falling edge on the SIG pin. It turns the  set  state(Comm and NO connected). The reference code is shown below:       #define LatchingRelay 3\n    void setup()\n    {\n    pinMode(LatchingRelay,OUTPUT);\n\n    digitalWrite(3,HIGH);\n    delay(1000);\n    digitalWrite(3,LOW);\n    delay(1000);\n    }\n    void loop()\n    {\n\n    }   This module consumes little power when working state doesn t change. After setting the relay state, you do not need to supply power for the Latching Relay any more, which makes it especially low power consumption.    Note \nRelay is on the \"reset\" status when being released from stock.    Notes   1. The two-way relays are controlled at the same time.   2. The NO(NC) indicator will flash once when switch to \"set\"(\"reset\") status.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-2-Coil_Latching_Relay/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D4 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_2_coil_latching_relay.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove 2-Coil Latching Relay to digital port D4\n    # SIG,NC,VCC,GND\n    relay = 4\n\n    grovepi.pinMode(relay, OUTPUT )\n\n    while True:\n        try:\n            # switch on for 5 seconds\n            grovepi.digitalWrite(relay,1)\n            print  on \n            time.sleep(5)\n\n            # switch off for 5 seconds\n            grovepi.digitalWrite(relay,0)\n            print  off \n            time.sleep(5)\n\n        except KeyboardInterrupt:\n            grovepi.digitalWrite(relay,0)\n            break\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_2_coil_latching_relay.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-2-Coil_Latching_Relay/#resources", 
            "text": "Grove - 2-Coil Latching Relay Eagle File  Latching_Relay_Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Chainable_RGB_LED/", 
            "text": "Grove - Chainable RGB LED\n is based on P9813 chip which is a full-color LED driver. It provides 3 constant-current drivers as well as modulated output of 256 shades of gray. It communicates with a MCU using 2-wire transmission (Data and Clock). This 2-wire transmission can be used to cascade additional \nGrove - Chainable RGB LED\n modules. The built-in clock regeneration enhances the transmission distance. This Grove module is suitable for any colorful LED based projects.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nOperating Voltage: 5V\n\n\nOperating Current: 20mA\n\n\nCommunication Protocol: Serial\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nWhen you get Grove - Chainble RGB LED, you may think how I can light up it. Now we will show you this demo: all colors of RGB cycles in an uniform way.\nThe hardware installation like this:\n\nPicture\n\n\nTo complete this demo, you can use one or more Grove - Chainable RGB LED. Note that the IN interface of one Grove - Chainable RGB LED should be connect to D7/D8 of \nGrove - Base Shield\n and its OUT interface connect to IN interface of another Grove - Chainable RGB LED, chainable more LED in this way.\n\n\n\n\nDownload \nChainable LED Library\n and install it to Arduino Library. There is the course about \nhow to install Arduino Library\n in wiki page.\n\n\nOpen the example CycleThroughColors by the path:File-\nExamples-\nChainableLED_master and upload it to Seeeduino.\n\n\n\n\n    /* \n     * Example of using the ChainableRGB library for controlling a Grove RGB.\n     * This code cycles through all the colors in an uniform way. This is accomplished using a HSB color space. \n     */\n    #include \nChainableLED.h\n\n\n    #define NUM_LEDS  5\n\n    ChainableLED leds(7, 8, NUM_LEDS);\n\n    void setup()\n    {\n    }\n\n    float hue = 0.0;\n    boolean up = true;\n\n    void loop()\n    {\n      for (byte i=0; i\nNUM_LEDS; i++)\n        leds.setColorHSB(i, hue, 1.0, 0.5);\n\n      delay(50);\n\n      if (up)\n        hue+= 0.025;\n      else\n        hue-= 0.025;\n\n      if (hue\n=1.0 \n up)\n        up = false;\n      else if (hue\n=0.0 \n\u00a0!up)\n        up = true;\n    }\n\n\n\n\nYou can observe this scene: colors of two LED will gradient consistently.\n\n\nExtended application:\n\nBased on \nChainable LED Library\n, we have designed this demo: RGB color varies with the temperature measured by Grove - temperature. The RGB color vary from green to red when the temperature is from 25 to 32. The test code is shown below. Do it if you are interested in it.\n\n\n    // demo of temperature -\n rgbLED\n    // temperature form 25 - 32, rgbLed from green -\n red\n    // Grove-temperature plu to A0\n    // LED plug to D7,D8\n\n    #include \nStreaming.h\n\n    #include \nChainableLED.h\n\n\n    #define TEMPUP 32\n    #define TEMPDOWN 25\n\n    ChainableLED leds(7, 8, 1); // connect to pin7 and pin8 , one led\n\n    int getAnalog() // get value from A0\n    {\n        int sum = 0;\n        for(int i=0; i\n32; i++)\n        {\n            sum += analogRead(A0);\n        }\n\n        return sum\n5;\n    }\n\n    float getTemp() // get temperature\n    {\n        float temperature = 0.0;\n        float resistance = 0.0;\n        int B = 3975; //B value of the thermistor\n\n        int a = getAnalog();\n\n        resistance = (float)(1023-a)*10000/a; //get the resistance of the sensor;\n        temperature = 1/(log(resistance/10000)/B+1/298.15)-273.15; //convert to temperature via datasheet\u00a0;\n        return temperature;\n    }\n\n    void ledLight(int dta) // light led\n    {\n\n        dta = dta/4; // 0 - 255\n\n        int colorR = dta;\n        int colorG = 255-dta;\n        int colorB = 0;\n\n        leds.setColorRGB(0, colorR, colorG, colorB);\n    }\n\n    void setup()\n    {\n        Serial.begin(38400);\n        cout \n \nhello world\u00a0!\n \n endl;\n    }\n\n    void loop()\n    {\n        float temp = getTemp();\n        int nTemp = temp*100;\n\n        nTemp = nTemp \n TEMPUP*100\u00a0? TEMPUP*100\u00a0: (nTemp \n TEMPDOWN*100\u00a0? TEMPDOWN*100\u00a0: nTemp);\n        nTemp = map(nTemp, TEMPDOWN*100, TEMPUP*100, 0, 1023);\n        ledLight(nTemp);\n        delay(100);\n    }\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D7 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n     nano grove_chainable_rgb_led.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect first LED in Chainable RGB LED chain to digital port D7\n    # In: CI,DI,VCC,GND\n    # Out: CO,DO,VCC,GND\n    pin = 7\n\n    # I have 10 LEDs connected in series with the first connected to the GrovePi and the last not connected\n    # First LED input socket connected to GrovePi, output socket connected to second LED input and so on\n    numleds = 1  \n\n    grovepi.pinMode(pin,\nOUTPUT\n)\n    time.sleep(1)\n\n    # Chainable RGB LED methods\n    # grovepi.storeColor(red, green, blue)\n    # grovepi.chainableRgbLed_init(pin, numLeds)\n    # grovepi.chainableRgbLed_test(pin, numLeds, testColor)\n    # grovepi.chainableRgbLed_pattern(pin, pattern, whichLed)\n    # grovepi.chainableRgbLed_modulo(pin, offset, divisor)\n    # grovepi.chainableRgbLed_setLevel(pin, level, reverse)\n\n    # test colors used in grovepi.chainableRgbLed_test()\n    testColorBlack = 0   # 0b000 #000000\n    testColorBlue = 1    # 0b001 #0000FF\n    testColorGreen = 2   # 0b010 #00FF00\n    testColorCyan = 3    # 0b011 #00FFFF\n    testColorRed = 4     # 0b100 #FF0000\n    testColorMagenta = 5 # 0b101 #FF00FF\n    testColorYellow = 6  # 0b110 #FFFF00\n    testColorWhite = 7   # 0b111 #FFFFFF\n\n    # patterns used in grovepi.chainableRgbLed_pattern()\n    thisLedOnly = 0\n    allLedsExceptThis = 1\n    thisLedAndInwards = 2\n    thisLedAndOutwards = 3\n\n    try:\n\n        print \nTest 1) Initialise\n\n\n        # init chain of leds\n        grovepi.chainableRgbLed_init(pin, numleds)\n        time.sleep(.5)\n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set led 1 to green\n        grovepi.chainableRgbLed_pattern(pin, thisLedOnly, 0)\n        time.sleep(.5)\n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set led 10 to red\n        grovepi.chainableRgbLed_pattern(pin, thisLedOnly, 9)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 2a) Test Patterns - black\n\n\n        # test pattern 0 - black (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(1)\n\n\n        print \nTest 2b) Test Patterns - blue\n\n\n        # test pattern 1 blue\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlue)\n        time.sleep(1)\n\n\n        print \nTest 2c) Test Patterns - green\n\n\n        # test pattern 2 green\n        grovepi.chainableRgbLed_test(pin, numleds, testColorGreen)\n        time.sleep(1)\n\n\n        print \nTest 2d) Test Patterns - cyan\n\n\n        # test pattern 3 cyan\n        grovepi.chainableRgbLed_test(pin, numleds, testColorCyan)\n        time.sleep(1)\n\n\n        print \nTest 2e) Test Patterns - red\n\n\n        # test pattern 4 red\n        grovepi.chainableRgbLed_test(pin, numleds, testColorRed)\n        time.sleep(1)\n\n\n        print \nTest 2f) Test Patterns - magenta\n\n\n        # test pattern 5 magenta\n        grovepi.chainableRgbLed_test(pin, numleds, testColorMagenta)\n        time.sleep(1)\n\n\n        print \nTest 2g) Test Patterns - yellow\n\n\n        # test pattern 6 yellow\n        grovepi.chainableRgbLed_test(pin, numleds, testColorYellow)\n        time.sleep(1)\n\n\n        print \nTest 2h) Test Patterns - white\n\n\n        # test pattern 7 white\n        grovepi.chainableRgbLed_test(pin, numleds, testColorWhite)\n        time.sleep(1)\n\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 3a) Set using pattern - this led only\n\n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set led 3 to red\n        grovepi.chainableRgbLed_pattern(pin, thisLedOnly, 2)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 3b) Set using pattern - all leds except this\n\n\n        # change color to blue\n        grovepi.storeColor(0,0,255)\n        time.sleep(.5)\n\n        # set all leds except for 3 to blue\n        grovepi.chainableRgbLed_pattern(pin, allLedsExceptThis, 3)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 3c) Set using pattern - this led and inwards\n\n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set leds 1-3 to green\n        grovepi.chainableRgbLed_pattern(pin, thisLedAndInwards, 2)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 3d) Set using pattern - this led and outwards\n\n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set leds 7-10 to green\n        grovepi.chainableRgbLed_pattern(pin, thisLedAndOutwards, 6)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 4a) Set using modulo - all leds\n\n\n        # change color to black (fully off)\n        grovepi.storeColor(0,0,0)\n        time.sleep(.5)\n\n        # set all leds black\n        # offset 0 means start at first led\n        # divisor 1 means every led\n        grovepi.chainableRgbLed_modulo(pin, 0, 1)\n        time.sleep(.5)\n\n        # change color to white (fully on)\n        grovepi.storeColor(255,255,255)\n        time.sleep(.5)\n\n        # set all leds white\n        grovepi.chainableRgbLed_modulo(pin, 0, 1)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 4b) Set using modulo - every 2\n\n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set every 2nd led to red\n        grovepi.chainableRgbLed_modulo(pin, 0, 2)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n\n        print \nTest 4c) Set using modulo - every 2, offset 1\n\n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set every 2nd led to green, offset 1\n        grovepi.chainableRgbLed_modulo(pin, 1, 2)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 4d) Set using modulo - every 3, offset 0\n\n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set every 3nd led to red\n        grovepi.chainableRgbLed_modulo(pin, 0, 3)\n        time.sleep(.5)\n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set every 3nd led to green, offset 1\n        grovepi.chainableRgbLed_modulo(pin, 1, 3)\n        time.sleep(.5)\n\n        # change color to blue\n        grovepi.storeColor(0,0,255)\n        time.sleep(.5)\n\n        # set every 3nd led to blue, offset 2\n        grovepi.chainableRgbLed_modulo(pin, 2, 3)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 4e) Set using modulo - every 3, offset 1\n\n\n        # change color to yellow\n        grovepi.storeColor(255,255,0)\n        time.sleep(.5)\n\n        # set every 4nd led to yellow\n        grovepi.chainableRgbLed_modulo(pin, 1, 3)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n\n        print \nTest 4f) Set using modulo - every 3, offset 2\n\n\n        # change color to magenta\n        grovepi.storeColor(255,0,255)\n        time.sleep(.5)\n\n        # set every 4nd led to magenta\n        grovepi.chainableRgbLed_modulo(pin, 2, 3)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 5a) Set level 6\n\n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set leds 1-6 to green\n        grovepi.write_i2c_block(0x04,[95,pin,6,0])\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print \nTest 5b) Set level 7 - reverse\n\n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set leds 4-10 to red\n        grovepi.write_i2c_block(0x04,[95,pin,7,1])\n        time.sleep(.5)\n\n\n    except KeyboardInterrupt:\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        break\n    except IOError:\n        print \nError\n\n\n\n\n\n\n\nNotice that there\ns something you have to concern of:\n\n\n\n\n    pin = 7         #setting up the output pin\n    numleds = 1     #how many leds you plug\n\n\n\n\n\n\nAlso all methods you can see in grovepi.py is:\n\n\n\n\n    storeColor(red, green, blue)\n    chainableRgbLed_init(pin, numLeds)\n    chainableRgbLed_test(pin, numLeds, testColor)\n    chainableRgbLed_pattern(pin, pattern, whichLed)\n    chainableRgbLed_modulo(pin, offset, divisor)\n    chainableRgbLed_setLevel(pin, level, reverse)\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_chainable_rgb_led.py\n\n\n\n\n6.This demo may not work if your grovepi dosen\nt have the newest firmware, update the firmware.\n\n\n    cd yourpath/GrovePi/Firmware\n    sudo ./firmware_update.sh\n\n\n\n\nWith Beaglebone Green\n\uf0c1\n\n\nTo begin editing programs that live on BBG, you can use the Cloud9 IDE.\n\n\nAs a simple exercise to become familiar with Cloud9 IDE, creating a simple application to blink one of the 4 user programmable LEDs on the BeagleBone is a good start.\n\n\nIf this is your first time to use Cloud9 IDE, please follow this \nlink\n.\n\n\nStep1:\n Set the Grove - UART socket as a Grove - GPIO Socket, just follow this \nlink\n.\n\n\nStep2:\n Click the \n+\n in the top-right to create a new file.\n\n\n\n\n\n\nStep3:\n Copy and paste the following code into the new tab\n\n\nimport time\nimport Adafruit_BBIO.GPIO as GPIO\n\u00a0\nCLK_PIN = \nP9_22\n\nDATA_PIN = \nP9_21\n\nNUMBER_OF_LEDS = 1\n\u00a0\nclass ChainableLED():\n    def __init__(self, clk_pin, data_pin, number_of_leds):\n        self.__clk_pin = clk_pin\n        self.__data_pin = data_pin\n        self.__number_of_leds = number_of_leds\n\u00a0\n        GPIO.setup(self.__clk_pin, GPIO.OUT)\n        GPIO.setup(self.__data_pin, GPIO.OUT)\n\u00a0\n        for i in range(self.__number_of_leds):\n            self.setColorRGB(i, 0, 0, 0)\n\u00a0\n    def clk(self):\n        GPIO.output(self.__clk_pin, GPIO.LOW)\n        time.sleep(0.00002)\n        GPIO.output(self.__clk_pin, GPIO.HIGH)\n        time.sleep(0.00002)\n\u00a0\n    def sendByte(self, b):\n        \nSend one bit at a time, starting with the MSB\n\n        for i in range(8):\n            # If MSB is 1, write one and clock it, else write 0 and clock\n            if (b \n 0x80) != 0:\n                GPIO.output(self.__data_pin, GPIO.HIGH)\n            else:\n                GPIO.output(self.__data_pin, GPIO.LOW)\n            self.clk()\n\u00a0\n            # Advance to the next bit to send\n            b = b \n 1\n\u00a0\n    def sendColor(self, red, green, blue):\n        \nStart by sending a byte with the format '1 1 /B7 /B6 /G7 /G6 /R7 /R6' \n\n        #prefix = B11000000\n        prefix = 0xC0\n        if (blue \n 0x80) == 0:     \n            #prefix |= B00100000\n            prefix |= 0x20\n        if (blue \n 0x40) == 0:     \n            #prefix |= B00010000\n            prefix |= 0x10\n        if (green \n 0x80) == 0:    \n            #prefix |= B00001000\n            prefix |= 0x08\n        if (green \n 0x40) == 0:    \n            #prefix |= B00000100\n            prefix |= 0x04\n        if (red \n 0x80) == 0:      \n            #prefix |= B00000010\n            prefix |= 0x02\n        if (red \n 0x40) == 0:      \n            #prefix |= B00000001\n            prefix |= 0x01\n        self.sendByte(prefix)\n\u00a0\n        # Now must send the 3 colors\n        self.sendByte(blue)\n        self.sendByte(green)\n        self.sendByte(red)\n\u00a0\n    def setColorRGB(self, led, red, green, blue):\n        # Send data frame prefix (32x '0')\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n\u00a0\n        # Send color data for each one of the leds\n        for i in range(self.__number_of_leds):\n            '''\n            if i == led:\n                _led_state[i*3 + _CL_RED] = red;\n                _led_state[i*3 + _CL_GREEN] = green;\n                _led_state[i*3 + _CL_BLUE] = blue;\n            sendColor(_led_state[i*3 + _CL_RED], \n                      _led_state[i*3 + _CL_GREEN], \n                      _led_state[i*3 + _CL_BLUE]);\n            '''\n            self.sendColor(red, green, blue)\n\u00a0\n        # Terminate data frame (32x \n0\n)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n\u00a0\n\u00a0\n# Note: Use P9_22(UART2_RXD) and P9_21(UART2_TXD) as GPIO.\n# Connect the Grove - Chainable RGB LED to UART Grove port of Beaglebone Green.\nif __name__ == \n__main__\n:\n    rgb_led = ChainableLED(CLK_PIN, DATA_PIN, NUMBER_OF_LEDS)\n\u00a0\n    while True:\n        # The first parameter: NUMBER_OF_LEDS - 1; Other parameters: the RGB values.\n        rgb_led.setColorRGB(0, 255, 0, 0)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 0, 255, 0)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 0, 0, 255)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 0, 255, 255)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 255, 0, 255)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 255, 255, 0)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 255, 255, 255)\n        time.sleep(2)\n\n\n\n\nStep4:\n Save the file by clicking the disk icon and giving the file a name with the .py extension.\n\n\nStep5:\n Connect Grove Chainable RGB LED to Grove UART socket on BBG.\n\n\nStep6:\n Run the code. You\nll find the RGB LED is changing color every 2 seconds.\n\n\nResources\n\uf0c1\n\n\n\n\nChainable RGB LED eagle file\n\n\nP9813 Datasheet\n\n\nChainable RGB LED Library for the P9813\n\n\nGithub repository for Chainable RGB LED Library (new)", 
            "title": "Grove - Chainable RGB LED"
        }, 
        {
            "location": "/Grove-Chainable_RGB_LED/#specifications", 
            "text": "Operating Voltage: 5V  Operating Current: 20mA  Communication Protocol: Serial", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Chainable_RGB_LED/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Chainable_RGB_LED/#with-arduino", 
            "text": "When you get Grove - Chainble RGB LED, you may think how I can light up it. Now we will show you this demo: all colors of RGB cycles in an uniform way.\nThe hardware installation like this: Picture  To complete this demo, you can use one or more Grove - Chainable RGB LED. Note that the IN interface of one Grove - Chainable RGB LED should be connect to D7/D8 of  Grove - Base Shield  and its OUT interface connect to IN interface of another Grove - Chainable RGB LED, chainable more LED in this way.   Download  Chainable LED Library  and install it to Arduino Library. There is the course about  how to install Arduino Library  in wiki page.  Open the example CycleThroughColors by the path:File- Examples- ChainableLED_master and upload it to Seeeduino.       /* \n     * Example of using the ChainableRGB library for controlling a Grove RGB.\n     * This code cycles through all the colors in an uniform way. This is accomplished using a HSB color space. \n     */\n    #include  ChainableLED.h \n\n    #define NUM_LEDS  5\n\n    ChainableLED leds(7, 8, NUM_LEDS);\n\n    void setup()\n    {\n    }\n\n    float hue = 0.0;\n    boolean up = true;\n\n    void loop()\n    {\n      for (byte i=0; i NUM_LEDS; i++)\n        leds.setColorHSB(i, hue, 1.0, 0.5);\n\n      delay(50);\n\n      if (up)\n        hue+= 0.025;\n      else\n        hue-= 0.025;\n\n      if (hue =1.0   up)\n        up = false;\n      else if (hue =0.0  \u00a0!up)\n        up = true;\n    }  You can observe this scene: colors of two LED will gradient consistently.  Extended application: \nBased on  Chainable LED Library , we have designed this demo: RGB color varies with the temperature measured by Grove - temperature. The RGB color vary from green to red when the temperature is from 25 to 32. The test code is shown below. Do it if you are interested in it.      // demo of temperature -  rgbLED\n    // temperature form 25 - 32, rgbLed from green -  red\n    // Grove-temperature plu to A0\n    // LED plug to D7,D8\n\n    #include  Streaming.h \n    #include  ChainableLED.h \n\n    #define TEMPUP 32\n    #define TEMPDOWN 25\n\n    ChainableLED leds(7, 8, 1); // connect to pin7 and pin8 , one led\n\n    int getAnalog() // get value from A0\n    {\n        int sum = 0;\n        for(int i=0; i 32; i++)\n        {\n            sum += analogRead(A0);\n        }\n\n        return sum 5;\n    }\n\n    float getTemp() // get temperature\n    {\n        float temperature = 0.0;\n        float resistance = 0.0;\n        int B = 3975; //B value of the thermistor\n\n        int a = getAnalog();\n\n        resistance = (float)(1023-a)*10000/a; //get the resistance of the sensor;\n        temperature = 1/(log(resistance/10000)/B+1/298.15)-273.15; //convert to temperature via datasheet\u00a0;\n        return temperature;\n    }\n\n    void ledLight(int dta) // light led\n    {\n\n        dta = dta/4; // 0 - 255\n\n        int colorR = dta;\n        int colorG = 255-dta;\n        int colorB = 0;\n\n        leds.setColorRGB(0, colorR, colorG, colorB);\n    }\n\n    void setup()\n    {\n        Serial.begin(38400);\n        cout    hello world\u00a0!    endl;\n    }\n\n    void loop()\n    {\n        float temp = getTemp();\n        int nTemp = temp*100;\n\n        nTemp = nTemp   TEMPUP*100\u00a0? TEMPUP*100\u00a0: (nTemp   TEMPDOWN*100\u00a0? TEMPDOWN*100\u00a0: nTemp);\n        nTemp = map(nTemp, TEMPDOWN*100, TEMPUP*100, 0, 1023);\n        ledLight(nTemp);\n        delay(100);\n    }", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Chainable_RGB_LED/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D7 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code        nano grove_chainable_rgb_led.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect first LED in Chainable RGB LED chain to digital port D7\n    # In: CI,DI,VCC,GND\n    # Out: CO,DO,VCC,GND\n    pin = 7\n\n    # I have 10 LEDs connected in series with the first connected to the GrovePi and the last not connected\n    # First LED input socket connected to GrovePi, output socket connected to second LED input and so on\n    numleds = 1  \n\n    grovepi.pinMode(pin, OUTPUT )\n    time.sleep(1)\n\n    # Chainable RGB LED methods\n    # grovepi.storeColor(red, green, blue)\n    # grovepi.chainableRgbLed_init(pin, numLeds)\n    # grovepi.chainableRgbLed_test(pin, numLeds, testColor)\n    # grovepi.chainableRgbLed_pattern(pin, pattern, whichLed)\n    # grovepi.chainableRgbLed_modulo(pin, offset, divisor)\n    # grovepi.chainableRgbLed_setLevel(pin, level, reverse)\n\n    # test colors used in grovepi.chainableRgbLed_test()\n    testColorBlack = 0   # 0b000 #000000\n    testColorBlue = 1    # 0b001 #0000FF\n    testColorGreen = 2   # 0b010 #00FF00\n    testColorCyan = 3    # 0b011 #00FFFF\n    testColorRed = 4     # 0b100 #FF0000\n    testColorMagenta = 5 # 0b101 #FF00FF\n    testColorYellow = 6  # 0b110 #FFFF00\n    testColorWhite = 7   # 0b111 #FFFFFF\n\n    # patterns used in grovepi.chainableRgbLed_pattern()\n    thisLedOnly = 0\n    allLedsExceptThis = 1\n    thisLedAndInwards = 2\n    thisLedAndOutwards = 3\n\n    try:\n\n        print  Test 1) Initialise \n\n        # init chain of leds\n        grovepi.chainableRgbLed_init(pin, numleds)\n        time.sleep(.5)\n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set led 1 to green\n        grovepi.chainableRgbLed_pattern(pin, thisLedOnly, 0)\n        time.sleep(.5)\n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set led 10 to red\n        grovepi.chainableRgbLed_pattern(pin, thisLedOnly, 9)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 2a) Test Patterns - black \n\n        # test pattern 0 - black (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(1)\n\n\n        print  Test 2b) Test Patterns - blue \n\n        # test pattern 1 blue\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlue)\n        time.sleep(1)\n\n\n        print  Test 2c) Test Patterns - green \n\n        # test pattern 2 green\n        grovepi.chainableRgbLed_test(pin, numleds, testColorGreen)\n        time.sleep(1)\n\n\n        print  Test 2d) Test Patterns - cyan \n\n        # test pattern 3 cyan\n        grovepi.chainableRgbLed_test(pin, numleds, testColorCyan)\n        time.sleep(1)\n\n\n        print  Test 2e) Test Patterns - red \n\n        # test pattern 4 red\n        grovepi.chainableRgbLed_test(pin, numleds, testColorRed)\n        time.sleep(1)\n\n\n        print  Test 2f) Test Patterns - magenta \n\n        # test pattern 5 magenta\n        grovepi.chainableRgbLed_test(pin, numleds, testColorMagenta)\n        time.sleep(1)\n\n\n        print  Test 2g) Test Patterns - yellow \n\n        # test pattern 6 yellow\n        grovepi.chainableRgbLed_test(pin, numleds, testColorYellow)\n        time.sleep(1)\n\n\n        print  Test 2h) Test Patterns - white \n\n        # test pattern 7 white\n        grovepi.chainableRgbLed_test(pin, numleds, testColorWhite)\n        time.sleep(1)\n\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 3a) Set using pattern - this led only \n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set led 3 to red\n        grovepi.chainableRgbLed_pattern(pin, thisLedOnly, 2)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 3b) Set using pattern - all leds except this \n\n        # change color to blue\n        grovepi.storeColor(0,0,255)\n        time.sleep(.5)\n\n        # set all leds except for 3 to blue\n        grovepi.chainableRgbLed_pattern(pin, allLedsExceptThis, 3)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 3c) Set using pattern - this led and inwards \n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set leds 1-3 to green\n        grovepi.chainableRgbLed_pattern(pin, thisLedAndInwards, 2)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 3d) Set using pattern - this led and outwards \n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set leds 7-10 to green\n        grovepi.chainableRgbLed_pattern(pin, thisLedAndOutwards, 6)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 4a) Set using modulo - all leds \n\n        # change color to black (fully off)\n        grovepi.storeColor(0,0,0)\n        time.sleep(.5)\n\n        # set all leds black\n        # offset 0 means start at first led\n        # divisor 1 means every led\n        grovepi.chainableRgbLed_modulo(pin, 0, 1)\n        time.sleep(.5)\n\n        # change color to white (fully on)\n        grovepi.storeColor(255,255,255)\n        time.sleep(.5)\n\n        # set all leds white\n        grovepi.chainableRgbLed_modulo(pin, 0, 1)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 4b) Set using modulo - every 2 \n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set every 2nd led to red\n        grovepi.chainableRgbLed_modulo(pin, 0, 2)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n\n        print  Test 4c) Set using modulo - every 2, offset 1 \n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set every 2nd led to green, offset 1\n        grovepi.chainableRgbLed_modulo(pin, 1, 2)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 4d) Set using modulo - every 3, offset 0 \n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set every 3nd led to red\n        grovepi.chainableRgbLed_modulo(pin, 0, 3)\n        time.sleep(.5)\n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set every 3nd led to green, offset 1\n        grovepi.chainableRgbLed_modulo(pin, 1, 3)\n        time.sleep(.5)\n\n        # change color to blue\n        grovepi.storeColor(0,0,255)\n        time.sleep(.5)\n\n        # set every 3nd led to blue, offset 2\n        grovepi.chainableRgbLed_modulo(pin, 2, 3)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 4e) Set using modulo - every 3, offset 1 \n\n        # change color to yellow\n        grovepi.storeColor(255,255,0)\n        time.sleep(.5)\n\n        # set every 4nd led to yellow\n        grovepi.chainableRgbLed_modulo(pin, 1, 3)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n\n        print  Test 4f) Set using modulo - every 3, offset 2 \n\n        # change color to magenta\n        grovepi.storeColor(255,0,255)\n        time.sleep(.5)\n\n        # set every 4nd led to magenta\n        grovepi.chainableRgbLed_modulo(pin, 2, 3)\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 5a) Set level 6 \n\n        # change color to green\n        grovepi.storeColor(0,255,0)\n        time.sleep(.5)\n\n        # set leds 1-6 to green\n        grovepi.write_i2c_block(0x04,[95,pin,6,0])\n        time.sleep(.5)\n\n        # pause so you can see what happened\n        time.sleep(2)\n\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        time.sleep(.5)\n\n\n        print  Test 5b) Set level 7 - reverse \n\n        # change color to red\n        grovepi.storeColor(255,0,0)\n        time.sleep(.5)\n\n        # set leds 4-10 to red\n        grovepi.write_i2c_block(0x04,[95,pin,7,1])\n        time.sleep(.5)\n\n\n    except KeyboardInterrupt:\n        # reset (all off)\n        grovepi.chainableRgbLed_test(pin, numleds, testColorBlack)\n        break\n    except IOError:\n        print  Error    Notice that there s something you have to concern of:       pin = 7         #setting up the output pin\n    numleds = 1     #how many leds you plug   Also all methods you can see in grovepi.py is:       storeColor(red, green, blue)\n    chainableRgbLed_init(pin, numLeds)\n    chainableRgbLed_test(pin, numLeds, testColor)\n    chainableRgbLed_pattern(pin, pattern, whichLed)\n    chainableRgbLed_modulo(pin, offset, divisor)\n    chainableRgbLed_setLevel(pin, level, reverse)  5.Run the demo.      sudo python grove_chainable_rgb_led.py  6.This demo may not work if your grovepi dosen t have the newest firmware, update the firmware.      cd yourpath/GrovePi/Firmware\n    sudo ./firmware_update.sh", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Chainable_RGB_LED/#with-beaglebone-green", 
            "text": "To begin editing programs that live on BBG, you can use the Cloud9 IDE.  As a simple exercise to become familiar with Cloud9 IDE, creating a simple application to blink one of the 4 user programmable LEDs on the BeagleBone is a good start.  If this is your first time to use Cloud9 IDE, please follow this  link .  Step1:  Set the Grove - UART socket as a Grove - GPIO Socket, just follow this  link .  Step2:  Click the  +  in the top-right to create a new file.    Step3:  Copy and paste the following code into the new tab  import time\nimport Adafruit_BBIO.GPIO as GPIO\n\u00a0\nCLK_PIN =  P9_22 \nDATA_PIN =  P9_21 \nNUMBER_OF_LEDS = 1\n\u00a0\nclass ChainableLED():\n    def __init__(self, clk_pin, data_pin, number_of_leds):\n        self.__clk_pin = clk_pin\n        self.__data_pin = data_pin\n        self.__number_of_leds = number_of_leds\n\u00a0\n        GPIO.setup(self.__clk_pin, GPIO.OUT)\n        GPIO.setup(self.__data_pin, GPIO.OUT)\n\u00a0\n        for i in range(self.__number_of_leds):\n            self.setColorRGB(i, 0, 0, 0)\n\u00a0\n    def clk(self):\n        GPIO.output(self.__clk_pin, GPIO.LOW)\n        time.sleep(0.00002)\n        GPIO.output(self.__clk_pin, GPIO.HIGH)\n        time.sleep(0.00002)\n\u00a0\n    def sendByte(self, b):\n         Send one bit at a time, starting with the MSB \n        for i in range(8):\n            # If MSB is 1, write one and clock it, else write 0 and clock\n            if (b   0x80) != 0:\n                GPIO.output(self.__data_pin, GPIO.HIGH)\n            else:\n                GPIO.output(self.__data_pin, GPIO.LOW)\n            self.clk()\n\u00a0\n            # Advance to the next bit to send\n            b = b   1\n\u00a0\n    def sendColor(self, red, green, blue):\n         Start by sending a byte with the format '1 1 /B7 /B6 /G7 /G6 /R7 /R6'  \n        #prefix = B11000000\n        prefix = 0xC0\n        if (blue   0x80) == 0:     \n            #prefix |= B00100000\n            prefix |= 0x20\n        if (blue   0x40) == 0:     \n            #prefix |= B00010000\n            prefix |= 0x10\n        if (green   0x80) == 0:    \n            #prefix |= B00001000\n            prefix |= 0x08\n        if (green   0x40) == 0:    \n            #prefix |= B00000100\n            prefix |= 0x04\n        if (red   0x80) == 0:      \n            #prefix |= B00000010\n            prefix |= 0x02\n        if (red   0x40) == 0:      \n            #prefix |= B00000001\n            prefix |= 0x01\n        self.sendByte(prefix)\n\u00a0\n        # Now must send the 3 colors\n        self.sendByte(blue)\n        self.sendByte(green)\n        self.sendByte(red)\n\u00a0\n    def setColorRGB(self, led, red, green, blue):\n        # Send data frame prefix (32x '0')\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n\u00a0\n        # Send color data for each one of the leds\n        for i in range(self.__number_of_leds):\n            '''\n            if i == led:\n                _led_state[i*3 + _CL_RED] = red;\n                _led_state[i*3 + _CL_GREEN] = green;\n                _led_state[i*3 + _CL_BLUE] = blue;\n            sendColor(_led_state[i*3 + _CL_RED], \n                      _led_state[i*3 + _CL_GREEN], \n                      _led_state[i*3 + _CL_BLUE]);\n            '''\n            self.sendColor(red, green, blue)\n\u00a0\n        # Terminate data frame (32x  0 )\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n        self.sendByte(0x00)\n\u00a0\n\u00a0\n# Note: Use P9_22(UART2_RXD) and P9_21(UART2_TXD) as GPIO.\n# Connect the Grove - Chainable RGB LED to UART Grove port of Beaglebone Green.\nif __name__ ==  __main__ :\n    rgb_led = ChainableLED(CLK_PIN, DATA_PIN, NUMBER_OF_LEDS)\n\u00a0\n    while True:\n        # The first parameter: NUMBER_OF_LEDS - 1; Other parameters: the RGB values.\n        rgb_led.setColorRGB(0, 255, 0, 0)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 0, 255, 0)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 0, 0, 255)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 0, 255, 255)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 255, 0, 255)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 255, 255, 0)\n        time.sleep(2)\n        rgb_led.setColorRGB(0, 255, 255, 255)\n        time.sleep(2)  Step4:  Save the file by clicking the disk icon and giving the file a name with the .py extension.  Step5:  Connect Grove Chainable RGB LED to Grove UART socket on BBG.  Step6:  Run the code. You ll find the RGB LED is changing color every 2 seconds.", 
            "title": "With Beaglebone Green"
        }, 
        {
            "location": "/Grove-Chainable_RGB_LED/#resources", 
            "text": "Chainable RGB LED eagle file  P9813 Datasheet  Chainable RGB LED Library for the P9813  Github repository for Chainable RGB LED Library (new)", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Dry-Reed_Relay/", 
            "text": "The \nGrove-Dry Reed Relay\n is a relay module which works through magnetizing the vibration reed via the current in the coils. Compared to electromagnetic relays, the contacts completely sealed is the biggest feature of the Dry-Reed Relay. Besides, it features simplicity in construct, compactness, fast speed and long life, which make it widely applied in many fields such as microelectronic detection, Automatic Control etc.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove Interface\n\n\nHigh Speed\n\n\nGood stability\n\n\nLong contact life\n\n\nContact fully sealed\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n4.8\n\n\n\n\n5.0\n\n\n\n\n5.2\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCoil Resistance\n\n\n\n\n225\n\n\n\n\n250\n\n\n\n\n275\n\n\n\n\n\u03a9\n\n\n\n\n\n\n\n\nPick-Up Voltage\n\n\n\n\n3.75\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nSwitching Current(Max)\n\n\n\n\n0.5\n\n\n\n\nA\n\n\n\n\n\n\n\n\nSwitching Voltage(Max)\n\n\n\n\n120 VAC/60VDC\n\n\n\n\n-\n\n\n\n\n\n\n\n\nCarrying Current(Max)\n\n\n\n\n1.0\n\n\n\n\nA\n\n\n\n\n\n\n\n\nOperate Time(Max)\n\n\n\n\n1.0\n\n\n\n\nmS\n\n\n\n\n\n\n\n\nRelease Time(Max)\n\n\n\n\n0.5\n\n\n\n\nmS\n\n\n\n\n\n\n\n\nMechanical Life(at no load)\n\n\n\n\n1\u00d7108 operations\n\n\n\n\n-\n\n\n\n\n\n\n\n\nAmbient Temperature\n\n\n\n\n-30\n\n\n\n\n/\n\n\n\n\n70\n\n\n\n\n\u02daC\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThe Dry-Reed Relay can support up to 60VDC 1A load. You can use it to control resistance load,\n \nbut it is not applicable to inductive load(such as Motor)\n.\n\n\nThe usage of this Dry-reed relay is quite alike that of common relays.\n\n\n\n\nConnect electric light to Grove - Dry-Reed Relay and power for electric light.\n\n\n\n\nConnect Grove - Dry-Reed Relay to port D2 of \nGrove - Base Shield\n and plug it into Arduino/Seeeduino.\n\n\n\n\n\n\nUpload the below code. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n\n    int Relay = 2;\n\n    // the setup routine runs once when you press reset:\n    void setup() {                \n      // initialize the digital pin as an output.\n      pinMode(Relay, OUTPUT);     \n    }\n\n    // the loop routine runs over and over again forever:\n    void loop() {\n      digitalWrite(Relay, HIGH);   //the Relay close(HIGH is the voltage level)\n      delay(5000);               // wait for five seconds\n      digitalWrite(Relay, LOW);    //the Relay normally open by making the voltage LOW\n      delay(5000);               // wait for five seconds\n    }\n\n\n\n\n\n\nThe electric light will light up for seconds ,then off for seconds, repeatedly.For the special applications, you may need to write the code by yourself.\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D4 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_relay.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Relay to digital port D4\n    # SIG,NC,VCC,GND\n    relay = 4\n\n    grovepi.pinMode(relay,\nOUTPUT\n)\n\n    while True:\n        try:\n            # switch on for 5 seconds\n            grovepi.digitalWrite(relay,1)\n            print \non\n\n            time.sleep(5)\n\n            # switch off for 5 seconds\n            grovepi.digitalWrite(relay,0)\n            print \noff\n\n            time.sleep(5)\n\n        except KeyboardInterrupt:\n            grovepi.digitalWrite(relay,0)\n            break\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_relay.py\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Dry-Reed Relay Eagle File\n\n\nDry-Reed Relay Datasheet", 
            "title": "Grove - Dry-Reed Relay"
        }, 
        {
            "location": "/Grove-Dry-Reed_Relay/#features", 
            "text": "Grove Interface  High Speed  Good stability  Long contact life  Contact fully sealed", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Dry-Reed_Relay/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n4.8  \n5.0  \n5.2  \nVDC    \nCoil Resistance  \n225  \n250  \n275  \n\u03a9    \nPick-Up Voltage  \n3.75  \nVDC    \nSwitching Current(Max)  \n0.5  \nA    \nSwitching Voltage(Max)  \n120 VAC/60VDC  \n-    \nCarrying Current(Max)  \n1.0  \nA    \nOperate Time(Max)  \n1.0  \nmS    \nRelease Time(Max)  \n0.5  \nmS    \nMechanical Life(at no load)  \n1\u00d7108 operations  \n-    \nAmbient Temperature  \n-30  \n/  \n70  \n\u02daC", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Dry-Reed_Relay/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Dry-Reed_Relay/#with-arduino", 
            "text": "The Dry-Reed Relay can support up to 60VDC 1A load. You can use it to control resistance load,   but it is not applicable to inductive load(such as Motor) .  The usage of this Dry-reed relay is quite alike that of common relays.   Connect electric light to Grove - Dry-Reed Relay and power for electric light.   Connect Grove - Dry-Reed Relay to port D2 of  Grove - Base Shield  and plug it into Arduino/Seeeduino.    Upload the below code. Please click  here  if you do not know how to upload.        int Relay = 2;\n\n    // the setup routine runs once when you press reset:\n    void setup() {                \n      // initialize the digital pin as an output.\n      pinMode(Relay, OUTPUT);     \n    }\n\n    // the loop routine runs over and over again forever:\n    void loop() {\n      digitalWrite(Relay, HIGH);   //the Relay close(HIGH is the voltage level)\n      delay(5000);               // wait for five seconds\n      digitalWrite(Relay, LOW);    //the Relay normally open by making the voltage LOW\n      delay(5000);               // wait for five seconds\n    }   The electric light will light up for seconds ,then off for seconds, repeatedly.For the special applications, you may need to write the code by yourself.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-Dry-Reed_Relay/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D4 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_relay.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove Relay to digital port D4\n    # SIG,NC,VCC,GND\n    relay = 4\n\n    grovepi.pinMode(relay, OUTPUT )\n\n    while True:\n        try:\n            # switch on for 5 seconds\n            grovepi.digitalWrite(relay,1)\n            print  on \n            time.sleep(5)\n\n            # switch off for 5 seconds\n            grovepi.digitalWrite(relay,0)\n            print  off \n            time.sleep(5)\n\n        except KeyboardInterrupt:\n            grovepi.digitalWrite(relay,0)\n            break\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_relay.py", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-Dry-Reed_Relay/#resources", 
            "text": "Grove - Dry-Reed Relay Eagle File  Dry-Reed Relay Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-EL_Driver/", 
            "text": "Grove - EL Driver is designed for driving EL Wires. It integrates a very small inverter to drive the EL Wire, so you can easily light up the EL Wire with just one single Grove cable.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv1.0\n\n\nInitial public release\n\n\nDec 11, 2014\n\n\n\n\n\n\n\n\nSupported EL Wires:\n\uf0c1\n\n\n\n\nEL Wire-Green 3m\n\n\nEL Wire-Red 3m\n\n\nEL Wire-Blue 3m\n\n\nEL Wire-Yellow 3m\n\n\nEL Wire-White 3m\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible interface\n\n\n3.3V/5V Compatible\n\n\nIntegrated Inverter Transformer\n\n\nInput Current: 300mA Max (According to the load)\n\n\nSupported max EL Capacitance: 15nF\n\n\n\n\nUsage\n\uf0c1\n\n\nHere we show how to use Arduino to control the state of the LED.\n\n\n\n\n\n\nConnect the Grove - EL Driver to Base Shield\ns \ndigital port 2\n with 4pin Grove Cable. Of course you can change to other valid digital ports if it\ns necessary and the definitions of the port should be changed too. Connect a EL Wire to EL Driver \nJ1\n port with the given cable in product package.\n\n\n\n\n\n\nPlug it onto the Arduino/Seeeduino. Connect the board to PC using USB cable.\n\n\n\n\n\n\nCopy the demo code to your sketch, then upload to Arudino or Seeeduino board. Please click \nhere\n if you do not know how to upload.\nYou will see the EL Wire blink every second.\n\n\n\n\n\n\n/*************************   2014 Seeedstudio   **************************\n* File Name         \u00a0: GroveELDriverDemoCode.ino\n* Author            \u00a0: Seeedteam\n* Version           \u00a0: V1.0\n* Date              \u00a0: 11/12/2014\n* Description       \u00a0: Demo code for Grove - EL Driver\n*************************************************************************/\n\u00a0\n#define ELPin 2 //connect EL Driver to digital pin2\nvoid setup() {                \n  // initialize the digital pin2 as an output.\n  pinMode(ELPin, OUTPUT);     \n}\n\u00a0\nvoid loop() {\n  digitalWrite(ELPin, HIGH);   // set the EL Wire on\n  delay(500);               // for 500ms\n  digitalWrite(ELPin, LOW);   // set the EL Wire off\n  delay(500);\n}\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nsch_pcb_eagle\n\n\nsch_pdf", 
            "title": "Grove - EL Driver"
        }, 
        {
            "location": "/Grove-EL_Driver/#version-tracker", 
            "text": "Revision  Descriptions  Release      v1.0  Initial public release  Dec 11, 2014", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Grove-EL_Driver/#supported-el-wires", 
            "text": "EL Wire-Green 3m  EL Wire-Red 3m  EL Wire-Blue 3m  EL Wire-Yellow 3m  EL Wire-White 3m", 
            "title": "Supported EL Wires:"
        }, 
        {
            "location": "/Grove-EL_Driver/#features", 
            "text": "Grove compatible interface  3.3V/5V Compatible  Integrated Inverter Transformer  Input Current: 300mA Max (According to the load)  Supported max EL Capacitance: 15nF", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-EL_Driver/#usage", 
            "text": "Here we show how to use Arduino to control the state of the LED.    Connect the Grove - EL Driver to Base Shield s  digital port 2  with 4pin Grove Cable. Of course you can change to other valid digital ports if it s necessary and the definitions of the port should be changed too. Connect a EL Wire to EL Driver  J1  port with the given cable in product package.    Plug it onto the Arduino/Seeeduino. Connect the board to PC using USB cable.    Copy the demo code to your sketch, then upload to Arudino or Seeeduino board. Please click  here  if you do not know how to upload.\nYou will see the EL Wire blink every second.    /*************************   2014 Seeedstudio   **************************\n* File Name         \u00a0: GroveELDriverDemoCode.ino\n* Author            \u00a0: Seeedteam\n* Version           \u00a0: V1.0\n* Date              \u00a0: 11/12/2014\n* Description       \u00a0: Demo code for Grove - EL Driver\n*************************************************************************/\n\u00a0\n#define ELPin 2 //connect EL Driver to digital pin2\nvoid setup() {                \n  // initialize the digital pin2 as an output.\n  pinMode(ELPin, OUTPUT);     \n}\n\u00a0\nvoid loop() {\n  digitalWrite(ELPin, HIGH);   // set the EL Wire on\n  delay(500);               // for 500ms\n  digitalWrite(ELPin, LOW);   // set the EL Wire off\n  delay(500);\n}", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-EL_Driver/#resources", 
            "text": "sch_pcb_eagle  sch_pdf", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Haptic_Motor/", 
            "text": "Grove - Haptic motor is a grove module integrated with \nDRV2605L\n which will give your project more feelings. This motor is specially designed for various effects, such as ramping the vibration level up and down, for wearables and other IoT devices. Right now we have developed an easy-to-use library which simulate 123 kinds in total of vibrating modes and this will make your prototyping quicker. Also, you can develop more advanced functions with driver DRV2605L which will improve actuator performance in terms of acceleration consistency, start time, and break time and is accessible through a shared I2C compatible bus or PWM input signal.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nMore vibration effects.\n\n\nQuicken your project prototyping process.\n\n\nEasy-to-use library with 123 kinds of vibrating modes.\n\n\nPowerful driver to implanting more advanced functions.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating voltage\n\n\n3.3~5.0 V\n\n\n\n\n\n\nRipples (at maximum power)\n\n\n50~100 mV\n\n\n\n\n\n\nMax power\n\n\n750 mW\n\n\n\n\n\n\nI2C speed\n\n\n100 kHz\n\n\n\n\n\n\nVibration effects\n\n\n123 types\n\n\n\n\n\n\nDriver\n\n\nDRV2605L\n\n\n\n\n\n\nPort\n\n\nI\n2\nC\n\n\n\n\n\n\nDefault I\n2\nC Address\n\n\n0x5A\n\n\n\n\n\n\n\n\nApplication ideas\n\uf0c1\n\n\n\n\nMobile phone, tablets.\n\n\nWearable devices.\n\n\nRemote controls, touch-enabled devices.\n\n\nIndustrial human-machine interfaces.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\nFront view:\n\n\n\n\nRear view:\n\n\n\n\nGetting started\n\uf0c1\n\n\n\n\nNote\n\nThis section only shows you how to build a basic development environment. You can build a development environment for your project with following guides:\n\n\n\n\nBuild IDE\n\uf0c1\n\n\nRefer to following guides to building an appropriate IDE:\n\n\nGetting Started on Windows\n\n\nGetting Started on Mac OS X\n\n\n\n\nNote\n\nArduino board will also be fine if you happen to have no Seeeduino board because \nSeeeduino\n is compatible with Arduino.\n\n\n\n\nHardware connection\n\uf0c1\n\n\n\n\nNotes\n\n\na. Make sure you have built a development environment successful through previous steps.\n\n\nb.Make sure your board has selected Arduino Uno and COM port right chosen. Connect to I\n2\nC interface on Seeeduino board and Haptic motor with grove wire.\n\n\n\n\n\n\n\nDownload sample code\n\uf0c1\n\n\n\n\nYou can download \nsample code\n and library or header files.\n\n\nClick a button named \nDownload Zip\n at \nGithub\n.\n\n\nDecompress the downloaded ZIP file.\n\n\nRemove the \n-master\n twice in decompressed file name.\n\n\nCopy the folder Grove_Haptic_Motor into your library folder (In default, it is same with Sketchbook Location which can be found by clicking File \n Preference).Under Windows, it will likely be called \nMy Documents\\Arduino\\libraries\n. For Mac users, it will likely be called \nDocuments/Arduino/libraries\n. On Linux, it will be the \nlibraries\n folder in your sketchbook.\n\n\nCopy file \ndrv2605.cpp\n and file \ndrv2605.h\n to its parent directory.\n\n\n\n\nLoad sample code\n\uf0c1\n\n\n\n\nNote\n\nIn this case we use \nSeeeduino 4.2\n as experiment board which is a compatible board with Arduino.\n\n\n\n\n\n\nTip\n\nYou can use \nBase shield v2\n as expansion board which will make your connection of modules simple.\n\n\n\n\n\n\nWarning\n\nNever touch driver DRV2605L which may cause damage to it when it is powered.\n\n\n\n\n\n\n\n\nMake sure haptic motor and main control board well connected.\n\n\nLoad your sample code drv2605.ino under example file of decompressed file.\n\n\nFlash your code to your main control board by click Project-\nUpload(CTRL+U).\n\n\nAfter uploading, you now get haptic motor vibrate at a smooth style.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic files in \nEagle format\n and \nPDF format\n.\n\n\nMore about drive circuit DRV2605L\n.\n\n\nGit repository", 
            "title": "Grove - Haptic Motor"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#features", 
            "text": "More vibration effects.  Quicken your project prototyping process.  Easy-to-use library with 123 kinds of vibrating modes.  Powerful driver to implanting more advanced functions.", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#specifications", 
            "text": "Parameter  Value      Operating voltage  3.3~5.0 V    Ripples (at maximum power)  50~100 mV    Max power  750 mW    I2C speed  100 kHz    Vibration effects  123 types    Driver  DRV2605L    Port  I 2 C    Default I 2 C Address  0x5A", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#application-ideas", 
            "text": "Mobile phone, tablets.  Wearable devices.  Remote controls, touch-enabled devices.  Industrial human-machine interfaces.", 
            "title": "Application ideas"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#hardware-overview", 
            "text": "Front view:   Rear view:", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#getting-started", 
            "text": "Note \nThis section only shows you how to build a basic development environment. You can build a development environment for your project with following guides:", 
            "title": "Getting started"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#build-ide", 
            "text": "Refer to following guides to building an appropriate IDE:  Getting Started on Windows  Getting Started on Mac OS X   Note \nArduino board will also be fine if you happen to have no Seeeduino board because  Seeeduino  is compatible with Arduino.", 
            "title": "Build IDE"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#hardware-connection", 
            "text": "Notes  a. Make sure you have built a development environment successful through previous steps.  b.Make sure your board has selected Arduino Uno and COM port right chosen. Connect to I 2 C interface on Seeeduino board and Haptic motor with grove wire.", 
            "title": "Hardware connection"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#download-sample-code", 
            "text": "You can download  sample code  and library or header files.  Click a button named  Download Zip  at  Github .  Decompress the downloaded ZIP file.  Remove the  -master  twice in decompressed file name.  Copy the folder Grove_Haptic_Motor into your library folder (In default, it is same with Sketchbook Location which can be found by clicking File   Preference).Under Windows, it will likely be called  My Documents\\Arduino\\libraries . For Mac users, it will likely be called  Documents/Arduino/libraries . On Linux, it will be the  libraries  folder in your sketchbook.  Copy file  drv2605.cpp  and file  drv2605.h  to its parent directory.", 
            "title": "Download sample code"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#load-sample-code", 
            "text": "Note \nIn this case we use  Seeeduino 4.2  as experiment board which is a compatible board with Arduino.   Tip \nYou can use  Base shield v2  as expansion board which will make your connection of modules simple.   Warning \nNever touch driver DRV2605L which may cause damage to it when it is powered.    Make sure haptic motor and main control board well connected.  Load your sample code drv2605.ino under example file of decompressed file.  Flash your code to your main control board by click Project- Upload(CTRL+U).  After uploading, you now get haptic motor vibrate at a smooth style.", 
            "title": "Load sample code"
        }, 
        {
            "location": "/Grove-Haptic_Motor/#resources", 
            "text": "Schematic files in  Eagle format  and  PDF format .  More about drive circuit DRV2605L .  Git repository", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver/", 
            "text": "Grove - I2C Motor Driver V1.0\n\n\n\n\n\n\nGrove - I2C Motor Driver V1.2\n\n\n\n\n\n\nGrove - I2C Motor Driver V1.3", 
            "title": "Grove - I2C Motor Driver"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/", 
            "text": "The Grove - I2C Motor Driver V1.3 (latest version) can directly control Stepper Motor or DC Motor. Its heart is a dual channel H-bridge driver chip\uff08L298N\uff09that can handle current up to 2A per channel, controlled by an Atmel ATmega8L which handles the I2C communication with for example an Arduino. Both motors can be driven simultaneously while set to a different speed and direction. It can power two brushed DC motors or one 4-wire two-phase stepper motor. It requires a 6V to 15V power supply to power the motor and has an onboard 5V voltage regulator which can power the I2C bus and the Arduino(selectable by jumper). All driver lines are protected by diodes from back-EMF.\n\n\nContrast to the \nGrove - I2C motor driver V1.2\n, the V1.3 enables users to control the stepper more easily. You do not need to control the steppers all the time anymore, simply send a command to I2C motor driver V1.3 to drive a stepper, and it will act as your command, which would save your Arduino resource and simplify your code.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv1.0\n\n\nInitial public release\n\n\nMay 17th, 2012\n\n\n\n\n\n\nv1.2\n\n\nModify the I2C address set by hardware\n\n\nJuly 2nd, 2012\n\n\n\n\n\n\nv1.3\n\n\nModify the firmware to support off-line Stepper\n\n\nFeb 18th, 2013\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove Compatible\n\n\nI2C Interface\n\n\nAdjustable motor speed and rotation direction\n\n\nChangeable slave address by hardware\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n6\n\n\n\n\n-\n\n\n\n\n15\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nMax Output Current per channel\n\n\n\n\n0.5\n\n\n\n\nA\n\n\n\n\n\n\n\n\nMaximum Total current\n\n\n\n\n1.0\n\n\n\n\nA\n\n\n\n\n\n\n\n\nInput/output voltage on I2C bus\n\n\n\n\n5\n\n\n\n\nV\n\n\n\n\n\n\n\n\nCommunication protocol\n\n\n\n\nI2C\n\n\n\n\n/\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n78M05 IC:\n 5V voltage regulator\n\n\nL298 IC:\n Dual full bridge driver\n\n\nATmega8 IC:\n Control Motor Rotate.\n\n\n\n\nNote\n\nInput voltage on screw terminals is regulated to 5V and connected to I2C +5V via a jumper (J4). Remove jumper if both external power via the screw terminals and power via the I2C header are used. Use jumper if 5V should be supplied to the I2C bus.\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nRobots\n\n\nHomebuilt RC cars\n\n\nCase fans\n\n\nHigh power LED illumination\n\n\n\n\n\n\nCaution\n\nThe board will be very hot while operating over 1Amp. Do keep your hands off!\n\n\n\n\nUsage\n\uf0c1\n\n\nThe I2C Motor Driver can control motor which is based on the chip L298. The L298 isn\u2019t just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. Hooking up to a motor means you can have it spin in both directions; and with PWM input, you can use your Arduino to make them spin at any speed. Because the L298 has 2 H-bridges, you can make a robot turn around by spinning each wheel in different directions, and of course go forwards and backwards.\n\n\nNow, let us use the I2C Motor Driver to control two DC motors or a stepper rotating clockwise and anticlockwise.\n\n\nSet the address of the I2C Motor Driver\n\uf0c1\n\n\n\n\nSet the address by dial switch is a new function added to the new I2C Motor Driver.\n\n\n\n\n\n\n\n\nThen keep the address setup in the program the same as the address setup on the I2C motor driver. The default address setup in the program is 0x0f.\n\n\n\n\n\n\n\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n\n\n\nHow to drive 2 DC motors\n\uf0c1\n\n\n\n\n\n\nNote\n\nThe first thing to notice however, is that you need an external power source for your DC motors. The 5V pin on the Arduino cannot provide enough power to drive 2 motors, you may damage your Arduino if you do so.\n\n\n\n\nAnd then program your Arduino as below:\n\n\n#include \nWire.h\n\n     .......\n     .......\n    \n Driver functions \n\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n  while(1)  {\n    MotorSpeedSetAB(100,20);\n    delay(10); //this delay needed\n    MotorDirectionSet(0b1010);  //0b1010  Rotating in the positive direction \n    delay(1000); \n    MotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\n    delay(500);\n  }\n}\n\n\n\n\nIn this program, Arduino first set the speed of the 2 DC motors with the \nMotorSpeedSetAB()\ncommand, and then set the DC motors work directions with \nMotorDirectionSet()\n command. please refer to the \nFunction Reference\n for details, you can download all the demo code in the \nResources\n.\n\n\nHow to drive a stepper using I2C motor driver V1.3\n\uf0c1\n\n\nAs the upgraded version of \nI2C motor DriverV1.2\n, You can drive stepper via 2 methods for I2C motor driver V1.3.\n\n\n1. Control the stepper directly by Arduino\n\nThe I2C motor Driver can also be used to drive a 4-wire stepper. Connect your stepper to the output pins of I2C motor driver, and then connect motor driver to your Arduino/Seeeduino with I2C bus. Program your Arduino as below:\n\n\n#include \nWire.h\n\n     .......\n     .......\n    \n Driver functions \n\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n while(1)  {\n    MotorSpeedSetAB(100,100);//when driving a stepper, the speed should be set to 100;\n    delay(10);\n    MotorDirectionSet(0b0001);\n    delay(4);\n      MotorDirectionSet(0b0011);\n    delay(4);  \n    MotorDirectionSet(0b0010);\n    delay(4);\n      MotorDirectionSet(0b0110);\n    delay(4);  \n    MotorDirectionSet(0b0100);\n    delay(4);  \n    MotorDirectionSet(0b1100);\n    delay(4);\n      MotorDirectionSet(0b1000);\n    delay(4);\n      MotorDirectionSet(0b1001);\n    delay(4);\n  }\n}\n\n\n\n\nThis connected 4-wire stepper will rotate; you can adjust the rotation speed or step number in your Arduino program. You can also use some other stepper libraries to control it. For all the demo code please refer to \nResources\n.\n\n\n\n\n2. Control the Stepper using the I2C motor Driver V1.3 on-chip ATmega8L.\n\n Take \n24BYJ48\n as an example, The hardware installation as shown below:\n\n\n\n\nThe connection between 24BYJ48 Stepper Motor and I2C Motor Driver is as shown below:\n\n\n\n\nDownload the \nGrove-I2C motor driver V1.3 demo code\n, and open the \nStepperControlMode2.ino\n:\n\n\n#include \nWire.h\n\n#define MotorSpeedSet             0x82\n#define PWMFrequenceSet           0x84\n#define DirectionSet              0xaa\n#define MotorSetA                 0xa1\n#define MotorSetB                 0xa5\n#define Nothing                   0x01\n#define EnableStepper             0x1a\n#define UnenableStepper           0x1b\n#define Stepernu                  0x1c\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n// set the steps you want, if 255, the stepper will rotate continuously;\nvoid SteperStepset(unsigned char stepnu)\n{\n  Wire.beginTransmission(I2CMotorDriverAdd); // transmit to device I2CMotorDriverAdd\n  Wire.write(Stepernu);          // Send the stepernu command \n  Wire.write(stepnu);            // send the steps\n  Wire.write(Nothing);           // send nothing   \n  Wire.endTransmission();        // stop transmitting \n}\n     .......\n     .......\n     .......\n     .......\nvoid stepperrun()\n{\n Serial.println(\nsent command to + direction, very fast\n);\n SteperStepset(255);\n StepperMotorEnable(1, 1);// ennable the i2c motor driver a stepper. \n  delay(5000);\n  Serial.println(\nsent command to - direction, slow\n);\n  SteperStepset(255);\n  StepperMotorEnable(0, 20);\n  delay(5000);\n   Serial.println(\nsent command to - direction, fast\n);\n  StepperMotorEnable(0, 2);// ennable the i2c motor driver a stepper. \n  delay(5000);\n Serial.println(\nsent command to + direction,100 steps, fast\n);\n SteperStepset(100);\n  StepperMotorEnable(1,5);\n delay(3000);\n\u00a0\n Serial.println(\nsent command to shut down the stepper\n);\n StepperMotorUnenable();\n delay(1000);\n\u00a0\n  Serial.println(\nsent command to - direction, slow, and 10 steps then stop\n);\n SteperStepset(10);\n StepperMotorEnable(0,40);\n delay(5000);\n Serial.println(\nsent command to shut down the stepper\n);\n StepperMotorUnenable();\n delay(5000);\n}\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000);\n  Serial.begin(9600);\n  Serial.println(\nsetup begin\n);\n  stepperrun();\n}\nvoid loop()  {\n\u00a0\n}\n\n\n\n\nIn this demo code, Arduino sends stepper-control command to I2C motor driver via I2C bus, with SteperStepset() to set the step number, and StepperMotorEnable() to set the direction and speed. Please refer to the \nFunction Reference\n for the details.\n\n\nNote that if you have I2C motor driver V1.2 and want to use the off-line Stepper control methods, you will need to upgrade your firmware in your V1.2 motor driver with a \nAVRISP\n and upload the .hex file to your I2C motor driver. Please download the .hex file and source code and related tips in the \nResources\n. \n\n\nFunction Reference\n\uf0c1\n\n\n1. void SteperStepset(unsigned char stepnu)\n\n\nDescription: Set the steps you want.\n\n\nstepnu: the Parameter can be 1~255. if 255, the stepper will rotate continuously;\n\n\nUsage:\n\n\nSerial.println(\"sent command to + direction,100 steps, fast\");\nSteperStepset(100);\n\n\n\n2. void StepperMotorEnable(unsigned char Direction, unsigned char motorspeed)\n\n\nDescription: Enable the IIC motor driver to drive a 4-wire stepper.\n\n\nDirection: Stepper direction 1/0\n\n\nmotorspeed: defines the time interval the i2C motor driver, Change it output to drive the stepper. The actual interval time is\u00a0: motorspeed * 4ms. That is , When motor speed is 10, the interval time would be 40 ms.\n\n\nUsage:\n\n\nStepperMotorEnable(1, 1);// enable the i2c motor driver a stepper.\n\n\n\n3. void StepperMotorUnenable()\n\n\nDescription: Uneanble IIC motor drive to drive the stepper.\n\n\nUsage:\n\n\nStepperMotorUnenable();\n\n\n\n4. void MotorSpeedSetAB(unsigned char MotorSpeedA , unsigned char MotorSpeedB)\n\n\nDescription: defines the speed of motor 1 and motor 2\n\n\nMotorSpeedA: the DC motor A speed, should be 0~100;\n\n\nMotorSpeedB: the DC motor B speed, should be 0~100;\n\n\nUsage:\n\n\nSerial.println(\"sent DC speed 100\");\nMotorSpeedSetAB(100,100);//defines the speed of motor 1 and motor 2;\ndelay(10); //this delay needed\n\n\n\n5. void MotorPWMFrequenceSet(unsigned char Frequence)\n\n\nDescription:set the prescale frequency of PWM, 0x03 default\n\n\nFrequency: the prescale frequency of PWM\n\n\n6. void MotorDirectionSet(unsigned char Direction)\n\n\nDescription: Adjust the direction of the motors\n\n\nDirection:can be Forward/Reverse rotating.\n\n\nUsage:\n\n\nMotorDirectionSet(0b1010);  //\"0b1010\" defines the output polarity, \"10\" means the M+ is \"positive\" while the M- is \"negative\"\n                         // make sure M+ and M- is different polarity when driving DC motors.\ndelay(1000); \nMotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\ndelay(500);\n\n\n\n7. void MotorDriectionAndSpeedSet(unsigned char Direction,unsigned char MotorSpeedA,unsigned char MotorSpeedB)\n\n\nDescription: Adjust the direction and speed altogether.\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - I2C Motor Driver V1.3 Eagle File\n\n\nI2C Motor DriverV13 Demo Code\n\n\nL298 Datasheet\n\n\n78M05 Datasheet\n\n\nOn-Chip Firmware for I2C motor driver", 
            "title": "Grove - I2C Motor Driver V1.3"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#version-tracker", 
            "text": "Revision  Descriptions  Release      v1.0  Initial public release  May 17th, 2012    v1.2  Modify the I2C address set by hardware  July 2nd, 2012    v1.3  Modify the firmware to support off-line Stepper  Feb 18th, 2013", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#features", 
            "text": "Grove Compatible  I2C Interface  Adjustable motor speed and rotation direction  Changeable slave address by hardware", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n6  \n-  \n15  \nVDC    \nMax Output Current per channel  \n0.5  \nA    \nMaximum Total current  \n1.0  \nA    \nInput/output voltage on I2C bus  \n5  \nV    \nCommunication protocol  \nI2C  \n/", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#hardware-overview", 
            "text": "78M05 IC:  5V voltage regulator  L298 IC:  Dual full bridge driver  ATmega8 IC:  Control Motor Rotate.   Note \nInput voltage on screw terminals is regulated to 5V and connected to I2C +5V via a jumper (J4). Remove jumper if both external power via the screw terminals and power via the I2C header are used. Use jumper if 5V should be supplied to the I2C bus.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#application-ideas", 
            "text": "Robots  Homebuilt RC cars  Case fans  High power LED illumination    Caution \nThe board will be very hot while operating over 1Amp. Do keep your hands off!", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#usage", 
            "text": "The I2C Motor Driver can control motor which is based on the chip L298. The L298 isn\u2019t just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. Hooking up to a motor means you can have it spin in both directions; and with PWM input, you can use your Arduino to make them spin at any speed. Because the L298 has 2 H-bridges, you can make a robot turn around by spinning each wheel in different directions, and of course go forwards and backwards.  Now, let us use the I2C Motor Driver to control two DC motors or a stepper rotating clockwise and anticlockwise.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#set-the-address-of-the-i2c-motor-driver", 
            "text": "Set the address by dial switch is a new function added to the new I2C Motor Driver.     Then keep the address setup in the program the same as the address setup on the I2C motor driver. The default address setup in the program is 0x0f.    #define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver", 
            "title": "Set the address of the I2C Motor Driver"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#how-to-drive-2-dc-motors", 
            "text": "Note \nThe first thing to notice however, is that you need an external power source for your DC motors. The 5V pin on the Arduino cannot provide enough power to drive 2 motors, you may damage your Arduino if you do so.  And then program your Arduino as below:  #include  Wire.h \n     .......\n     .......\n      Driver functions  \n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n  while(1)  {\n    MotorSpeedSetAB(100,20);\n    delay(10); //this delay needed\n    MotorDirectionSet(0b1010);  //0b1010  Rotating in the positive direction \n    delay(1000); \n    MotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\n    delay(500);\n  }\n}  In this program, Arduino first set the speed of the 2 DC motors with the  MotorSpeedSetAB() command, and then set the DC motors work directions with  MotorDirectionSet()  command. please refer to the  Function Reference  for details, you can download all the demo code in the  Resources .", 
            "title": "How to drive 2 DC motors"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#how-to-drive-a-stepper-using-i2c-motor-driver-v13", 
            "text": "As the upgraded version of  I2C motor DriverV1.2 , You can drive stepper via 2 methods for I2C motor driver V1.3.  1. Control the stepper directly by Arduino \nThe I2C motor Driver can also be used to drive a 4-wire stepper. Connect your stepper to the output pins of I2C motor driver, and then connect motor driver to your Arduino/Seeeduino with I2C bus. Program your Arduino as below:  #include  Wire.h \n     .......\n     .......\n      Driver functions  \n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n while(1)  {\n    MotorSpeedSetAB(100,100);//when driving a stepper, the speed should be set to 100;\n    delay(10);\n    MotorDirectionSet(0b0001);\n    delay(4);\n      MotorDirectionSet(0b0011);\n    delay(4);  \n    MotorDirectionSet(0b0010);\n    delay(4);\n      MotorDirectionSet(0b0110);\n    delay(4);  \n    MotorDirectionSet(0b0100);\n    delay(4);  \n    MotorDirectionSet(0b1100);\n    delay(4);\n      MotorDirectionSet(0b1000);\n    delay(4);\n      MotorDirectionSet(0b1001);\n    delay(4);\n  }\n}  This connected 4-wire stepper will rotate; you can adjust the rotation speed or step number in your Arduino program. You can also use some other stepper libraries to control it. For all the demo code please refer to  Resources .   2. Control the Stepper using the I2C motor Driver V1.3 on-chip ATmega8L.  Take  24BYJ48  as an example, The hardware installation as shown below:   The connection between 24BYJ48 Stepper Motor and I2C Motor Driver is as shown below:   Download the  Grove-I2C motor driver V1.3 demo code , and open the  StepperControlMode2.ino :  #include  Wire.h \n#define MotorSpeedSet             0x82\n#define PWMFrequenceSet           0x84\n#define DirectionSet              0xaa\n#define MotorSetA                 0xa1\n#define MotorSetB                 0xa5\n#define Nothing                   0x01\n#define EnableStepper             0x1a\n#define UnenableStepper           0x1b\n#define Stepernu                  0x1c\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n// set the steps you want, if 255, the stepper will rotate continuously;\nvoid SteperStepset(unsigned char stepnu)\n{\n  Wire.beginTransmission(I2CMotorDriverAdd); // transmit to device I2CMotorDriverAdd\n  Wire.write(Stepernu);          // Send the stepernu command \n  Wire.write(stepnu);            // send the steps\n  Wire.write(Nothing);           // send nothing   \n  Wire.endTransmission();        // stop transmitting \n}\n     .......\n     .......\n     .......\n     .......\nvoid stepperrun()\n{\n Serial.println( sent command to + direction, very fast );\n SteperStepset(255);\n StepperMotorEnable(1, 1);// ennable the i2c motor driver a stepper. \n  delay(5000);\n  Serial.println( sent command to - direction, slow );\n  SteperStepset(255);\n  StepperMotorEnable(0, 20);\n  delay(5000);\n   Serial.println( sent command to - direction, fast );\n  StepperMotorEnable(0, 2);// ennable the i2c motor driver a stepper. \n  delay(5000);\n Serial.println( sent command to + direction,100 steps, fast );\n SteperStepset(100);\n  StepperMotorEnable(1,5);\n delay(3000);\n\u00a0\n Serial.println( sent command to shut down the stepper );\n StepperMotorUnenable();\n delay(1000);\n\u00a0\n  Serial.println( sent command to - direction, slow, and 10 steps then stop );\n SteperStepset(10);\n StepperMotorEnable(0,40);\n delay(5000);\n Serial.println( sent command to shut down the stepper );\n StepperMotorUnenable();\n delay(5000);\n}\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000);\n  Serial.begin(9600);\n  Serial.println( setup begin );\n  stepperrun();\n}\nvoid loop()  {\n\u00a0\n}  In this demo code, Arduino sends stepper-control command to I2C motor driver via I2C bus, with SteperStepset() to set the step number, and StepperMotorEnable() to set the direction and speed. Please refer to the  Function Reference  for the details.  Note that if you have I2C motor driver V1.2 and want to use the off-line Stepper control methods, you will need to upgrade your firmware in your V1.2 motor driver with a  AVRISP  and upload the .hex file to your I2C motor driver. Please download the .hex file and source code and related tips in the  Resources .", 
            "title": "How to drive a stepper using I2C motor driver V1.3"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#function-reference", 
            "text": "1. void SteperStepset(unsigned char stepnu)  Description: Set the steps you want.  stepnu: the Parameter can be 1~255. if 255, the stepper will rotate continuously;  Usage:  Serial.println(\"sent command to + direction,100 steps, fast\");\nSteperStepset(100);  2. void StepperMotorEnable(unsigned char Direction, unsigned char motorspeed)  Description: Enable the IIC motor driver to drive a 4-wire stepper.  Direction: Stepper direction 1/0  motorspeed: defines the time interval the i2C motor driver, Change it output to drive the stepper. The actual interval time is\u00a0: motorspeed * 4ms. That is , When motor speed is 10, the interval time would be 40 ms.  Usage:  StepperMotorEnable(1, 1);// enable the i2c motor driver a stepper.  3. void StepperMotorUnenable()  Description: Uneanble IIC motor drive to drive the stepper.  Usage:  StepperMotorUnenable();  4. void MotorSpeedSetAB(unsigned char MotorSpeedA , unsigned char MotorSpeedB)  Description: defines the speed of motor 1 and motor 2  MotorSpeedA: the DC motor A speed, should be 0~100;  MotorSpeedB: the DC motor B speed, should be 0~100;  Usage:  Serial.println(\"sent DC speed 100\");\nMotorSpeedSetAB(100,100);//defines the speed of motor 1 and motor 2;\ndelay(10); //this delay needed  5. void MotorPWMFrequenceSet(unsigned char Frequence)  Description:set the prescale frequency of PWM, 0x03 default  Frequency: the prescale frequency of PWM  6. void MotorDirectionSet(unsigned char Direction)  Description: Adjust the direction of the motors  Direction:can be Forward/Reverse rotating.  Usage:  MotorDirectionSet(0b1010);  //\"0b1010\" defines the output polarity, \"10\" means the M+ is \"positive\" while the M- is \"negative\"\n                         // make sure M+ and M- is different polarity when driving DC motors.\ndelay(1000); \nMotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\ndelay(500);  7. void MotorDriectionAndSpeedSet(unsigned char Direction,unsigned char MotorSpeedA,unsigned char MotorSpeedB)  Description: Adjust the direction and speed altogether.", 
            "title": "Function Reference"
        }, 
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#resources", 
            "text": "Grove - I2C Motor Driver V1.3 Eagle File  I2C Motor DriverV13 Demo Code  L298 Datasheet  78M05 Datasheet  On-Chip Firmware for I2C motor driver", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/", 
            "text": "The Infrared Emitter is used to transmit infrared signals through an infrared LED, while there is an \nInfrared receiver\n to get the signals on the other side. An infrared LED is like any other LED, with its color centered around 940nm. We can not only use the emitter to transmit data or commands, but also to emulate remotes to control your home appliance using an Arduino. The Infrared Emitter can transmit signals reliable up to 10 meters. Beyond 10 meters, the receiver may not get the signals.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nVoltage: 3.3-5V\n\n\nDistance:10m\n\n\n\n\nDemonstration\n\uf0c1\n\n\nThe Grove - Infrared Emitter can send data while Grove - Infrared Receiver will receive them.\n\n\n\n\nConnect the Grove - Infrared Emitter to D3.\n\n\nConnect the Grove - Infrared Receiver to D2.\n\n\n\n\n\n\nWith Arduino/Seeeduino\n\uf0c1\n\n\nSuggest Reading for Starter\n\uf0c1\n\n\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\n\n\n\n\nGetting Started with Seeeduino/Arduino\n\n\n\n\n\n\nIRSendRev Library\n\uf0c1\n\n\nWe have created a library to help you start playing quickly with the Seeeduino/Arduino, in this section we\nll show you how to set up the library.\n\n\nSetup\n\uf0c1\n\n\n\n\nDownload the \nlibrary code as a zip file\n from the IRSendRev github page.\n\n\nUnzip the downloaded file into your \u2026/arduino/libraries.\n\n\nRename the unzipped folder \nIRSendRev\n\n\nStart the Arduino IDE (or restart if it is open).\n\n\n\n\nInfrared Emitter Examples/Applications\n\uf0c1\n\n\nThese examples are going to show you how to use features of Grove - Infrared Emitter. You can use Grove - Infrared Emitter in combination with Grove - Infrared Receiver. Connect the IR send pins to D3 for this demo.\n\n\nReceiver\n\uf0c1\n\n\n\n\nNote\n\nYou need to have a \nGrove - Infrared Receiver\n. And upload this demo to the board with Infrared Receiver Grove.\n\n\n\n\n\n\nOpen File-\nExamples-\nIRSendRev-\nexample-\nrecv sketch for a complete example, or copy and paste code below to a new Arduino sketch.\n\n\n\n\nDescription\n: \nThis example connect the IR receiver pins to D2 for this demo. You can see the remote control\ns infrared data that received through a serial port terminal, then write the received infrared data into send.ino and upload to the board with Infrared Emitter Grove, so you can send the same data with remote control\ns button.\n\n\nApplication\n: \nYou can note the remote control\ns infrared data down through Infrared Receiver, then send the same data through Infrared Emitter in some cases, such as open the fan switch when indoor temperature is greater than 26 degrees.\n\n\n#include \nIRSendRev.h\n\n\u00a0\n#define BIT_LEN         0\n#define BIT_START_H     1\n#define BIT_START_L     2\n#define BIT_DATA_H      3\n#define BIT_DATA_L      4\n#define BIT_DATA_LEN    5\n#define BIT_DATA        6\n\u00a0\nconst int pinRecv = 2;              // ir receiver connect to D2\n\u00a0\nvoid setup()\n{\n    Serial.begin(115200);\n    IR.Init(pinRecv);\n    Serial.println(\ninit over\n);\n}\n\u00a0\nunsigned char dta[20];\n\u00a0\nvoid loop()\n{\n    if(IR.IsDta())                  // get IR data\n    {\n        IR.Recv(dta);               // receive data to dta\n\u00a0\n        Serial.println(\n+------------------------------------------------------+\n);\n        Serial.print(\nLEN = \n);\n        Serial.println(dta[BIT_LEN]);\n        Serial.print(\nSTART_H: \n);\n        Serial.print(dta[BIT_START_H]);\n        Serial.print(\n\\tSTART_L: \n);\n        Serial.println(dta[BIT_START_L]);\n\u00a0\n        Serial.print(\nDATA_H: \n);\n        Serial.print(dta[BIT_DATA_H]);\n        Serial.print(\n\\tDATA_L: \n);\n        Serial.println(dta[BIT_DATA_L]);\n\u00a0\n        Serial.print(\n\\r\\nDATA_LEN = \n);\n        Serial.println(dta[BIT_DATA_LEN]);\n\u00a0\n        Serial.print(\nDATA: \n);\n        for(int i=0; i\ndta[BIT_DATA_LEN]; i++)\n        {\n            Serial.print(\n0x\n);\n            Serial.print(dta[i+BIT_DATA], HEX);\n            Serial.print(\n\\t\n);\n        }\n        Serial.println();\n\u00a0\n        Serial.print(\nDATA: \n);\n        for(int i=0; i\ndta[BIT_DATA_LEN]; i++)\n        {\n            Serial.print(dta[i+BIT_DATA], DEC);\n            Serial.print(\n\\t\n);\n        }\n        Serial.println();\n        Serial.println(\n+------------------------------------------------------+\\r\\n\\r\\n\n);\n    }\n}\n\n\n\n\n\n\nUpload the code to the development board.\n\n\nOpen the serial monitor window and wait for the input.\n\n\nUsing IR remote control sending data\n(This example uses MIDEA Company\ns IR remote control of fans, and press the open/close key.)\n.\n\n\nYou can see the information below.\n\n\n\n\n\n\nEmitter\n\uf0c1\n\n\n\n\nOpen File-\nExamples-\nIRSendRev-\nexample-\nsend sketch for a complete example, or copy and paste code below to a new Arduino sketch.\n\n\n\n\nDescription\n: \nConnect the IR send pins to D3 for this demo. You can see the remote control\ns infrared data that received through Infrared Receiver, such as the example above. Then write the received infrared data into this example and upload to the board with Infrared Emitter Grove, so you can send the same data with remote control\ns button.\n\n\nApplication\n: \nYou can note the remote control\ns infrared data down through Infrared Receiver, then send the same data through Infrared Emitter in some cases, such as open the fan switch when indoor temperature is greater than 26 degrees.\n\n\n\n\nNote\n\nYou must connect the IR send pins to D3 for this demo.\n\n\n\n\n#include \nIRSendRev.h\n\n\u00a0\n#define BIT_LEN         0\n#define BIT_START_H     1\n#define BIT_START_L     2\n#define BIT_DATA_H      3\n#define BIT_DATA_L      4\n#define BIT_DATA_LEN    5\n#define BIT_DATA        6\n\u00a0\nconst int ir_freq = 38;                 // 38k\n\u00a0\nunsigned char dtaSend[20];\n\u00a0\nvoid dtaInit()\n{\n    dtaSend[BIT_LEN]        = 11;          // all data that needs to be sent\n    dtaSend[BIT_START_H]    = 180;         // the logic high duration of \nStart\n\n    dtaSend[BIT_START_L]    = 91;          // the logic low duration of \nStart\n\n    dtaSend[BIT_DATA_H]     = 11;          // the logic \nlong\n duration in the communication\n    dtaSend[BIT_DATA_L]     = 33;          // the logic \nshort\n duration in the communication\n\u00a0\n    dtaSend[BIT_DATA_LEN]   = 6;           // Number of data which will sent. If the number is other, you should increase or reduce dtaSend[BIT_DATA+x].\n\u00a0\n    dtaSend[BIT_DATA+0]     = 128;           // data that will sent\n    dtaSend[BIT_DATA+1]     = 127;\n    dtaSend[BIT_DATA+2]     = 192;\n    dtaSend[BIT_DATA+3]     = 63;\n    dtaSend[BIT_DATA+4]     = 192;\n    dtaSend[BIT_DATA+5]     = 63;\n}\n\u00a0\nvoid setup()\n{\n    dtaInit();\n}\n\u00a0\nvoid loop()\n{\n    IR.Send(dtaSend, 38);\n\u00a0\n    delay(2000);\n}\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove-Infrared Emitter eagle files\n\n\nIR Send and Receiver Library\n\n\nTSAL6200 Datasheet", 
            "title": "Grove - Infrared Emitter"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#specifications", 
            "text": "Voltage: 3.3-5V  Distance:10m", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#demonstration", 
            "text": "The Grove - Infrared Emitter can send data while Grove - Infrared Receiver will receive them.   Connect the Grove - Infrared Emitter to D3.  Connect the Grove - Infrared Receiver to D2.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#with-arduinoseeeduino", 
            "text": "", 
            "title": "With Arduino/Seeeduino"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#suggest-reading-for-starter", 
            "text": "Download Arduino and install Arduino driver    Getting Started with Seeeduino/Arduino", 
            "title": "Suggest Reading for Starter"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#irsendrev-library", 
            "text": "We have created a library to help you start playing quickly with the Seeeduino/Arduino, in this section we ll show you how to set up the library.", 
            "title": "IRSendRev Library"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#setup", 
            "text": "Download the  library code as a zip file  from the IRSendRev github page.  Unzip the downloaded file into your \u2026/arduino/libraries.  Rename the unzipped folder  IRSendRev  Start the Arduino IDE (or restart if it is open).", 
            "title": "Setup"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#infrared-emitter-examplesapplications", 
            "text": "These examples are going to show you how to use features of Grove - Infrared Emitter. You can use Grove - Infrared Emitter in combination with Grove - Infrared Receiver. Connect the IR send pins to D3 for this demo.", 
            "title": "Infrared Emitter Examples/Applications"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#receiver", 
            "text": "Note \nYou need to have a  Grove - Infrared Receiver . And upload this demo to the board with Infrared Receiver Grove.   Open File- Examples- IRSendRev- example- recv sketch for a complete example, or copy and paste code below to a new Arduino sketch.   Description : \nThis example connect the IR receiver pins to D2 for this demo. You can see the remote control s infrared data that received through a serial port terminal, then write the received infrared data into send.ino and upload to the board with Infrared Emitter Grove, so you can send the same data with remote control s button.  Application : \nYou can note the remote control s infrared data down through Infrared Receiver, then send the same data through Infrared Emitter in some cases, such as open the fan switch when indoor temperature is greater than 26 degrees.  #include  IRSendRev.h \n\u00a0\n#define BIT_LEN         0\n#define BIT_START_H     1\n#define BIT_START_L     2\n#define BIT_DATA_H      3\n#define BIT_DATA_L      4\n#define BIT_DATA_LEN    5\n#define BIT_DATA        6\n\u00a0\nconst int pinRecv = 2;              // ir receiver connect to D2\n\u00a0\nvoid setup()\n{\n    Serial.begin(115200);\n    IR.Init(pinRecv);\n    Serial.println( init over );\n}\n\u00a0\nunsigned char dta[20];\n\u00a0\nvoid loop()\n{\n    if(IR.IsDta())                  // get IR data\n    {\n        IR.Recv(dta);               // receive data to dta\n\u00a0\n        Serial.println( +------------------------------------------------------+ );\n        Serial.print( LEN =  );\n        Serial.println(dta[BIT_LEN]);\n        Serial.print( START_H:  );\n        Serial.print(dta[BIT_START_H]);\n        Serial.print( \\tSTART_L:  );\n        Serial.println(dta[BIT_START_L]);\n\u00a0\n        Serial.print( DATA_H:  );\n        Serial.print(dta[BIT_DATA_H]);\n        Serial.print( \\tDATA_L:  );\n        Serial.println(dta[BIT_DATA_L]);\n\u00a0\n        Serial.print( \\r\\nDATA_LEN =  );\n        Serial.println(dta[BIT_DATA_LEN]);\n\u00a0\n        Serial.print( DATA:  );\n        for(int i=0; i dta[BIT_DATA_LEN]; i++)\n        {\n            Serial.print( 0x );\n            Serial.print(dta[i+BIT_DATA], HEX);\n            Serial.print( \\t );\n        }\n        Serial.println();\n\u00a0\n        Serial.print( DATA:  );\n        for(int i=0; i dta[BIT_DATA_LEN]; i++)\n        {\n            Serial.print(dta[i+BIT_DATA], DEC);\n            Serial.print( \\t );\n        }\n        Serial.println();\n        Serial.println( +------------------------------------------------------+\\r\\n\\r\\n );\n    }\n}   Upload the code to the development board.  Open the serial monitor window and wait for the input.  Using IR remote control sending data (This example uses MIDEA Company s IR remote control of fans, and press the open/close key.) .  You can see the information below.", 
            "title": "Receiver"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#emitter", 
            "text": "Open File- Examples- IRSendRev- example- send sketch for a complete example, or copy and paste code below to a new Arduino sketch.   Description : \nConnect the IR send pins to D3 for this demo. You can see the remote control s infrared data that received through Infrared Receiver, such as the example above. Then write the received infrared data into this example and upload to the board with Infrared Emitter Grove, so you can send the same data with remote control s button.  Application : \nYou can note the remote control s infrared data down through Infrared Receiver, then send the same data through Infrared Emitter in some cases, such as open the fan switch when indoor temperature is greater than 26 degrees.   Note \nYou must connect the IR send pins to D3 for this demo.  #include  IRSendRev.h \n\u00a0\n#define BIT_LEN         0\n#define BIT_START_H     1\n#define BIT_START_L     2\n#define BIT_DATA_H      3\n#define BIT_DATA_L      4\n#define BIT_DATA_LEN    5\n#define BIT_DATA        6\n\u00a0\nconst int ir_freq = 38;                 // 38k\n\u00a0\nunsigned char dtaSend[20];\n\u00a0\nvoid dtaInit()\n{\n    dtaSend[BIT_LEN]        = 11;          // all data that needs to be sent\n    dtaSend[BIT_START_H]    = 180;         // the logic high duration of  Start \n    dtaSend[BIT_START_L]    = 91;          // the logic low duration of  Start \n    dtaSend[BIT_DATA_H]     = 11;          // the logic  long  duration in the communication\n    dtaSend[BIT_DATA_L]     = 33;          // the logic  short  duration in the communication\n\u00a0\n    dtaSend[BIT_DATA_LEN]   = 6;           // Number of data which will sent. If the number is other, you should increase or reduce dtaSend[BIT_DATA+x].\n\u00a0\n    dtaSend[BIT_DATA+0]     = 128;           // data that will sent\n    dtaSend[BIT_DATA+1]     = 127;\n    dtaSend[BIT_DATA+2]     = 192;\n    dtaSend[BIT_DATA+3]     = 63;\n    dtaSend[BIT_DATA+4]     = 192;\n    dtaSend[BIT_DATA+5]     = 63;\n}\n\u00a0\nvoid setup()\n{\n    dtaInit();\n}\n\u00a0\nvoid loop()\n{\n    IR.Send(dtaSend, 38);\n\u00a0\n    delay(2000);\n}", 
            "title": "Emitter"
        }, 
        {
            "location": "/Grove-Infrared_Emitter/#resources", 
            "text": "Grove-Infrared Emitter eagle files  IR Send and Receiver Library  TSAL6200 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/", 
            "text": "Grove - LED Matrix Driver v1.0 is UART (Serial) to dot matrix LED driver that incorporates various graphics functions.It can only support 32\u00d764 LED matrix. This product is a \nGrove\n compatible UART interface. It provides easy and rich APIs that abstract the complexity of the underlying LED driving hardware. All you need to is just call these APIs in code to implement different functionalities for your project.\n\n\nEach dot(i.e pixel) support dual color LEDs. It can produce three colors totally: red (primary color), green(primary color) and yellow (mixed color). The input current for all LEDs can be set at a time.\n\n\n\n\n\n\nNote\n\nThis Grove module does not support changing the input current of each LED separately.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible and easy to use\n\n\nHighly abstracted and complete API\n\n\nSupport dual-color LED-pixel. Three colors totally (the third color is a mix of two primary color)\n\n\nInterface: UART(SoftSerial in Arduino)\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating voltage(V)\n\n\n3.3\u20135 Volts\n\n\n\n\n\n\nOperating current(mA)\n\n\nMaximum: 28\u201350 mA\n\n\n\n\n\n\nOutput voltage (from matrix driver)\n\n\n3.3 Volts\n\n\n\n\n\n\nSymbols/Graphics functions supported\n\n\nDot, straight line, circle, char, string, number, emoji, image (you can display these symbols by calling API directly in code)\n\n\n\n\n\n\nSupported LED matrix size\n\n\n32(row)\u00d764(column)\n\n\n\n\n\n\nSupported color in each LED matrix dot\n\n\nDual LEDs (green and red) and a mixed color(yellow), and you can use only one LED in each LED matrix dot\n\n\n\n\n\n\nConnector for LED matrix\n\n\nDBSTAR_HUB 08A\n\n\n\n\n\n\nProtocol for Grove port\n\n\nUART\n\n\n\n\n\n\nWorking temperature\n\n\n-40\u201380 \u2103\n\n\n\n\n\n\nDimensions\n\n\n46.5\u00d744 mm\n\n\n\n\n\n\nWeight\n\n\n9 g(for the module), 12.5(for all single package)\n\n\n\n\n\n\n\n\nPlatforms supported\n\uf0c1\n\n\n\n\n\n\n\n\nSeeeduino/Arduino\n\n\nRaspberry Pi\n\n\nBeagleBone\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform. But, you will need additional Grove Shield like Grove - Base shield v2 board.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nGrove socket\n, to connect this product to main control board.\n\n\nLED matrix port(DBSTAR_HUB 08A )\n, to connect LED matrix. If you can not find a connector like this, you can user jumper wires as an alternative.\n\n\n\n\nPackage includes\n(main parts)\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - LED Matrix Driver v1.0\n\n\n1 piece\n\n\n\n\n\n\nGrove cable\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nNow let us run some basic examples with this module.\n\n\nWith Arduino\n\uf0c1\n\n\nMaterial required\n\uf0c1\n\n\n\n\nGrove - LED Matrix Driver v1.0 \u00d7 1\n\n\n32\u00d764 LED matrix with one red and one green LEDs in matrix dots (single color LED matrix will also be fine) \u00d7 1\n\n\nPower line (ribbon shape) for \u00d7 1\n\n\n5 Volts(output) Adapter to regulate input voltage for LED matrix \u00d7 1\n\n\n8-pin(female) ribbon cable \u00d7 1\n\n\nArduino UNO (other Arduino models will also be fine) \u00d7 1\n\n\nGrove cable\n \u00d7 1\n\n\nGrove - Base Shield \u00d7 1\n\n\n\n\nConnections\n\uf0c1\n\n\nConnect all parts as following:\n\n\n\n\n\n\nCoding Work\n\uf0c1\n\n\nYou can find more demo sketch at \nhttps://github.com/Seeed-Studio/Grove_LED_Matrix_Driver\n and development library at \nhttps://github.com/Seeed-Studio/Grove_LED_Matrix_Driver/tree/master/Arduino/LEDMatrix\n\n\n\n\n\n\nA typical demo code. You can upload code to main control board with \nCodebender\n.\n\n\n\n\n\n\n\n\n\n\nDownload and upload the code. If you do not know how to upload an Arduino sketch, please visit \nhttps://www.arduino.cc/en/Guide/Windows\n for Windows user or \nhttps://www.arduino.cc/en/Guide/MacOSX\n for Mac user. You can see the result as below.\n\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nSchematic file\n\n\nSTM32F103C8T6 Datasheet\n\n\nLibrary on Github\n\n\nFirmware for this product\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - LED Matrix Driver v1.0"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#features", 
            "text": "Grove compatible and easy to use  Highly abstracted and complete API  Support dual-color LED-pixel. Three colors totally (the third color is a mix of two primary color)  Interface: UART(SoftSerial in Arduino)", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#specifications", 
            "text": "Parameter  Value      Operating voltage(V)  3.3\u20135 Volts    Operating current(mA)  Maximum: 28\u201350 mA    Output voltage (from matrix driver)  3.3 Volts    Symbols/Graphics functions supported  Dot, straight line, circle, char, string, number, emoji, image (you can display these symbols by calling API directly in code)    Supported LED matrix size  32(row)\u00d764(column)    Supported color in each LED matrix dot  Dual LEDs (green and red) and a mixed color(yellow), and you can use only one LED in each LED matrix dot    Connector for LED matrix  DBSTAR_HUB 08A    Protocol for Grove port  UART    Working temperature  -40\u201380 \u2103    Dimensions  46.5\u00d744 mm    Weight  9 g(for the module), 12.5(for all single package)", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#platforms-supported", 
            "text": "Seeeduino/Arduino  Raspberry Pi  BeagleBone  LinkIt ONE              Note \nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform. But, you will need additional Grove Shield like Grove - Base shield v2 board.", 
            "title": "Platforms supported"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#hardware-overview", 
            "text": "Grove socket , to connect this product to main control board.  LED matrix port(DBSTAR_HUB 08A ) , to connect LED matrix. If you can not find a connector like this, you can user jumper wires as an alternative.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#package-includesmain-parts", 
            "text": "Parts name  Quantity      Grove - LED Matrix Driver v1.0  1 piece    Grove cable  1 piece", 
            "title": "Package includes(main parts)"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#getting-started", 
            "text": "Now let us run some basic examples with this module.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#with-arduino", 
            "text": "", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#material-required", 
            "text": "Grove - LED Matrix Driver v1.0 \u00d7 1  32\u00d764 LED matrix with one red and one green LEDs in matrix dots (single color LED matrix will also be fine) \u00d7 1  Power line (ribbon shape) for \u00d7 1  5 Volts(output) Adapter to regulate input voltage for LED matrix \u00d7 1  8-pin(female) ribbon cable \u00d7 1  Arduino UNO (other Arduino models will also be fine) \u00d7 1  Grove cable  \u00d7 1  Grove - Base Shield \u00d7 1", 
            "title": "Material required"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#connections", 
            "text": "Connect all parts as following:", 
            "title": "Connections"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#coding-work", 
            "text": "You can find more demo sketch at  https://github.com/Seeed-Studio/Grove_LED_Matrix_Driver  and development library at  https://github.com/Seeed-Studio/Grove_LED_Matrix_Driver/tree/master/Arduino/LEDMatrix    A typical demo code. You can upload code to main control board with  Codebender .      Download and upload the code. If you do not know how to upload an Arduino sketch, please visit  https://www.arduino.cc/en/Guide/Windows  for Windows user or  https://www.arduino.cc/en/Guide/MacOSX  for Mac user. You can see the result as below.", 
            "title": "Coding Work"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#resources", 
            "text": "Schematic file  STM32F103C8T6 Datasheet  Library on Github  Firmware for this product", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-LED_Matrix_Driver_v1.0/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-MP3_v2.0/", 
            "text": "Grove - MP3 v2.0 is a tiny-sized and compact audio module. It supports various audio file operations for an audio file of MP3, WAV and WMV format, such as random music playing, play music in specific files, and so on. With serial communication, you can use all predefined command or command combinations to do all operations on music files. This module also supports general file systems such as FAT16 and FAT32. It gets a Grove UART interface, a 3.5 mm audio jack and a micro-SD slot. With this module, you can add some noise to your silent applications.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nProduct revision\n\n\nRelease date\n\n\nSupport status\n\n\n\n\n\n\n\n\n\n\nVersion 1.0\n\n\nApril 28 2013\u200e\n\n\nSupported\n\n\n\n\n\n\nVersion 2.0\n\n\nDec 15 2015\n\n\nSupported\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGeneral operations on audio files\n\n\nOn-board micro-SD slot and 3.5 mm audio jack\n\n\nSupport sample rate of 8 / 11.025 / 12 / 16 / 22.05 / 24 / 32 / 44.1 / 48(KHz)\n\n\n24-bit DAC output, 90 dB (at Max.) dynamic output range, signal-noise ratio at 85 dB\n\n\nMP3, WMV and WAV audio format and FAT16, FAT32 files system supported\n\n\nEmbed 10 levels of equalization in total\n\n\n\n\nApplication ideas\n\uf0c1\n\n\n\n\nMiddle-level audio module for any applications.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nInput\n\n\n5 V (DC)\n\n\n\n\n\n\nOperating current (no signal output state)\n\n\nless than 15 mA\n\n\n\n\n\n\nOperating current\n\n\nless than 40 mA\n\n\n\n\n\n\nChip\n\n\nKT403A \n(datasheet)\n\n\n\n\n\n\nChip LDO output voltage\n\n\n3.3 V\n\n\n\n\n\n\nChip output current\n\n\n100mA(at Max.)\n\n\n\n\n\n\nFile formats supported\n\n\nMP3, WAV, WMA\n\n\n\n\n\n\nMaximum memory supported for SD card\n\n\n32 GB\n\n\n\n\n\n\nSampling rate\n\n\n8 / 11.025 / 12 / 16 / 22.05 / 24 / 32 / 44.1 / 48(KHz)\n\n\n\n\n\n\n\n\nPlatforms supported\n\uf0c1\n\n\n\n\n\n\n\n\nSeeeduino/Arduino\n\n\nRaspberry Pi\n\n\nBeagleBone\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform. But, you will need additional Grove Shield like Grove - Base shield v2 board.\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nParts list\n\uf0c1\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - MP3 v2.0\n\n\n1PC\n\n\n\n\n\n\nGrove - Universal Cable\n\n\n1PC\n\n\n\n\n\n\n\n\nGet started\n\uf0c1\n\n\nMaterial required\n\uf0c1\n\n\n\n\nSeeeduino \u00d7 1\n\n\nGrove - Base Shield v2 \u00d7 1\n\n\nGrove - MP3 v2.0 \u00d7 1\n\n\nSD card with music inside \u00d7 1\n\n\nUSB cable (type A to micro type-B) \u00d7 1\n\n\nHeadset, earphone or stereo with 3.5 mm audio jack \u00d7 1\n\n\n\n\nPreparations\n\uf0c1\n\n\nRefer to following guides to building an appropriate IDE:.\n\n\n\n\nNote\n\nWe have chosen Seeeduino and it is compatible with Arduino in this case. So you can also use Arduino board instead.\n\n\n\n\nGetting Started on Windows\n\n\nGetting Started on Mac OS X\n\n\nHardware connections\n\uf0c1\n\n\n\n\nA example to run\n\uf0c1\n\n\nDownload example\n\uf0c1\n\n\n1.Github \naddress\n which also contain sufficient API to download codes.\n\n\n2.Refer to \nhere\n to learn how to do some preliminary work before running code.\n\n\n3.Load file \nMP3_Play_Test.ino\n into Arduino and upload to the main controller board.\n\n\n4.Open Serial Monitor (Ctrl + Shift + M) to send a command to play music.\n\n\n\n\nNote\n\nWe need to choose \nNo line ending\n beside baud rate droplist at bottom-right of Serial Monitor window.\n\n\n\n\n5.In this case, we type \n1\n which is a command to play music. You can find more command comments in demo source code.\n\n\n6.Now enjoy the music.\n\n\nAdvanced programming\n\uf0c1\n\n\nFor advanced programming, you can \ndownload\n datasheet of chip KT403A.\n\n\nResources\n\uf0c1\n\n\n\n\nHardware \nSchematic files\n\n\nLibraries\n on Github.\n\n\nKT403A \nDatasheet\n (part)\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - MP3 v2.0"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#version-tracker", 
            "text": "Product revision  Release date  Support status      Version 1.0  April 28 2013\u200e  Supported    Version 2.0  Dec 15 2015  Supported", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#features", 
            "text": "General operations on audio files  On-board micro-SD slot and 3.5 mm audio jack  Support sample rate of 8 / 11.025 / 12 / 16 / 22.05 / 24 / 32 / 44.1 / 48(KHz)  24-bit DAC output, 90 dB (at Max.) dynamic output range, signal-noise ratio at 85 dB  MP3, WMV and WAV audio format and FAT16, FAT32 files system supported  Embed 10 levels of equalization in total", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#application-ideas", 
            "text": "Middle-level audio module for any applications.", 
            "title": "Application ideas"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#specifications", 
            "text": "Parameter  Value      Input  5 V (DC)    Operating current (no signal output state)  less than 15 mA    Operating current  less than 40 mA    Chip  KT403A  (datasheet)    Chip LDO output voltage  3.3 V    Chip output current  100mA(at Max.)    File formats supported  MP3, WAV, WMA    Maximum memory supported for SD card  32 GB    Sampling rate  8 / 11.025 / 12 / 16 / 22.05 / 24 / 32 / 44.1 / 48(KHz)", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#platforms-supported", 
            "text": "Seeeduino/Arduino  Raspberry Pi  BeagleBone  LinkIt ONE              Note \nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform. But, you will need additional Grove Shield like Grove - Base shield v2 board.", 
            "title": "Platforms supported"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#hardware-overview", 
            "text": "", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#parts-list", 
            "text": "Parts name  Quantity      Grove - MP3 v2.0  1PC    Grove - Universal Cable  1PC", 
            "title": "Parts list"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#get-started", 
            "text": "", 
            "title": "Get started"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#material-required", 
            "text": "Seeeduino \u00d7 1  Grove - Base Shield v2 \u00d7 1  Grove - MP3 v2.0 \u00d7 1  SD card with music inside \u00d7 1  USB cable (type A to micro type-B) \u00d7 1  Headset, earphone or stereo with 3.5 mm audio jack \u00d7 1", 
            "title": "Material required"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#preparations", 
            "text": "Refer to following guides to building an appropriate IDE:.   Note \nWe have chosen Seeeduino and it is compatible with Arduino in this case. So you can also use Arduino board instead.  Getting Started on Windows  Getting Started on Mac OS X", 
            "title": "Preparations"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#hardware-connections", 
            "text": "", 
            "title": "Hardware connections"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#a-example-to-run", 
            "text": "", 
            "title": "A example to run"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#download-example", 
            "text": "1.Github  address  which also contain sufficient API to download codes.  2.Refer to  here  to learn how to do some preliminary work before running code.  3.Load file  MP3_Play_Test.ino  into Arduino and upload to the main controller board.  4.Open Serial Monitor (Ctrl + Shift + M) to send a command to play music.   Note \nWe need to choose  No line ending  beside baud rate droplist at bottom-right of Serial Monitor window.  5.In this case, we type  1  which is a command to play music. You can find more command comments in demo source code.  6.Now enjoy the music.", 
            "title": "Download example"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#advanced-programming", 
            "text": "For advanced programming, you can  download  datasheet of chip KT403A.", 
            "title": "Advanced programming"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#resources", 
            "text": "Hardware  Schematic files  Libraries  on Github.  KT403A  Datasheet  (part)", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-MP3_v2.0/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/", 
            "text": "This Grove - MIni I2C motor driver includes two DRV8830. The DRV8830 provides an integrated motor driver solution for battery-powered toys, printers, and other low-voltage or battery-powered motion control applications. The module has two H-bridge drivers, and can drive two DC motors or two winding of stepper motors, as well as other loads like solenoids.It requires an onboard 5V voltage regulator which can power the I2C bus. All driver lines are diode protected from back EMF.It features two LEDs for fault indicator and four LEDs to indicate which direction each motor is running. GROVE system plug and I2C interface enables you to daisy-chain the driver with many other devices.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nWithout external power supply\n\n\nTwo leds for fault indicator\n\n\nDefault maximum drive current 200 mA\n\n\nGrove compatible\n\n\nI2C interface\n\n\nMotor\ns speed and direction can control\n\n\nNumber of channels: 2\n\n\nEasy to use\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\nThis motor driver can be used to drive any brushed electronic motor as long as it doesn\nt consume more than 1A at 5v.\nTwo motors can be driven simultaneously while set to a different speed and direction.\nThe speed can be set fully proportional and is controlled by I2C command.\n\n\n\n\n\n\nBattery-Powered:\n\n\n\n\nPrinters\n\n\nToys\n\n\nRobotics\n\n\nCameras\n\n\nPhones\n\n\n\n\n\n\n\n\nSmall Actuators, Pumps, etc.\n\n\n\n\n\n\nHere are some projects for your reference.\n\n\n\n\n\n\n\n\nMake a Mini Toy Car\n\n\nMake a Steampunk Style Award\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it NOW!\n\n\nMake it NOW!\n\n\n\n\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n2.75\n\n\n\n\n5\n\n\n\n\n6.8\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nMax Output Current per channel\n\n\n\n\n0.2(default)\n\n\n\n\n-\n\n\n\n\n1\n\n\n\n\nA\n\n\n\n\n\n\n\n\nInput/output voltage on I2C bus\n\n\n\n\n3.3/5\n\n\n\n\nV\n\n\n\n\n\n\n\n\nCommunication protocol\n\n\n\n\nI2C\n\n\n\n\n/\n\n\n\n\n\n\n\n\nDefault I2C Address\n\n\n\n\n0xC0, 0xC4\n\n\n\n\n/\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\n\n\nGrove Interface\n - Grove products have a eco system and all have a same connector which can plug onto the \nBase Shield\n. Connect this module to the I\n2\nC port of Base Shield, and then it can work well with Arduino. However, you can also connect Grove - Mini I2C Motor Driver to Arduino without Base Shield by jumper wires.\n\n\n\n\n\n\n\n\n\nArduino UNO\n\n\n\n\nBase Shield\n\n\n\n\nGrove - Mini I2C Motor Driver\n\n\n\n\n\n\n\n\n5V\n\n\n\n\nI2C port\n\n\n\n\nVCC\n\n\n\n\n\n\n\n\nGND\n\n\n\n\nGND\n\n\n\n\n\n\n\n\nSDA\n\n\n\n\nSDA\n\n\n\n\n\n\n\n\nSCL\n\n\n\n\nSCL\n\n\n\n\n\n\n\n\n\n\nCH1 fault indicator\n - Channel 1 fault indicator.\n\n\nCH2 fault indicator\n - Channel 2 fault indicator.\n\n\nDirection indicator\n - Motor direction indicator.\n\n\nCH1 Output Connector\n - Motor 1 connector.\n\n\nCH2 Output Connector\n - Motor 2 connector.\n\n\n\n\nHardware function\n\uf0c1\n\n\nChange Default maximum drive current\n\uf0c1\n\n\nThe default maximum drive current of each channel is 200mA, see the front picture of the board\n\n\n\n\nEach channel (CH1,CH2) has been added a resistor, and each value of resistor (R5,R12) is 1 \u03a9, so the maximum drive current is 200mA according to the following equation\n\n\n\n\n\n\n\n\nMeantime, each channel provides a reserved solderable pad (R6 for CH1, R13 for CH2), so you can solder a resistor onto the board to change the resistor value of each channel. Following is the new equation if adding resistor to the board\n\n\n\n\n \n\n\n\n\n\n\n\nCaution\n\nMaximum working current of each channel must be less than 1A. So the minimum value of resistor soldered to the reserved pad should not less than 0.2 \u03a9.\n\n\n\n\nChange Default I\n2\nC Address\n\uf0c1\n\n\nThe I\n2\nC address of each channel is changeable. Please take a look at the back side of the board, you will find there are 4 jumper pads; A0_CH1 and A1_CH1 are for channel 1, A0_CH2 and A1_CH2 are for channel 2, as shown below:\n\n\n\n\n\n\n\n\nYou can solder or unsolder each jumper to change the I2C address:\n\n\n\n\n1 - You need a solder iron, just solder two sides of the jumper together\n\n\n0 - You need a solder iron, just unsolder two sides of the jumper.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\nThe library of Grove - Mini I2C Motor driver is dependent on the default address.\n\n\n\n\nGetting Started\n\uf0c1\n\n\nNow, let us begin to use the Grove - Mini I2C Motor Driver.\n\n\nPreparations\n\uf0c1\n\n\nNow we are making a demo for Grove - Mini I2C Motor Driver v1.0 which require following modules.\n\n\n\n\n2 * DC Motor 2V-6V\n\n\nSeeeduino Lite\n\n\n\n\nSeeeduino Lite is compatible with Arduino.\n\n\nIf you are using an Arduino UNO or any others Arduino compatible boards that with out a Grove connect,\n\n\nYou will need a \nGrove Base Shield\n to connect the Grove easily.\n\n\nIf this is your first time using Arduino or Seeeduino, Please put hand on \nhere\n to start your Arduino journey.\n\n\nHardware Installation\n\uf0c1\n\n\nGrove - Mini I2C Motor Driver got one Grove socket for connecting two modules above.\nThey are:\n\n\n\n\n2 * DC Motor 2V-6V - connnect to CH1 \n CH2 Output connector.\n\n\nSeeeduino Lite\n\n\n\n\nConnect Seeeduino\ns Grove I2C Interface to Mini Motor Driver\ns Grove Interface as shown below:\n\n\n\n\nSoftware Work\n\uf0c1\n\n\n\n\nThe Grove - Mini I2C Motor Driver can control motor which is based on the chip DRV8830. The DRV8830 is not just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. You can use your Arduino to make them spin at any speed.\n\n\nBecause the module has 2 H-bridges, you can not only make a robot go forwards and backwards, but also turn around by having each wheel spin in a different direction.\n\n\nConnect Seeeduino to computer use a micro USB cable.\n\n\nNow, let us use the Grove - Mini I2C Motor Driver to control two DC motors rotating in the positive or opposite direction.\n\n\nGiven below is an example program to be used with an Arduino. The code for this is very basic, but you can also change it and do it your own way.\n\n\n/****************************************************************\nExample code demonstrating the use of the Arduino Library for\nthe SparkFun MiniMoto board, which uses the TI DRV8830 IC for I2C\nlow-voltage DC motor control.\n\u00a0\nThis code is beerware; if you use it, please buy me (or any other\nSparkFun employee) a cold beverage next time you run into one of\nus at the local.\n\u00a0\n17 Sep 2013- Mike Hord, SparkFun Electronics\n\u00a0\nCode developed in Arduino 1.0.5, on a Fio classic board.\n\u00a0\n**Updated for Arduino 1.6.4 5/2015**\n****************************************************************/\n\u00a0\n#include \nSparkFunMiniMoto.h\n  // Include the MiniMoto library\n\u00a0\n// Create two MiniMoto instances, with different address settings.\nMiniMoto motor0(0xC4); // A1 = 1, A0 = clear\nMiniMoto motor1(0xC0); // A1 = 1, A0 = 1 (default)\n\u00a0\n#define FAULTn  16     // Pin used for fault detection.\n\u00a0\n// Nothing terribly special in the setup() function- prep the\n//  serial port, print a little greeting, and set up our fault\n//  pin as an input.\nvoid setup()\n{\n    Serial.begin(9600);\n    Serial.println(\nHello, world!\n);\n    pinMode(FAULTn, INPUT);\n}\n\u00a0\n// The loop() function just spins the motors one way, then the\n//  other, while constantly monitoring for any fault conditions\n//  to occur. If a fault does occur, it will be reported over\n//  the serial port, and then operation continues.\nvoid loop()\n{\n    Serial.println(\nForward!\n);\n    motor0.drive(100);\n    motor1.drive(100);\n    delayUntil(1000);\n    Serial.println(\nStop!\n);\n    motor0.stop();\n    motor1.stop();\n    delay(1000);\n    Serial.println(\nReverse!\n);\n    motor0.drive(-100);\n    motor1.drive(-100);\n    delayUntil(1000);\n    Serial.println(\nBrake!\n);\n    motor0.brake();\n    motor1.brake();\n    delay(1000);\n}\n\u00a0\n// delayUntil() is a little function to run the motor either for\n//  a designated time OR until a fault occurs. Note that this is\n//  a very simple demonstration; ideally, an interrupt would be\n//  used to service faults rather than blocking the application\n//  during motion and polling for faults.\nvoid delayUntil(unsigned long elapsedTime)\n{\n    // See the \nBlinkWithoutDelay\n example for more details on how\n    //  and why this loop works the way it does.\n    unsigned long startTime = millis();\n    while (startTime + elapsedTime \n millis())\n    {\n        // If FAULTn goes low, a fault condition *may* exist. To be\n        //  sure, we'll need to check the FAULT bit.\n        if (digitalRead(FAULTn) == LOW)\n        {\n            // We're going to check both motors; the logic is the same\n            //  for each...\n            byte result = motor0.getFault();\n            // If result masked by FAULT is non-zero, we've got a fault\n            //  condition, and we should report it.\n            if (result \n FAULT)\n            {\n                Serial.print(\nMotor 0 fault: \n);\n                if (result \n OCP) Serial.println(\nChip overcurrent!\n);\n                if (result \n ILIMIT) Serial.println(\nLoad current limit!\n);\n                if (result \n UVLO) Serial.println(\nUndervoltage!\n);\n                if (result \n OTS) Serial.println(\nOver temp!\n);\n                break; // We want to break out of the motion immediately,\n                //  so we can stop motion in response to our fault.\n            }\n            result = motor1.getFault();\n            if (result \n FAULT)\n            {\n                Serial.print(\nMotor 1 fault: \n);\n                if (result \n OCP) Serial.println(\nChip overcurrent!\n);\n                if (result \n ILIMIT) Serial.println(\nLoad current limit!\n);\n                if (result \n UVLO) Serial.println(\nUndervoltage!\n);\n                if (result \n OTS) Serial.println(\nOver temp!\n);\n                break;\n            }\n        }\n    }\n}\n\n\n\n\nNow click Upload(CTRL+U) to burn testing code. Please refer to \nhere\n for any error prompt and you can also add comment on \ncommunity\n.\n\n\nReview Results\n\uf0c1\n\n\nAfter upload is complete, the motors will rotate in the positive or opposite direction in cycle.\n\n\nResources\n\uf0c1\n\n\n\n\nDRV8830 Datasheet\n\n\nGrove - Mini I2C Motor Driver_Eagle_File\n\n\nGrove - Mini I2C Motor Driver Schematic Document\n\n\nGrove - Mini I2C Motor Driver Source Library\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - Mini I2C Motor Driver v1.0"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#features", 
            "text": "Without external power supply  Two leds for fault indicator  Default maximum drive current 200 mA  Grove compatible  I2C interface  Motor s speed and direction can control  Number of channels: 2  Easy to use", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#application-ideas", 
            "text": "This motor driver can be used to drive any brushed electronic motor as long as it doesn t consume more than 1A at 5v.\nTwo motors can be driven simultaneously while set to a different speed and direction.\nThe speed can be set fully proportional and is controlled by I2C command.    Battery-Powered:   Printers  Toys  Robotics  Cameras  Phones     Small Actuators, Pumps, etc.    Here are some projects for your reference.     Make a Mini Toy Car  Make a Steampunk Style Award          Make it NOW!  Make it NOW!", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n2.75  \n5  \n6.8  \nVDC    \nMax Output Current per channel  \n0.2(default)  \n-  \n1  \nA    \nInput/output voltage on I2C bus  \n3.3/5  \nV    \nCommunication protocol  \nI2C  \n/    \nDefault I2C Address  \n0xC0, 0xC4  \n/", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#hardware-overview", 
            "text": "Grove Interface  - Grove products have a eco system and all have a same connector which can plug onto the  Base Shield . Connect this module to the I 2 C port of Base Shield, and then it can work well with Arduino. However, you can also connect Grove - Mini I2C Motor Driver to Arduino without Base Shield by jumper wires.     \nArduino UNO  \nBase Shield  \nGrove - Mini I2C Motor Driver    \n5V  \nI2C port  \nVCC    \nGND  \nGND    \nSDA  \nSDA    \nSCL  \nSCL     CH1 fault indicator  - Channel 1 fault indicator.  CH2 fault indicator  - Channel 2 fault indicator.  Direction indicator  - Motor direction indicator.  CH1 Output Connector  - Motor 1 connector.  CH2 Output Connector  - Motor 2 connector.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#hardware-function", 
            "text": "", 
            "title": "Hardware function"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#change-default-maximum-drive-current", 
            "text": "The default maximum drive current of each channel is 200mA, see the front picture of the board   Each channel (CH1,CH2) has been added a resistor, and each value of resistor (R5,R12) is 1 \u03a9, so the maximum drive current is 200mA according to the following equation     Meantime, each channel provides a reserved solderable pad (R6 for CH1, R13 for CH2), so you can solder a resistor onto the board to change the resistor value of each channel. Following is the new equation if adding resistor to the board        Caution \nMaximum working current of each channel must be less than 1A. So the minimum value of resistor soldered to the reserved pad should not less than 0.2 \u03a9.", 
            "title": "Change Default maximum drive current"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#change-default-i2c-address", 
            "text": "The I 2 C address of each channel is changeable. Please take a look at the back side of the board, you will find there are 4 jumper pads; A0_CH1 and A1_CH1 are for channel 1, A0_CH2 and A1_CH2 are for channel 2, as shown below:     You can solder or unsolder each jumper to change the I2C address:   1 - You need a solder iron, just solder two sides of the jumper together  0 - You need a solder iron, just unsolder two sides of the jumper.       Note \nThe library of Grove - Mini I2C Motor driver is dependent on the default address.", 
            "title": "Change Default I2C Address"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#getting-started", 
            "text": "Now, let us begin to use the Grove - Mini I2C Motor Driver.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#preparations", 
            "text": "Now we are making a demo for Grove - Mini I2C Motor Driver v1.0 which require following modules.   2 * DC Motor 2V-6V  Seeeduino Lite   Seeeduino Lite is compatible with Arduino.  If you are using an Arduino UNO or any others Arduino compatible boards that with out a Grove connect,  You will need a  Grove Base Shield  to connect the Grove easily.  If this is your first time using Arduino or Seeeduino, Please put hand on  here  to start your Arduino journey.", 
            "title": "Preparations"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#hardware-installation", 
            "text": "Grove - Mini I2C Motor Driver got one Grove socket for connecting two modules above.\nThey are:   2 * DC Motor 2V-6V - connnect to CH1   CH2 Output connector.  Seeeduino Lite   Connect Seeeduino s Grove I2C Interface to Mini Motor Driver s Grove Interface as shown below:", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#software-work", 
            "text": "The Grove - Mini I2C Motor Driver can control motor which is based on the chip DRV8830. The DRV8830 is not just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. You can use your Arduino to make them spin at any speed.  Because the module has 2 H-bridges, you can not only make a robot go forwards and backwards, but also turn around by having each wheel spin in a different direction.  Connect Seeeduino to computer use a micro USB cable.  Now, let us use the Grove - Mini I2C Motor Driver to control two DC motors rotating in the positive or opposite direction.  Given below is an example program to be used with an Arduino. The code for this is very basic, but you can also change it and do it your own way.  /****************************************************************\nExample code demonstrating the use of the Arduino Library for\nthe SparkFun MiniMoto board, which uses the TI DRV8830 IC for I2C\nlow-voltage DC motor control.\n\u00a0\nThis code is beerware; if you use it, please buy me (or any other\nSparkFun employee) a cold beverage next time you run into one of\nus at the local.\n\u00a0\n17 Sep 2013- Mike Hord, SparkFun Electronics\n\u00a0\nCode developed in Arduino 1.0.5, on a Fio classic board.\n\u00a0\n**Updated for Arduino 1.6.4 5/2015**\n****************************************************************/\n\u00a0\n#include  SparkFunMiniMoto.h   // Include the MiniMoto library\n\u00a0\n// Create two MiniMoto instances, with different address settings.\nMiniMoto motor0(0xC4); // A1 = 1, A0 = clear\nMiniMoto motor1(0xC0); // A1 = 1, A0 = 1 (default)\n\u00a0\n#define FAULTn  16     // Pin used for fault detection.\n\u00a0\n// Nothing terribly special in the setup() function- prep the\n//  serial port, print a little greeting, and set up our fault\n//  pin as an input.\nvoid setup()\n{\n    Serial.begin(9600);\n    Serial.println( Hello, world! );\n    pinMode(FAULTn, INPUT);\n}\n\u00a0\n// The loop() function just spins the motors one way, then the\n//  other, while constantly monitoring for any fault conditions\n//  to occur. If a fault does occur, it will be reported over\n//  the serial port, and then operation continues.\nvoid loop()\n{\n    Serial.println( Forward! );\n    motor0.drive(100);\n    motor1.drive(100);\n    delayUntil(1000);\n    Serial.println( Stop! );\n    motor0.stop();\n    motor1.stop();\n    delay(1000);\n    Serial.println( Reverse! );\n    motor0.drive(-100);\n    motor1.drive(-100);\n    delayUntil(1000);\n    Serial.println( Brake! );\n    motor0.brake();\n    motor1.brake();\n    delay(1000);\n}\n\u00a0\n// delayUntil() is a little function to run the motor either for\n//  a designated time OR until a fault occurs. Note that this is\n//  a very simple demonstration; ideally, an interrupt would be\n//  used to service faults rather than blocking the application\n//  during motion and polling for faults.\nvoid delayUntil(unsigned long elapsedTime)\n{\n    // See the  BlinkWithoutDelay  example for more details on how\n    //  and why this loop works the way it does.\n    unsigned long startTime = millis();\n    while (startTime + elapsedTime   millis())\n    {\n        // If FAULTn goes low, a fault condition *may* exist. To be\n        //  sure, we'll need to check the FAULT bit.\n        if (digitalRead(FAULTn) == LOW)\n        {\n            // We're going to check both motors; the logic is the same\n            //  for each...\n            byte result = motor0.getFault();\n            // If result masked by FAULT is non-zero, we've got a fault\n            //  condition, and we should report it.\n            if (result   FAULT)\n            {\n                Serial.print( Motor 0 fault:  );\n                if (result   OCP) Serial.println( Chip overcurrent! );\n                if (result   ILIMIT) Serial.println( Load current limit! );\n                if (result   UVLO) Serial.println( Undervoltage! );\n                if (result   OTS) Serial.println( Over temp! );\n                break; // We want to break out of the motion immediately,\n                //  so we can stop motion in response to our fault.\n            }\n            result = motor1.getFault();\n            if (result   FAULT)\n            {\n                Serial.print( Motor 1 fault:  );\n                if (result   OCP) Serial.println( Chip overcurrent! );\n                if (result   ILIMIT) Serial.println( Load current limit! );\n                if (result   UVLO) Serial.println( Undervoltage! );\n                if (result   OTS) Serial.println( Over temp! );\n                break;\n            }\n        }\n    }\n}  Now click Upload(CTRL+U) to burn testing code. Please refer to  here  for any error prompt and you can also add comment on  community .", 
            "title": "Software Work"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#review-results", 
            "text": "After upload is complete, the motors will rotate in the positive or opposite direction in cycle.", 
            "title": "Review Results"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#resources", 
            "text": "DRV8830 Datasheet  Grove - Mini I2C Motor Driver_Eagle_File  Grove - Mini I2C Motor Driver Schematic Document  Grove - Mini I2C Motor Driver Source Library", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Mini_I2C_Motor_Driver_v1.0/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-Speaker/", 
            "text": "The Grove- Speaker is a module which consists of power amplification and voice outputs. The loudness can be adjusted by the on-board potentiometer. With different input frequencies, the loud-speaker generates different tones. Coding the music into arduino, DIY your own music box!\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nVolume Adjustable\n\n\nGrove Interface\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n4.0\n\n\n5.0\n\n\n5.5\n\n\nVDC\n\n\n\n\n\n\nVoltage Gain\n\n\n-\n\n\n-\n\n\n46\n\n\ndb\n\n\n\n\n\n\nBand Width\n\n\n-\n\n\n-\n\n\n20\n\n\nKHz\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nThe speaker can emit a variety of sounds like a car horn, doorbell and ignition . The different sounds are based on the frequency of the input signal.\n\n\nYou can supply different frequency signal to this module with Arduino. Arduino generates these signal via PWM or even digital write and delay.Here we are going to show you how to generate these signals using \ndelay()\n, the speaker sound bass 1~7.\n\n\n\n\n/*macro definition of Speaker pin*/\n#define SPEAKER 3\n\nint BassTab[]={1911,1702,1516,1431,1275,1136,1012};//bass 1~7\n\nvoid setup() \n{\n    pinInit();\n}\nvoid loop()\n{\n    /*sound bass 1~7*/\n    for(int note_index=0;note_index\n7;note_index++)\n    {\n        sound(note_index);\n        delay(500);\n    }\n}\nvoid pinInit()\n{\n    pinMode(SPEAKER,OUTPUT);\n    digitalWrite(SPEAKER,LOW);\n}\nvoid sound(uint8_t note_index)\n{\n    for(int i=0;i\n100;i++)   \n    {\n        digitalWrite(SPEAKER,HIGH);\n        delayMicroseconds(BassTab[note_index]);\n        digitalWrite(SPEAKER,LOW);\n        delayMicroseconds(BassTab[note_index]);\n    }\n}\n\n\n\n\n\nNote\n\nDue to the influence of the capacitance, the module can only output the bass signal, and the treble is unable to emit.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - Speaker Eagle File\n\n\nHow to generate different tone with MCU\n\n\nGrove_-_Speaker_v1.0_brd.pdf\n\n\nGrove_-_Speaker_v1.0_sch.pdf\n\n\nLM386 Low Voltage Audio Power Amplifier Datasheet", 
            "title": "Grove - Speaker"
        }, 
        {
            "location": "/Grove-Speaker/#features", 
            "text": "Volume Adjustable  Grove Interface", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Speaker/#specifications", 
            "text": "Item  Min  Typical  Max  Unit      Working Voltage  4.0  5.0  5.5  VDC    Voltage Gain  -  -  46  db    Band Width  -  -  20  KHz", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Speaker/#usage", 
            "text": "The speaker can emit a variety of sounds like a car horn, doorbell and ignition . The different sounds are based on the frequency of the input signal.  You can supply different frequency signal to this module with Arduino. Arduino generates these signal via PWM or even digital write and delay.Here we are going to show you how to generate these signals using  delay() , the speaker sound bass 1~7.   /*macro definition of Speaker pin*/\n#define SPEAKER 3\n\nint BassTab[]={1911,1702,1516,1431,1275,1136,1012};//bass 1~7\n\nvoid setup() \n{\n    pinInit();\n}\nvoid loop()\n{\n    /*sound bass 1~7*/\n    for(int note_index=0;note_index 7;note_index++)\n    {\n        sound(note_index);\n        delay(500);\n    }\n}\nvoid pinInit()\n{\n    pinMode(SPEAKER,OUTPUT);\n    digitalWrite(SPEAKER,LOW);\n}\nvoid sound(uint8_t note_index)\n{\n    for(int i=0;i 100;i++)   \n    {\n        digitalWrite(SPEAKER,HIGH);\n        delayMicroseconds(BassTab[note_index]);\n        digitalWrite(SPEAKER,LOW);\n        delayMicroseconds(BassTab[note_index]);\n    }\n}   Note \nDue to the influence of the capacitance, the module can only output the bass signal, and the treble is unable to emit.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Speaker/#resources", 
            "text": "Grove - Speaker Eagle File  How to generate different tone with MCU  Grove_-_Speaker_v1.0_brd.pdf  Grove_-_Speaker_v1.0_sch.pdf  LM386 Low Voltage Audio Power Amplifier Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-Variable_Color_LED/", 
            "text": "This Grove consists of one 8mm RGB LED. It operates at 5V DC. When SIG pin is logic HIGH, the RGB LED will light up. Perfect for use on Seeeduino digital outputs, or also can be controlled by pulse-width modulation. And it uses three adjustable resistor to change the color of the RGB LED.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove compatible\n\n\nColor adjustable\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nToys\n\n\nDecoration\n\n\n\n\n\n\nCaution\n\nBe gentle while adjusting the R, G and B adjustable resistances in case of over-turning.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nOperate Voltage\n\n\n5.0\n\n\nVDC\n\n\n\n\n\n\nWorking Current\n\n\n20\n\n\nmA\n\n\n\n\n\n\nVariable Resistor\n\n\n1\n\n\nK\u03a9\n\n\n\n\n\n\n\n\nUsage\n\uf0c1\n\n\nThe three resistances RED, GREEN and BLUE of the module control the R, G and B channels respectively. By adjusting the three adjustable resistances, it can turn out variable color. The thing to notice, however, is that be gentle when turning the adjustable resistances.\n\n\nThe following sketch demonstrates a simple application of controlling its brightness. As the picture on the below indicates, the Variable Color LED is connected to digital port 9 of the \nGrove - Base Shield\n. The hardware installation is as follows:\n\n\n\n\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\nDemo code like:\n\n\nint ledPin = 9;    // LED connected to digital pin 9\n\nvoid setup()  { \n  // nothing happens in setup \n}\n\nvoid loop()  { \n  // fade in from min to max in increments of 5 points:\n  for(int fadeValue = 0\u00a0; fadeValue \n= 255; fadeValue +=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  }\n\n  // fade out from max to min in increments of 5 points:\n  for(int fadeValue = 255\u00a0; fadeValue \n= 0; fadeValue -=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  } \n}\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n    Adjust the three adjustable resistances, I am sure you will like it. Have a try!\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nVariable Color LED eagle_file", 
            "title": "Grove - Variable Color LED"
        }, 
        {
            "location": "/Grove-Variable_Color_LED/#features", 
            "text": "Grove compatible  Color adjustable", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-Variable_Color_LED/#application-ideas", 
            "text": "Toys  Decoration    Caution \nBe gentle while adjusting the R, G and B adjustable resistances in case of over-turning.", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-Variable_Color_LED/#specifications", 
            "text": "Item  Typical  Unit      Operate Voltage  5.0  VDC    Working Current  20  mA    Variable Resistor  1  K\u03a9", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-Variable_Color_LED/#usage", 
            "text": "The three resistances RED, GREEN and BLUE of the module control the R, G and B channels respectively. By adjusting the three adjustable resistances, it can turn out variable color. The thing to notice, however, is that be gentle when turning the adjustable resistances.  The following sketch demonstrates a simple application of controlling its brightness. As the picture on the below indicates, the Variable Color LED is connected to digital port 9 of the  Grove - Base Shield . The hardware installation is as follows:    Copy and paste code below to a new Arduino sketch.   Demo code like:  int ledPin = 9;    // LED connected to digital pin 9\n\nvoid setup()  { \n  // nothing happens in setup \n}\n\nvoid loop()  { \n  // fade in from min to max in increments of 5 points:\n  for(int fadeValue = 0\u00a0; fadeValue  = 255; fadeValue +=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  }\n\n  // fade out from max to min in increments of 5 points:\n  for(int fadeValue = 255\u00a0; fadeValue  = 0; fadeValue -=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  } \n}   Upload the code, Please click  here  if you do not know how to upload.\n    Adjust the three adjustable resistances, I am sure you will like it. Have a try!", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-Variable_Color_LED/#resources", 
            "text": "Variable Color LED eagle_file", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-4-Digit_Display/", 
            "text": "Grove - 4-Digit Display module is a 12-pin module. In this module, we utilise a TM1637 to scale down the number of controlling pins to 2. That is to say, it controls both the content and the luminance via only 2 digital pins of Arduino or Seeeduino. For projects that require alpha-numeric display, this can be a nice choice.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\n4 digit red alpha-numeric display\n\n\nGrove compatible interface (3.3V/5V)\n\n\n8 adjustable luminance levels\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nTime display\n\n\nStopwatch\n\n\nSensors\n input display\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3.3\n\n\n\n\n5.0\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n0.2\n\n\n\n\n27\n\n\n\n\n80\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nDimensions\n\n\n\n\n42x24x14\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nNet Weight\n\n\n\n\n7\u00b11\n\n\n\n\ng\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nGrove interface\n - Can be connected to digital port on Grove - Base Shield.\n\n\n4 - digit display\n - Common anode digital tube.\n\n\nPin definition:\n CLK DIO VCC GND\n\n\nGetting Started\n\uf0c1\n\n\nWith \nTI LaunchPad\n\uf0c1\n\n\nDisplaying the Numbers (4-Digital-Display)\n\n\nThis example demonstrates how to display some digital numbers using a Grove-4-Digital Display.\n\n\n\n\n/*\n * TM1637.cpp\n * A library for the 4 digit display\n */\n#include \nTM1637.h\n\n#define CLK 39 //pins definitions for TM1637 and can be changed to other ports\n#define DIO 38\nTM1637 tm1637(CLK,DIO);\nvoid setup()\n{\n    tm1637.init();\n    tm1637.set(BRIGHT_TYPICAL);//BRIGHT_TYPICAL = 2,BRIGHT_DARKEST = 0,BRIGHTEST = 7;\n}\nvoid loop()\n{\n    int8_t NumTab[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};//0~9,A,b,C,d,E,F\n    int8_t ListDisp[4];\n    unsigned char i = 0;\n    unsigned char count = 0;\n    delay(150);\n    while(1)\n    {\n        i = count;\n        count ++;\n        if(count == sizeof(NumTab)) count = 0;\n        for(unsigned char BitSelect = 0;BitSelect \n 4;BitSelect ++)\n        {\n            ListDisp[BitSelect] = NumTab[i];\n            i ++;\n            if(i == sizeof(NumTab)) i = 0;\n        }\n        tm1637.display(0,ListDisp[0]);\n        tm1637.display(1,ListDisp[1]);\n        tm1637.display(2,ListDisp[2]);\n        tm1637.display(3,ListDisp[3]);\n        delay(300);\n    }\n}\n\n\n\n\nWith \nArduino\n\uf0c1\n\n\nThe module uses an LED drive chip - TM1637 to control the contents and change the luminance. Here we drive it to display time.\n\n\n\n\n\n\nConnect the Grove socket marked \nIN\n on the LED Strip Driver and digital port 2 of the \nGrove - Base Shield\n with a Grove cable. You can change to the digital port as you like. But don\nt forget to change the port number in the definition of the demo code at the same time.\n\n\n\n\n\n\nPlug onto Arduino/Seeeduino or plug \nGrove - Mega Shield\n onto Arduino Mega.\n\n\nSeeeduino and Grove - 4-digit display:\n\n\n\n\nArduino Mega and Grove - 4-digit display:\n\n\n\n\n\n\n\nConnect Arduino/Seeeduino to PC via a USB cable.\n\n\n\n\n\n\nDownload \nthe 4-Digit Display library\n and \nTimerOne library\n. Unzip and put them in the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries.\n\n\n\n\n\n\nRestart the Arduino IDE, open one demo code you like, for example ClockDisplay directly by the path:File -\n Example -\nDigitalTube-\nClockDisplay.\n\n\n\n\n\n\n\n\nUpload the demo code and the clock will be ticking in a few seconds. Please click \nhere\n if you do not know how to upload.\n\n\nYou can see this:\n\n\n\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D5 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_4_digit_display.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove 4 Digit Display to digital port D5\n    # CLK,DIO,VCC,GND\n    display = 5\n    grovepi.pinMode(display,\nOUTPUT\n)\n\n    # If you have an analog sensor connect it to A0 so you can monitor it below\n    sensor = 0\n    grovepi.pinMode(sensor,\nINPUT\n)\n\n    time.sleep(.5)\n\n    # 4 Digit Display methods\n    # grovepi.fourDigit_init(pin)\n    # grovepi.fourDigit_number(pin,value,leading_zero)\n    # grovepi.fourDigit_brightness(pin,brightness)\n    # grovepi.fourDigit_digit(pin,segment,value)\n    # grovepi.fourDigit_segment(pin,segment,leds)\n    # grovepi.fourDigit_score(pin,left,right)\n    # grovepi.fourDigit_monitor(pin,analog,duration)\n    # grovepi.fourDigit_on(pin)\n    # grovepi.fourDigit_off(pin)\n\n    while True:\n        try:\n            print \nTest 1) Initialise\n\n            grovepi.fourDigit_init(display)\n            time.sleep(.5)\n\n            print \nTest 2) Set brightness\n\n            for i in range(0,8):\n                grovepi.fourDigit_brightness(display,i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n            # set to lowest brightness level\n            grovepi.fourDigit_brightness(display,0)\n            time.sleep(.5)\n\n            print \nTest 3) Set number without leading zeros\n\n            leading_zero = 0\n            grovepi.fourDigit_number(display,1,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,12,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,123,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,1234,leading_zero)\n            time.sleep(.5)\n\n            print \nTest 4) Set number with leading zeros\n\n            leading_zero = 1\n            grovepi.fourDigit_number(display,5,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,56,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,567,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,5678,leading_zero)\n            time.sleep(.5)\n\n            print \nTest 5) Set individual digit\n\n            grovepi.fourDigit_digit(display,0,2)\n            grovepi.fourDigit_digit(display,1,6)\n            grovepi.fourDigit_digit(display,2,9)\n            grovepi.fourDigit_digit(display,3,15) # 15 = F\n            time.sleep(.5)\n\n            print \nTest 6) Set individual segment\n\n            grovepi.fourDigit_segment(display,0,118) # 118 = H\n            grovepi.fourDigit_segment(display,1,121) # 121 = E\n            grovepi.fourDigit_segment(display,2,118) # 118 = H\n            grovepi.fourDigit_segment(display,3,121) # 121 = E\n            time.sleep(.5)\n\n            grovepi.fourDigit_segment(display,0,57) # 57 = C\n            grovepi.fourDigit_segment(display,1,63) # 63 = O\n            grovepi.fourDigit_segment(display,2,63) # 63 = O\n            grovepi.fourDigit_segment(display,3,56) # 56 = L\n            time.sleep(.5)\n\n            print \nTest 7) Set score\n\n            grovepi.fourDigit_score(display,0,0)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,0)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,1)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,2)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,3)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,4)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,5)\n            time.sleep(.5)\n\n            print \nTest 8) Set time\n\n            grovepi.fourDigit_score(display,12,59)\n            time.sleep(.5)\n\n            print \nTest 9) Monitor analog pin\n\n            seconds = 10\n            grovepi.fourDigit_monitor(display,sensor,seconds)\n            time.sleep(.5)\n\n            print \nTest 10) Switch all on\n\n            grovepi.fourDigit_on(display)\n            time.sleep(.5)\n\n            print \nTest 11) Switch all off\n\n            grovepi.fourDigit_off(display)\n            time.sleep(.5)\n\n        except KeyboardInterrupt:\n            grovepi.fourDigit_off(display)\n            break\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n   sudo python grove_4_digit_display.py\n\n\n\n6.This demo may not work if your grovepi doesn\nt have the newest firmware, update the firmware.\n\n\ncd yourpath/GrovePi/Firmware\nsudo ./firmware_update.sh\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - 4-Digit Display V1.0 eagle files\n\n\nSchematic in PDF\n\n\n4-Digit Display library\n\n\nTimerOne library\n\n\nFour-Digit Display Suli Library\n\n\nTM1637 datasheet\n\n\n\n\nRelated Projects\n\n\nIf you want to make some awesome projects by 4-Digit Display, here\ns one project for reference.\n\n\n\n\nAir Quality Box\n\n\n\n\n\n\nWith this demo, we can see the air quality data on 4-Digit Display.", 
            "title": "Grove - 4-Digit Display"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#features", 
            "text": "4 digit red alpha-numeric display  Grove compatible interface (3.3V/5V)  8 adjustable luminance levels", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#application-ideas", 
            "text": "Time display  Stopwatch  Sensors  input display", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#specifications", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3.3  \n5.0  \n5.5  \nVDC    \nCurrent  \n0.2  \n27  \n80  \nmA    \nDimensions  \n42x24x14  \nmm    \nNet Weight  \n7\u00b11  \ng", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#hardware-overview", 
            "text": "Grove interface  - Can be connected to digital port on Grove - Base Shield.  4 - digit display  - Common anode digital tube.  Pin definition:  CLK DIO VCC GND", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#with-ti-launchpad", 
            "text": "Displaying the Numbers (4-Digital-Display)  This example demonstrates how to display some digital numbers using a Grove-4-Digital Display.   /*\n * TM1637.cpp\n * A library for the 4 digit display\n */\n#include  TM1637.h \n#define CLK 39 //pins definitions for TM1637 and can be changed to other ports\n#define DIO 38\nTM1637 tm1637(CLK,DIO);\nvoid setup()\n{\n    tm1637.init();\n    tm1637.set(BRIGHT_TYPICAL);//BRIGHT_TYPICAL = 2,BRIGHT_DARKEST = 0,BRIGHTEST = 7;\n}\nvoid loop()\n{\n    int8_t NumTab[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};//0~9,A,b,C,d,E,F\n    int8_t ListDisp[4];\n    unsigned char i = 0;\n    unsigned char count = 0;\n    delay(150);\n    while(1)\n    {\n        i = count;\n        count ++;\n        if(count == sizeof(NumTab)) count = 0;\n        for(unsigned char BitSelect = 0;BitSelect   4;BitSelect ++)\n        {\n            ListDisp[BitSelect] = NumTab[i];\n            i ++;\n            if(i == sizeof(NumTab)) i = 0;\n        }\n        tm1637.display(0,ListDisp[0]);\n        tm1637.display(1,ListDisp[1]);\n        tm1637.display(2,ListDisp[2]);\n        tm1637.display(3,ListDisp[3]);\n        delay(300);\n    }\n}", 
            "title": "With TI LaunchPad"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#with-arduino", 
            "text": "The module uses an LED drive chip - TM1637 to control the contents and change the luminance. Here we drive it to display time.    Connect the Grove socket marked  IN  on the LED Strip Driver and digital port 2 of the  Grove - Base Shield  with a Grove cable. You can change to the digital port as you like. But don t forget to change the port number in the definition of the demo code at the same time.    Plug onto Arduino/Seeeduino or plug  Grove - Mega Shield  onto Arduino Mega.  Seeeduino and Grove - 4-digit display:   Arduino Mega and Grove - 4-digit display:    Connect Arduino/Seeeduino to PC via a USB cable.    Download  the 4-Digit Display library  and  TimerOne library . Unzip and put them in the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries.    Restart the Arduino IDE, open one demo code you like, for example ClockDisplay directly by the path:File -  Example - DigitalTube- ClockDisplay.     Upload the demo code and the clock will be ticking in a few seconds. Please click  here  if you do not know how to upload.  You can see this:", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D5 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_4_digit_display.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n\n    # Connect the Grove 4 Digit Display to digital port D5\n    # CLK,DIO,VCC,GND\n    display = 5\n    grovepi.pinMode(display, OUTPUT )\n\n    # If you have an analog sensor connect it to A0 so you can monitor it below\n    sensor = 0\n    grovepi.pinMode(sensor, INPUT )\n\n    time.sleep(.5)\n\n    # 4 Digit Display methods\n    # grovepi.fourDigit_init(pin)\n    # grovepi.fourDigit_number(pin,value,leading_zero)\n    # grovepi.fourDigit_brightness(pin,brightness)\n    # grovepi.fourDigit_digit(pin,segment,value)\n    # grovepi.fourDigit_segment(pin,segment,leds)\n    # grovepi.fourDigit_score(pin,left,right)\n    # grovepi.fourDigit_monitor(pin,analog,duration)\n    # grovepi.fourDigit_on(pin)\n    # grovepi.fourDigit_off(pin)\n\n    while True:\n        try:\n            print  Test 1) Initialise \n            grovepi.fourDigit_init(display)\n            time.sleep(.5)\n\n            print  Test 2) Set brightness \n            for i in range(0,8):\n                grovepi.fourDigit_brightness(display,i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n            # set to lowest brightness level\n            grovepi.fourDigit_brightness(display,0)\n            time.sleep(.5)\n\n            print  Test 3) Set number without leading zeros \n            leading_zero = 0\n            grovepi.fourDigit_number(display,1,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,12,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,123,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,1234,leading_zero)\n            time.sleep(.5)\n\n            print  Test 4) Set number with leading zeros \n            leading_zero = 1\n            grovepi.fourDigit_number(display,5,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,56,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,567,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,5678,leading_zero)\n            time.sleep(.5)\n\n            print  Test 5) Set individual digit \n            grovepi.fourDigit_digit(display,0,2)\n            grovepi.fourDigit_digit(display,1,6)\n            grovepi.fourDigit_digit(display,2,9)\n            grovepi.fourDigit_digit(display,3,15) # 15 = F\n            time.sleep(.5)\n\n            print  Test 6) Set individual segment \n            grovepi.fourDigit_segment(display,0,118) # 118 = H\n            grovepi.fourDigit_segment(display,1,121) # 121 = E\n            grovepi.fourDigit_segment(display,2,118) # 118 = H\n            grovepi.fourDigit_segment(display,3,121) # 121 = E\n            time.sleep(.5)\n\n            grovepi.fourDigit_segment(display,0,57) # 57 = C\n            grovepi.fourDigit_segment(display,1,63) # 63 = O\n            grovepi.fourDigit_segment(display,2,63) # 63 = O\n            grovepi.fourDigit_segment(display,3,56) # 56 = L\n            time.sleep(.5)\n\n            print  Test 7) Set score \n            grovepi.fourDigit_score(display,0,0)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,0)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,1)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,2)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,3)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,4)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,5)\n            time.sleep(.5)\n\n            print  Test 8) Set time \n            grovepi.fourDigit_score(display,12,59)\n            time.sleep(.5)\n\n            print  Test 9) Monitor analog pin \n            seconds = 10\n            grovepi.fourDigit_monitor(display,sensor,seconds)\n            time.sleep(.5)\n\n            print  Test 10) Switch all on \n            grovepi.fourDigit_on(display)\n            time.sleep(.5)\n\n            print  Test 11) Switch all off \n            grovepi.fourDigit_off(display)\n            time.sleep(.5)\n\n        except KeyboardInterrupt:\n            grovepi.fourDigit_off(display)\n            break\n        except IOError:\n            print  Error   5.Run the demo.     sudo python grove_4_digit_display.py  6.This demo may not work if your grovepi doesn t have the newest firmware, update the firmware.  cd yourpath/GrovePi/Firmware\nsudo ./firmware_update.sh", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-4-Digit_Display/#resources", 
            "text": "Grove - 4-Digit Display V1.0 eagle files  Schematic in PDF  4-Digit Display library  TimerOne library  Four-Digit Display Suli Library  TM1637 datasheet   Related Projects  If you want to make some awesome projects by 4-Digit Display, here s one project for reference.   Air Quality Box    With this demo, we can see the air quality data on 4-Digit Display.", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/", 
            "text": "Done with tedious mono color backlight? This Grove enables you to set the color to whatever you like via \nthe simple and concise Grove interface. It takes I2C as communication method with your microcontroller. \nSo number of pins required for data exchange and backlight control shrinks from ~10 to 2, relieving IOs for \nother challenging tasks. Besides, Grove - LCD RGB Backlight supports user-defined characters. Want to get \na love heart or some other foreign characters? Just take advantage of this feature and design it! \nThis product is a replacement of Grove - Serial LCD. If you are looking for primitive 16x2 LCD modules, we \nhave green yellow backlight version and blue backlight version on sale also.\n\n\n\n\n\n\nNote\n\n\nThis document work for Version 1.0, 2.0 and 4.0.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nRGB Backlight\n\n\nI2C communication\n\n\nBuilt-in English fonts\n\n\n16x2 LCD\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nIntem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nInput Voltage\n\n\n5V\n\n\n\n\n\n\nOperating Current\n\n\n60mA\n\n\n\n\n\n\nCGROM\n\n\n10880 bit\n\n\n\n\n\n\nCGRAM\n\n\n64x8 bit\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nHuman Machine Interface\n\n\nSmart House\n\n\nSensor Hub\n\n\n\n\nHere are some projects for your reference. \n\n\n\n\n\n\n\n\nEdison Wi-Fi Address\n\n\nWiFi Enabled Greenhouse\n\n\nGrove Lucky Dumpling\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it Now!\n\n\nMake it Now!\n\n\nMake it Now!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nToothbrushing Instructor\n\n\nLinkIt ONE Pager\n\n\nLinkIt ONE IoT Demo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it Now!\n\n\nMake it Now!\n\n\nMake it Now!\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nThis getting started will show you how to use Grove - LCD RGB Backlight, we need a \nSeeeduino\n as well. \n\n\n\n\nNote\n\n\nThis demo is under Win10 and Arduino IDE1.6.9.\n\n\n\n\nSTEP1. Download Arduino Library\n\uf0c1\n\n\nYou need to download the library and install to your Arduino IDE.\n\n\n\n\nSTEP2. Hardware Installation\n\uf0c1\n\n\nHardware installation is very easy, because there\ns an I2C Grove in Seeeduino, so what we need to do is \nconnect it to I2C Grove via a Grove cable. \n\n\n\n\nSTEP3. Download Code and Upload\n\uf0c1\n\n\nYou can download the demo code in Github, click here, then extract it to anywhere. \n\n\nIf you have some problem with this step, please refer to Getting Start with Seeeduino there is a Hello World example in the library, open it, and upload to Seeeduino V3.0. Then you can see \nHello world\n on the first row, and second row will print the number of second since reset. \n\n\n\n\nSTEP4. Change Color of Backlight\n\uf0c1\n\n\nOne of Grove - LCD RGB Backlight\ns most important feature is: you can change the color backlight, and it\ns \na very simple thing, just use the following function: \n\n\nvoid setRGB(int r, int g, int b);\n\n\n\nThen let\ns try a Red backlight.\nModify the code about color into:\n\n\nconst int colorR = 255;\nconst int colorG = 0;\nconst int colorB = 0;\n\n\n\nUpload the code again, woo, see the backlight turn to Red? Then why not try another color? Whatever you like. \n\n\nResources\n\uf0c1\n\n\n\n\nSoftware Library\n\n\nGithub page for the Library\n\n\nGithub page for this document", 
            "title": "Grove - LCD RGB Backlight"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#features", 
            "text": "RGB Backlight  I2C communication  Built-in English fonts  16x2 LCD", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#specification", 
            "text": "Intem  Value      Input Voltage  5V    Operating Current  60mA    CGROM  10880 bit    CGRAM  64x8 bit", 
            "title": "Specification"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#application-ideas", 
            "text": "Human Machine Interface  Smart House  Sensor Hub   Here are some projects for your reference.      Edison Wi-Fi Address  WiFi Enabled Greenhouse  Grove Lucky Dumpling           Make it Now!  Make it Now!  Make it Now!        Toothbrushing Instructor  LinkIt ONE Pager  LinkIt ONE IoT Demo           Make it Now!  Make it Now!  Make it Now!", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#getting-started", 
            "text": "This getting started will show you how to use Grove - LCD RGB Backlight, we need a  Seeeduino  as well.    Note  This demo is under Win10 and Arduino IDE1.6.9.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#step1-download-arduino-library", 
            "text": "You need to download the library and install to your Arduino IDE.", 
            "title": "STEP1. Download Arduino Library"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#step2-hardware-installation", 
            "text": "Hardware installation is very easy, because there s an I2C Grove in Seeeduino, so what we need to do is \nconnect it to I2C Grove via a Grove cable.", 
            "title": "STEP2. Hardware Installation"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#step3-download-code-and-upload", 
            "text": "You can download the demo code in Github, click here, then extract it to anywhere.   If you have some problem with this step, please refer to Getting Start with Seeeduino there is a Hello World example in the library, open it, and upload to Seeeduino V3.0. Then you can see  Hello world  on the first row, and second row will print the number of second since reset.", 
            "title": "STEP3. Download Code and Upload"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#step4-change-color-of-backlight", 
            "text": "One of Grove - LCD RGB Backlight s most important feature is: you can change the color backlight, and it s \na very simple thing, just use the following function:   void setRGB(int r, int g, int b);  Then let s try a Red backlight.\nModify the code about color into:  const int colorR = 255;\nconst int colorG = 0;\nconst int colorB = 0;  Upload the code again, woo, see the backlight turn to Red? Then why not try another color? Whatever you like.", 
            "title": "STEP4. Change Color of Backlight"
        }, 
        {
            "location": "/Grove-LCD_RGB_Backlight/#resources", 
            "text": "Software Library  Github page for the Library  Github page for this document", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-LED_Bar/", 
            "text": "Grove \u2013 LED Bar is comprised of a 10 segment LED gauge bar and an MY9221 LED controlling chip. It can be used as an indicator for remaining battery life, voltage, water level, music volume or other values that require a gradient display. There are 10 LED bars in the LED bar graph: one red, one yellow, one light green, and seven green bars. Demo code is available to get you up and running quickly. It lights up the LEDs sequentially from red to green, so the entire bar graph is lit up in the end. Want to go further? Go ahead and code your own effect.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nInput Voltage: 3.3V/5V\n\n\nEach LED segment can be controlled individually via code\n\n\nIntuitive display\n\n\nFlexible power option, supports 3-5.5DC\n\n\nAvailable demo code\n\n\nSuli-compatible Library\n\n\n\n\n\n\nNote\n\nMore details about Suli-compatible Library, please refer to \nSuli\n\n\n\n\n\nDemonstration\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThis is a simple demo which can you help you to start with Grove - LED Bar quickly.\n\n\nWe need a \nSeeeduino V3.0\n and a \nGrove - Base Shield\n as well.\n\n\nHardware Installation\n\uf0c1\n\n\nPlug the Grove - LED Bar onto the digital port 8 on Grove - Base Shield, and then plug the base shield onto Arduino.\n\n\nDownload Code and Upload\n\uf0c1\n\n\nYou can download the library in github, click \nhere\n, then extract it to libraries folder of Arduino.\n\n\nThen open Arduino IDE, File -\n examples -\n LED_Bar -\n Level, you can open the demo code.\n\n\n\n\nClick Upload to Upload the code, if you have any problem about how to start Arduino, please click \nhere\n for some help.\n\n\nWorking Now\n\uf0c1\n\n\nYour Grove - LED Bar is working now, it\ns shine.\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D3 by using a grove cable.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_ledbar.py   # \nCtrl+x\n to exit #\n\n\n\n\n    import time\n    import grovepi\n    import random\n\n    # Connect the Grove LED Bar to digital port D5\n    # DI,DCKI,VCC,GND\n    ledbar = 5\n\n    grovepi.pinMode(ledbar,\nOUTPUT\n)\n    time.sleep(1)\n    i = 0\n\n    # LED Bar methods\n    # grovepi.ledBar_init(pin,orientation)\n    # grovepi.ledBar_orientation(pin,orientation)\n    # grovepi.ledBar_setLevel(pin,level)\n    # grovepi.ledBar_setLed(pin,led,state)\n    # grovepi.ledBar_toggleLed(pin,led)\n    # grovepi.ledBar_setBits(pin,state)\n    # grovepi.ledBar_getBits(pin)\n\n    while True:\n        try:\n            print \nTest 1) Initialise - red to green\n\n            # ledbar_init(pin,orientation)\n            # orientation: (0 = red to green, 1 = green to red)\n            grovepi.ledBar_init(ledbar, 0)\n            time.sleep(.5)\n\n\n            print \nTest 2) Set level\n\n            # ledbar_setLevel(pin,level)\n            # level: (0-10)\n            for i in range(0,11):\n                grovepi.ledBar_setLevel(ledbar, i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n            grovepi.ledBar_setLevel(ledbar, 8)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLevel(ledbar, 2)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLevel(ledbar, 5)\n            time.sleep(.5)\n\n\n            print \nTest 3) Switch on/off a single LED\n\n            # ledbar_setLed(pin,led,state)\n            # led: which led (1-10)\n            # state: off or on (0,1)\n            grovepi.ledBar_setLed(ledbar, 10, 1)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 9, 1)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 8, 1)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 1, 0)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 2, 0)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 3, 0)\n            time.sleep(.5)\n\n\n            print \nTest 4) Toggle a single LED\n\n            # flip a single led - if it is currently on, it will become off and vice versa\n            # ledbar_toggleLed(ledbar, led)\n            grovepi.ledBar_toggleLed(ledbar, 1)\n            time.sleep(.5)\n\n            grovepi.ledBar_toggleLed(ledbar, 2)\n            time.sleep(.5)\n\n            grovepi.ledBar_toggleLed(ledbar, 9)\n            time.sleep(.5)\n\n            grovepi.ledBar_toggleLed(ledbar, 10)\n            time.sleep(.5)\n\n\n            print \nTest 5) Set state - control all leds with 10 bits\n\n            # ledbar_setBits(ledbar, state)\n            # state: (0-1023) or (0x00-0x3FF) or (0b0000000000-0b1111111111) or (int('0000000000',2)-int('1111111111',2))\n            for i in range(0,32):\n                grovepi.ledBar_setBits(ledbar, i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print \nTest 6) Get current state\n\n            # state = ledbar_getBits(ledbar)\n            # state: (0-1023) a bit for each of the 10 LEDs\n            state = grovepi.ledBar_getBits(ledbar)\n            print \nwith first 5 leds lit, the state should be 31 or 0x1F\n\n            print state\n\n            # bitwise shift five bits to the left\n            state = state \n 5\n            # the state should now be 992 or 0x3E0\n            # when saved the last 5 LEDs will be lit instead of the first 5 LEDs\n            time.sleep(.5)\n\n\n            print \nTest 7) Set state - save the state we just modified\n\n            # ledbar_setBits(ledbar, state)\n            # state: (0-1023) a bit for each of the 10 LEDs\n            grovepi.ledBar_setBits(ledbar, state)\n            time.sleep(.5)\n\n\n            print \nTest 8) Swap orientation - green to red - current state is preserved\n\n            # ledbar_orientation(pin,orientation)\n            # orientation: (0 = red to green, 1 = green to red)\n            # when you reverse the led bar orientation, all methods know how to handle the new LED index\n            # green to red\n            grovepi.ledBar_orientation(ledbar, 1)\n            time.sleep(.5)\n\n            # red to green\n            grovepi.ledBar_orientation(ledbar, 0)\n            time.sleep(.5)\n\n            # green to red\n            grovepi.ledBar_orientation(ledbar, 1)\n            time.sleep(.5)\n\n\n            print \nTest 9) Set level, again\n\n            # ledbar_setLevel(pin,level)\n            # level: (0-10)\n            # note the red LED is now at index 10 instead of 1\n            for i in range(0,11):\n                grovepi.ledBar_setLevel(ledbar, i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print \nTest 10) Set a single LED, again\n\n            # ledbar_setLed(pin,led,state)\n            # led: which led (1-10)\n            # state: off or on (0,1)\n            grovepi.ledBar_setLed(ledbar, 1, 0)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 3, 0)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 5, 0)\n            time.sleep(.5)\n\n\n            print \nTest 11) Toggle a single LED, again\n\n            # ledbar_toggleLed(ledbar, led)\n            grovepi.ledBar_toggleLed(ledbar, 2)\n            time.sleep(.5)\n\n            grovepi.ledBar_toggleLed(ledbar, 4)\n            time.sleep(.5)\n\n\n            print \nTest 12) Get state\n\n            # state = ledbar_getBits(ledbar)\n            # state: (0-1023) a bit for each of the 10 LEDs\n            state = grovepi.ledBar_getBits(ledbar)\n\n            # the last 5 LEDs are lit, so the state should be 992 or 0x3E0\n\n            # bitwise shift five bits to the right\n            state = state \n 5\n            # the state should now be 31 or 0x1F\n\n\n            print \nTest 13) Set state, again\n\n            # ledbar_setBits(ledbar, state)\n            # state: (0-1023) a bit for each of the 10 LEDs\n            grovepi.ledBar_setBits(ledbar, state)\n            time.sleep(.5)\n\n\n            print \nTest 14) Step\n\n            # step through all 10 LEDs\n            for i in range(0,11):\n                grovepi.ledBar_setLevel(ledbar, i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print \nTest 15) Bounce\n\n            # switch on the first two LEDs\n            grovepi.ledBar_setLevel(ledbar, 2)\n\n            # get the current state (which is 0x3)\n            state = grovepi.ledBar_getBits(ledbar)\n\n            # bounce to the right\n            for i in range(0,9):\n                # bit shift left and update\n                state \n= 1;\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n\n            # bounce to the left\n            for i in range(0,9):\n                # bit shift right and update\n                state \n= 1;\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print \nTest 16) Random\n\n            for i in range(0,21):\n                state = random.randint(0,1023)\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print \nTest 17) Invert\n\n            # set every 2nd LED on - 341 or 0x155\n            state = 341\n            for i in range(0,5):\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n\n                # bitwise XOR all 10 LEDs on with the current state\n                state = 0x3FF ^ state\n\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print \nTest 18) Walk through all possible combinations\n\n            for i in range(0,1024):\n                grovepi.ledBar_setBits(ledbar, i)\n                time.sleep(.1)\n            time.sleep(.4)\n\n        except KeyboardInterrupt:\n            grovepi.ledBar_setBits(ledbar, 0)\n            break\n        except IOError:\n            print \nError\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_ledbar.py\n\n\n\n\n6.This demo may not work if your grovepi dosen\nt have the newest firmware, update the firmware.\n\n\n    cd yourpath/GrovePi/Firmware\n    sudo ./firmware_update.sh\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - LED Bar Eagle File\n\n\nGrove - LED Bar Library\n\n\nSuli-compatible Library\n\n\nMY9221 Datasheet\n\n\n\n\nHelp us make it better\n\uf0c1", 
            "title": "Grove - LED Bar"
        }, 
        {
            "location": "/Grove-LED_Bar/#features", 
            "text": "Input Voltage: 3.3V/5V  Each LED segment can be controlled individually via code  Intuitive display  Flexible power option, supports 3-5.5DC  Available demo code  Suli-compatible Library    Note \nMore details about Suli-compatible Library, please refer to  Suli", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-LED_Bar/#demonstration", 
            "text": "", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-LED_Bar/#with-arduino", 
            "text": "This is a simple demo which can you help you to start with Grove - LED Bar quickly.  We need a  Seeeduino V3.0  and a  Grove - Base Shield  as well.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-LED_Bar/#hardware-installation", 
            "text": "Plug the Grove - LED Bar onto the digital port 8 on Grove - Base Shield, and then plug the base shield onto Arduino.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-LED_Bar/#download-code-and-upload", 
            "text": "You can download the library in github, click  here , then extract it to libraries folder of Arduino.  Then open Arduino IDE, File -  examples -  LED_Bar -  Level, you can open the demo code.   Click Upload to Upload the code, if you have any problem about how to start Arduino, please click  here  for some help.", 
            "title": "Download Code and Upload"
        }, 
        {
            "location": "/Grove-LED_Bar/#working-now", 
            "text": "Your Grove - LED Bar is working now, it s shine.", 
            "title": "Working Now"
        }, 
        {
            "location": "/Grove-LED_Bar/#with-raspberry-pi", 
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D3 by using a grove cable.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_ledbar.py   #  Ctrl+x  to exit #      import time\n    import grovepi\n    import random\n\n    # Connect the Grove LED Bar to digital port D5\n    # DI,DCKI,VCC,GND\n    ledbar = 5\n\n    grovepi.pinMode(ledbar, OUTPUT )\n    time.sleep(1)\n    i = 0\n\n    # LED Bar methods\n    # grovepi.ledBar_init(pin,orientation)\n    # grovepi.ledBar_orientation(pin,orientation)\n    # grovepi.ledBar_setLevel(pin,level)\n    # grovepi.ledBar_setLed(pin,led,state)\n    # grovepi.ledBar_toggleLed(pin,led)\n    # grovepi.ledBar_setBits(pin,state)\n    # grovepi.ledBar_getBits(pin)\n\n    while True:\n        try:\n            print  Test 1) Initialise - red to green \n            # ledbar_init(pin,orientation)\n            # orientation: (0 = red to green, 1 = green to red)\n            grovepi.ledBar_init(ledbar, 0)\n            time.sleep(.5)\n\n\n            print  Test 2) Set level \n            # ledbar_setLevel(pin,level)\n            # level: (0-10)\n            for i in range(0,11):\n                grovepi.ledBar_setLevel(ledbar, i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n            grovepi.ledBar_setLevel(ledbar, 8)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLevel(ledbar, 2)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLevel(ledbar, 5)\n            time.sleep(.5)\n\n\n            print  Test 3) Switch on/off a single LED \n            # ledbar_setLed(pin,led,state)\n            # led: which led (1-10)\n            # state: off or on (0,1)\n            grovepi.ledBar_setLed(ledbar, 10, 1)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 9, 1)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 8, 1)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 1, 0)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 2, 0)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 3, 0)\n            time.sleep(.5)\n\n\n            print  Test 4) Toggle a single LED \n            # flip a single led - if it is currently on, it will become off and vice versa\n            # ledbar_toggleLed(ledbar, led)\n            grovepi.ledBar_toggleLed(ledbar, 1)\n            time.sleep(.5)\n\n            grovepi.ledBar_toggleLed(ledbar, 2)\n            time.sleep(.5)\n\n            grovepi.ledBar_toggleLed(ledbar, 9)\n            time.sleep(.5)\n\n            grovepi.ledBar_toggleLed(ledbar, 10)\n            time.sleep(.5)\n\n\n            print  Test 5) Set state - control all leds with 10 bits \n            # ledbar_setBits(ledbar, state)\n            # state: (0-1023) or (0x00-0x3FF) or (0b0000000000-0b1111111111) or (int('0000000000',2)-int('1111111111',2))\n            for i in range(0,32):\n                grovepi.ledBar_setBits(ledbar, i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print  Test 6) Get current state \n            # state = ledbar_getBits(ledbar)\n            # state: (0-1023) a bit for each of the 10 LEDs\n            state = grovepi.ledBar_getBits(ledbar)\n            print  with first 5 leds lit, the state should be 31 or 0x1F \n            print state\n\n            # bitwise shift five bits to the left\n            state = state   5\n            # the state should now be 992 or 0x3E0\n            # when saved the last 5 LEDs will be lit instead of the first 5 LEDs\n            time.sleep(.5)\n\n\n            print  Test 7) Set state - save the state we just modified \n            # ledbar_setBits(ledbar, state)\n            # state: (0-1023) a bit for each of the 10 LEDs\n            grovepi.ledBar_setBits(ledbar, state)\n            time.sleep(.5)\n\n\n            print  Test 8) Swap orientation - green to red - current state is preserved \n            # ledbar_orientation(pin,orientation)\n            # orientation: (0 = red to green, 1 = green to red)\n            # when you reverse the led bar orientation, all methods know how to handle the new LED index\n            # green to red\n            grovepi.ledBar_orientation(ledbar, 1)\n            time.sleep(.5)\n\n            # red to green\n            grovepi.ledBar_orientation(ledbar, 0)\n            time.sleep(.5)\n\n            # green to red\n            grovepi.ledBar_orientation(ledbar, 1)\n            time.sleep(.5)\n\n\n            print  Test 9) Set level, again \n            # ledbar_setLevel(pin,level)\n            # level: (0-10)\n            # note the red LED is now at index 10 instead of 1\n            for i in range(0,11):\n                grovepi.ledBar_setLevel(ledbar, i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print  Test 10) Set a single LED, again \n            # ledbar_setLed(pin,led,state)\n            # led: which led (1-10)\n            # state: off or on (0,1)\n            grovepi.ledBar_setLed(ledbar, 1, 0)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 3, 0)\n            time.sleep(.5)\n\n            grovepi.ledBar_setLed(ledbar, 5, 0)\n            time.sleep(.5)\n\n\n            print  Test 11) Toggle a single LED, again \n            # ledbar_toggleLed(ledbar, led)\n            grovepi.ledBar_toggleLed(ledbar, 2)\n            time.sleep(.5)\n\n            grovepi.ledBar_toggleLed(ledbar, 4)\n            time.sleep(.5)\n\n\n            print  Test 12) Get state \n            # state = ledbar_getBits(ledbar)\n            # state: (0-1023) a bit for each of the 10 LEDs\n            state = grovepi.ledBar_getBits(ledbar)\n\n            # the last 5 LEDs are lit, so the state should be 992 or 0x3E0\n\n            # bitwise shift five bits to the right\n            state = state   5\n            # the state should now be 31 or 0x1F\n\n\n            print  Test 13) Set state, again \n            # ledbar_setBits(ledbar, state)\n            # state: (0-1023) a bit for each of the 10 LEDs\n            grovepi.ledBar_setBits(ledbar, state)\n            time.sleep(.5)\n\n\n            print  Test 14) Step \n            # step through all 10 LEDs\n            for i in range(0,11):\n                grovepi.ledBar_setLevel(ledbar, i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print  Test 15) Bounce \n            # switch on the first two LEDs\n            grovepi.ledBar_setLevel(ledbar, 2)\n\n            # get the current state (which is 0x3)\n            state = grovepi.ledBar_getBits(ledbar)\n\n            # bounce to the right\n            for i in range(0,9):\n                # bit shift left and update\n                state  = 1;\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n\n            # bounce to the left\n            for i in range(0,9):\n                # bit shift right and update\n                state  = 1;\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print  Test 16) Random \n            for i in range(0,21):\n                state = random.randint(0,1023)\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print  Test 17) Invert \n            # set every 2nd LED on - 341 or 0x155\n            state = 341\n            for i in range(0,5):\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n\n                # bitwise XOR all 10 LEDs on with the current state\n                state = 0x3FF ^ state\n\n                grovepi.ledBar_setBits(ledbar, state)\n                time.sleep(.2)\n            time.sleep(.3)\n\n\n            print  Test 18) Walk through all possible combinations \n            for i in range(0,1024):\n                grovepi.ledBar_setBits(ledbar, i)\n                time.sleep(.1)\n            time.sleep(.4)\n\n        except KeyboardInterrupt:\n            grovepi.ledBar_setBits(ledbar, 0)\n            break\n        except IOError:\n            print  Error   5.Run the demo.      sudo python grove_ledbar.py  6.This demo may not work if your grovepi dosen t have the newest firmware, update the firmware.      cd yourpath/GrovePi/Firmware\n    sudo ./firmware_update.sh", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-LED_Bar/#resources", 
            "text": "Grove - LED Bar Eagle File  Grove - LED Bar Library  Suli-compatible Library  MY9221 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-LED_Bar/#help-us-make-it-better", 
            "text": "", 
            "title": "Help us make it better"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/", 
            "text": "It is a 16 color grayscale 128x64 dot matrix OLED display module with Grove compatible 4pin I2C interface. \nThis module is constructed with 96x96 dot matrix OLED module LY120 and SSD1327 driver IC. \nComparing to LCD, OLED screens are more competitive, which has a number of advantages such as high \nbrightness, self-emission, high contrast ratio, slim / thin outline, wide viewing angle, wide temperature \nrange, and low power consumption. \n\n\n\n\nCommunicate Mode: I2C \n\n\nGrayscale Display: 16 Gray shades. \n\n\nSupports both Normal and Inverse Color Display. \n\n\nSupports Continuous Horizontal Scrolling. \n\n\nGrove compatible Interface \n\n\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nOperating Voltage\n\n\n3.3/5 V\n\n\n\n\n\n\nDot Matrix\n\n\n96x96\n\n\n\n\n\n\nDisplay Color\n\n\n16 Grayscale\n\n\n\n\n\n\nOLED Display\n\n\nLY120-96096\n\n\n\n\n\n\nDriver Chip\n\n\nSSD1327Z\n\n\n\n\n\n\nDot Size\n\n\n0.15(W)mm x 0.15(H)mm\n\n\n\n\n\n\nDot Pitch\n\n\n0.75(W)mm x 0.175(H)mm\n\n\n\n\n\n\nOperating Temperature\n\n\n-40~70 oC\n\n\n\n\n\n\n\n\nPlatform Support\n\uf0c1\n\n\n\n\n\n\n\n\nArduino\n\n\nWio\n\n\nBeagleBone\n\n\nRaspberry Pi\n\n\nLinkIt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\n\n\nNote\n\n\nThis chapter is based on Win10 and Arduino IDE 1.6.9\n\n\n\n\nThis is an easy-to-use module, what you need to do is connect the module to I2C port of a Base Shield. There\nre 4 pins, defined as below.\n\n\n\n\n\n\n\n\npin\n\n\nFunction\n\n\nNote\n\n\nCable color\n\n\n\n\n\n\n\n\n\n\npin1\n\n\nSCL\n\n\nI2C Clock\n\n\nYELLOW\n\n\n\n\n\n\npin2\n\n\nSDA\n\n\nI2C Data\n\n\nWHITE\n\n\n\n\n\n\npin3\n\n\nVCC\n\n\nPower, 5V/3.3V\n\n\nRED\n\n\n\n\n\n\npin4\n\n\nGND\n\n\nGround\n\n\nBLACK\n\n\n\n\n\n\n\n\nHere we will show you how this Grove - OLED Display works via a simple demo. First of all, you need to prepare the below stuffs:\n\n\n\n\n\n\n\n\nSeeeduino V4\n\n\nGrove - OLED Display 1.12``\n\n\nBase Shield\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\nGet ONE Now\n\n\n\n\n\n\n\n\nConnection\n\uf0c1\n\n\nThanks to the benefit of Grove series modules, you don\nt need to make soldering or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have only one Grove module. \n\n\n\n\nGrove - OLED Display 1.12``\n is an \nI2C\n module, we connect it to \nI2C\n port at this demo.\n\n\n\n\n\n\nDownload the library\n\uf0c1\n\n\nWe provide an Arduino Library for this Grove - OLED Display 1.12``, click on the below button to download it. \n\n\n\n\nUnzip the file and put to libraries folder of your Arduino IDE. \nThere\nre many examples in this library, which is consist of\n\n\n\n\nOLED_Bitmap_Inverse_Display\n\n\nOLED_Draw_Bitmap\n\n\nOLED_Hello_World\n\n\nOLED_Inverse_Display\n\n\nOLED_PrintNumbers\n\n\nOLED_Scroll_Left\n\n\nOLED_Scroll_Right\n\n\nOLED_Z_Display_Driver_Test_Suite\n\n\n\n\nUpload example to an Arduino\n\uf0c1\n\n\nNow let\ns try upload \nOLED_Hello_World\n to Seeeduino V4. Open your Arduino IDE, click on \n\n\nFile \n Example \n OLED_Display_96x96-master \n OLED_Hello_World\n\n\n\n\nThe code is open, select the right board and right COM Port, then click on Upload button which will take few seconds. \n\n\n\n\nIf the code is uploaded correctly, take look at your display, something was printed on it. \n\n\n\n\nThen please try the other examples to see what will happen.\n\n\nAPIs of the library\n\uf0c1\n\n\nSeeed Gray OLED library provides complete software interfaces to exercise the capabilities of \nSSD1327Z driver with a 96x96 gray OLED. Almost all useful features are implemented and all \nfunctions are in public scope. This makes Seeed Gray OLED Library extensible. Seeed Gray OLED \nlibrary uses Arduino Wire library. Hence initialize wire library before initializing Seeed OLED library. \n\n\ninit()\n\uf0c1\n\n\nInitializes the Seeed OLED frame and sets the display to Normal mode.\n\n\nExample:\n\n\nSeeedGrayOled.init();  //initialze SEEED Gray OLED display\n\n\n\nclearDisplay()\n\uf0c1\n\n\nClears the whole screen. Should be used before starting a fresh start or after scroll deactivation. \nThis function also sets the cursor to top left corner. \n\n\nExample: \n\n\nSeeedGrayOled.clearDisplay();  //clear the screen and set start position to top left corner\n\n\n\nsetNormalDisplay()\n\uf0c1\n\n\nConfigures the display to normal mode(non-inverse) mode. \n\n\nExample:\n\n\nSeeedGrayOled.setNormalDisplay();//Set display to normal mode (i.e non-inverse mode)\n\n\n\nsetContrastLevel(unsigned char ContrastLevel)\n\uf0c1\n\n\nSet the contrast ratio of OLED display. ContrastLevel can be any number from 0 - 255. \nExample: \n\n\nSeeedGrayOled.setContrastLevel(127); //Set display contrast ratio to half level( i.e 256/2 1 ).\n\n\n\nsetInverseDisplay())\n\uf0c1\n\n\nConfigures the display to inverse mode. \nExample:\n\n\nSeeedGrayOled.setInverseDisplay();      //Set display to inverse mode\n\n\n\nsetHorizontalMode()\n\uf0c1\n\n\nConfigures the display to horizontal addressing mode. \nExample:\n\n\nSeeedGrayOled.setHorizontalMode();      //Set addressing mode to Horizontal Mode\n\n\n\nsetVerticalMode()\n\uf0c1\n\n\nConfigures the display to vertical addressing mode. Texts are drawn in vertical mode. Please set \nthe display to vertical mode before printing text. \nExample:\n\n\nSeeedGrayOled.setVerticalMode();      //Set addressing mode to Vertical Mode\n\n\n\nsetTextXY(X,Y)\n\uf0c1\n\n\nSet the text\ns position (cursor) to Xth Text Row, Yth Text Column.96x96 OLED is divided into 12 \nrows and 12 Columns of text. This row and column should not be confused with OLED Row and \nColumn. \n\n\n\n\nX can be any number from 0 - 11. \n\n\nY can be any number from 0 - 11. \n\n\n\n\nExample:\n\n\nSeeedGrayOled.setTextXY(0,0);  //Set the cursor to 0th Text Row, 0th Text Column\n\n\n\nputChar(unsigned char c)\n\uf0c1\n\n\nPrint a character to OLED display starting from current address-pointer set by setTextXY(X,Y). This \nfunction is internally used by putString(). \n\n\nExample:\n\n\nSeeedGrayOled.putChar('S'); //Print the character S\n\n\n\nputString(cont char *string)\n\uf0c1\n\n\nPrint string to OLED display starting from current address-pointer set by setTextXY(X,Y) \nExample:\n\n\nSeeedGrayOled.putString(\"Hello World!\"); //Print the String\n\n\n\nputNumber(long n)\n\uf0c1\n\n\nPrint numbers to OLED display starting from current address-pointer set by setTextXY(X,Y). \nNumber can be any char,int or long datatype. It also takes care of -ve sign. \n\n\nExample:\n\n\nSeeedGrayOled.putNumber(-56123); //Print number -56123\n\n\n\ndrawBitmap(unsigned char *bitmaparray, int bytes)\n\uf0c1\n\n\nDisplay a binary bitmap on the OLED matrix. The data is provided through a pointer to uni-dimensional array holding bitmap. The bitmap data is available in continuous rows of columns \nas like Horizontal Addressing mode. bytes is size of bitmap in bytes. \n\n\nExample:\n\n\nSeeedGrayOled.drawBitmap(SeeedLogo,96*96/8);   //  Draw binary Bitmap (96 pixels *96 pixels  / 8) bytes\n\n\n\nsetHorizontalScrollProperties\n\uf0c1\n\n\nSet the properties of horizontal scroll. \n\n\n\n\nDirection can be any of Scroll_Left and Scroll_Right. \n\n\nstartRow can be 0 - 127 \n\n\nendRow can be 0 - 127. It should be greater than startRow \n\n\nstartColumn can be 0 - 63 \n\n\nendColumn can be 0 - 63. It should be greater than startRow \n\n\nscrollSpeed can be any of defines:Scroll_2Frames, Scroll_3Frames, Scroll_4Frames, Scroll_5Frames, Scroll_25Frames,Scroll_64Frames, Scroll_128Frames,Scroll_256Frames. \n\n\n\n\nExample:\n\n\nSeeedGrayOled.setHorizontalScrollProperties(Scroll_Left,72,95,0,47,Scroll_5Frames);  //Set the properties of Horizontal Scroll\n\n\n\nactivateScroll()\n\uf0c1\n\n\nEnable scrolling. This should be used only after setting horizontal scroll properties. \nExample:\n\n\nSeeedGrayOled.activateScroll();   //Enable scrolling.\n\n\n\ndeactivateScroll()\n\uf0c1\n\n\nDisable scrolling. This should be used after activateScroll(); \nExample:\n\n\nSeeedGrayOled.activateScroll();   //Disable scrolling.\n\n\n\nResources\n\uf0c1\n\n\n\n\nGithub Repository of the Library\n\n\nSchematic in Eagle\n\n\nSSD1327 Datasheet\n\n\nLY120 Datasheet\n\n\nReference for Make a 96x96 Image\n\n\nGithub Repository of this Document", 
            "title": "Grove - OLED Display 1.12&#34;"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#specifications", 
            "text": "Item  Value      Operating Voltage  3.3/5 V    Dot Matrix  96x96    Display Color  16 Grayscale    OLED Display  LY120-96096    Driver Chip  SSD1327Z    Dot Size  0.15(W)mm x 0.15(H)mm    Dot Pitch  0.75(W)mm x 0.175(H)mm    Operating Temperature  -40~70 oC", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#platform-support", 
            "text": "Arduino  Wio  BeagleBone  Raspberry Pi  LinkIt", 
            "title": "Platform Support"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#getting-started", 
            "text": "Note  This chapter is based on Win10 and Arduino IDE 1.6.9   This is an easy-to-use module, what you need to do is connect the module to I2C port of a Base Shield. There re 4 pins, defined as below.     pin  Function  Note  Cable color      pin1  SCL  I2C Clock  YELLOW    pin2  SDA  I2C Data  WHITE    pin3  VCC  Power, 5V/3.3V  RED    pin4  GND  Ground  BLACK     Here we will show you how this Grove - OLED Display works via a simple demo. First of all, you need to prepare the below stuffs:     Seeeduino V4  Grove - OLED Display 1.12``  Base Shield           Get ONE Now  Get ONE Now  Get ONE Now", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#connection", 
            "text": "Thanks to the benefit of Grove series modules, you don t need to make soldering or bread board, what you need to do is connect the modules to the right port of Base Shield. For this demo, we have only one Grove module.    Grove - OLED Display 1.12``  is an  I2C  module, we connect it to  I2C  port at this demo.", 
            "title": "Connection"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#download-the-library", 
            "text": "We provide an Arduino Library for this Grove - OLED Display 1.12``, click on the below button to download it.    Unzip the file and put to libraries folder of your Arduino IDE. \nThere re many examples in this library, which is consist of   OLED_Bitmap_Inverse_Display  OLED_Draw_Bitmap  OLED_Hello_World  OLED_Inverse_Display  OLED_PrintNumbers  OLED_Scroll_Left  OLED_Scroll_Right  OLED_Z_Display_Driver_Test_Suite", 
            "title": "Download the library"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#upload-example-to-an-arduino", 
            "text": "Now let s try upload  OLED_Hello_World  to Seeeduino V4. Open your Arduino IDE, click on   File   Example   OLED_Display_96x96-master   OLED_Hello_World   The code is open, select the right board and right COM Port, then click on Upload button which will take few seconds.    If the code is uploaded correctly, take look at your display, something was printed on it.    Then please try the other examples to see what will happen.", 
            "title": "Upload example to an Arduino"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#apis-of-the-library", 
            "text": "Seeed Gray OLED library provides complete software interfaces to exercise the capabilities of \nSSD1327Z driver with a 96x96 gray OLED. Almost all useful features are implemented and all \nfunctions are in public scope. This makes Seeed Gray OLED Library extensible. Seeed Gray OLED \nlibrary uses Arduino Wire library. Hence initialize wire library before initializing Seeed OLED library.", 
            "title": "APIs of the library"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#init", 
            "text": "Initializes the Seeed OLED frame and sets the display to Normal mode.  Example:  SeeedGrayOled.init();  //initialze SEEED Gray OLED display", 
            "title": "init()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#cleardisplay", 
            "text": "Clears the whole screen. Should be used before starting a fresh start or after scroll deactivation. \nThis function also sets the cursor to top left corner.   Example:   SeeedGrayOled.clearDisplay();  //clear the screen and set start position to top left corner", 
            "title": "clearDisplay()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#setnormaldisplay", 
            "text": "Configures the display to normal mode(non-inverse) mode.   Example:  SeeedGrayOled.setNormalDisplay();//Set display to normal mode (i.e non-inverse mode)", 
            "title": "setNormalDisplay()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#setcontrastlevelunsigned-char-contrastlevel", 
            "text": "Set the contrast ratio of OLED display. ContrastLevel can be any number from 0 - 255. \nExample:   SeeedGrayOled.setContrastLevel(127); //Set display contrast ratio to half level( i.e 256/2 1 ).", 
            "title": "setContrastLevel(unsigned char ContrastLevel)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#setinversedisplay", 
            "text": "Configures the display to inverse mode. \nExample:  SeeedGrayOled.setInverseDisplay();      //Set display to inverse mode", 
            "title": "setInverseDisplay())"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#sethorizontalmode", 
            "text": "Configures the display to horizontal addressing mode. \nExample:  SeeedGrayOled.setHorizontalMode();      //Set addressing mode to Horizontal Mode", 
            "title": "setHorizontalMode()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#setverticalmode", 
            "text": "Configures the display to vertical addressing mode. Texts are drawn in vertical mode. Please set \nthe display to vertical mode before printing text. \nExample:  SeeedGrayOled.setVerticalMode();      //Set addressing mode to Vertical Mode", 
            "title": "setVerticalMode()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#settextxyxy", 
            "text": "Set the text s position (cursor) to Xth Text Row, Yth Text Column.96x96 OLED is divided into 12 \nrows and 12 Columns of text. This row and column should not be confused with OLED Row and \nColumn.    X can be any number from 0 - 11.   Y can be any number from 0 - 11.    Example:  SeeedGrayOled.setTextXY(0,0);  //Set the cursor to 0th Text Row, 0th Text Column", 
            "title": "setTextXY(X,Y)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#putcharunsigned-char-c", 
            "text": "Print a character to OLED display starting from current address-pointer set by setTextXY(X,Y). This \nfunction is internally used by putString().   Example:  SeeedGrayOled.putChar('S'); //Print the character S", 
            "title": "putChar(unsigned char c)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#putstringcont-char-string", 
            "text": "Print string to OLED display starting from current address-pointer set by setTextXY(X,Y) \nExample:  SeeedGrayOled.putString(\"Hello World!\"); //Print the String", 
            "title": "putString(cont char *string)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#putnumberlong-n", 
            "text": "Print numbers to OLED display starting from current address-pointer set by setTextXY(X,Y). \nNumber can be any char,int or long datatype. It also takes care of -ve sign.   Example:  SeeedGrayOled.putNumber(-56123); //Print number -56123", 
            "title": "putNumber(long n)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#drawbitmapunsigned-char-bitmaparray-int-bytes", 
            "text": "Display a binary bitmap on the OLED matrix. The data is provided through a pointer to uni-dimensional array holding bitmap. The bitmap data is available in continuous rows of columns \nas like Horizontal Addressing mode. bytes is size of bitmap in bytes.   Example:  SeeedGrayOled.drawBitmap(SeeedLogo,96*96/8);   //  Draw binary Bitmap (96 pixels *96 pixels  / 8) bytes", 
            "title": "drawBitmap(unsigned char *bitmaparray, int bytes)"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#sethorizontalscrollproperties", 
            "text": "Set the properties of horizontal scroll.    Direction can be any of Scroll_Left and Scroll_Right.   startRow can be 0 - 127   endRow can be 0 - 127. It should be greater than startRow   startColumn can be 0 - 63   endColumn can be 0 - 63. It should be greater than startRow   scrollSpeed can be any of defines:Scroll_2Frames, Scroll_3Frames, Scroll_4Frames, Scroll_5Frames, Scroll_25Frames,Scroll_64Frames, Scroll_128Frames,Scroll_256Frames.    Example:  SeeedGrayOled.setHorizontalScrollProperties(Scroll_Left,72,95,0,47,Scroll_5Frames);  //Set the properties of Horizontal Scroll", 
            "title": "setHorizontalScrollProperties"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#activatescroll", 
            "text": "Enable scrolling. This should be used only after setting horizontal scroll properties. \nExample:  SeeedGrayOled.activateScroll();   //Enable scrolling.", 
            "title": "activateScroll()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#deactivatescroll", 
            "text": "Disable scrolling. This should be used after activateScroll(); \nExample:  SeeedGrayOled.activateScroll();   //Disable scrolling.", 
            "title": "deactivateScroll()"
        }, 
        {
            "location": "/Grove-OLED_Display_1.12inch/#resources", 
            "text": "Github Repository of the Library  Schematic in Eagle  SSD1327 Datasheet  LY120 Datasheet  Reference for Make a 96x96 Image  Github Repository of this Document", 
            "title": "Resources"
        }, 
        {
            "location": "/I2C_LCD/", 
            "text": "I2C_LCD is an easy-to-use display module, It can make display easier. Using it can reduce the difficulty of make, so that makers can focus on the core of the work.\n\n\nWe developed the Arduino library for I2C_LCD, user just need a few lines of the code can achieve complex graphics and text display features. It can replace the serial monitor of Arduino in some place, you can get running informations without a computer.\n\n\nMore than that, we also develop the dedicated picture data convert software (bitmap converter)now is available to support PC platform of windows, Linux, Mac OS. Through the bitmap convert software you can get your favorite picture displayed on I2C_LCD, without the need for complex programming.\n\n\nI2C_LCD can provide you with a very convenient way of make. Enjoy yourself!\n\n\nProduct Version\n\uf0c1\n\n\n\n\n\n\n\n\nVersion\n\n\nHow to buy\n\n\n\n\n\n\n\n\n\n\nI2C_LCD (With universal Grove cable)\n\n\n\n\n\n\n\n\nI2C_LCD (With conversion Grove cable)\n\n\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nOnly 2 Arduino pins are occupied (Use I2C interface).\n\n\nSupports standard I2C mode (100Kbit/s) and fast I2C mode (400Kbit/s).\n\n\nCompatible with multiple communication logic levels: 2.8~5VDC.\n\n\nArduino library supported, use a line of code to complete the display.\n\n\nIntegrate 7 sizes of ASCll fonts, 5 graphics functions.\n\n\nProvide dedicated picture data convert software (Bitmap Converter).\n\n\nMost of the complex operation is processed by I2C_LCD independent controller, saving user controller resources.\n\n\nSupports cursor function, can set up 16 cursor flicker frequency.\n\n\nSupports 128 level backlight lightness adjustment.\n\n\nSupport 64 level screen contrast adjustment.\n\n\nSupport device address modification.\n\n\nSupports 127 I2C_LCD work in parallel.\n\n\nWhen debugging code, it can take the place of the serial monitor to monitor the program running state.\n\n\nTwo abnormal recovery methods are provided: reset and restore the factory settings.\n\n\nCompatible with Grove interface and 4Pin-100mil interface (under the Grove socket).\n\n\n4 symmetrical fixed hole design for easy user installation.\n\n\nChina style unique appearance.\n\n\n\n\nPlatform Support\n\uf0c1\n\n\n\n\n\n\n\n\nArduino\n\n\nWio\n\n\nBeagleBone\n\n\nRaspberry Pi\n\n\nLinkIt\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterface Function\n\uf0c1\n\n\n\n\nSpecification\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nScreen Type\n\n\nDual colour LCD\n\n\n\n\n\n\nScreen Resolution\n\n\n128*64 Pixels\n\n\n\n\n\n\nScreen Active Area (L*W)\n\n\n47.1*26.5mm\n\n\n\n\n\n\nIndividual Pixel Size\n\n\n0.33*0.33mm\n\n\n\n\n\n\nCommunication Mode\n\n\nI2C(100Kbit/s and 400Kbit/s)\n\n\n\n\n\n\nController\n\n\nSTM8S005KBT6\n\n\n\n\n\n\nOperating Frequency\n\n\n16 MHz\n\n\n\n\n\n\nWeight\n\n\n20g\n\n\n\n\n\n\n\n\nElectrical Characteristics\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nMin.\n\n\nTypical\n\n\nMNax.\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nSupply voltage\uff085V to GND\uff09\n\n\n4.5\n\n\n5\n\n\n5.5\n\n\nV\n\n\n\n\n\n\nLogic Voltage\uff08SCL/SDA\uff09\n\n\n2.8\n\n\n5\n\n\n5.5\n\n\nV\n\n\n\n\n\n\nHBM ESD\n\n\n-\n\n\n5000\n\n\n-\n\n\nV\n\n\n\n\n\n\nTemperature\n\n\n-20\n\n\n25\n\n\n70\n\n\n\u2103\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nStep 1:\n Install the latest version of Arduino IDE to your computer.\n\n\n\n\nStep 2:\n Download and install the I2C_LCD library to Arduino IDE:\n\n\nOpen Arduino IDE, click Sketch -\n Include library -\n Add .ZIP library.\n\n\n\n\nFind and select the I2C_LCD.zip file you just downloaded.\n\n\n\n\nRestart the Arduino IDE.\n\n\nStep 3:\n Chose the example project which you like. (Take \nHelloWorld\n project for example here.)\nClick \nFile \n Examples \n I2C_LCD \n HelloWorld\n\n\n\n\nStep 4:\n Connect I2C_LCD to your Seeeduino Vx board with Grove cable. Then connect Seeeduino Vx board to your computer.\n\n\n\n\nStep 5:\n Select your board and serial port.\n\n\nSelect the board: Click Tools \n Board \n Arduino Duemilanove or Diecimila(Seeeduino V3.0 Or early version), Arduino Uno(Seeeduino Lotus or Seeeduino V4.0).\n\n\n\n\nSelect the COM: Click Tools -\n Serial Port -\n COMX(which connected with your board.)\n\n\n\n\nStep 6:\n Upload the program and enjoy yourself!\n\n\n\n\nPS:\n\n\n\n\nFor more details about library install please refer to http://www.arduino.cc/en/Guide/Liaries.\n\n\nIf you encounter other problems during the use, please refer to the User Manual for help. If you can\nt solve it, please contact us.\n\n\n\n\nTechnical support:\n Joney.s@foxmail.com\n\n\nVersion Tracker\n\uf0c1\n\n\nI2C_LCD Hardware:\n\n\n\n\n\n\n\n\nRevision\n\n\nRelease Note\n\n\nRelease Date\n\n\n\n\n\n\n\n\n\n\nI2C_LCD_v1.2\n\n\n1. Add production test point.\n\n\nSep 18, 2015\n\n\n\n\n\n\nI2C_LCD_v1.1\n\n\n1. Modify the logo position. 2. Modify the board shape. 3. Modify the button position.\n\n\nMay 8, 2014\n\n\n\n\n\n\nI2C_LCD_v1.0\n\n\n1. Modify the power circuit wiring.\n\n\nMar 1, 2014\n\n\n\n\n\n\nI2C_LCD_v0.9b\n\n\n1. Initial public release.\n\n\nFeb 15, 2014\n\n\n\n\n\n\n\n\nI2C_LCD Library:\n\n\n\n\n\n\n\n\nRevision\n\n\nRelease Note\n\n\nRelease Date\n\n\n\n\n\n\n\n\n\n\nI2C_LCD_v1.21\n\n\nSupport LinkIt boards.\n\n\nAug 21, 2016\n\n\n\n\n\n\nI2C_LCD_v1.20\n\n\nReorganize I2C_LCD driver interface, make it easy to transplant to any other boards.\n\n\nApr 16, 2016\n\n\n\n\n\n\nI2C_LCD_v1.12\n\n\nModify the bug that can\nt display bitmap when y coordinate is more than 16.\n\n\nSep 4, 2015\n\n\n\n\n\n\nI2C_LCD_v1.11\n\n\nModify the bug that \n\\t\n can\nt print.\n\n\nJun 27, 2015\n\n\n\n\n\n\nI2C_LCD_v1.10\n\n\n1.Add LCD print function. 2.Edit DeviceAddressConfig example.\n\n\nJun 25, 2015\n\n\n\n\n\n\nI2C_LCD_v1.0\n\n\nInitial public release.\n\n\nJuly 6, 2014\n\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\nKeeping update the latest version.\n\n\nThe \nrepository of Arduino library hosted here\n, if you have any good idea of the code, you can pull to us.\n\n\n\n\nI2C_LCD Library\n\n\nI2C_LCD User Manual EN\n\n\nI2C_LCD User Manual \u4e2d\u6587\n\n\nBitmapConverter(ForWindows)\n\n\nBitmapConverter(ForMacOS)\n\n\nBitmapConverter(ForLinux)\n\n\nI2C_LCD_SourceFile\n\n\n\n\nHelp us to make it better\n\uf0c1\n\n\nThank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.\n\n\nIt is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:\n\n\n\n\nReplace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.\n\n\nReview and rewrite documents for hundreds of products to make them more understandable.\n\n\nInspected repair all the URL to make sure it can be linked to the right page.\n\n\n\n\nAlthough we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.\n\n\nBy the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "I2C LCD"
        }, 
        {
            "location": "/I2C_LCD/#product-version", 
            "text": "Version  How to buy      I2C_LCD (With universal Grove cable)     I2C_LCD (With conversion Grove cable)", 
            "title": "Product Version"
        }, 
        {
            "location": "/I2C_LCD/#features", 
            "text": "Only 2 Arduino pins are occupied (Use I2C interface).  Supports standard I2C mode (100Kbit/s) and fast I2C mode (400Kbit/s).  Compatible with multiple communication logic levels: 2.8~5VDC.  Arduino library supported, use a line of code to complete the display.  Integrate 7 sizes of ASCll fonts, 5 graphics functions.  Provide dedicated picture data convert software (Bitmap Converter).  Most of the complex operation is processed by I2C_LCD independent controller, saving user controller resources.  Supports cursor function, can set up 16 cursor flicker frequency.  Supports 128 level backlight lightness adjustment.  Support 64 level screen contrast adjustment.  Support device address modification.  Supports 127 I2C_LCD work in parallel.  When debugging code, it can take the place of the serial monitor to monitor the program running state.  Two abnormal recovery methods are provided: reset and restore the factory settings.  Compatible with Grove interface and 4Pin-100mil interface (under the Grove socket).  4 symmetrical fixed hole design for easy user installation.  China style unique appearance.", 
            "title": "Features"
        }, 
        {
            "location": "/I2C_LCD/#platform-support", 
            "text": "Arduino  Wio  BeagleBone  Raspberry Pi  LinkIt", 
            "title": "Platform Support"
        }, 
        {
            "location": "/I2C_LCD/#interface-function", 
            "text": "", 
            "title": "Interface Function"
        }, 
        {
            "location": "/I2C_LCD/#specification", 
            "text": "Parameter  Value      Screen Type  Dual colour LCD    Screen Resolution  128*64 Pixels    Screen Active Area (L*W)  47.1*26.5mm    Individual Pixel Size  0.33*0.33mm    Communication Mode  I2C(100Kbit/s and 400Kbit/s)    Controller  STM8S005KBT6    Operating Frequency  16 MHz    Weight  20g", 
            "title": "Specification"
        }, 
        {
            "location": "/I2C_LCD/#electrical-characteristics", 
            "text": "Parameter  Min.  Typical  MNax.  Unit      Supply voltage\uff085V to GND\uff09  4.5  5  5.5  V    Logic Voltage\uff08SCL/SDA\uff09  2.8  5  5.5  V    HBM ESD  -  5000  -  V    Temperature  -20  25  70  \u2103", 
            "title": "Electrical Characteristics"
        }, 
        {
            "location": "/I2C_LCD/#getting-started", 
            "text": "Step 1:  Install the latest version of Arduino IDE to your computer.   Step 2:  Download and install the I2C_LCD library to Arduino IDE:  Open Arduino IDE, click Sketch -  Include library -  Add .ZIP library.   Find and select the I2C_LCD.zip file you just downloaded.   Restart the Arduino IDE.  Step 3:  Chose the example project which you like. (Take  HelloWorld  project for example here.)\nClick  File   Examples   I2C_LCD   HelloWorld   Step 4:  Connect I2C_LCD to your Seeeduino Vx board with Grove cable. Then connect Seeeduino Vx board to your computer.   Step 5:  Select your board and serial port.  Select the board: Click Tools   Board   Arduino Duemilanove or Diecimila(Seeeduino V3.0 Or early version), Arduino Uno(Seeeduino Lotus or Seeeduino V4.0).   Select the COM: Click Tools -  Serial Port -  COMX(which connected with your board.)   Step 6:  Upload the program and enjoy yourself!   PS:   For more details about library install please refer to http://www.arduino.cc/en/Guide/Liaries.  If you encounter other problems during the use, please refer to the User Manual for help. If you can t solve it, please contact us.   Technical support:  Joney.s@foxmail.com", 
            "title": "Getting Started"
        }, 
        {
            "location": "/I2C_LCD/#version-tracker", 
            "text": "I2C_LCD Hardware:     Revision  Release Note  Release Date      I2C_LCD_v1.2  1. Add production test point.  Sep 18, 2015    I2C_LCD_v1.1  1. Modify the logo position. 2. Modify the board shape. 3. Modify the button position.  May 8, 2014    I2C_LCD_v1.0  1. Modify the power circuit wiring.  Mar 1, 2014    I2C_LCD_v0.9b  1. Initial public release.  Feb 15, 2014     I2C_LCD Library:     Revision  Release Note  Release Date      I2C_LCD_v1.21  Support LinkIt boards.  Aug 21, 2016    I2C_LCD_v1.20  Reorganize I2C_LCD driver interface, make it easy to transplant to any other boards.  Apr 16, 2016    I2C_LCD_v1.12  Modify the bug that can t display bitmap when y coordinate is more than 16.  Sep 4, 2015    I2C_LCD_v1.11  Modify the bug that  \\t  can t print.  Jun 27, 2015    I2C_LCD_v1.10  1.Add LCD print function. 2.Edit DeviceAddressConfig example.  Jun 25, 2015    I2C_LCD_v1.0  Initial public release.  July 6, 2014", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/I2C_LCD/#resources", 
            "text": "Keeping update the latest version.  The  repository of Arduino library hosted here , if you have any good idea of the code, you can pull to us.   I2C_LCD Library  I2C_LCD User Manual EN  I2C_LCD User Manual \u4e2d\u6587  BitmapConverter(ForWindows)  BitmapConverter(ForMacOS)  BitmapConverter(ForLinux)  I2C_LCD_SourceFile", 
            "title": "Resources"
        }, 
        {
            "location": "/I2C_LCD/#help-us-to-make-it-better", 
            "text": "Thank you for choosing Seeed. As one of the world-leading open-hardware suppliers, Seeedstudio has been continuously creating well-quality and diversified modules for our customers, makers and developers. As a young company, it is inevitable that there are things we neglected the importance, for example, our document system. It is a little shame however true that we have been continuously receiving complaint about how hard it is to use our document system\u2014\u2014ugly interface, confusing content, and the URL that can never be opened etc. Here we sincerely apologize for all the inconvenient you\u2019ve experienced during using the old system.  It is time to say good bye to the user-unfriendly old document system now, in order to bring better experience to our users, we have launched a project to optimize the document system from the middle of 2016. The work includes:   Replace the old WiKi system with a new one that developed from Mkdocs, a more widely used and cooler project documentation tool.  Review and rewrite documents for hundreds of products to make them more understandable.  Inspected repair all the URL to make sure it can be linked to the right page.   Although we have tried our best to optimize, it is still possible that we make some mistakes, so if you find anything that needs to be updated, it is very welcome to submit the amended version as our contributor or give us suggestions in the survey below. Please don\u2019t forget to leave your email address if you need our reply, we will reply to you as soon as we can.  By the way, we will feel very happy and encouraged if we receive 5 stars from you. With the help and encouragement from you, we believe that we can make this document better and better!", 
            "title": "Help us to make it better"
        }, 
        {
            "location": "/Communication/", 
            "text": "// to be continued", 
            "title": "Communication"
        }, 
        {
            "location": "/Grove-125KHz_RFID_Reader/", 
            "text": "This Grove-125KHz RFID Reader is a module used to read uem4100 RFID card information with two output formats: Uart and Wiegand. It has a sensitivity with maximum 7cm sensing distance. There is also \nthe electronic brick version\n of this module. It can help you with project like internet of thing and access control system.\n\n\nAnd you should use the module below while using RFID reader:\n\n\n\n\nRFID tag combo (125khz)\n\n\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nVoltage: 4.75-5.25V\n\n\nWorking Frequency: 125 KHz\n\n\nSensing Distance(Max): 70mm\n\n\nTTL Output: 9600 baudrate, 8 data bits, 1 stop bit, and no verify bit\n\n\nWiegand Output: 26 bits Wiegand format, 1 even verify bit, 24 data bits, and 1 odd verify bit\n\n\n\n\nDemonstration\n\uf0c1\n\n\nHere we show how to read RFID information using the Grove - 125KHz RFID Reader. Connect Grove - 125KHz RFID Reader to UART of Grove - Base Shield.\n\n\n\n\nUart Mode (Jumper set to the left two pins)\n\uf0c1\n\n\nYou would need to select the jumper to \nU\n to enter this mode, and the setting is: 9600bps, N, 8, 1, TTL output\n\n\n// link between the computer and the SoftSerial Shield\n//at 9600 bps 8-N-1\n//Computer is connected to Hardware UART\n//SoftSerial Shield is connected to the Software UART:D2\nD3\n\u00a0\n#include \nSoftwareSerial.h\n\n\u00a0\nSoftwareSerial SoftSerial(2, 3);\nunsigned char buffer[64]; // buffer array for data receive over serial port\nint count=0;     // counter for buffer array\n\u00a0\nvoid setup()\n{\n    SoftSerial.begin(9600);               // the SoftSerial baud rate\n    Serial.begin(9600);             // the Serial port of Arduino baud rate.\n}\n\u00a0\nvoid loop()\n{\n    if (SoftSerial.available())              // if date is coming from software serial port ==\n data is coming from SoftSerial shield\n    {\n        while(SoftSerial.available())          // reading data into char array\n        {\n            buffer[count++]=SoftSerial.read();     // writing data into array\n            if(count == 64)break;\n        }\n        Serial.write(buffer,count);            // if no data transmission ends, write buffer to hardware serial port\n        clearBufferArray();              // call clearBufferArray function to clear the stored data from the array\n        count = 0;                       // set counter of while loop to zero\n    }\n    if (Serial.available())            // if data is available on hardware serial port ==\n data is coming from PC or notebook\n    SoftSerial.write(Serial.read());       // write it to the SoftSerial shield\n}\nvoid clearBufferArray()              // function to clear buffer array\n{\n    for (int i=0; i\ncount;i++)\n    {\n        buffer[i]=NULL;\n    }                  // clear all index of array with command NULL\n}\n\n\n\n\nOpen the Serial Monitor, the card information can be displayed as shown below:\n\n\n\n\nWiegand Mode (Jumper Set to the Right two Pins)\n\uf0c1\n\n\nYou would need to select the jumper to \nW\n to enter this mode.\nThe \nWiegand demo code\n for Seeeduino is designed to read Wiegand data in interrupt mode.\n\n\nIn Wiegand Mode, output data is formatted with 26bits including 24bits card info and 2 bits parity.\n\n\n\n\n\n\n\nbit\n\n\n\n\n0\n\n\n\n\n1\n\n\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n5\n\n\n\n\n6\n\n\n\n\n7\n\n\n\n\n8\n\n\n\n\n9\n\n\n\n\n10\n\n\n\n\n11\n\n\n\n\n12\n\n\n\n\n13\n\n\n\n\n14\n\n\n\n\n15\n\n\n\n\n16\n\n\n\n\n17\n\n\n\n\n18\n\n\n\n\n19\n\n\n\n\n20\n\n\n\n\n21\n\n\n\n\n22\n\n\n\n\n23\n\n\n\n\n24\n\n\n\n\n25\n\n\n\n\n\n\n\n\n-\n\n\n\n\nPE\n\n\n\n\nD\n\n\n\n\nP0\n\n\n\n\n\n\n\n\n-\n\n\n\n\n-\n\n\n\n\nE\n\n\n\n\n0\n\n\n\n\n-\n\n\n\n\n\n\n\n\n-\n\n\n\n\n-\n\n\n\n\nD2[7..0]\n\n\n\n\nD1[7..0]\n\n\n\n\nD0[7..0]\n\n\n\n\n-\n\n\n\n\n\n\n\n\n\n\nPE is even bit, PO is odd bit;\n\n\nE is the data bit which was involved in even, O is the data bit which was involved in odd;\n\n\nDX[7..0] is the data bit which correspond to Mifare@ Standard \n Light card read only ID;\n\n\n\n\nHow to convert the output to Card Number\n\uf0c1\n\n\nTake ID: 0009776930 for example:\n\n\n\n\nCard Number ID: 0009776930 ------- Decimalism [Start Bit(00) + Card Number(8 numbers)]\n\n\nOutput: 0700952F229F ------------- Hex [[Start Bit(07h) + Card Number(8 numbers) + Checksum]\n\n\nThe calculator for decimal and hex numbers is available online.", 
            "title": "Grove - 125KHz RFID Reader"
        }, 
        {
            "location": "/Grove-125KHz_RFID_Reader/#specifications", 
            "text": "Voltage: 4.75-5.25V  Working Frequency: 125 KHz  Sensing Distance(Max): 70mm  TTL Output: 9600 baudrate, 8 data bits, 1 stop bit, and no verify bit  Wiegand Output: 26 bits Wiegand format, 1 even verify bit, 24 data bits, and 1 odd verify bit", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-125KHz_RFID_Reader/#demonstration", 
            "text": "Here we show how to read RFID information using the Grove - 125KHz RFID Reader. Connect Grove - 125KHz RFID Reader to UART of Grove - Base Shield.", 
            "title": "Demonstration"
        }, 
        {
            "location": "/Grove-125KHz_RFID_Reader/#uart-mode-jumper-set-to-the-left-two-pins", 
            "text": "You would need to select the jumper to  U  to enter this mode, and the setting is: 9600bps, N, 8, 1, TTL output  // link between the computer and the SoftSerial Shield\n//at 9600 bps 8-N-1\n//Computer is connected to Hardware UART\n//SoftSerial Shield is connected to the Software UART:D2 D3\n\u00a0\n#include  SoftwareSerial.h \n\u00a0\nSoftwareSerial SoftSerial(2, 3);\nunsigned char buffer[64]; // buffer array for data receive over serial port\nint count=0;     // counter for buffer array\n\u00a0\nvoid setup()\n{\n    SoftSerial.begin(9600);               // the SoftSerial baud rate\n    Serial.begin(9600);             // the Serial port of Arduino baud rate.\n}\n\u00a0\nvoid loop()\n{\n    if (SoftSerial.available())              // if date is coming from software serial port ==  data is coming from SoftSerial shield\n    {\n        while(SoftSerial.available())          // reading data into char array\n        {\n            buffer[count++]=SoftSerial.read();     // writing data into array\n            if(count == 64)break;\n        }\n        Serial.write(buffer,count);            // if no data transmission ends, write buffer to hardware serial port\n        clearBufferArray();              // call clearBufferArray function to clear the stored data from the array\n        count = 0;                       // set counter of while loop to zero\n    }\n    if (Serial.available())            // if data is available on hardware serial port ==  data is coming from PC or notebook\n    SoftSerial.write(Serial.read());       // write it to the SoftSerial shield\n}\nvoid clearBufferArray()              // function to clear buffer array\n{\n    for (int i=0; i count;i++)\n    {\n        buffer[i]=NULL;\n    }                  // clear all index of array with command NULL\n}  Open the Serial Monitor, the card information can be displayed as shown below:", 
            "title": "Uart Mode (Jumper set to the left two pins)"
        }, 
        {
            "location": "/Grove-125KHz_RFID_Reader/#wiegand-mode-jumper-set-to-the-right-two-pins", 
            "text": "You would need to select the jumper to  W  to enter this mode.\nThe  Wiegand demo code  for Seeeduino is designed to read Wiegand data in interrupt mode.  In Wiegand Mode, output data is formatted with 26bits including 24bits card info and 2 bits parity.    \nbit  \n0  \n1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  \n17  \n18  \n19  \n20  \n21  \n22  \n23  \n24  \n25    \n-  \nPE  \nD  \nP0    \n-  \n-  \nE  \n0  \n-    \n-  \n-  \nD2[7..0]  \nD1[7..0]  \nD0[7..0]  \n-     PE is even bit, PO is odd bit;  E is the data bit which was involved in even, O is the data bit which was involved in odd;  DX[7..0] is the data bit which correspond to Mifare@ Standard   Light card read only ID;", 
            "title": "Wiegand Mode (Jumper Set to the Right two Pins)"
        }, 
        {
            "location": "/Grove-125KHz_RFID_Reader/#how-to-convert-the-output-to-card-number", 
            "text": "Take ID: 0009776930 for example:   Card Number ID: 0009776930 ------- Decimalism [Start Bit(00) + Card Number(8 numbers)]  Output: 0700952F229F ------------- Hex [[Start Bit(07h) + Card Number(8 numbers) + Checksum]  The calculator for decimal and hex numbers is available online.", 
            "title": "How to convert the output to Card Number"
        }, 
        {
            "location": "/Grove-315MHz_RF_Kit/", 
            "text": "This kit is used for one way wireless communication at a frequency of 315MHz and includes a transmitter module and a receiver module. The twig configuration of this kit allows for around 40 meters of transmitting distance indoors, or around 100 meters outside. The 315 MHz frequency is suitable for use without a license in the United States. For use in Europe, please see the 433 MHz version of this product.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGROVE compatible interface.\n\n\nUses ASK (Amplitude Shift Keying) Modulation.\n\n\nOne way communication.\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nRemote control\n\n\nRemote automation\n\n\nAlarm\n\n\n\n\nMechanical Dimensions\n\uf0c1\n\n\n\n\nReceiver: 24mm by 42mm\n\n\nTransmitter: 20mm by 24mm\n\n\n\n\nUsage\n\uf0c1\n\n\nThe transmitter and receiver modules both rely on a single wire for communication. Though using the UART supplied by the arduino platform can work, it is recommended, instead, to use the VirtualWire library which uses Amplitude Shift Keying for modulation which provides better communication.\n\n\nBoth the transmitter and receiver modules require three wires: Vcc, Ground, and signal. Pin 2 of both parts of the kit are not connected.\n\n\nHardware Installation\n\uf0c1\n\n\nConnect the Transmitter module to Digital I/O 2 of the \nStem_-_Base_Shield\n on the arduino being used for transmission.\n\n\nConnect the Transmitter module to Digital I/O 2 of the \nStem_-_Base_Shield\n on the receiving arduino.\n\n\nProgramming\n\uf0c1\n\n\nSample code for Transmitter:\n\n\n#include \nVirtualWire.h\n\n\u00a0\nint RF_TX_PIN = 2;\n\u00a0\nvoid setup()\n{\n  vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n  vw_setup(2000); // Transmission speed in bits per second.\n}\n\u00a0\nvoid loop()\n{\n  const char *msg = \nhello\n;\n  vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n  delay(400);\n\u00a0\n}\n\n\n\n\nSample code for Receiver:\n\n\n#include \nVirtualWire.h\n\n\u00a0\nint RF_RX_PIN = 2;\n\u00a0\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\nsetup\n);\n  vw_set_rx_pin(RF_RX_PIN);  // Setup receive pin.\n  vw_setup(2000); // Transmission speed in bits per second.\n  vw_rx_start(); // Start the PLL receiver.\n}\n\u00a0\nvoid loop()\n{\n  uint8_t buf[VW_MAX_MESSAGE_LEN];\n  uint8_t buflen = VW_MAX_MESSAGE_LEN;\n  if(vw_get_message(buf, \nbuflen)) // non-blocking I/O\n  {\n    int i;\n    // Message with a good checksum received, dump HEX\n    Serial.print(\nGot: \n);\n    for(i = 0; i \n buflen; ++i)\n    {\n      Serial.print(buf[i], HEX);\n      Serial.print(\n \n);\n    }\n    Serial.println(\n);\n  }\n}\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nDemo code: \n433MHz demo.zip\n\n\nVirtualWire 1.20\n\n\nVirtualWire Documentation\n\n\nTI:LM358PSR", 
            "title": "Grove - 315MHz RF Kit"
        }, 
        {
            "location": "/Grove-315MHz_RF_Kit/#features", 
            "text": "GROVE compatible interface.  Uses ASK (Amplitude Shift Keying) Modulation.  One way communication.", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-315MHz_RF_Kit/#application-ideas", 
            "text": "Remote control  Remote automation  Alarm", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-315MHz_RF_Kit/#mechanical-dimensions", 
            "text": "Receiver: 24mm by 42mm  Transmitter: 20mm by 24mm", 
            "title": "Mechanical Dimensions"
        }, 
        {
            "location": "/Grove-315MHz_RF_Kit/#usage", 
            "text": "The transmitter and receiver modules both rely on a single wire for communication. Though using the UART supplied by the arduino platform can work, it is recommended, instead, to use the VirtualWire library which uses Amplitude Shift Keying for modulation which provides better communication.  Both the transmitter and receiver modules require three wires: Vcc, Ground, and signal. Pin 2 of both parts of the kit are not connected.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-315MHz_RF_Kit/#hardware-installation", 
            "text": "Connect the Transmitter module to Digital I/O 2 of the  Stem_-_Base_Shield  on the arduino being used for transmission.  Connect the Transmitter module to Digital I/O 2 of the  Stem_-_Base_Shield  on the receiving arduino.", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-315MHz_RF_Kit/#programming", 
            "text": "Sample code for Transmitter:  #include  VirtualWire.h \n\u00a0\nint RF_TX_PIN = 2;\n\u00a0\nvoid setup()\n{\n  vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n  vw_setup(2000); // Transmission speed in bits per second.\n}\n\u00a0\nvoid loop()\n{\n  const char *msg =  hello ;\n  vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n  delay(400);\n\u00a0\n}  Sample code for Receiver:  #include  VirtualWire.h \n\u00a0\nint RF_RX_PIN = 2;\n\u00a0\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println( setup );\n  vw_set_rx_pin(RF_RX_PIN);  // Setup receive pin.\n  vw_setup(2000); // Transmission speed in bits per second.\n  vw_rx_start(); // Start the PLL receiver.\n}\n\u00a0\nvoid loop()\n{\n  uint8_t buf[VW_MAX_MESSAGE_LEN];\n  uint8_t buflen = VW_MAX_MESSAGE_LEN;\n  if(vw_get_message(buf,  buflen)) // non-blocking I/O\n  {\n    int i;\n    // Message with a good checksum received, dump HEX\n    Serial.print( Got:  );\n    for(i = 0; i   buflen; ++i)\n    {\n      Serial.print(buf[i], HEX);\n      Serial.print(   );\n    }\n    Serial.println( );\n  }\n}", 
            "title": "Programming"
        }, 
        {
            "location": "/Grove-315MHz_RF_Kit/#resources", 
            "text": "Demo code:  433MHz demo.zip  VirtualWire 1.20  VirtualWire Documentation  TI:LM358PSR", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/", 
            "text": "This kit is used for one way wireless communication at a frequency of 433MHz and includes a transmitter module and a receiver module. The twig configuration of this kit allows for around 40 meters of transmitting distance indoors, or around 100 meters outside.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nRevision\n\n\nDescription\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv0.9b\n\n\nInitial public release\n\n\n03,Oct,2011\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGROVE compatible interface.\n\n\nUses ASK (Amplitude Shift Keying) Modulation.\n\n\nOne way communication.\n\n\n\n\nSpecifications\n\uf0c1\n\n\nTransmitter Module\n\uf0c1\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n3.0\n\n\n\n\n5.0\n\n\n\n\n12.0\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n3\n\n\n\n\n/\n\n\n\n\n10\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nWork Mode\n\n\n\n\nASK\n\n\n\n\n/\n\n\n\n\n\n\n\n\nTransmit Power(Max)\n\n\n\n\n15\n\n\n\n\nmW\n\n\n\n\n\n\n\n\nWorking Distance\n\n\n\n\n40\n\n\n\n\n/\n\n\n\n\n100\n\n\n\n\nm\n\n\n\n\n\n\n\n\nReceiver Module\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n5\n\n\nVDC\n\n\n\n\n\n\nQuiescent Current\n\n\n5\n\n\nmA\n\n\n\n\n\n\nReceiver Sensitivity\n\n\n-105\n\n\ndBm\n\n\n\n\n\n\nOperating frequency\n\n\n433.92\n\n\nMHz\n\n\n\n\n\n\n\n\nApplication Ideas\n\uf0c1\n\n\n\n\nRemote control\n\n\nRemote automation\n\n\nAlarm\n\n\n\n\nUsage\n\uf0c1\n\n\nThe transmitter and receiver modules both rely on a single wire for communication. Though using the UART supplied by the Arduino platform can work, it is recommended, instead, to use the VirtualWire library which uses Amplitude Shift Keying for modulation which provides better communication.\n\n\nBoth the transmitter and receiver modules require three wires: Vcc, Ground, and signal. Pin 2 of both parts of the kit are not connected.\n\n\n\n\nConnect the Transmitter module to Digital I/O 2 of the \nGrove_-_Base_Shield\n on the Arduino being used for transmission.\n\n\n\n\nError creating thumbnail: Invalid thumbnail parameters\n\n\n\n\nConnect the Receiver module to Digital I/O 2 of the \nGrove_-_Base_Shield\n on the receiving Arduino.\n\n\n\n\nError creating thumbnail: Invalid thumbnail parameters\n\n\n\n\nDownload the \nVirtualWire library\n and unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries. Please reference \nhere\n.\n\n\nUpload the code below for transmitter module:\n\n\n\n\n    #include \nVirtualWire.h\n\n\n    //Grove - 315(433) RF link kit Demo v1.0\n    //by\u00a0:http://www.seeedstudio.com/\n    //connect the sent module to D2 to use  \n    #include \nVirtualWire.h\n\n\n    int RF_TX_PIN = 2;\n\n    void setup()\n    {\n      vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n      vw_setup(2000); // Transmission speed in bits per second.\n    }\n\n    void loop()\n    {\n      const char *msg = \nhello\n;\n      vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n      delay(400);\n\n    }\n\n\n\n\n\n\nUpload the code below for receiver module:\n\n\n\n\n    //Grove - 315(433) RF link kit Demo v1.0\n    //by\u00a0:http://www.seeedstudio.com/\n    //connect the receive module to D2 to use ..\n    #include \nVirtualWire.h\n\n\n    int RF_RX_PIN = 2;\n\n    void setup()\n    {\n      Serial.begin(9600);\n      Serial.println(\nsetup\n);\n      vw_set_rx_pin(RF_RX_PIN);  // Setup receive pin.\n      vw_setup(2000); // Transmission speed in bits per second.\n      vw_rx_start(); // Start the PLL receiver.\n    }\n\n    void loop()\n    {\n      uint8_t buf[VW_MAX_MESSAGE_LEN];\n      uint8_t buflen = VW_MAX_MESSAGE_LEN;\n      if(vw_get_message(buf, \nbuflen)) // non-blocking I/O\n      {\n        int i;\n        // Message with a good checksum received, dump HEX\n        Serial.print(\nGot: \n);\n        for(i = 0; i \n buflen; ++i)\n        {\n          Serial.print(buf[i], HEX);\n          Serial.print(\n \n);\n          //Serial.print(buf[i]);\n        }\n        Serial.println(\n);\n      }\n    }\n\n\n\n\n\n\nOpen the serial monitor of receiver module to see the result.\n\n\n\n\n\n\nThis is just a simple transmitter and receiver instance as a reference.\n\n\nResources\n\uf0c1\n\n\n\n\nVirtualWire Library.zip\n\n\n433MHz_demo.zip\n\n\nVirtualWire Documentation\n\n\nTI:LM358PSR\n\n\nR433A Datasheet", 
            "title": "Grove - 433MHz Simple RF Link Kit"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#version-tracker", 
            "text": "Revision  Description  Release      v0.9b  Initial public release  03,Oct,2011", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#features", 
            "text": "GROVE compatible interface.  Uses ASK (Amplitude Shift Keying) Modulation.  One way communication.", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#specifications", 
            "text": "", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#transmitter-module", 
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n3.0  \n5.0  \n12.0  \nVDC    \nCurrent  \n3  \n/  \n10  \nmA    \nWork Mode  \nASK  \n/    \nTransmit Power(Max)  \n15  \nmW    \nWorking Distance  \n40  \n/  \n100  \nm", 
            "title": "Transmitter Module"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#receiver-module", 
            "text": "Item  Typical  Unit      Working Voltage  5  VDC    Quiescent Current  5  mA    Receiver Sensitivity  -105  dBm    Operating frequency  433.92  MHz", 
            "title": "Receiver Module"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#application-ideas", 
            "text": "Remote control  Remote automation  Alarm", 
            "title": "Application Ideas"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#usage", 
            "text": "The transmitter and receiver modules both rely on a single wire for communication. Though using the UART supplied by the Arduino platform can work, it is recommended, instead, to use the VirtualWire library which uses Amplitude Shift Keying for modulation which provides better communication.  Both the transmitter and receiver modules require three wires: Vcc, Ground, and signal. Pin 2 of both parts of the kit are not connected.   Connect the Transmitter module to Digital I/O 2 of the  Grove_-_Base_Shield  on the Arduino being used for transmission.   Error creating thumbnail: Invalid thumbnail parameters   Connect the Receiver module to Digital I/O 2 of the  Grove_-_Base_Shield  on the receiving Arduino.   Error creating thumbnail: Invalid thumbnail parameters   Download the  VirtualWire library  and unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries. Please reference  here .  Upload the code below for transmitter module:       #include  VirtualWire.h \n\n    //Grove - 315(433) RF link kit Demo v1.0\n    //by\u00a0:http://www.seeedstudio.com/\n    //connect the sent module to D2 to use  \n    #include  VirtualWire.h \n\n    int RF_TX_PIN = 2;\n\n    void setup()\n    {\n      vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n      vw_setup(2000); // Transmission speed in bits per second.\n    }\n\n    void loop()\n    {\n      const char *msg =  hello ;\n      vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n      delay(400);\n\n    }   Upload the code below for receiver module:       //Grove - 315(433) RF link kit Demo v1.0\n    //by\u00a0:http://www.seeedstudio.com/\n    //connect the receive module to D2 to use ..\n    #include  VirtualWire.h \n\n    int RF_RX_PIN = 2;\n\n    void setup()\n    {\n      Serial.begin(9600);\n      Serial.println( setup );\n      vw_set_rx_pin(RF_RX_PIN);  // Setup receive pin.\n      vw_setup(2000); // Transmission speed in bits per second.\n      vw_rx_start(); // Start the PLL receiver.\n    }\n\n    void loop()\n    {\n      uint8_t buf[VW_MAX_MESSAGE_LEN];\n      uint8_t buflen = VW_MAX_MESSAGE_LEN;\n      if(vw_get_message(buf,  buflen)) // non-blocking I/O\n      {\n        int i;\n        // Message with a good checksum received, dump HEX\n        Serial.print( Got:  );\n        for(i = 0; i   buflen; ++i)\n        {\n          Serial.print(buf[i], HEX);\n          Serial.print(   );\n          //Serial.print(buf[i]);\n        }\n        Serial.println( );\n      }\n    }   Open the serial monitor of receiver module to see the result.    This is just a simple transmitter and receiver instance as a reference.", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#resources", 
            "text": "VirtualWire Library.zip  433MHz_demo.zip  VirtualWire Documentation  TI:LM358PSR  R433A Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/", 
            "text": "Grove - BLE (dual model) v1.0 uses CSR dual mode Bluetooth chip. The chip is based on ARM architecture and supports AT instructions. Users can develop flexibly according to the serial baud rate, equipment name, pairing password.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nBT Version: Bluetooth Specification V4.0 \n BLE\n\n\nUART send and receive max bytes is 512\n\n\nOther device to module in SPP mode: 90 Bytes per packet\n\n\nOther device to module in BLE mode: 20 Bytes per packet\n\n\nTwo data transmission mode, balance mode and high speed mode\n\n\nWorking frequency: 2.4GHz ISM band\n\n\nModulation method: GFSK(Gaussian Frequency Shift Keying)\n\n\nRF Power: -23dbm, -6dbm, 0dbm, 6dbm.\n\n\nSpeed: Asynchronous: 3K Bytes\n\n\nSynchronous: 3K Bytes\n\n\nSecurity: Authentication and encryption\n\n\nService: Slave SPP, Peripheral BLE, UUID FFE0,FFE1\n\n\nPower: +3.3/+5.0VDC 50mA\n\n\nLong range: SPP 30 meters, BLE 60 meters\n\n\nPower: SPP 13.5mA, BLE 9.5mA\n\n\nWorking temperature: \u20135 ~ +65 Centigrade\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nK2\n: During connected status, it could be disconnected by pressing K2 button more than 100ms. During sleep mode, it could be restored through pressing K2 (factory settings) button.\n\n\nU1\n: U1 is the wireless module, it includes automatic power on reset circuit.\n\n\nD1\n: The LED works in two mode: \nSleeping\n is indicated by flashing slowly and \nConnected\n status indicated by continuous illumination.\n\n\nJ1\n: The standard Grove connector.\n\n\n\n\nCaution\n\nBLE transmission speed is slower than SPP transmission, so we selected the lower one in the design, in accordance with the speed of a BLE dual-mode product planning.\n\n\n\n\nHardware Installation\n\uf0c1\n\n\nConnecting Bluetooth to PC through UART Bee\n\uf0c1\n\n\nThe Bluetooth provides a serial port with standard Grove socket, most USB-UART converter can be used. Here we use a \nUartSBee V5\n to connect Bluetooth and PC.\n\n\n\nConnecting Bluetooth to Arduino\n\uf0c1\n\n\nSince Arduino Uno have no Grove socket, we use \nSeeeduino Lotus\n instead. You could use Arduino with \nGrove Base Shield V2\n as well.\nAs an example, D2 and D3 are used as software UART. So, plug the Grove cable into \nD2\n socket\n\n\n\nSoftware Instructions\n\uf0c1\n\n\nConventions\n\uf0c1\n\n\n\n\nIn EDR mode, only slave can be configured while either master or slave can be in BLE mode.\n\n\nFactory default setting:\n\n\nEDR Name HMSoft, Slave role, PinCode 1234\n\n\nBLE Name HMSoft, Slave role, PinCode 000000\n\n\nBaud: 115200, N, 8, 1;\n\n\n\n\n\n\nAT Command format:\n\n\nUppercase AT command format. string format, without any other symbol. (e.g. \\r or \\n).\n\n\nAny incorrect command would get no response.\n\n\n\n\n\n\n\n\nAT Commands\n\uf0c1\n\n\n1. Test Command\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT\n\n\nOK/ER/Disconnect link\n\n\nNone\n\n\n\n\n\n\n\n\nIf module is not connected to remote device will receive: \u201cOK\u201d\n\n\nIf module has an error, will receive: \u201cER\u201d\n\n\nIf Module has connected, module will disconnected from remote device, if \u201cAT + NOTI\u201d is setup to 1, will receive information string\n\n\n2. Query module EDR address\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+ADDE?\n\n\nOK+ Get: MAC\n\n\nNone\n\n\n\n\n\n\n\n\n3. Query module BLE address\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+ADDB?\n\n\nOK+ Get: MAC\n\n\nNone\n\n\n\n\n\n\n\n\n4. Query/Set Authentication mode\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+AUTH?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1, (Default: 0)\n0 \u2013 Not authentication\n1 \u2013 Must authentication\n\n\n\n\n\n\n\n\n\nS: AT+AUTH[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\nAT+AUTH0: allow made an insecure connection.\nAT+AUTH1: every connection must with authentication.\n\n\n5. Query/Set A to B mode\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+ATOB?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1, (Default: 0)\n0 \u2013 Not Open ATOB\n1 \u2013 Open ATOB mode\n\n\n\n\n\n\n\n\n\nS: AT+ATOB[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\nThis command must work with AT+MODE0 command. When A device (SPP mode) connect to the module and B device (BLE mode) is also connect to the module, The data string from A device send to the module will send to B device. The data string from B device send to the module is also send to the A device.\n\n\n6. Query/Set baud rate\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+BAUD?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 1~7, (Default: 6).\n1 - 4800\n2 \u2013 9600\n3 \u2013 19200\n4 \u2013 38400\n5 \u2013 57600\n6 \u2013 115200\n7 - 230400\n\n\n\n\n\n\n\n\n\nS: AT+BAUD[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\n7. Clear bond information\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+BONDE\n\n\nOK+BONDE\n\n\nClear EDR bond info\n\n\n\n\n\n\nAT+BONDB\n\n\nOK+BONDB\n\n\nClear BLE bond info\n\n\n\n\n\n\n\n\nBLE mode not supports it yet.\n\n\n8. Clear Last Connected EDR Device Address\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+CLEAE\n\n\nOK+CLEAE\n\n\nNone\n\n\n\n\n\n\n\n\n9. Clear Last Connected BLE Device Address\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+CLEAB\n\n\nOK+CLEAB\n\n\nNone\n\n\n\n\n\n\n\n\n10. Query/Set Module DUAL Work Mode\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+DUAL?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1, (Default: 0)\n0 \u2013 Allow dual connect.\n1 \u2013 Allow one connect.\n\n\n\n\n\n\n\n\n\nS: AT+DUAL[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\nAT+DUAL0: allow two connections at same time (SPP and BLE).\nAT+DUAL1: Only allow one connection at same time (SPP or BLE)\n\n\n11. Query/Set hardware flow control switch\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nAT+FIOW?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1,(Default: 0)\n0: Hardware flow control off\n1: Hardware flow control on\n\n\n\n\n\n\n\n\n\nAT+FIOW[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\n12. Query/Set module data transmission speed mode\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nAT+HIGH?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1,(Default: 0)\n0: Balance mode\n1: High speed mode\n\n\n\n\n\n\n\n\n\nAT+HIGH[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\nIn balance mode, we balanced SPP and BLE with a steady speed.\nIn high speed mode, we don\u2019t control speed, so SPP mode will got high speed.\nIn high speed mode, module lost RESETB pin function, but you still could use\n\u201cAT+RESET\u201d command to reset module.\n\n\n13. System Help Information\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+HELP?\n\n\nHelp Information\n\n\nNone\n\n\n\n\n\n\n\n\n14. Query/Set module loaded notify\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nAT+INIT?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1,?, (Default: 0)\n0: Loaded notify 0ff\n1: Loaded notify on\n\n\n\n\n\n\n\n\n\nAT+INIT[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\nWhen \u201cAT+INIT1\u201d is setup, after module loaded, module will output \u201cOK+INIT\u201d string through UART.\n\n\n15. Query/Set Module Work Mode\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+MODE?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1, (Default: 0)\n0 \u2013 Data transmission.\n1 \u2013 Remote control.\n\n\n\n\n\n\n\n\n\nS: AT+MODE[P1]\n\n\n\n\nOK+ Set:[ P1]\n\n\n\n\n\n\n\n\nAT+MODE0: Only transfer data when connection establishment.\nAT+MODE1: Transfer data and response AT commands.\n\n\n16. Query/Set Notify information\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+NOTI?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1, (Default: 0)\n0: Don\u2019t Notify\n1: Notify\n\n\n\n\n\n\n\n\n\nS: AT+NOTI[P1]\n\n\n\n\nOK+ Set:[ P1]\n\n\n\n\n\n\n\n\nAfter AT+NOTI1, module will send connect or disconnect string through\nUART when module state is changed:\n\n\nOK+CONE ======== EDR connect\n\n\nOK+LSTE ========= EDR disconnect\n\n\nOK+CONB========= BLE connect\n\n\nOK+LSTB ========= BLE disconnect\n\n\nOK+LSTA ========= except disconnect, module will reset after 500 ms.\n\n\n17. Query/Set notify mode\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+NOTP?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1; default: 0\n0: without address\n1: with address\n\n\n\n\n\n\n\n\n\nQ: AT+NOTP[P1]\n\n\n\n\nOK+ Set:[ P1]\n\n\n\n\n\n\n\n\nThis command must work with \u201cAT+NOTI1\u201d, if this switch is open, when the module connect to disconnect, the prompt string will include the remote address.\n\n\n18. Query/Set Module EDR name\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+NAME?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: module EDR name,\nMax length is 12.\nDefault: HMSoft\n\n\n\n\n\n\n\n\n\nQ: AT+NAME[P1]\n\n\n\n\nOK+ Set:[ P1]\n\n\n\n\n\n\n\n\n19. Query/Set Module BLE name\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+NAMB?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: module BLE name,\nMax length is 12.\nDefault: HMSoft\n\n\n\n\n\n\n\n\n\nS: AT+NAMB[P1]\n\n\n\n\nOK+ Set:[ P1]\n\n\n\n\n\n\n\n\n20. Query/Set PIO1 output status (System LED)e\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+PIO1?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1\n0: Unconnected Output 500ms High 500ms Low, Connected output High.\n1: Unconnected output Low, Connected output High.\nDefault: 0\n\n\n\n\n\n\n\n\n\nS: AT+ PIO1 [P1]\n\n\n\n\nOK+ Set:[ P1]\n\n\n\n\n\n\n\n\n21. Query/Set PIO output status\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+PIO[P1]?\n\n\n\n\nOK+ Get:[P1][P2]\n\n\n\n\nP1: 2~B (HM-12)\nP2: 2~3 (HM-13)\n0: Output Low\n1: Output High\n?: Query\n\n\n\n\n\n\n\n\n\nS: AT+ PIO[P1][P2]\n\n\n\n\nOK+ Set:[P1][P2]\n\n\n\n\n\n\n\n\n22. Query/Set EDR Pin Code\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+PINE?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: module EDR Code\nMax length: 6\nDefault: 1234\n\n\n\n\n\n\n\n\n\nS: AT+PINE[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\n23. Query/Set BLE Pin Code\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+PINB?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: module BLE Code\n000000~999999\nDefault: 000000\n\n\n\n\n\n\n\n\n\nS: AT+PINB[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\n24. Query/Set UART parity bit\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+PARI?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1, 2, (Default: 0)\n0: Parity None\n1: Parity even\n2: Parity odd\n\n\n\n\n\n\n\n\n\nS: AT+PARI[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\n25. Restore all setup value to factory setup\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+RENEW\n\n\nOK+RENEW\n\n\nNone\n\n\n\n\n\n\n\n\n26. Restart module\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+RESET\n\n\nOK+RESET\n\n\nNone\n\n\n\n\n\n\n\n\n27. Query BLE RSSI value\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+RSSB?\n\n\nOK+RSSB: [P1]\n\n\nP1: RSSI value\n\n\n\n9999: No connection\n\n9998: Try later\n\n9997: Read error\n\nXxxx: RSSI value\n\n\n\n\n\n\n\n\n\nThis command must use after \u201cAT+MODE1\u201d is setup. This command is only used by remote Bluetooth device. \n\n\n28. Query EDR RSSI value\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+RSSE?\n\n\nOK+RSSE: [P1]\n\n\nP1: RSSI value\n\n\n\n9999: No connection\n\n9998: Try later\n\n9997: Read error\n\nXxxx: RSSI value\n\n\n\n\n\n\n\n\n\n29. Query Last Connected EDR Device Address\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+RADE?\n\n\nOK+Get:MAC Address\n\n\nNone\n\n\n\n\n\n\n\n\n30. Query Last Connected BLE Device Address\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+RADB?\n\n\nOK+Get:MAC Address\n\n\nNone\n\n\n\n\n\n\n\n\n31. Query/Set Master and Slaver Role\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nAT+ROLB?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1 (default: 0)\n0: Peripheral\n1: Central\n\n\n\n\n\n\n\n\n\nAT+ROLB[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\nThis command will take effect after module next power on or reset. \n\n\n32. Query/Set EDR work mode\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+SCAN?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1, (Default: 0)\n0: Discovery and connectable\n1: Only connectable\n\n\n\n\n\n\n\n\n\nS: AT+SCAN[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\n33. Query/Set UART stop bit\n\n\n\n\n\n\n\nSend\n\n\n\n\nReceive\n\n\n\n\nParameter\n\n\n\n\n\n\n\n\nQ: AT+STOP?\n\n\n\n\nOK+ Get:[P1]\n\n\n\n\nP1: 0, 1, (Default: 0)\n0: 1 stop bit\n1: 2 stop bits\n\n\n\n\n\n\n\n\n\nS: AT+STOP[P1]\n\n\n\n\nOK+ Set:[P1]\n\n\n\n\n\n\n\n\n34. Query Software Version\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSend\n\n\nReceive\n\n\nParameter\n\n\n\n\n\n\n\n\n\n\nAT+VERR?\n\n\n\nAT+VERS?\n\n\nVersion Information\n\n\nNone\n\n\n\n\n\n\n\n\n\nProgramming\n\uf0c1\n\n\nConfigure the Bluetooth module with Serial under Windows\n\uf0c1\n\n\nThis section shows how to configure Bluetooth with PC, some basic methods of setting could be learn. Set up hardware connection refer to \u201cHardware Installation\u201d section. You will find the blue LED on the module flashes illustrate no connection is set up.\n\n\nOpen a serial terminal and set Baud Rate:115200, Databits: 8, Stopbits: 1 and No Flow Control. Send \u201cAT\u201d to Bluetooth with the serial terminal and \u201cOK\u201d will be return if all goes well. The Bluetooth only respond AT commands when no connection was set up, or all commands were seen as string and sent out. You can distinguish the status through LED indicates.\n\n\n\n\nThen some useful configurations could be sent. Here are some samples of commands and responses.\n\n\n\n\n\n\nTest serial connection, send \u201cAT\u201d, will return \u201cOK\u201d.\n\n\n\n\n\n\nRestore factory settings, send \u201cAT+RENEW\u201d, return \u201cOK+RENEW\u201d.\n\n\n\n\n\n\nReset baud rate of serial port, send \u201cAT+BAUD2\u201d, return \u201cOK+Set:2\u201d.\n\n\n\n\n\n\nEnable authentication, send \u201cAT+AUTH1\u201d, return \u201cOK+Set:1\u201d.\n\n\n\n\n\n\nReset the Bluetooth, send \u201cAT+RESET\u201d, return \u201dOK+RESET\u201d.\n\n\n\n\n\n\nQuery firmware version, send \u201cAT+VERS?\u201d, return \u201cOK+Get:HMSoftV217\u201d.\n\n\n\n\n\n\nQuery MAC of EDR, send \u201cAT+ADDE?\u201d, return \u201cOK+Get:000E0E002074\u201d.\n\n\n\n\n\n\nQuery MAC of BLE, send \u201cAT+ADDB?\u201d, return \u201cOK+Get:000E0B002074\u201d.\n\n\n\n\n\n\nSet the name of EDR, send \u201cAT+NAMEHM-13-EDR\u201d, return \u201cOK+Set:HM-13-EDR\u201d.\n\n\n\n\n\n\nSet the name of BLE, send \u201cAT+NAMEHM-13-BLE\u201d, return \u201cOK+Set:HM-13-BLE\u201d.\n\n\n\n\n\n\nSet the password of EDR, send \u201cAT+PINE123451\u201d, return \u201cOK+Set:123451\u201d.\n\n\n\n\n\n\nSet the password of BLE, send \u201cAT+PINB123451\u201d, return \u201cOK+Set:123451\u201d.\n\n\n\n\n\n\nEnable discovery and connectable, send \u201cAT+SCAN0\u201d, return \u201cOK+Set:0\u201d.\n\n\n\n\n\n\nEnable notify information of connection, send \u201cAT+NOTI1\u201d, return \u201cOK+Set:1\u201d.\n\n\n\n\n\n\nNotify information include address, send \u201cAT+NOTP1\u201d, return \u201cOK+Set:1\u201d.\n\n\n\n\n\n\nEnable user key, send \u201cAT+PIO01\u201d, return \u201cOK+Set:1\u201d.\n\n\n\n\n\n\nSet to Central mode, send \u201cAT+ROLB1\u201d, return \u201cAT+ROLB1\u201d.\n\n\n\n\n\n\nOr Set to Peripheral mode, send \u201cAT+ROLB0\u201d, return \u201cAT+ROLB0\u201d.\n\n\nWe use two Bluetooth connected with PC, one was set as Central while the other is Peripheral. Several seconds later they find each other and the LED stop flash, connected!\n\n\nCommunicate with iPhone\n\uf0c1\n\n\nThis kind of Bluetooth module has two protocol: Bluetooth EDR(Enhanced Data Rate) and Bluetooth Low Energy. It can communicate with any device that has one of these protocols. Some Android phone with OS higher than 4.3 and iPhone4 or later have BLE ability. We use a iPhone to demonstrate how to use a cellphone to interact with Bluetooth.\n\n\nPower the Bluetooth and configure it as Peripheral role. Search LightBlue in Apple Store and install it. Launch the app, you may find \u201cHM-13-BLE\u201d which we just renamed. Touch it to connect, then touch \u201cProperties\u201d to control it. The key \u201cHex\u201d on the top right is for change data format, maybe String is easy to see. Hit \u201cListen for notifications\u201d to enable data receiving. Then we can send data to PC through BLE, hit \u201cWrite new value\u201d and write some words. Also PC can transfer data to iPhone with serial terminal.\n\n\n\n\n\n\n\n\n \n\n\n\n\nData transmission between Two Arduinos\n\uf0c1\n\n\nAre you ready to code? It\u2019s time to do something after practice. Prepare a pair of Bluetooth, and Arduino or other platform to control them. Here we use two Arduino Uno. Set up the connection as mentioned in section \u201cHardware Installation\u201d.\n\n\nThe program of Central and Peripheral use the same code, the only difference is the micro define at the beginning of the program. To assign the Bluetooth to Central role, Just need to modify the text to \u201c#define MASTER 1\u201d, or \u201c#define MASTER 1\u201d if Peripheral role was assigned.\n\n\nThe initialisation program flow please refer to the following flow chart. First of all we need to distinguish the presetting baud rate of the Bluetooth. After this, send commands to restore factory settings, and change baud rate from 115200 to 9600 since software serial will not working well at high baud rate. Then other parameters were configured to the Bluetooth with Reset command in the final.\n\n\n\n\nAfter the initialisation, the Central and Peripheral will do different things, the Central will send message to Peripheral interval and print what received from Peripheral while the Peripheral only responds the Central.\n\n\nClick \nhere\n to download the test code and open HM-13_SW.ino with Arduino IDE, compile and download to Arduino Uno. Remember to configure the Bluetooth to different role by modify the macro at the beginning. If you have any problem about how to start Arduino, please click \nhere\n for some help.\n\n\nAfter downloading program, open two serial terminal windows, the LEDs on Bluetooth will flash, several seconds later, they stop to flash and keep on, this indicates that they connected to each other. \nAccording to the program is written, the Central sends message to the Peripheral continually and get feedback every time.\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nHM-13 Bluetooth Module Datasheet\n\n\nArduino code\n\n\nEAGLE_Grove-BLE_(dual_model)_v1.0_sch_pcb\n\n\nPDF_Grove-BLE_(dual_model)_v1.0_sch", 
            "title": "Grove - BLE (dual model) v1.0"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#features", 
            "text": "BT Version: Bluetooth Specification V4.0   BLE  UART send and receive max bytes is 512  Other device to module in SPP mode: 90 Bytes per packet  Other device to module in BLE mode: 20 Bytes per packet  Two data transmission mode, balance mode and high speed mode  Working frequency: 2.4GHz ISM band  Modulation method: GFSK(Gaussian Frequency Shift Keying)  RF Power: -23dbm, -6dbm, 0dbm, 6dbm.  Speed: Asynchronous: 3K Bytes  Synchronous: 3K Bytes  Security: Authentication and encryption  Service: Slave SPP, Peripheral BLE, UUID FFE0,FFE1  Power: +3.3/+5.0VDC 50mA  Long range: SPP 30 meters, BLE 60 meters  Power: SPP 13.5mA, BLE 9.5mA  Working temperature: \u20135 ~ +65 Centigrade", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#hardware-overview", 
            "text": "K2 : During connected status, it could be disconnected by pressing K2 button more than 100ms. During sleep mode, it could be restored through pressing K2 (factory settings) button.  U1 : U1 is the wireless module, it includes automatic power on reset circuit.  D1 : The LED works in two mode:  Sleeping  is indicated by flashing slowly and  Connected  status indicated by continuous illumination.  J1 : The standard Grove connector.   Caution \nBLE transmission speed is slower than SPP transmission, so we selected the lower one in the design, in accordance with the speed of a BLE dual-mode product planning.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#hardware-installation", 
            "text": "", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#connecting-bluetooth-to-pc-through-uart-bee", 
            "text": "The Bluetooth provides a serial port with standard Grove socket, most USB-UART converter can be used. Here we use a  UartSBee V5  to connect Bluetooth and PC.", 
            "title": "Connecting Bluetooth to PC through UART Bee"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#connecting-bluetooth-to-arduino", 
            "text": "Since Arduino Uno have no Grove socket, we use  Seeeduino Lotus  instead. You could use Arduino with  Grove Base Shield V2  as well.\nAs an example, D2 and D3 are used as software UART. So, plug the Grove cable into  D2  socket", 
            "title": "Connecting Bluetooth to Arduino"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#software-instructions", 
            "text": "", 
            "title": "Software Instructions"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#conventions", 
            "text": "In EDR mode, only slave can be configured while either master or slave can be in BLE mode.  Factory default setting:  EDR Name HMSoft, Slave role, PinCode 1234  BLE Name HMSoft, Slave role, PinCode 000000  Baud: 115200, N, 8, 1;    AT Command format:  Uppercase AT command format. string format, without any other symbol. (e.g. \\r or \\n).  Any incorrect command would get no response.", 
            "title": "Conventions"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#at-commands", 
            "text": "1. Test Command     Send  Receive  Parameter      AT  OK/ER/Disconnect link  None     If module is not connected to remote device will receive: \u201cOK\u201d  If module has an error, will receive: \u201cER\u201d  If Module has connected, module will disconnected from remote device, if \u201cAT + NOTI\u201d is setup to 1, will receive information string  2. Query module EDR address     Send  Receive  Parameter      AT+ADDE?  OK+ Get: MAC  None     3. Query module BLE address     Send  Receive  Parameter      AT+ADDB?  OK+ Get: MAC  None     4. Query/Set Authentication mode    \nSend  \nReceive  \nParameter    \nQ: AT+AUTH?  \nOK+ Get:[P1]  \nP1: 0, 1, (Default: 0)\n0 \u2013 Not authentication\n1 \u2013 Must authentication    \nS: AT+AUTH[P1]  \nOK+ Set:[P1]    AT+AUTH0: allow made an insecure connection.\nAT+AUTH1: every connection must with authentication.  5. Query/Set A to B mode    \nSend  \nReceive  \nParameter    \nQ: AT+ATOB?  \nOK+ Get:[P1]  \nP1: 0, 1, (Default: 0)\n0 \u2013 Not Open ATOB\n1 \u2013 Open ATOB mode    \nS: AT+ATOB[P1]  \nOK+ Set:[P1]    This command must work with AT+MODE0 command. When A device (SPP mode) connect to the module and B device (BLE mode) is also connect to the module, The data string from A device send to the module will send to B device. The data string from B device send to the module is also send to the A device.  6. Query/Set baud rate    \nSend  \nReceive  \nParameter    \nQ: AT+BAUD?  \nOK+ Get:[P1]  \nP1: 1~7, (Default: 6).\n1 - 4800\n2 \u2013 9600\n3 \u2013 19200\n4 \u2013 38400\n5 \u2013 57600\n6 \u2013 115200\n7 - 230400    \nS: AT+BAUD[P1]  \nOK+ Set:[P1]    7. Clear bond information     Send  Receive  Parameter      AT+BONDE  OK+BONDE  Clear EDR bond info    AT+BONDB  OK+BONDB  Clear BLE bond info     BLE mode not supports it yet.  8. Clear Last Connected EDR Device Address     Send  Receive  Parameter      AT+CLEAE  OK+CLEAE  None     9. Clear Last Connected BLE Device Address     Send  Receive  Parameter      AT+CLEAB  OK+CLEAB  None     10. Query/Set Module DUAL Work Mode    \nSend  \nReceive  \nParameter    \nQ: AT+DUAL?  \nOK+ Get:[P1]  \nP1: 0, 1, (Default: 0)\n0 \u2013 Allow dual connect.\n1 \u2013 Allow one connect.    \nS: AT+DUAL[P1]  \nOK+ Set:[P1]    AT+DUAL0: allow two connections at same time (SPP and BLE).\nAT+DUAL1: Only allow one connection at same time (SPP or BLE)  11. Query/Set hardware flow control switch    \nSend  \nReceive  \nParameter    \nAT+FIOW?  \nOK+ Get:[P1]  \nP1: 0, 1,(Default: 0)\n0: Hardware flow control off\n1: Hardware flow control on    \nAT+FIOW[P1]  \nOK+ Set:[P1]    12. Query/Set module data transmission speed mode    \nSend  \nReceive  \nParameter    \nAT+HIGH?  \nOK+ Get:[P1]  \nP1: 0, 1,(Default: 0)\n0: Balance mode\n1: High speed mode    \nAT+HIGH[P1]  \nOK+ Set:[P1]    In balance mode, we balanced SPP and BLE with a steady speed.\nIn high speed mode, we don\u2019t control speed, so SPP mode will got high speed.\nIn high speed mode, module lost RESETB pin function, but you still could use\n\u201cAT+RESET\u201d command to reset module.  13. System Help Information     Send  Receive  Parameter      AT+HELP?  Help Information  None     14. Query/Set module loaded notify    \nSend  \nReceive  \nParameter    \nAT+INIT?  \nOK+ Get:[P1]  \nP1: 0, 1,?, (Default: 0)\n0: Loaded notify 0ff\n1: Loaded notify on    \nAT+INIT[P1]  \nOK+ Set:[P1]    When \u201cAT+INIT1\u201d is setup, after module loaded, module will output \u201cOK+INIT\u201d string through UART.  15. Query/Set Module Work Mode    \nSend  \nReceive  \nParameter    \nQ: AT+MODE?  \nOK+ Get:[P1]  \nP1: 0, 1, (Default: 0)\n0 \u2013 Data transmission.\n1 \u2013 Remote control.    \nS: AT+MODE[P1]  \nOK+ Set:[ P1]    AT+MODE0: Only transfer data when connection establishment.\nAT+MODE1: Transfer data and response AT commands.  16. Query/Set Notify information    \nSend  \nReceive  \nParameter    \nQ: AT+NOTI?  \nOK+ Get:[P1]  \nP1: 0, 1, (Default: 0)\n0: Don\u2019t Notify\n1: Notify    \nS: AT+NOTI[P1]  \nOK+ Set:[ P1]    After AT+NOTI1, module will send connect or disconnect string through\nUART when module state is changed:  OK+CONE ======== EDR connect  OK+LSTE ========= EDR disconnect  OK+CONB========= BLE connect  OK+LSTB ========= BLE disconnect  OK+LSTA ========= except disconnect, module will reset after 500 ms.  17. Query/Set notify mode    \nSend  \nReceive  \nParameter    \nQ: AT+NOTP?  \nOK+ Get:[P1]  \nP1: 0, 1; default: 0\n0: without address\n1: with address    \nQ: AT+NOTP[P1]  \nOK+ Set:[ P1]    This command must work with \u201cAT+NOTI1\u201d, if this switch is open, when the module connect to disconnect, the prompt string will include the remote address.  18. Query/Set Module EDR name    \nSend  \nReceive  \nParameter    \nQ: AT+NAME?  \nOK+ Get:[P1]  \nP1: module EDR name,\nMax length is 12.\nDefault: HMSoft    \nQ: AT+NAME[P1]  \nOK+ Set:[ P1]    19. Query/Set Module BLE name    \nSend  \nReceive  \nParameter    \nQ: AT+NAMB?  \nOK+ Get:[P1]  \nP1: module BLE name,\nMax length is 12.\nDefault: HMSoft    \nS: AT+NAMB[P1]  \nOK+ Set:[ P1]    20. Query/Set PIO1 output status (System LED)e    \nSend  \nReceive  \nParameter    \nQ: AT+PIO1?  \nOK+ Get:[P1]  \nP1: 0, 1\n0: Unconnected Output 500ms High 500ms Low, Connected output High.\n1: Unconnected output Low, Connected output High.\nDefault: 0    \nS: AT+ PIO1 [P1]  \nOK+ Set:[ P1]    21. Query/Set PIO output status    \nSend  \nReceive  \nParameter    \nQ: AT+PIO[P1]?  \nOK+ Get:[P1][P2]  \nP1: 2~B (HM-12)\nP2: 2~3 (HM-13)\n0: Output Low\n1: Output High\n?: Query    \nS: AT+ PIO[P1][P2]  \nOK+ Set:[P1][P2]    22. Query/Set EDR Pin Code    \nSend  \nReceive  \nParameter    \nQ: AT+PINE?  \nOK+ Get:[P1]  \nP1: module EDR Code\nMax length: 6\nDefault: 1234    \nS: AT+PINE[P1]  \nOK+ Set:[P1]    23. Query/Set BLE Pin Code    \nSend  \nReceive  \nParameter    \nQ: AT+PINB?  \nOK+ Get:[P1]  \nP1: module BLE Code\n000000~999999\nDefault: 000000    \nS: AT+PINB[P1]  \nOK+ Set:[P1]    24. Query/Set UART parity bit    \nSend  \nReceive  \nParameter    \nQ: AT+PARI?  \nOK+ Get:[P1]  \nP1: 0, 1, 2, (Default: 0)\n0: Parity None\n1: Parity even\n2: Parity odd    \nS: AT+PARI[P1]  \nOK+ Set:[P1]    25. Restore all setup value to factory setup     Send  Receive  Parameter      AT+RENEW  OK+RENEW  None     26. Restart module     Send  Receive  Parameter      AT+RESET  OK+RESET  None     27. Query BLE RSSI value          Send  Receive  Parameter      AT+RSSB?  OK+RSSB: [P1]  P1: RSSI value  9999: No connection \n9998: Try later \n9997: Read error \nXxxx: RSSI value     This command must use after \u201cAT+MODE1\u201d is setup. This command is only used by remote Bluetooth device.   28. Query EDR RSSI value          Send  Receive  Parameter      AT+RSSE?  OK+RSSE: [P1]  P1: RSSI value  9999: No connection \n9998: Try later \n9997: Read error \nXxxx: RSSI value     29. Query Last Connected EDR Device Address     Send  Receive  Parameter      AT+RADE?  OK+Get:MAC Address  None     30. Query Last Connected BLE Device Address     Send  Receive  Parameter      AT+RADB?  OK+Get:MAC Address  None     31. Query/Set Master and Slaver Role    \nSend  \nReceive  \nParameter    \nAT+ROLB?  \nOK+ Get:[P1]  \nP1: 0, 1 (default: 0)\n0: Peripheral\n1: Central    \nAT+ROLB[P1]  \nOK+ Set:[P1]    This command will take effect after module next power on or reset.   32. Query/Set EDR work mode    \nSend  \nReceive  \nParameter    \nQ: AT+SCAN?  \nOK+ Get:[P1]  \nP1: 0, 1, (Default: 0)\n0: Discovery and connectable\n1: Only connectable    \nS: AT+SCAN[P1]  \nOK+ Set:[P1]    33. Query/Set UART stop bit    \nSend  \nReceive  \nParameter    \nQ: AT+STOP?  \nOK+ Get:[P1]  \nP1: 0, 1, (Default: 0)\n0: 1 stop bit\n1: 2 stop bits    \nS: AT+STOP[P1]  \nOK+ Set:[P1]    34. Query Software Version          Send  Receive  Parameter      AT+VERR?  AT+VERS?  Version Information  None", 
            "title": "AT Commands"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#programming", 
            "text": "", 
            "title": "Programming"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#configure-the-bluetooth-module-with-serial-under-windows", 
            "text": "This section shows how to configure Bluetooth with PC, some basic methods of setting could be learn. Set up hardware connection refer to \u201cHardware Installation\u201d section. You will find the blue LED on the module flashes illustrate no connection is set up.  Open a serial terminal and set Baud Rate:115200, Databits: 8, Stopbits: 1 and No Flow Control. Send \u201cAT\u201d to Bluetooth with the serial terminal and \u201cOK\u201d will be return if all goes well. The Bluetooth only respond AT commands when no connection was set up, or all commands were seen as string and sent out. You can distinguish the status through LED indicates.   Then some useful configurations could be sent. Here are some samples of commands and responses.    Test serial connection, send \u201cAT\u201d, will return \u201cOK\u201d.    Restore factory settings, send \u201cAT+RENEW\u201d, return \u201cOK+RENEW\u201d.    Reset baud rate of serial port, send \u201cAT+BAUD2\u201d, return \u201cOK+Set:2\u201d.    Enable authentication, send \u201cAT+AUTH1\u201d, return \u201cOK+Set:1\u201d.    Reset the Bluetooth, send \u201cAT+RESET\u201d, return \u201dOK+RESET\u201d.    Query firmware version, send \u201cAT+VERS?\u201d, return \u201cOK+Get:HMSoftV217\u201d.    Query MAC of EDR, send \u201cAT+ADDE?\u201d, return \u201cOK+Get:000E0E002074\u201d.    Query MAC of BLE, send \u201cAT+ADDB?\u201d, return \u201cOK+Get:000E0B002074\u201d.    Set the name of EDR, send \u201cAT+NAMEHM-13-EDR\u201d, return \u201cOK+Set:HM-13-EDR\u201d.    Set the name of BLE, send \u201cAT+NAMEHM-13-BLE\u201d, return \u201cOK+Set:HM-13-BLE\u201d.    Set the password of EDR, send \u201cAT+PINE123451\u201d, return \u201cOK+Set:123451\u201d.    Set the password of BLE, send \u201cAT+PINB123451\u201d, return \u201cOK+Set:123451\u201d.    Enable discovery and connectable, send \u201cAT+SCAN0\u201d, return \u201cOK+Set:0\u201d.    Enable notify information of connection, send \u201cAT+NOTI1\u201d, return \u201cOK+Set:1\u201d.    Notify information include address, send \u201cAT+NOTP1\u201d, return \u201cOK+Set:1\u201d.    Enable user key, send \u201cAT+PIO01\u201d, return \u201cOK+Set:1\u201d.    Set to Central mode, send \u201cAT+ROLB1\u201d, return \u201cAT+ROLB1\u201d.    Or Set to Peripheral mode, send \u201cAT+ROLB0\u201d, return \u201cAT+ROLB0\u201d.  We use two Bluetooth connected with PC, one was set as Central while the other is Peripheral. Several seconds later they find each other and the LED stop flash, connected!", 
            "title": "Configure the Bluetooth module with Serial under Windows"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#communicate-with-iphone", 
            "text": "This kind of Bluetooth module has two protocol: Bluetooth EDR(Enhanced Data Rate) and Bluetooth Low Energy. It can communicate with any device that has one of these protocols. Some Android phone with OS higher than 4.3 and iPhone4 or later have BLE ability. We use a iPhone to demonstrate how to use a cellphone to interact with Bluetooth.  Power the Bluetooth and configure it as Peripheral role. Search LightBlue in Apple Store and install it. Launch the app, you may find \u201cHM-13-BLE\u201d which we just renamed. Touch it to connect, then touch \u201cProperties\u201d to control it. The key \u201cHex\u201d on the top right is for change data format, maybe String is easy to see. Hit \u201cListen for notifications\u201d to enable data receiving. Then we can send data to PC through BLE, hit \u201cWrite new value\u201d and write some words. Also PC can transfer data to iPhone with serial terminal.", 
            "title": "Communicate with iPhone"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#data-transmission-between-two-arduinos", 
            "text": "Are you ready to code? It\u2019s time to do something after practice. Prepare a pair of Bluetooth, and Arduino or other platform to control them. Here we use two Arduino Uno. Set up the connection as mentioned in section \u201cHardware Installation\u201d.  The program of Central and Peripheral use the same code, the only difference is the micro define at the beginning of the program. To assign the Bluetooth to Central role, Just need to modify the text to \u201c#define MASTER 1\u201d, or \u201c#define MASTER 1\u201d if Peripheral role was assigned.  The initialisation program flow please refer to the following flow chart. First of all we need to distinguish the presetting baud rate of the Bluetooth. After this, send commands to restore factory settings, and change baud rate from 115200 to 9600 since software serial will not working well at high baud rate. Then other parameters were configured to the Bluetooth with Reset command in the final.   After the initialisation, the Central and Peripheral will do different things, the Central will send message to Peripheral interval and print what received from Peripheral while the Peripheral only responds the Central.  Click  here  to download the test code and open HM-13_SW.ino with Arduino IDE, compile and download to Arduino Uno. Remember to configure the Bluetooth to different role by modify the macro at the beginning. If you have any problem about how to start Arduino, please click  here  for some help.  After downloading program, open two serial terminal windows, the LEDs on Bluetooth will flash, several seconds later, they stop to flash and keep on, this indicates that they connected to each other. \nAccording to the program is written, the Central sends message to the Peripheral continually and get feedback every time.", 
            "title": "Data transmission between Two Arduinos"
        }, 
        {
            "location": "/Grove-BLE-dual_model-v1.0/#resources", 
            "text": "HM-13 Bluetooth Module Datasheet  Arduino code  EAGLE_Grove-BLE_(dual_model)_v1.0_sch_pcb  PDF_Grove-BLE_(dual_model)_v1.0_sch", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-GPS/", 
            "text": "This Grove - GPS module is a cost-efficient and field-programmable gadget armed with a SIM28 (u-blox 6 is the old version) and serial communication configuration. It features 22 tracking / 66 acquisition channel GPS receiver. The sensitivity of tracking and acquisition both reach up to -160dBm, making it a great choice for personal navigation projects and location services, as well as an outstanding one among products of the same price class.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nSupports NMEA and u-blox 6 protocols. ( Till Jan,10 2014, after that SIM28 instead)\n\n\nLow power consumption\n\n\nBaud rates configurable\n\n\nGrove compatible interface\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nParameter\n\n\nRange/Value\n\n\n\n\n\n\n\n\n\n\nInput Voltage\n\n\n3.3/5V\n\n\n\n\n\n\nBaudRate\n\n\n4800 - 57600(u-blox version)\n\n\n\n\n\n\nBaudRate\n\n\n9600 - 115200(SIM28 version)\n\n\n\n\n\n\nDefault BaudRate\n\n\n9600\n\n\n\n\n\n\n\n\nPlatforms Supported\n\uf0c1\n\n\n\n\n\n\n\n\nArduino\n\n\nRaspberry Pi\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGetting Started\n\uf0c1\n\n\nFollowing documents help in getting the user started with Grove.\n\n\n\n\nto Grove system\n\n\n\n\nDemos\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nThis sample simply reads from the GPS using software serial and sends it back out on the serial port.\n\n\n\n\n\n\nConnect the Grove-GPS to Digital I/O 2 on the \nGrove - Base Shield\n using a Grove Universal 4 pin cable.\n\n\n\n\n\n\nUpload the code below. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n\n// link between the computer and the SoftSerial Shield\n//at 9600 bps 8-N-1\n//Computer is connected to Hardware UART\n//SoftSerial Shield is connected to the Software UART:D2\nD3\n\u00a0\n#include \nSoftwareSerial.h\n\n\u00a0\nSoftwareSerial SoftSerial(2, 3);\nunsigned char buffer[64];                   // buffer array for data receive over serial port\nint count=0;                                // counter for buffer array\n\u00a0\nvoid setup()\n{\n    SoftSerial.begin(9600);                 // the SoftSerial baud rate\n    Serial.begin(9600);                     // the Serial port of Arduino baud rate.\n}\n\u00a0\nvoid loop()\n{\n    if (SoftSerial.available())                     // if date is coming from software serial port ==\n data is coming from SoftSerial shield\n    {\n        while(SoftSerial.available())               // reading data into char array\n        {\n            buffer[count++]=SoftSerial.read();      // writing data into array\n            if(count == 64)break;\n        }\n        Serial.write(buffer,count);                 // if no data transmission ends, write buffer to hardware serial port\n        clearBufferArray();                         // call clearBufferArray function to clear the stored data from the array\n        count = 0;                                  // set counter of while loop to zero\n\u00a0\n\u00a0\n    }\n    if (Serial.available())                 // if data is available on hardware serial port ==\n data is coming from PC or notebook\n    SoftSerial.write(Serial.read());        // write it to the SoftSerial shield\n}\n\u00a0\nvoid clearBufferArray()                     // function to clear buffer array\n{\n    for (int i=0; i\ncount;i++)\n    { buffer[i]=NULL;}                      // clear all index of array with command NULL\n}\n\n\n\n\n\n\n\n\nInstall \nu-center\n. Upload the code below to your Arduino/Seeeduino and then open u-center.\n\n\n\n\nClick Receiver -\n Port and select the COM port that the Arduino is using.\n\n\nClick Receiver -\n Baudrate and make sure 9600 is selected.\n\n\nClick View -\n Text Console and you should get a window that will stream NMEA data.\n\n\nOpen the serial monitor,You can see as show below:\n\n\n\n\n\n\n\n\n\n\nTo View data in Google Earth:\n\n\n\n\nClick File -\n Database Export -\n Google Earth KML\n\n\nThis should launch Google Earth with the history that was captured by u-center.\n\n\nAlternatively, data can be recorded by pressing the red circle on the toolbar which will then ask you where you want to save the record.\n\n\nWhen you have captured enough data, click the black square to stop recording.\n\n\nYou can then convert the .ubx file generated to KML by using uploading the ubx file to \nGPSVisualizer\n.\n\n\n\n\n\n\n\n\nWith \nRaspberry Pi\n\uf0c1\n\n\n1.You need a Raspberry Pi and a GrovePi or GrovePi+.\n\n\n2.You should have completed configuring the development environment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug Grove GPS into grovepi socket RPISER.\n\n\n\n\n4.Navigate to the demos\n directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_gps.py   # \nCtrl+x\n to exit #\n\n\n\n\nimport serial, time\nimport smbus\nimport math\nimport RPi.GPIO as GPIO\nimport struct\nimport sys\n\u00a0\nser = serial.Serial('/dev/ttyAMA0',  9600, timeout = 0)   #Open the serial port at 9600 baud\nser.flush()\n\u00a0\nclass GPS:\n    #The GPS module used is a Grove GPS module http://www.seeedstudio.com/depot/Grove-GPS-p-959.html\n    inp=[]\n    # Refer to SIM28 NMEA spec file http://www.seeedstudio.com/wiki/images/a/a0/SIM28_DATA_File.zip\n    GGA=[]\n\u00a0\n    #Read data from the GPS\n    def read(self): \n        while True:\n            GPS.inp=ser.readline()\n            if GPS.inp[:6] =='$GPGGA': # GGA data , packet 1, has all the data we need\n                break\n            time.sleep(0.1)\n        try:\n            ind=GPS.inp.index('$GPGGA',5,len(GPS.inp)) #Sometimes multiple GPS data packets come into the stream. Take the data only after the last '$GPGGA' is seen\n            GPS.inp=GPS.inp[ind:]\n        except ValueError:\n            print \n\n        GPS.GGA=GPS.inp.split(\n,\n)   #Split the stream into individual parts\n        return [GPS.GGA]\n\u00a0\n    #Split the data into individual elements\n    def vals(self):\n        time=GPS.GGA[1]\n        lat=GPS.GGA[2]\n        lat_ns=GPS.GGA[3]\n        long=GPS.GGA[4]\n        long_ew=GPS.GGA[5]\n        fix=GPS.GGA[6]\n        sats=GPS.GGA[7]\n        alt=GPS.GGA[9]\n        return [time,fix,sats,alt,lat,lat_ns,long,long_ew]\n\u00a0\ng=GPS()\nf=open(\ngps_data.csv\n,'w')   #Open file to log the data\nf.write(\nname,latitude,longitude\\n\n)   #Write the header to the top of the file\nind=0\nwhile True:\n    try:\n        x=g.read()  #Read from GPS\n        [t,fix,sats,alt,lat,lat_ns,long,long_ew]=g.vals() #Get the individial values\n        print \nTime:\n,t,\nFix status:\n,fix,\nSats in view:\n,sats,\nAltitude\n,alt,\nLat:\n,lat,lat_ns,\nLong:\n,long,long_ew\n        s=str(t)+\n,\n+str(float(lat)/100)+\n,\n+str(float(long)/100)+\n\\n\n   \n        f.write(s)   #Save to file\n        time.sleep(2)\n    except IndexError:\n        print \nUnable to read\n\n    except KeyboardInterrupt:\n        f.close()\n        print \nExiting\n\n        sys.exit(0)\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_gps.py\n\n\n\n\n6.Result\n\n\n\n\n\n\nNote\n\nGPS is better used outdoors. It is recommended to put your raspberry pi outside the window or any place outdoors.\n\n\n\n\nSIM28 module Note:\n\uf0c1\n\n\n\n\nGPS Bee has change the module as SIM28 which the same footprint as origin version.\n\n\nYou should use \nSIMCom GPS DEMO\n tools to receive SIM28 module data.\n\n\n\n\nOpen SIMCom_GPS_DEMO tools, go to Module-\nproperties-\nmodule-\nselect SIM28.\n\n\n\n\n\n\n\n\nOpen SIMCom_GPS_DEMO tools, go to Module-\nconnect. Select the serial port which the GPS module used.\n\n\n\n\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGPS Eagle File\n\n\nGPS Schematic(PDF)\n\n\nE-1612-UB Datasheet\n\n\nU-Blox6 Receiver Description Protocol Spec\n\n\nU-Blox u-center GPS evaluation software\n\n\nSIM28_DATA_File\n\n\nSIMCom_GPS_DEMO_V1.07", 
            "title": "Grove - GPS"
        }, 
        {
            "location": "/Grove-GPS/#features", 
            "text": "Supports NMEA and u-blox 6 protocols. ( Till Jan,10 2014, after that SIM28 instead)  Low power consumption  Baud rates configurable  Grove compatible interface", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-GPS/#specifications", 
            "text": "Parameter  Range/Value      Input Voltage  3.3/5V    BaudRate  4800 - 57600(u-blox version)    BaudRate  9600 - 115200(SIM28 version)    Default BaudRate  9600", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-GPS/#platforms-supported", 
            "text": "Arduino  Raspberry Pi", 
            "title": "Platforms Supported"
        }, 
        {
            "location": "/Grove-GPS/#getting-started", 
            "text": "Following documents help in getting the user started with Grove.   to Grove system", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-GPS/#demos", 
            "text": "", 
            "title": "Demos"
        }, 
        {
            "location": "/Grove-GPS/#with-arduino", 
            "text": "This sample simply reads from the GPS using software serial and sends it back out on the serial port.    Connect the Grove-GPS to Digital I/O 2 on the  Grove - Base Shield  using a Grove Universal 4 pin cable.    Upload the code below. Please click  here  if you do not know how to upload.    // link between the computer and the SoftSerial Shield\n//at 9600 bps 8-N-1\n//Computer is connected to Hardware UART\n//SoftSerial Shield is connected to the Software UART:D2 D3\n\u00a0\n#include  SoftwareSerial.h \n\u00a0\nSoftwareSerial SoftSerial(2, 3);\nunsigned char buffer[64];                   // buffer array for data receive over serial port\nint count=0;                                // counter for buffer array\n\u00a0\nvoid setup()\n{\n    SoftSerial.begin(9600);                 // the SoftSerial baud rate\n    Serial.begin(9600);                     // the Serial port of Arduino baud rate.\n}\n\u00a0\nvoid loop()\n{\n    if (SoftSerial.available())                     // if date is coming from software serial port ==  data is coming from SoftSerial shield\n    {\n        while(SoftSerial.available())               // reading data into char array\n        {\n            buffer[count++]=SoftSerial.read();      // writing data into array\n            if(count == 64)break;\n        }\n        Serial.write(buffer,count);                 // if no data transmission ends, write buffer to hardware serial port\n        clearBufferArray();                         // call clearBufferArray function to clear the stored data from the array\n        count = 0;                                  // set counter of while loop to zero\n\u00a0\n\u00a0\n    }\n    if (Serial.available())                 // if data is available on hardware serial port ==  data is coming from PC or notebook\n    SoftSerial.write(Serial.read());        // write it to the SoftSerial shield\n}\n\u00a0\nvoid clearBufferArray()                     // function to clear buffer array\n{\n    for (int i=0; i count;i++)\n    { buffer[i]=NULL;}                      // clear all index of array with command NULL\n}    Install  u-center . Upload the code below to your Arduino/Seeeduino and then open u-center.   Click Receiver -  Port and select the COM port that the Arduino is using.  Click Receiver -  Baudrate and make sure 9600 is selected.  Click View -  Text Console and you should get a window that will stream NMEA data.  Open the serial monitor,You can see as show below:      To View data in Google Earth:   Click File -  Database Export -  Google Earth KML  This should launch Google Earth with the history that was captured by u-center.  Alternatively, data can be recorded by pressing the red circle on the toolbar which will then ask you where you want to save the record.  When you have captured enough data, click the black square to stop recording.  You can then convert the .ubx file generated to KML by using uploading the ubx file to  GPSVisualizer .", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-GPS/#with-raspberry-pi", 
            "text": "1.You need a Raspberry Pi and a GrovePi or GrovePi+.  2.You should have completed configuring the development environment, otherwise follow  here .  3.Connection   Plug Grove GPS into grovepi socket RPISER.   4.Navigate to the demos  directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_gps.py   #  Ctrl+x  to exit #  import serial, time\nimport smbus\nimport math\nimport RPi.GPIO as GPIO\nimport struct\nimport sys\n\u00a0\nser = serial.Serial('/dev/ttyAMA0',  9600, timeout = 0)   #Open the serial port at 9600 baud\nser.flush()\n\u00a0\nclass GPS:\n    #The GPS module used is a Grove GPS module http://www.seeedstudio.com/depot/Grove-GPS-p-959.html\n    inp=[]\n    # Refer to SIM28 NMEA spec file http://www.seeedstudio.com/wiki/images/a/a0/SIM28_DATA_File.zip\n    GGA=[]\n\u00a0\n    #Read data from the GPS\n    def read(self): \n        while True:\n            GPS.inp=ser.readline()\n            if GPS.inp[:6] =='$GPGGA': # GGA data , packet 1, has all the data we need\n                break\n            time.sleep(0.1)\n        try:\n            ind=GPS.inp.index('$GPGGA',5,len(GPS.inp)) #Sometimes multiple GPS data packets come into the stream. Take the data only after the last '$GPGGA' is seen\n            GPS.inp=GPS.inp[ind:]\n        except ValueError:\n            print  \n        GPS.GGA=GPS.inp.split( , )   #Split the stream into individual parts\n        return [GPS.GGA]\n\u00a0\n    #Split the data into individual elements\n    def vals(self):\n        time=GPS.GGA[1]\n        lat=GPS.GGA[2]\n        lat_ns=GPS.GGA[3]\n        long=GPS.GGA[4]\n        long_ew=GPS.GGA[5]\n        fix=GPS.GGA[6]\n        sats=GPS.GGA[7]\n        alt=GPS.GGA[9]\n        return [time,fix,sats,alt,lat,lat_ns,long,long_ew]\n\u00a0\ng=GPS()\nf=open( gps_data.csv ,'w')   #Open file to log the data\nf.write( name,latitude,longitude\\n )   #Write the header to the top of the file\nind=0\nwhile True:\n    try:\n        x=g.read()  #Read from GPS\n        [t,fix,sats,alt,lat,lat_ns,long,long_ew]=g.vals() #Get the individial values\n        print  Time: ,t, Fix status: ,fix, Sats in view: ,sats, Altitude ,alt, Lat: ,lat,lat_ns, Long: ,long,long_ew\n        s=str(t)+ , +str(float(lat)/100)+ , +str(float(long)/100)+ \\n    \n        f.write(s)   #Save to file\n        time.sleep(2)\n    except IndexError:\n        print  Unable to read \n    except KeyboardInterrupt:\n        f.close()\n        print  Exiting \n        sys.exit(0)  5.Run the demo.      sudo python grove_gps.py  6.Result    Note \nGPS is better used outdoors. It is recommended to put your raspberry pi outside the window or any place outdoors.", 
            "title": "With Raspberry Pi"
        }, 
        {
            "location": "/Grove-GPS/#sim28-module-note", 
            "text": "GPS Bee has change the module as SIM28 which the same footprint as origin version.  You should use  SIMCom GPS DEMO  tools to receive SIM28 module data.   Open SIMCom_GPS_DEMO tools, go to Module- properties- module- select SIM28.     Open SIMCom_GPS_DEMO tools, go to Module- connect. Select the serial port which the GPS module used.", 
            "title": "SIM28 module Note:"
        }, 
        {
            "location": "/Grove-GPS/#resources", 
            "text": "GPS Eagle File  GPS Schematic(PDF)  E-1612-UB Datasheet  U-Blox6 Receiver Description Protocol Spec  U-Blox u-center GPS evaluation software  SIM28_DATA_File  SIMCom_GPS_DEMO_V1.07", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-I2C_ADC/", 
            "text": "Grove - I2C ADC is a 12-bit precision ADC module based on ADC121C021. It helps you increase the accuracy of value collected from analog sensor by providing a constant reference voltage. Because its address is changeable, you can use up to 9 I2C ADC at the same time at most. At the other hand, this module provides auto sleep function which lowers the power consumption considerably.\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nLow power consumption\n\n\nHigh precision\n\n\nAutomatic power-down mode\n\n\nAddress changeable\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n5.0\n\n\nVDC\n\n\n\n\n\n\nResolution\n\n\n12\n\n\nBit\n\n\n\n\n\n\nSample Rate\n\n\n188.9\n\n\nksps\n\n\n\n\n\n\nDimension\n\n\n40X20\n\n\nmm\n\n\n\n\n\n\n\n\nHardware Overview\n\uf0c1\n\n\n\n\nJ1:\n used to connect Arduino IIC Interface as Grove - I2C ADC output interface.\n\n\nJ2:\n used to connect analog sensor as Grove - I2C ADC input interface.\n\n\nU1:\n ADC121C021 IC,12-Bit Analog-to-Digital Converter\n\n\nThe black line area is used to set the IIC address. ADDR0 and ADDR1 are shipped connected to L. You can change them to \nH\n or floating by a little modification on the board(floating is neither connecting \nH\n nor connecting \nL\n). Find details in the Reference.\n\n\nGetting Started\n\uf0c1\n\n\nWith \nArduino\n\uf0c1\n\n\nGrove - I2C ADC has two interfaces: input socket(J2) and output socket(J1). Connect an analog sensor to its input socket and connect the I2C ADC to Arduino/Seeeduino also via Grove cables.\n\n\nTake Grove - Gas Sensor as an example, and now we learn how to read sensor data using Grove - I2C ADC.\nThe hardware installation should be like this:\n\n\n\n\nNow you can read the gas sensor value using the code below.\n\n\n#include \nWire.h\n\n\u00a0\n#define ADDR_ADC121             0x55\n\u00a0\n#define V_REF 3.00\n\u00a0\n#define REG_ADDR_RESULT         0x00\n#define REG_ADDR_ALERT          0x01\n#define REG_ADDR_CONFIG         0x02\n#define REG_ADDR_LIMITL         0x03\n#define REG_ADDR_LIMITH         0x04\n#define REG_ADDR_HYST           0x05\n#define REG_ADDR_CONVL          0x06\n#define REG_ADDR_CONVH          0x07\n\u00a0\nunsigned int getData;\nfloat analogVal=0;         // convert\nvoid init_adc()\n{\n  Wire.beginTransmission(ADDR_ADC121);        // transmit to device\n  Wire.write(REG_ADDR_CONFIG);                // Configuration Register\n  Wire.write(0x20);\n  Wire.endTransmission();  \n}\n\u00a0\nvoid read_adc()     //unsigned int *data\n{\n\u00a0\n\u00a0\n    Wire.beginTransmission(ADDR_ADC121);        // transmit to device\n    Wire.write(REG_ADDR_RESULT);                // get result\n    Wire.endTransmission();\n\u00a0\n    Wire.requestFrom(ADDR_ADC121, 2);           // request 2byte from device\n    delay(1);\n    if(Wire.available()\n=2)\n    {\n      getData = (Wire.read()\n0x0f)\n8;\n      getData |= Wire.read();\n    }\n    Serial.print(\ngetData:\n);\n    Serial.println(getData);\n    delay(5);\n    Serial.print(\nThe analog value is:\n);\n    Serial.print(getData*V_REF*2/4096); \n    Serial.println(\nV\n);\n}\nvoid setup()\n{\n  Serial.begin(9600);\n  Wire.begin();\n  init_adc();\n}\n\u00a0\nvoid loop()\n{  read_adc();//adcRead);\n   delay(50);\n}\n\n\n\n\nIn the code above, we defined the Vref as 3.0V which is decided by the I2C ADC module. This reference voltage is more accurate than one generated by microcontroller. And you can make that more accurate by measuring the voltage between VA and GND and use that value to replace 3.00 in the code above.\n\n\nNow you can upload the code. Please click \nhere\n if you do not know how to upload.\n\n\nAfterwards, open the serial monitor and read the values:\n\n\n\n\n\n\nNote\n\nThe address of Grove - I2C ADC is changeable which means you can redefine its address. That requires some hardware modification on the board. If you are thinking about using more than one I2C ADCs at the same time, follow the instructions in the Reference part below to do so. The maximum number of I2C ADCs that can be used simultaneously is 9, but there are only 4 I2C sockets on \nGrove - Base Shield V1.3\n, so if you want to use more than 4 I2C ADC, take a \nGrove - I2C Hub\n to create more I2C sockets.\n\n\n\n\nWith Beaglebone Green\n\uf0c1\n\n\nTo begin editing programs that live on BBG, you can use the Cloud9 IDE.\nAs a simple exercise to become familiar with Cloud9 IDE, creating a simple application to blink one of the 4 user programmable LEDs on the BeagleBone is a good start.\n\n\nIf this is your first time to use Cloud9 IDE, please follow this \nlink\n.\n\n\nStep1:\n Set the Grove - UART socket as a Grove - GPIO Socket, just follow this \nlink\n.\n\n\nStep2:\n Click the \n+\n in the top-right to create a new file.\n\n\n\n\n\n\nStep3:\n Copy and paste the following code into the new tab\n\n\nfrom Adafruit_I2C import Adafruit_I2C\nimport time\n\u00a0\nADDR_ADC121 = 0x50\n\u00a0\nREG_ADDR_RESULT = 0x00\nREG_ADDR_ALERT = 0x01\nREG_ADDR_CONFIG = 0x02\nREG_ADDR_LIMITL = 0x03\nREG_ADDR_LIMITH = 0x04\nREG_ADDR_HYST = 0x05\nREG_ADDR_CONVL = 0x06\nREG_ADDR_CONVH = 0x07\n\u00a0\ni2c = Adafruit_I2C(ADDR_ADC121)           \n\u00a0\nclass I2cAdc:\n    def __init__(self):\n        i2c.write8(REG_ADDR_CONFIG, 0x20)\n\u00a0\n    def read_adc(self):\n        \nRead ADC data 0-4095.\n\n        data_list = i2c.readList(REG_ADDR_RESULT, 2)\n        #print 'data list', data_list\n        data = ((data_list[0] \n 0x0f) \n 8 | data_list[1]) \n 0xfff\n        return data\n\u00a0\nif __name__ == '__main__':\n    # Connect the Grove - I2C ADC to I2C Grove port of Beaglebone Green.\n    adc = I2cAdc()\n    while True:\n        print 'sensor value ', adc.read_adc()\n        time.sleep(.2)\n\n\n\n\nStep4:\n Save the file by clicking the disk icon and giving the file a name with the .py extension.\n\n\nStep5:\n Connect Grove I2C ADC to Grove I2C socket on BBG.\n\n\nStep6:\n Run the code. You\nll find that the terminal outputs AD value every 2 seconds.\n\n\nReference\n\uf0c1\n\n\nI2C Address Setting\n\uf0c1\n\n\nThe ADC I2C has a seven-bit hardware address which is decided by ADR0 and ADR1. ADR0 and ADR1 are connected to L inside the board as default. But you can change it. For example, use a knife to cut off the connection between L and ADR0(as the picture shown below), then you make the state of ADR0 into Floating(connected to nothing). And if you solder up ADR0 and H this time, then you make the value of ADR0 H.\n\n\n\n\nYou can find the relationship of hardware I2C address and the values of ADR0 and ADR1 in the following table.\n\n\n\n\n\n\n\nSlave Address[A6 - A0]\n\n\n\n\nADR0 and ADR1 inputs state\n\n\n\n\n\n\n\n\nADR1\n\n\n\n\nADR0\n\n\n\n\n\n\n\n\n1010000(0x50)\n\n\n\n\nFloating\n\n\n\n\nFloating\n\n\n\n\n\n\n\n\n1010001(0x51)\n\n\n\n\nFloating\n\n\n\n\nL\n\n\n\n\n\n\n\n\n1010010(0x52)\n\n\n\n\nFloating\n\n\n\n\nH\n\n\n\n\n\n\n\n\n1010100(0x54)\n\n\n\n\nL\n\n\n\n\nFloating\n\n\n\n\n\n\n\n\n1010101(default 0x55)\n\n\n\n\nL\n\n\n\n\nL\n\n\n\n\n\n\n\n\n1010110(0x56)\n\n\n\n\nL\n\n\n\n\nH\n\n\n\n\n\n\n\n\n1011000(0x58)\n\n\n\n\nH\n\n\n\n\nFloating\n\n\n\n\n\n\n\n\n1011001(0x59)\n\n\n\n\nH\n\n\n\n\nL\n\n\n\n\n\n\n\n\n1011010(0x5A)\n\n\n\n\nH\n\n\n\n\nH\n\n\n\n\n\n\n\n\nHow much does the I2C ADC increase the accuracy?\n\uf0c1\n\n\nHere is an experiment we make to give you a sense about how much the I2C ADC increase the accuracy of an analog sensor. First, let\ns check the values collected directly through analog port on Arduino/Seeeduino from an Grove - Gas Sensor(MQ5)\n\n\n\n\nWe upload the code below to get the data.\n\n\n    /*\n     * Grove - Gas Sensor(MQ5)  \n     *\n     * The Gas Sensor detect the related Gas density, \n     * Arduino get the result by analogread. the gas Density is \n     * 0~1, larger the output is, the denser the gas.\n     * Connect the Sensor to A0 in this demo;\n     * \n     *  By: http://www.seeedstudio.com\n    */\n    #define Vref 4.95\n    void setup() {\n      Serial.begin(9600);\n    }\n\n    void loop() {\n      float vol;\n      int sensorValue = analogRead(A0);\n      vol=(float)sensorValue/1023*Vref;\n      Serial.print(\nThe sensorValue is \n);\n      Serial.println(sensorValue);\n      Serial.print(\nThe analog value is \n);\n      Serial.print(vol);\n      Serial.println(\nV\n);\n      delay(100);\n    }\n\n\n\n\nThe result is:\n\n\n\n\nAs default, Vref is generated by Arduino which is theoretically 5V. But actually that is a value afloat which results the deviation of the final data. This kind of inaccuracy is avoided when using Grove - I2C ADC, because it provides a strict 3.0V as Vref.\nTo contrast, in the same condition, sensor values collected by the circuit with Grove - I2C ADC in the scope is shown below:\n\n\n\n\nIn order to find out which result is more close to the actual condition, here we use a multimeter to measure the voltage between the pin SIG and pin GND of the sensor.\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nI2C ADC Eagle File\n\n\nADC121C021 Datasheet", 
            "title": "Grove - I2C ADC"
        }, 
        {
            "location": "/Grove-I2C_ADC/#features", 
            "text": "Low power consumption  High precision  Automatic power-down mode  Address changeable", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-I2C_ADC/#specifications", 
            "text": "Item  Typical  Unit      Working Voltage  5.0  VDC    Resolution  12  Bit    Sample Rate  188.9  ksps    Dimension  40X20  mm", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-I2C_ADC/#hardware-overview", 
            "text": "J1:  used to connect Arduino IIC Interface as Grove - I2C ADC output interface.  J2:  used to connect analog sensor as Grove - I2C ADC input interface.  U1:  ADC121C021 IC,12-Bit Analog-to-Digital Converter  The black line area is used to set the IIC address. ADDR0 and ADDR1 are shipped connected to L. You can change them to  H  or floating by a little modification on the board(floating is neither connecting  H  nor connecting  L ). Find details in the Reference.", 
            "title": "Hardware Overview"
        }, 
        {
            "location": "/Grove-I2C_ADC/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/Grove-I2C_ADC/#with-arduino", 
            "text": "Grove - I2C ADC has two interfaces: input socket(J2) and output socket(J1). Connect an analog sensor to its input socket and connect the I2C ADC to Arduino/Seeeduino also via Grove cables.  Take Grove - Gas Sensor as an example, and now we learn how to read sensor data using Grove - I2C ADC.\nThe hardware installation should be like this:   Now you can read the gas sensor value using the code below.  #include  Wire.h \n\u00a0\n#define ADDR_ADC121             0x55\n\u00a0\n#define V_REF 3.00\n\u00a0\n#define REG_ADDR_RESULT         0x00\n#define REG_ADDR_ALERT          0x01\n#define REG_ADDR_CONFIG         0x02\n#define REG_ADDR_LIMITL         0x03\n#define REG_ADDR_LIMITH         0x04\n#define REG_ADDR_HYST           0x05\n#define REG_ADDR_CONVL          0x06\n#define REG_ADDR_CONVH          0x07\n\u00a0\nunsigned int getData;\nfloat analogVal=0;         // convert\nvoid init_adc()\n{\n  Wire.beginTransmission(ADDR_ADC121);        // transmit to device\n  Wire.write(REG_ADDR_CONFIG);                // Configuration Register\n  Wire.write(0x20);\n  Wire.endTransmission();  \n}\n\u00a0\nvoid read_adc()     //unsigned int *data\n{\n\u00a0\n\u00a0\n    Wire.beginTransmission(ADDR_ADC121);        // transmit to device\n    Wire.write(REG_ADDR_RESULT);                // get result\n    Wire.endTransmission();\n\u00a0\n    Wire.requestFrom(ADDR_ADC121, 2);           // request 2byte from device\n    delay(1);\n    if(Wire.available() =2)\n    {\n      getData = (Wire.read() 0x0f) 8;\n      getData |= Wire.read();\n    }\n    Serial.print( getData: );\n    Serial.println(getData);\n    delay(5);\n    Serial.print( The analog value is: );\n    Serial.print(getData*V_REF*2/4096); \n    Serial.println( V );\n}\nvoid setup()\n{\n  Serial.begin(9600);\n  Wire.begin();\n  init_adc();\n}\n\u00a0\nvoid loop()\n{  read_adc();//adcRead);\n   delay(50);\n}  In the code above, we defined the Vref as 3.0V which is decided by the I2C ADC module. This reference voltage is more accurate than one generated by microcontroller. And you can make that more accurate by measuring the voltage between VA and GND and use that value to replace 3.00 in the code above.  Now you can upload the code. Please click  here  if you do not know how to upload.  Afterwards, open the serial monitor and read the values:    Note \nThe address of Grove - I2C ADC is changeable which means you can redefine its address. That requires some hardware modification on the board. If you are thinking about using more than one I2C ADCs at the same time, follow the instructions in the Reference part below to do so. The maximum number of I2C ADCs that can be used simultaneously is 9, but there are only 4 I2C sockets on  Grove - Base Shield V1.3 , so if you want to use more than 4 I2C ADC, take a  Grove - I2C Hub  to create more I2C sockets.", 
            "title": "With Arduino"
        }, 
        {
            "location": "/Grove-I2C_ADC/#with-beaglebone-green", 
            "text": "To begin editing programs that live on BBG, you can use the Cloud9 IDE.\nAs a simple exercise to become familiar with Cloud9 IDE, creating a simple application to blink one of the 4 user programmable LEDs on the BeagleBone is a good start.  If this is your first time to use Cloud9 IDE, please follow this  link .  Step1:  Set the Grove - UART socket as a Grove - GPIO Socket, just follow this  link .  Step2:  Click the  +  in the top-right to create a new file.    Step3:  Copy and paste the following code into the new tab  from Adafruit_I2C import Adafruit_I2C\nimport time\n\u00a0\nADDR_ADC121 = 0x50\n\u00a0\nREG_ADDR_RESULT = 0x00\nREG_ADDR_ALERT = 0x01\nREG_ADDR_CONFIG = 0x02\nREG_ADDR_LIMITL = 0x03\nREG_ADDR_LIMITH = 0x04\nREG_ADDR_HYST = 0x05\nREG_ADDR_CONVL = 0x06\nREG_ADDR_CONVH = 0x07\n\u00a0\ni2c = Adafruit_I2C(ADDR_ADC121)           \n\u00a0\nclass I2cAdc:\n    def __init__(self):\n        i2c.write8(REG_ADDR_CONFIG, 0x20)\n\u00a0\n    def read_adc(self):\n         Read ADC data 0-4095. \n        data_list = i2c.readList(REG_ADDR_RESULT, 2)\n        #print 'data list', data_list\n        data = ((data_list[0]   0x0f)   8 | data_list[1])   0xfff\n        return data\n\u00a0\nif __name__ == '__main__':\n    # Connect the Grove - I2C ADC to I2C Grove port of Beaglebone Green.\n    adc = I2cAdc()\n    while True:\n        print 'sensor value ', adc.read_adc()\n        time.sleep(.2)  Step4:  Save the file by clicking the disk icon and giving the file a name with the .py extension.  Step5:  Connect Grove I2C ADC to Grove I2C socket on BBG.  Step6:  Run the code. You ll find that the terminal outputs AD value every 2 seconds.", 
            "title": "With Beaglebone Green"
        }, 
        {
            "location": "/Grove-I2C_ADC/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/Grove-I2C_ADC/#i2c-address-setting", 
            "text": "The ADC I2C has a seven-bit hardware address which is decided by ADR0 and ADR1. ADR0 and ADR1 are connected to L inside the board as default. But you can change it. For example, use a knife to cut off the connection between L and ADR0(as the picture shown below), then you make the state of ADR0 into Floating(connected to nothing). And if you solder up ADR0 and H this time, then you make the value of ADR0 H.   You can find the relationship of hardware I2C address and the values of ADR0 and ADR1 in the following table.    \nSlave Address[A6 - A0]  \nADR0 and ADR1 inputs state    \nADR1  \nADR0    \n1010000(0x50)  \nFloating  \nFloating    \n1010001(0x51)  \nFloating  \nL    \n1010010(0x52)  \nFloating  \nH    \n1010100(0x54)  \nL  \nFloating    \n1010101(default 0x55)  \nL  \nL    \n1010110(0x56)  \nL  \nH    \n1011000(0x58)  \nH  \nFloating    \n1011001(0x59)  \nH  \nL    \n1011010(0x5A)  \nH  \nH", 
            "title": "I2C Address Setting"
        }, 
        {
            "location": "/Grove-I2C_ADC/#how-much-does-the-i2c-adc-increase-the-accuracy", 
            "text": "Here is an experiment we make to give you a sense about how much the I2C ADC increase the accuracy of an analog sensor. First, let s check the values collected directly through analog port on Arduino/Seeeduino from an Grove - Gas Sensor(MQ5)   We upload the code below to get the data.      /*\n     * Grove - Gas Sensor(MQ5)  \n     *\n     * The Gas Sensor detect the related Gas density, \n     * Arduino get the result by analogread. the gas Density is \n     * 0~1, larger the output is, the denser the gas.\n     * Connect the Sensor to A0 in this demo;\n     * \n     *  By: http://www.seeedstudio.com\n    */\n    #define Vref 4.95\n    void setup() {\n      Serial.begin(9600);\n    }\n\n    void loop() {\n      float vol;\n      int sensorValue = analogRead(A0);\n      vol=(float)sensorValue/1023*Vref;\n      Serial.print( The sensorValue is  );\n      Serial.println(sensorValue);\n      Serial.print( The analog value is  );\n      Serial.print(vol);\n      Serial.println( V );\n      delay(100);\n    }  The result is:   As default, Vref is generated by Arduino which is theoretically 5V. But actually that is a value afloat which results the deviation of the final data. This kind of inaccuracy is avoided when using Grove - I2C ADC, because it provides a strict 3.0V as Vref.\nTo contrast, in the same condition, sensor values collected by the circuit with Grove - I2C ADC in the scope is shown below:   In order to find out which result is more close to the actual condition, here we use a multimeter to measure the voltage between the pin SIG and pin GND of the sensor.", 
            "title": "How much does the I2C ADC increase the accuracy?"
        }, 
        {
            "location": "/Grove-I2C_ADC/#resources", 
            "text": "I2C ADC Eagle File  ADC121C021 Datasheet", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-I2C_FM_Receiver/", 
            "text": "Grove - I2C FM Receiver is a wideband FM receiver module, this module is based on RDA5807M. The RDA5807M series is the newest generation single-chip broadcast FM stereo radio tuner with fully integrated synthesizer. The RDA5807M series has a powerful low-IF digital audio processor. The Grove - I2C FM Receiver has a headset jack, so it can connect to earphones or audio.\n\n\n\n\nVersion Tracker\n\uf0c1\n\n\n\n\n\n\n\n\nRevision\n\n\nDescription\n\n\nRelease date\n\n\n\n\n\n\n\n\n\n\nGrove - I2C FM Receiver v1.0\n\n\nInitial public release\n\n\n\n\n\n\n\n\nGrove - I2C FM Receiver v1.1\n\n\nFixed bug - DFM for J3\n\n\nDec 2, 2011\n\n\n\n\n\n\n\n\nFeatures\n\uf0c1\n\n\n\n\nGrove interface\n\n\nSupports worldwide frequency band: 50 - 115MHz\n\n\nSupport RDS/RBDS\n\n\nLower power consumption\n\n\nHeadset interface\n\n\nDigital auto gain control\n\n\nInput voltage: 3.3V - 5V\n\n\n\n\nUsage\n\uf0c1\n\n\nWe can change channel by Grove - Button and adjust volume by Grove - Rotary\n\n\nHardware Installation\n\uf0c1\n\n\nPart list\uff1a\n\n\n\n\nSeeeduino Lotus\n\n\nGrove - I2C FM Receiver\n\n\nGrove - Button\n\n\nGrove - Rotary\n\n\nEarphone\n\n\n\n\n\n\nSoftware Part\n\uf0c1\n\n\n\n\nDownload the code \nI2C FM Receiver\n.\n\n\nUnzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.\n\n\nOpen the code directly from the path: File -\n Example -\n I2C_FM_Receiver.\n\n\nUpload the code. Note that you should select the correct board type and COM port.\n\n\n\n\nYou can see Center Frequency:\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - I2C FM Receiver v1.0 Eagle File\n\n\nv1.0 Schematic in pdf\n\n\nDatasheet of RDA5807M\n\n\nGrove - I2C FM Receiver v1.1 Eagle File", 
            "title": "Grove - I2C FM Receiver"
        }, 
        {
            "location": "/Grove-I2C_FM_Receiver/#version-tracker", 
            "text": "Revision  Description  Release date      Grove - I2C FM Receiver v1.0  Initial public release     Grove - I2C FM Receiver v1.1  Fixed bug - DFM for J3  Dec 2, 2011", 
            "title": "Version Tracker"
        }, 
        {
            "location": "/Grove-I2C_FM_Receiver/#features", 
            "text": "Grove interface  Supports worldwide frequency band: 50 - 115MHz  Support RDS/RBDS  Lower power consumption  Headset interface  Digital auto gain control  Input voltage: 3.3V - 5V", 
            "title": "Features"
        }, 
        {
            "location": "/Grove-I2C_FM_Receiver/#usage", 
            "text": "We can change channel by Grove - Button and adjust volume by Grove - Rotary", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-I2C_FM_Receiver/#hardware-installation", 
            "text": "Part list\uff1a   Seeeduino Lotus  Grove - I2C FM Receiver  Grove - Button  Grove - Rotary  Earphone", 
            "title": "Hardware Installation"
        }, 
        {
            "location": "/Grove-I2C_FM_Receiver/#software-part", 
            "text": "Download the code  I2C FM Receiver .  Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.  Open the code directly from the path: File -  Example -  I2C_FM_Receiver.  Upload the code. Note that you should select the correct board type and COM port.   You can see Center Frequency:", 
            "title": "Software Part"
        }, 
        {
            "location": "/Grove-I2C_FM_Receiver/#resources", 
            "text": "Grove - I2C FM Receiver v1.0 Eagle File  v1.0 Schematic in pdf  Datasheet of RDA5807M  Grove - I2C FM Receiver v1.1 Eagle File", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-NFC/", 
            "text": "Near Field Communication (NFC) is a set of short-range wireless technologies. It is behind daily applications such as access control system and mobile payment system.\nGrove NFC features a highly integrated transceiver module PN532 which handles contactless communication at 13.56MHz. You can read and write a 13.56MHz tag with this module or implement point to point data exchange with two NFCs. Grove NFC is designed to use I2C or UART communication protocols, and UART is the default mode. In addition, we assign an independent PCB antenna which can easily stretch out of any enclosure you use, leaving more room for you to design the exterior of your project.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nWorking Voltage: 3.3V\n\n\nWorking Current:\n\n\nStatic Mode: 73mA\n\n\nWrite/Read Mode: 83mA\n\n\n\n\n\n\nSupport host interface: I2C, UART(default).\n\n\nServe for contactless communication at 13.56MHz.\n\n\nSupport ISO14443 Type A and Type B protocols.\n\n\nMax operating distance for detecting NFC tags is 28mm depending on current antenna size.\n\n\nSupport P2P communication.\n\n\nDimensions: 25.43mm x 20.35mm\n\n\n\n\nGet Started\n\uf0c1\n\n\n\n\nDownload \nPN532 library\n and put 4 folders(PN532, PN532_SPI, PN532_I2C and PN532_HSU) into Arduino\ns libraries.\n\n\nDownload \n[1]\n, put it into Arduino\ns library and rename it to NDEF.\n\n\nOpen Arduino IDE. If Arduino IDE is already opened, restart it.\n\n\nIn Arduino IDE, click menus: File -\n Example -\n NDEF -\n ReadTag\n\n\nWe used I2C interface in the libraries of NDEF, so please cut off the connection between P1 and UART via a little knife, and solder P1 and I2C together.\n\n\n\n\n\n\n\n\nCaution\n\nDebug for Grove - NFC v1.0\u00a0: There is a bug while using I2C communication, please use jumper wires to follow those connection\n\n\n\n\n\n\n\n\n\n\nArduino/Arduino Mega\n\n\nGrove - NFC\n\n\n\n\n\n\n\n\n\n\nSCL\n\n\nRX\n\n\n\n\n\n\nSDA\n\n\nTX\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\n\n\nYou can still use UART interface without cutting any connection, Seeeduino Mega(Arduino Mega) or Seeeduino lite(Arduino Leonardo) are preferred. Following is the modified program.\n\n\n#include \nPN532_HSU.h\n\n#include \nPN532.h\n\n#include \nNfcAdapter.h\n\n\u00a0\nPN532_HSU interface(Serial1);\nNfcAdapter nfc = NfcAdapter(interface);\n\u00a0\nvoid setup(void) {\n    Serial.begin(115200);\n    Serial.println(\nNDEF Reader\n);\n    nfc.begin();\n}\n\u00a0\nvoid loop(void) {\n    Serial.println(\n\\nScan a NFC tag\\n\n);\n    if (nfc.tagPresent())\n    {\n        NfcTag tag = nfc.read();\n        tag.print();\n    }\n    delay(5000);\n}\n\n\n\n\n\n\nNote\n\nIf using it with Seeeduino or Arduino UNO, the only way to get the return message is setting it to I\n2\nC interface bus. While using it with Mega or Leonardo, you can use UART interface bus. Ensure PN532 library and Don's NDEF libraries are downloaded for Arduino library. And you might test the example \nReadTag.ino\n under folder \nexample\n. Delete code Line 1 to Line 10 (line \n\\#else ......\n and the above lines to top).\n\n\n\n\nCut following connections:\n\n\n\n\nTP1 to UART\n\n\nTP2 to RX\n\n\nTP3 to TX\n\n\n\n\nSolder following connections:\n\n\n\n\nTP1 to I2C\n\n\nTP2 to SCL\n\n\nTP3 to SDA\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - NFC v1.0 EAGLE (schematic and board) files\n\n\nGrove - NFC v1.1 EAGLE (schematic and board) files\n\n\nPN532 Datasheet PDF", 
            "title": "Grove - NFC"
        }, 
        {
            "location": "/Grove-NFC/#specifications", 
            "text": "Working Voltage: 3.3V  Working Current:  Static Mode: 73mA  Write/Read Mode: 83mA    Support host interface: I2C, UART(default).  Serve for contactless communication at 13.56MHz.  Support ISO14443 Type A and Type B protocols.  Max operating distance for detecting NFC tags is 28mm depending on current antenna size.  Support P2P communication.  Dimensions: 25.43mm x 20.35mm", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-NFC/#get-started", 
            "text": "Download  PN532 library  and put 4 folders(PN532, PN532_SPI, PN532_I2C and PN532_HSU) into Arduino s libraries.  Download  [1] , put it into Arduino s library and rename it to NDEF.  Open Arduino IDE. If Arduino IDE is already opened, restart it.  In Arduino IDE, click menus: File -  Example -  NDEF -  ReadTag  We used I2C interface in the libraries of NDEF, so please cut off the connection between P1 and UART via a little knife, and solder P1 and I2C together.     Caution \nDebug for Grove - NFC v1.0\u00a0: There is a bug while using I2C communication, please use jumper wires to follow those connection     Arduino/Arduino Mega  Grove - NFC      SCL  RX    SDA  TX    GND  GND    5V  VCC     You can still use UART interface without cutting any connection, Seeeduino Mega(Arduino Mega) or Seeeduino lite(Arduino Leonardo) are preferred. Following is the modified program.  #include  PN532_HSU.h \n#include  PN532.h \n#include  NfcAdapter.h \n\u00a0\nPN532_HSU interface(Serial1);\nNfcAdapter nfc = NfcAdapter(interface);\n\u00a0\nvoid setup(void) {\n    Serial.begin(115200);\n    Serial.println( NDEF Reader );\n    nfc.begin();\n}\n\u00a0\nvoid loop(void) {\n    Serial.println( \\nScan a NFC tag\\n );\n    if (nfc.tagPresent())\n    {\n        NfcTag tag = nfc.read();\n        tag.print();\n    }\n    delay(5000);\n}   Note \nIf using it with Seeeduino or Arduino UNO, the only way to get the return message is setting it to I 2 C interface bus. While using it with Mega or Leonardo, you can use UART interface bus. Ensure PN532 library and Don's NDEF libraries are downloaded for Arduino library. And you might test the example  ReadTag.ino  under folder  example . Delete code Line 1 to Line 10 (line  \\#else ......  and the above lines to top).  Cut following connections:   TP1 to UART  TP2 to RX  TP3 to TX   Solder following connections:   TP1 to I2C  TP2 to SCL  TP3 to SDA", 
            "title": "Get Started"
        }, 
        {
            "location": "/Grove-NFC/#resources", 
            "text": "Grove - NFC v1.0 EAGLE (schematic and board) files  Grove - NFC v1.1 EAGLE (schematic and board) files  PN532 Datasheet PDF", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-NFC_Tag/", 
            "text": "Grove - NFC Tag is a highly integrated Near Field Communication Tag module,this module is I2C interface,which base on M24LR64E-R,M24LR64E-R have a 64-bit unique identifier and 64 -Kbit EEPROM.Grove - NFC Tag attach an independent PCB antenna which can easily stretch out of any enclosure you use, leaving more room for you to design the exterior of your project.\n\n\n\n\nSpecifications\n\uf0c1\n\n\n\n\nWorking Voltage:5V or 3V3\n\n\nWorking Current\n1mA\n\n\nEffective range\n2cm\n\n\nServe for contactless communication at 13.56MHz\n\n\nISO 15693 and ISO 18000-3 mode 1 compatible\n\n\n64-bit unique identifier (UID)\n\n\nRead Block \n Write (32-bit blocks)\n\n\nGrove I2C Interface\n\n\n\n\nUsage\n\uf0c1\n\n\nRead/Write from Mobile\n\uf0c1\n\n\n\n\nDownload \nNfcV-reader for Android\n and install it\n\n\nWe can Read/Write it from Mobile\n\n\n\n\n\n\n\n\n\n\n\n\nControl LED\n\uf0c1\n\n\n\n\nHardware Installation\n\n\n\n\n\n\n\n\nDownload \nNfcV-reader for Android\n and install it\n\n\nDownload \nNFC Tag Lib\n, rename it to NFC_Tag_M24LR6E and put it into Arduino\ns library .\n\n\nOpen Arduino IDE. If Arduino IDE is already opened, restart it.\n\n\nIn Arduino IDE, click menus: File -\n Example -\n NFC_Tag_M24LR6E -\n ledControl\n\n\nNow, you can control LED from your phone.\n\n\n\n\n\u00a0\n#include \nNfcTag.h\n\n#include \nWire.h\n\n\u00a0\nNfcTag nfcTag;\nint led = 5;\nbool flag = false;\nbool preFlag = false;\nvoid setup(){\n  Serial.begin(9600);\n  pinMode(led,OUTPUT);\n  nfcTag.init();\n}\n\u00a0\nvoid loop(){\n  flag = nfcTag.readByte(EEPROM_I2C_LENGTH-1) == 0xff?true:false;\n  if(flag != preFlag){\n    Serial.println(\nget remote NFC control signal!\n);\n    if(flag == true){\n      Serial.println(\nled will light up!\n);\n      digitalWrite(led,HIGH);\n    }else{\n      Serial.println(\nled will turn dark!\n);\n      digitalWrite(led,LOW);\n    }\n    preFlag = flag;\n  }\n  delay(5*1000);\n}\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nGrove - NFC Tag.PDF\n\n\nGrove - NFC Tag Eagle file\n\n\nM24LR64E-R datasheet.pdf\n\n\nNfcV-reader for Android\n\n\nNFC Tag M24LR6E Lib", 
            "title": "Grove - NFC Tag"
        }, 
        {
            "location": "/Grove-NFC_Tag/#specifications", 
            "text": "Working Voltage:5V or 3V3  Working Current 1mA  Effective range 2cm  Serve for contactless communication at 13.56MHz  ISO 15693 and ISO 18000-3 mode 1 compatible  64-bit unique identifier (UID)  Read Block   Write (32-bit blocks)  Grove I2C Interface", 
            "title": "Specifications"
        }, 
        {
            "location": "/Grove-NFC_Tag/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/Grove-NFC_Tag/#readwrite-from-mobile", 
            "text": "Download  NfcV-reader for Android  and install it  We can Read/Write it from Mobile", 
            "title": "Read/Write from Mobile"
        }, 
        {
            "location": "/Grove-NFC_Tag/#control-led", 
            "text": "Hardware Installation     Download  NfcV-reader for Android  and install it  Download  NFC Tag Lib , rename it to NFC_Tag_M24LR6E and put it into Arduino s library .  Open Arduino IDE. If Arduino IDE is already opened, restart it.  In Arduino IDE, click menus: File -  Example -  NFC_Tag_M24LR6E -  ledControl  Now, you can control LED from your phone.   \u00a0\n#include  NfcTag.h \n#include  Wire.h \n\u00a0\nNfcTag nfcTag;\nint led = 5;\nbool flag = false;\nbool preFlag = false;\nvoid setup(){\n  Serial.begin(9600);\n  pinMode(led,OUTPUT);\n  nfcTag.init();\n}\n\u00a0\nvoid loop(){\n  flag = nfcTag.readByte(EEPROM_I2C_LENGTH-1) == 0xff?true:false;\n  if(flag != preFlag){\n    Serial.println( get remote NFC control signal! );\n    if(flag == true){\n      Serial.println( led will light up! );\n      digitalWrite(led,HIGH);\n    }else{\n      Serial.println( led will turn dark! );\n      digitalWrite(led,LOW);\n    }\n    preFlag = flag;\n  }\n  delay(5*1000);\n}", 
            "title": "Control LED"
        }, 
        {
            "location": "/Grove-NFC_Tag/#resources", 
            "text": "Grove - NFC Tag.PDF  Grove - NFC Tag Eagle file  M24LR64E-R datasheet.pdf  NfcV-reader for Android  NFC Tag M24LR6E Lib", 
            "title": "Resources"
        }, 
        {
            "location": "/Grove-BLE_v1/", 
            "text": "Grove - BLE v1 (Grove - Bluetooth Low Energy v1) uses a Low Energy Bluetooth module \n \nHM-11\n, based on TI CC2540 chip, which has AT command support. As a Grove product it\ns convenient to use Grove - BLE with Arduino board via Base Shield.\n\n\n\n\nParameters\n\uf0c1\n\n\n\n\n\n\n\n\nSpecifications\n\n\nName\n\n\n\n\n\n\n\n\n\n\nBT Version\n\n\nBluetooth Specification V4.0 BLE\n\n\n\n\n\n\nWorking frequency\n\n\n2.4GHz ISM band\n\n\n\n\n\n\nModulation method\n\n\nGFSK(Gaussian Frequency Shift Keying)\n\n\n\n\n\n\nRF Power\n\n\n-23dbm, -6dbm, 0dbm, 6dbm, can modify through AT Command AT+POWE\n\n\n\n\n\n\nSpeed\n\n\nAsynchronous: 6K Bytes, Synchronous: 6K Bytes\n\n\n\n\n\n\nSensitivity\n\n\n\u2264-84dBm at 0.1% BER\n\n\n\n\n\n\nSecurity\n\n\nAuthentication and encryption\n\n\n\n\n\n\nService\n\n\nCentral \n Peripheral UUID FFE0,FFE1\n\n\n\n\n\n\nSupply Power\n\n\n3.3v - 5v\n\n\n\n\n\n\nWorking temperature\n\n\n\u20135 ~ +65 Centigrade\n\n\n\n\n\n\nSize\n\n\n20cm x 10cm\n\n\n\n\n\n\nWorking Current\n\n\n 10 mA\n\n\n\n\n\n\nSourcing Current\n\n\n 20 mA\n\n\n\n\n\n\nSleeping Current\n\n\n 1 mA\n\n\n\n\n\n\n\n\n\n\nAttention\n\nThe supply power of HM-11 is 3.3v, but the Grove - BLE is 3.3V to 5V.\n\n\n\n\nPinout\n\uf0c1\n\n\nGrove connector has four wires: GND, VCC, RX, TX.\n\n\nFeatures of Design\n\uf0c1\n\n\nWe have used TD6810 chip as the voltage regulator, so the range of the supply power can be 3.3v to 5v. Also , there\ns a level shift circuit which make sure the accuracy of data transmission.\n\n\nAT Commands\n\uf0c1\n\n\n1\uff09Query module address\n\n\nSend\uff1a AT+ADDR?\n\n\nReceive\uff1aOK+LADD:address\n\n\n2\uff09 Query baud rate\n\n\nSend\uff1aAT+BAUD?\n\n\nReceive\uff1aOK+Get:[para1]\n\n\nRange\uff1a 0~8; 0\n9600\uff0c1\n19200\uff0c2\n38400\uff0c3\n57600\uff0c4\n115200\uff0c5\n4800\uff0c6\n2400\uff0c7\n1200\uff0c8\n230400\n\n\nDefault: 0\n9600.\n\n\nSet baud rate\n\n\nSend\uff1aAT+BAUD[para1]\n\n\nReceive\uff1aOK+Set:[para1]\n\n\nEx.\uff1aSend \uff1aAT+BAUD1 \uff0cReceive\uff1aOK+Set:1. The Baud rate has been set to 19200\n\n\n\n\nNote\n\nIf setup to a value 7, After next power on, module will not support any AT Commands, until PIO0 is pressed, Module will change Baud to 9600.\n\n\n\n\n3\uff09 Try connect an address\n\n\nSend\uff1aAT+CON[para1]\n\n\nReceive\uff1aOK+CONN[para2]\n\n\nRange \uff1aA,E,F\n\n\nEx.\uff1aTry to connect an device which MAC address is 00:17:EA:09:09:09\n\n\nSend: AT+CON0017EA090909\n\n\nMay receive a reply: OK+CONNA \n Accept request, connecting\u00a0; OK+CONNE \n Connect error\u00a0; OK+CONN \n Connected , if AT+NOTI1 is setup\u00a0; OK+CONNF \n Connect Failed , After 10 seconds\n\n\n\n\nNote\n\nOnly central role is used. If remote device has already connected to other device or shut down, \u201cOK+CONNF\u201d will received after about 10 Seconds.\n\n\n\n\n4\uff09 Clear Last Connected device address\n\n\nSend\uff1aAT+CLEAR\n\n\nReceive\uff1aOK+CLEAR\n\n\n5\uff09 Query Module Work Mode\n\n\nSend\uff1aAT+MODE?\n\n\nReceive\uff1aOK+Get:[para]\n\n\nRange\uff1a 0~2;\n\n\n0\nTransmission Mode, 1\nPIO collection Mode + Mode 0, 2\nRemote Control Mode + Mode 0 . \n\n\nDefault: 0\n\n\nSet Module Work Mode\n\n\nSend\uff1aAT+MODE[]\n\n\nReceive\uff1aOK+Set:[para]\n\n\n6\uff09 Query Module name\n\n\nSend\uff1aAT+NAME?\n\n\nReceive\uff1aOK+NAME[para1]\n\n\nSet Module name\n\n\nSend\uff1aAT+NAME[para1]\n\n\nReceive\uff1aOK+Set:[para1]\n\n\nEx.\uff1aSend: AT+NAMESeeed\uff0c Receive\u00a0: OK+Set:Seeed\n\n\n\n\nNote\n\nName would change after next power on.\n\n\n\n\n7\uff09 Query Pin Code\n\n\nSend\uff1aAT+PASS?\n\n\nReceive\uff1aOK+PASS:[para1]\n\n\nRange\u00a0: 000000~999999. \n\n\nDefault\u00a0: 000000.\n\n\nSet Pin Code\n\n\nSend: AT+PASS[para1]\n\n\nReceive\uff1aOK+Set:[para1]\n\n\n8\uff09 Restore all setup value to factory setup\n\n\nSend\uff1aAT+RENEW\n\n\nReceive\uff1aOK+RENEW\n\n\n9\uff09 Restart module\n\n\nSend\uff1aAT+RESET\n\n\nReceive\uff1aOK+RESET\n\n\n10\uff09Query Master and Slaver Role\n\n\nSend\uff1aAT+ROLE[para1]\n\n\nReceive\uff1aOK+Set:[para1]\n\n\nRange\u00a0: 0~1;\n\n\n0\nPeripheral\u00a0: 1\nCentral\u00a0: Default: 0.\n\n\nMore AT commands please refer to the Datasheet of BLE module.\n\n\nSoftwareSerial Communication\n\uf0c1\n\n\n\n\nGrove - BLE can be used as a master or slave, you can use the one via different demos.\nIf you are going to use the following SoftwareSerial program, please refer to the way of connection in the previous pic. TX\nD2, RX\nD3.\n\n\nOpen Arduino IDE, copy the following program and upload it onto the Arduino/Seeeduino board. And then two BLE modules can communicate with each other.\n\n\nDemo\u00a0: BLE Slave\n\n\n    #include \nSoftwareSerial.h\n   //Software Serial Port\n    #define RxD 2\n    #define TxD 3\n\n    #define DEBUG_ENABLED  1\n\n    SoftwareSerial BLE(RxD,TxD);\n\n    void setup() \n    { \n      Serial.begin(9600);\n      pinMode(RxD, INPUT);\n      pinMode(TxD, OUTPUT);\n      setupBleConnection();\n\n    } \n\n    void loop() \n    { \n      char recvChar;\n      while(1){\n        if(BLE.available()){//check if there's any data sent from the remote BLE \n          recvChar = BLE.read();\n          Serial.print(recvChar);\n        }\n        if(Serial.available()){//check if there's any data sent from the local serial terminal, you can add the other applications here\n          recvChar  = Serial.read();\n          BLE.print(recvChar);\n        }\n      }\n    } \n\n    void setupBleConnection()\n    {\n      BLE.begin(9600); //Set BLE BaudRate to default baud rate 9600\n      BLE.print(\nAT+CLEAR\n); //clear all previous setting\n      BLE.print(\nAT+ROLE0\n); //set the bluetooth name as a slaver\n      BLE.print(\nAT+SAVE1\n);  //don't save the connect information\n    }\n\n\n\n\nDemo\u00a0: BLE Master\n\n\n    #include \nSoftwareSerial.h\n   //Software Serial Port\n    #define RxD 2\n    #define TxD 3\n\n    #define DEBUG_ENABLED  1\n\n    SoftwareSerial BLE(RxD,TxD);\n\n    void setup() \n    { \n      Serial.begin(9600);\n      pinMode(RxD, INPUT);\n      pinMode(TxD, OUTPUT);\n      setupBleConnection();\n\n    } \n\n    void loop() \n    { \n      char recvChar;\n      while(1){\n        if(BLE.available()){//check if there's any data sent from the remote BLE\n          recvChar = BLE.read();\n          Serial.print(recvChar);\n        }\n        if(Serial.available()){//check if there's any data sent from the local serial terminal, you can add the other applications here\n          recvChar  = Serial.read();\n          BLE.print(recvChar);\n        }\n      }\n    } \n\n    void setupBleConnection()\n    {\n      BLE.begin(9600); //Set BLE BaudRate to default baud rate 9600\n      BLE.print(\nAT+CLEAR\n); //clear all previous setting\n      BLE.print(\nAT+ROLE1\n); //set the bluetooth name as a master\n      BLE.print(\nAT+SAVE1\n);  //don't save the connect information\n    }\n\n\n\n\nResources\n\uf0c1\n\n\n\n\nBLE_apk_for_Android\n\n\nDatasheet of BLE module\n\n\nSchematic", 
            "title": "Grove BLE v1"
        }, 
        {
            "location": "/Grove-BLE_v1/#parameters", 
            "text": "Specifications  Name      BT Version  Bluetooth Specification V4.0 BLE    Working frequency  2.4GHz ISM band    Modulation method  GFSK(Gaussian Frequency Shift Keying)    RF Power  -23dbm, -6dbm, 0dbm, 6dbm, can modify through AT Command AT+POWE    Speed  Asynchronous: 6K Bytes, Synchronous: 6K Bytes    Sensitivity  \u2264-84dBm at 0.1% BER    Security  Authentication and encryption    Service  Central   Peripheral UUID FFE0,FFE1    Supply Power  3.3v - 5v    Working temperature  \u20135 ~ +65 Centigrade    Size  20cm x 10cm    Working Current   10 mA    Sourcing Current   20 mA    Sleeping Current   1 mA      Attention \nThe supply power of HM-11 is 3.3v, but the Grove - BLE is 3.3V to 5V.", 
            "title": "Parameters"
        }, 
        {
            "location": "/Grove-BLE_v1/#pinout", 
            "text": "Grove connector has four wires: GND, VCC, RX, TX.", 
            "title": "Pinout"
        }, 
        {
            "location": "/Grove-BLE_v1/#features-of-design", 
            "text": "We have used TD6810 chip as the voltage regulator, so the range of the supply power can be 3.3v to 5v. Also , there s a level shift circuit which make sure the accuracy of data transmission.", 
            "title": "Features of Design"
        }, 
        {
            "location": "/Grove-BLE_v1/#at-commands", 
            "text": "1\uff09Query module address  Send\uff1a AT+ADDR?  Receive\uff1aOK+LADD:address  2\uff09 Query baud rate  Send\uff1aAT+BAUD?  Receive\uff1aOK+Get:[para1]  Range\uff1a 0~8; 0 9600\uff0c1 19200\uff0c2 38400\uff0c3 57600\uff0c4 115200\uff0c5 4800\uff0c6 2400\uff0c7 1200\uff0c8 230400  Default: 0 9600.  Set baud rate  Send\uff1aAT+BAUD[para1]  Receive\uff1aOK+Set:[para1]  Ex.\uff1aSend \uff1aAT+BAUD1 \uff0cReceive\uff1aOK+Set:1. The Baud rate has been set to 19200   Note \nIf setup to a value 7, After next power on, module will not support any AT Commands, until PIO0 is pressed, Module will change Baud to 9600.  3\uff09 Try connect an address  Send\uff1aAT+CON[para1]  Receive\uff1aOK+CONN[para2]  Range \uff1aA,E,F  Ex.\uff1aTry to connect an device which MAC address is 00:17:EA:09:09:09  Send: AT+CON0017EA090909  May receive a reply: OK+CONNA   Accept request, connecting\u00a0; OK+CONNE   Connect error\u00a0; OK+CONN   Connected , if AT+NOTI1 is setup\u00a0; OK+CONNF   Connect Failed , After 10 seconds   Note \nOnly central role is used. If remote device has already connected to other device or shut down, \u201cOK+CONNF\u201d will received after about 10 Seconds.  4\uff09 Clear Last Connected device address  Send\uff1aAT+CLEAR  Receive\uff1aOK+CLEAR  5\uff09 Query Module Work Mode  Send\uff1aAT+MODE?  Receive\uff1aOK+Get:[para]  Range\uff1a 0~2;  0 Transmission Mode, 1 PIO collection Mode + Mode 0, 2 Remote Control Mode + Mode 0 .   Default: 0  Set Module Work Mode  Send\uff1aAT+MODE[]  Receive\uff1aOK+Set:[para]  6\uff09 Query Module name  Send\uff1aAT+NAME?  Receive\uff1aOK+NAME[para1]  Set Module name  Send\uff1aAT+NAME[para1]  Receive\uff1aOK+Set:[para1]  Ex.\uff1aSend: AT+NAMESeeed\uff0c Receive\u00a0: OK+Set:Seeed   Note \nName would change after next power on.  7\uff09 Query Pin Code  Send\uff1aAT+PASS?  Receive\uff1aOK+PASS:[para1]  Range\u00a0: 000000~999999.   Default\u00a0: 000000.  Set Pin Code  Send: AT+PASS[para1]  Receive\uff1aOK+Set:[para1]  8\uff09 Restore all setup value to factory setup  Send\uff1aAT+RENEW  Receive\uff1aOK+RENEW  9\uff09 Restart module  Send\uff1aAT+RESET  Receive\uff1aOK+RESET  10\uff09Query Master and Slaver Role  Send\uff1aAT+ROLE[para1]  Receive\uff1aOK+Set:[para1]  Range\u00a0: 0~1;  0 Peripheral\u00a0: 1 Central\u00a0: Default: 0.  More AT commands please refer to the Datasheet of BLE module.", 
            "title": "AT Commands"
        }, 
        {
            "location": "/Grove-BLE_v1/#softwareserial-communication", 
            "text": "Grove - BLE can be used as a master or slave, you can use the one via different demos. If you are going to use the following SoftwareSerial program, please refer to the way of connection in the previous pic. TX D2, RX D3.  Open Arduino IDE, copy the following program and upload it onto the Arduino/Seeeduino board. And then two BLE modules can communicate with each other.  Demo\u00a0: BLE Slave      #include  SoftwareSerial.h    //Software Serial Port\n    #define RxD 2\n    #define TxD 3\n\n    #define DEBUG_ENABLED  1\n\n    SoftwareSerial BLE(RxD,TxD);\n\n    void setup() \n    { \n      Serial.begin(9600);\n      pinMode(RxD, INPUT);\n      pinMode(TxD, OUTPUT);\n      setupBleConnection();\n\n    } \n\n    void loop() \n    { \n      char recvChar;\n      while(1){\n        if(BLE.available()){//check if there's any data sent from the remote BLE \n          recvChar = BLE.read();\n          Serial.print(recvChar);\n        }\n        if(Serial.available()){//check if there's any data sent from the local serial terminal, you can add the other applications here\n          recvChar  = Serial.read();\n          BLE.print(recvChar);\n        }\n      }\n    } \n\n    void setupBleConnection()\n    {\n      BLE.begin(9600); //Set BLE BaudRate to default baud rate 9600\n      BLE.print( AT+CLEAR ); //clear all previous setting\n      BLE.print( AT+ROLE0 ); //set the bluetooth name as a slaver\n      BLE.print( AT+SAVE1 );  //don't save the connect information\n    }  Demo\u00a0: BLE Master      #include  SoftwareSerial.h    //Software Serial Port\n    #define RxD 2\n    #define TxD 3\n\n    #define DEBUG_ENABLED  1\n\n    SoftwareSerial BLE(RxD,TxD);\n\n    void setup() \n    { \n      Serial.begin(9600);\n      pinMode(RxD, INPUT);\n      pinMode(TxD, OUTPUT);\n      setupBleConnection();\n\n    } \n\n    void loop() \n    { \n      char recvChar;\n      while(1){\n        if(BLE.available()){//check if there's any data sent from the remote BLE\n          recvChar = BLE.read();\n          Serial.print(recvChar);\n        }\n        if(Serial.available()){//check if there's any data sent from the local serial terminal, you can add the other applications here\n          recvChar  = Serial.read();\n          BLE.print(recvChar);\n        }\n      }\n    } \n\n    void setupBleConnection()\n    {\n      BLE.begin(9600); //Set BLE BaudRate to default baud rate 9600\n      BLE.print( AT+CLEAR ); //clear all previous setting\n      BLE.print( AT+ROLE1 ); //set the bluetooth name as a master\n      BLE.print( AT+SAVE1 );  //don't save the connect information\n    }", 
            "title": "SoftwareSerial Communication"
        }, 
        {
            "location": "/Grove-BLE_v1/#resources", 
            "text": "BLE_apk_for_Android  Datasheet of BLE module  Schematic", 
            "title": "Resources"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/", 
            "text": "Building an IoT project on your Raspberry Pi has never been an easy task for many developers. This is due to the messy hardware connections involved, and complicated software programming. Seeed and Microsoft have worked together to alleviate some of these challenges by introducing the Microsoft IoT Grove Kit.\n\n\nThe GrovePi+ cape included in the kit is fully compatible with your Raspberry Pi 3 and Raspberry Pi 2 that both run Windows 10 IoT Core. With the easy-to-use Grove system, you are now able to connect up to 15 Grove modules to your Raspberry Pi simply through the Grove interfaces on the GrovePi+.\n\n\nIn addition to the high performance sensors and actuators, the kit contains a 5 inch HDMI Display and a RGB LCD with a backlight. The Microsoft IoT Grove Kit is a powerful platform on which to begin your exploration on the Internet of Things.\n\n\nPlease note this kit DOES NOT include the Raspberry Pi board. Please visit \nhere\n to purchase separately.\n\n\n\n\nNote\n\n\nGrovePi+ and some of the code was designed by \nDexter Industry\n.  Click to get more information about Dexter. \n\n\n\n\n\n\nFEATURES\n\uf0c1\n\n\n\n\nEasy-to-use GrovePi+ that is compatible with Raspberry Pi B/B+/A+/2/3\n\n\nPlug-n-play Grove Modules for rapid prototyping\n\n\n\n\nPart List\n\uf0c1\n\n\n\n\n\n\n\n\nSKU\n\n\nPart Name\n\n\nQty\n\n\nLink\n\n\n\n\n\n\n\n\n\n\n103010002\n\n\nGrovePi+\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n104990243\n\n\n5 Inch HDMI Display with USB TouchScreen\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n103020005\n\n\nGrove - Relay\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n101020011\n\n\nGrove - Temp\nHumi Sensor\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n101020010\n\n\nGrove - Ultrasonic Ranger\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n104020006\n\n\nGrove LED Bar v2.0\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n101020048\n\n\nGrove - Rotary Angle Sensor(P)\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n107020000\n\n\nGrove - Buzzer\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n101020023\n\n\nGrove - Sound Sensor\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n101020014\n\n\nGrove - Light Sensor v1.2\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n101020003\n\n\nGrove - Button\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n104030001\n\n\nGrove - LCD RGB Backlight\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n109990056\n\n\nHDMI Cable\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n321010007\n\n\nMicro USB Cable - 48cm\n\n\n1\n\n\nGet One Now\n\n\n\n\n\n\n\n\nHardware connection for GrovePi+\n\uf0c1\n\n\n1.1  Connecting the GrovePi+ to the Raspberry Pi\n\uf0c1\n\n\nFirst, mount your GrovePi+ on the Raspberry Pi. The GrovePi+ slides over top of the\nRaspberry Pi as shown in the picture below.\n\n\n\n\nEnsure that the pins are properly aligned when stacking the GrovePi+.\n\n\nPowering up the Raspberry Pi\n\uf0c1\n\n\nTo power the GrovePi+ and the Raspberry Pi, you can use the micro USB power port on the Raspberry Pi.\nRemember to use a good power adapter capable of supplying 2A at 5V. If you want to run the GrovePi+ in a standalone configuration, then you might find a USB power bank.\n\n\n\n\nInstall GrovePi C# library for Raspberry Pi\n\uf0c1\n\n\nThe GrovePi can be programed in C#, but first you should install the Windows 10 IoT C# driver library for GrovePi, There\u2019re two ways to do this: install the NuGet package and use the GrovePi C# library code powered by Dexter .\n\n\nInstall the NuGet package\n\uf0c1\n\n\nThe GrovePi NuGet package for the current release is available. \nTo install GrovePi for Windows IoT follow the following steps.\n\n\nSTEP1.\n\uf0c1\n\n\nFrom the Tools menu, select Library Package Manager and then click Package Manager Console.\n\n\n\n\nThe \nPackage Manager Console window\n is displayed.\n\n\n\n\nSTEP2.\n\uf0c1\n\n\nRun the following command in the Package Manager Console.\n\n\nPM\n Install-Package GrovePi\n\n\n\nMore details at \nhttps://www.nuget.org/packages/GrovePi/\n. \n\n\nUse the GrovePi C# library code\n\uf0c1\n\n\nIf you\u2019re a senior programmer or you can\u2019t install the GrovePi NuGet package successfully, you can download the library code by click this \nhttps://github.com/DexterInd/GrovePi/tree/master/Software/CSharp\n.\n\n\nSTEP1.\n\uf0c1\n\n\nMove the two C# library projects \u201cGrovePi\u201d and \u201cDriver\u201d to the folder where your project resides. And add them to your project in Solution Explorer. \nFor example, right click the Solution \u201cGrovePiExamples \u201d, Add | Existing Project, as below shows.\n\n\n\n\nThen add \u201cGrovePi\u201d and \u201cDriver\u201d to the Solution Explorer.\n\n\n\n\nSTEP2.\n\uf0c1\n\n\nSet the C# library as the reference projects. Right click References and click Add References\n\n\n\n\nClick Projects | Solution, and check box as shown in the red box below. Then click OK.\n\n\n\n\nNow, you have already install the GrovePi C# library successfully.\n\n\nAll supported sensors are available through the DeviceFactory class.\n\n\nExamples\n\uf0c1\n\n\nBelow are some simple examples of how to use the library.\n\n\n\n\nMeasure Distance\n\n\n\n\nUltrasonic sensor plugged into digital pin 2 (D2)\n\n\nvar distance = DeviceFactory.Build.UltraSonicSensor(Pin.DigitalPin2).MeasureInCentimeters();\n\n\n\n\n\n\n\nDisplay Hello World\n\n\nDeviceFactory.Build.RgbLcdDisplay().SetText(\nHello World\n).SetBacklightRgb(0, 255, 255);\n\n\n\n\n\n\nSound the buzzer\n\n\n\n\n\n\nSound the buzzer plugged into digital pin 2 (D2).\n\n\nDeviceFactory.Build.Buzzer(Pin.DigitalPin2).ChangeState(SensorStatus.On);\n\n\n\nRunning Win10 IoT Examples on Rpi3\n\uf0c1\n\n\nHere we have a list of example projects that show just how easy it is to start a project with the Raspberry Pi. These Raspberry Pi projects combine easy-to-use Grove sensors with the powerful Raspberry Pi.\nYou can click \nhere\n to download the GrovePi Example code for win10. You will need to press the green button \u201cClone or download\u201d on the right and choose \u201cDownload ZIP\u201d. Then you need to extract the ZIP in a location of your choice.\nOpen the GrovePiExamples(win10).sln with your Visual Studio 2015, you can see there\u2019re 12 projects in the Solution Explorer as the picture below shows.\n\n\n\n\nBefore you get started, please build \nGrovePi\n project first. This is because the other projects depend on it.\n\n\nHello World from RGB LCD\n\uf0c1\n\n\nThis example is meant to be your first project with the GrovePi+. All the parts used in this project are available in the GrovePi+ Starter Kit. Once mastered, you can move on to more complicated projects like connecting a display or other sensors to the Raspberry Pi.\n\n\nStep1:\n Set the HelloWorld(LCD) project as StartUp Project.\n\uf0c1\n\n\nStep2:\n Hardware connection.\n\uf0c1\n\n\nConnect the RGB LCD to Port I2C-1 and power on the Raspberry Pi using the Grove wire connector. \n\n\n\n\nStep3:\n  Deploy your app.\n\uf0c1\n\n\n1)  With the application open in Visual Studio, set the architecture in the toolbar dropdown. Select ARM.\n\n\n2)  Next, in the Visual Studio toolbar, click on the Local Machine dropdown and select Remote Machine.\n\n\n\n\n3)  At this point, Visual Studio will present the Remote Connections dialog. If you previously used \nPowerShell\n to set a unique name for your device, you can enter it here (in this example, we\u2019re using my-device). Otherwise, use the IP address of your Windows IoT Core device. After entering the device name/IP select None for Windows Authentication, then click Select.\n\n\n\n\n4)  You can verify or modify these values by navigating to the project properties (select Properties in the Solution Explorer) and choosing the Debug tab on the left.\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe HelloWorld app will deploy and start on the Windows IoT device, and you will see the HelloWorld form the Grove RGB LCD.\n\n\nGrove Rotary Angle Sensor\n\uf0c1\n\n\nThis example can be set up the same way as HelloWorld(LCD).\n\n\n\n\nStep1:\n Set the GroveAngleSensor project as StartUp Project.\n\n\nStep2:\n Hardware connection.\nConnect the Grove Angle Sensor to Port A0 and connect Raspberry Pi to LCD screen by HDMI cable.\n\n\nStep3:\n Deploy your app. Refer to the HelloWorld(LCD) example of Step3.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveAngleSensor app will deploy and start on the Windows IoT device. You can see the Grove Angle Sensor value on the LCD Screen.\n\n\nGrove LED Bar\n\uf0c1\n\n\nThis example can be set up the same way as HelloWorld(LCD).\n\n\n\n\nStep1:\n Set the GroveLedBar project as StartUp Project.\n\n\nStep2:\n Hardware connection.\nConnect the Grove Led Bar to Port D5.\n\n\nStep3:\n Deploy your app. Refer to the HelloWorld(LCD) example of Step3.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveLedBar app will deploy and start on the Windows IoT device. You can see the Grove Led Bar will be lighted up in cycle.\n\n\nGrove - Light Sensor\n\uf0c1\n\n\nThis example is the same use as HelloWorld(LCD).\n\n\n\n\nStep1\n: Set the GroveLightSensor project as StartUp Project.\n\n\nStep2\n: Hardware connection.\nConnect the Grove Light Sensor to Port A2 and connect Raspberry Pi to LCD screen by HDMI cable.\n\n\nStep3\n: Deploy your app. Refer to the HelloWorld(LCD) example of Step3.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveLightSensor app will deploy and start on the Windows IoT device. You can see the Grove Light Sensor value on the LCD Screen.\n\n\nGrove - Relay\n\uf0c1\n\n\nThis example is the same use as HelloWorld(LCD).\n\n\n\n\nStep1\n: Set the GroveRelay project as StartUp Project.\n\n\nStep2\n: Hardware connection.\nConnect the Grove Relay to Port D2.\n\n\nStep3\n: Deploy your app. Refer to the HelloWorld(LCD) example of Step3.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveRelay app will deploy and start on the Windows IoT device. You can see the Grove Relay will open and close every 1 second.\n\n\nGrove - Sound Sensor\n\uf0c1\n\n\nThis example is the same use as HelloWorld(LCD).\n\n\n\n\nStep1\n: Set the GroveSoundSensor project as StartUp Project.\n\n\nStep2\n: Hardware connection.\nConnect the Grove Sound Sensor to Port A1 and connect Raspberry Pi to LCD screen by HDMI cable.\n\n\nStep3\n: Deploy your app. Refer to the HelloWorld(LCD) example of Step3.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveSoundSensor app will deploy and start on the Windows IoT device. You can see the Grove Sound Sensor value on the LCD Screen.\n\n\nGrove - Temperature and Humidity Sensor\n\uf0c1\n\n\nThis example is the same use as HelloWorld(LCD).\n\n\n\n\nStep1\n: Set the GroveTempAndHumi project as StartUp Project.\n\n\nStep2\n: Hardware connection.\nConnect the Grove Temp \n Humi Sensor to Port D3 and connect Raspberry Pi to LCD screen by HDMI cable.\n\n\nStep3\n: Deploy your app. Refer to the HelloWorld(LCD) example of Step3.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveTempAndHumi app will deploy and start on the Windows IoT device. You can see the Temperature and Humidity value on the LCD Screen.\n\n\nGrove - Ultrasonic Ranger\n\uf0c1\n\n\nThis example is the same use as HelloWorld(LCD).\n\n\n\n\nStep1\n: Set the GroveUltrasonicSensor project as StartUp Project.\n\n\nStep2\n: Hardware connection.\nConnect the Grove Ultrasonic Ranger to Port D4 and connect Raspberry Pi to LCD screen by HDMI cable.\n\n\nStep3\n: Deploy your app. Refer to the HelloWorld(LCD) example of Step3.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveUltrasonicSensor app will deploy and start on the Windows IoT device. You can see the Distance value on the LCD Screen.\n\n\nHome Weather Display\n\uf0c1\n\n\nThis example is the same use as HelloWorld(LCD).\n\n\n\n\nStep1\n: Set the HomeWeatherDisplay project as StartUp Project.\n\n\nStep2\n: Hardware connection.\nConnect the Grove Temp and Humi Sensor to Port D3, RGB LCD to Port I2C using the Grove wire connector. \n\n\nStep3\n: Deploy your app. Refer to the Blink example of Step5.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe Home Weather Display app will deploy and start on the Windows IoT device, and you can see the temperature on the RGB LCD.\n\n\nAll Modules in One Project\n\uf0c1\n\n\nThis example is the same use as HelloWorld(LCD).\n\n\n\n\nStep1\n: Set the All_in_One project as StartUp Project.\n\n\nStep2\n: Hardware connection.\n\n\nGrove - Relay \n D2\n\n\nGrove - Temp\nHumi Sensor \n D3\n\n\nGrove - Ultrasonic Ranger \n D4\n\n\nGrove - LED Bar V2.0 \n D5\n\n\nGrove - Buzer \n D6\n\n\nGrove - Button \n D7\n\n\nGrove - Rotary Angle Sensor \n A0\n\n\nGrove - Sound Sensor \n A1\n\n\nGrove - Light Sensor \n A2\n\n\n\n\n\n\n\n\nConnect the Grove Modules to GrovePi+ as the table shows. And connect Raspberry Pi to LCD screen by HDMI cable.\n\n\n\n\nStep3\n: Deploy your app. Refer to the HelloWorld(LCD) example of Step3.\n\n\n\n\nWhen everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe All_in_One app will deploy and start on the Windows IoT device.\nYou can see the Distance Sound Light value and relay state on the LCD Screen. The angle sensor will be shown as the chart on the screen. The Led Bar indicates the value of angle sensor. Press the Button and hold it, the Grove Relay will open.\n\n\nSee Also\n\uf0c1\n\n\n\n\nWindows Dev Center\n\n\nGrovePi C# Library Code\n\n\nExample Code", 
            "title": "Microsoft IoT Grove Kit (Azure Certified)"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#features", 
            "text": "Easy-to-use GrovePi+ that is compatible with Raspberry Pi B/B+/A+/2/3  Plug-n-play Grove Modules for rapid prototyping", 
            "title": "FEATURES"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#part-list", 
            "text": "SKU  Part Name  Qty  Link      103010002  GrovePi+  1  Get One Now    104990243  5 Inch HDMI Display with USB TouchScreen  1  Get One Now    103020005  Grove - Relay  1  Get One Now    101020011  Grove - Temp Humi Sensor  1  Get One Now    101020010  Grove - Ultrasonic Ranger  1  Get One Now    104020006  Grove LED Bar v2.0  1  Get One Now    101020048  Grove - Rotary Angle Sensor(P)  1  Get One Now    107020000  Grove - Buzzer  1  Get One Now    101020023  Grove - Sound Sensor  1  Get One Now    101020014  Grove - Light Sensor v1.2  1  Get One Now    101020003  Grove - Button  1  Get One Now    104030001  Grove - LCD RGB Backlight  1  Get One Now    109990056  HDMI Cable  1  Get One Now    321010007  Micro USB Cable - 48cm  1  Get One Now", 
            "title": "Part List"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#hardware-connection-for-grovepi", 
            "text": "", 
            "title": "Hardware connection for GrovePi+"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#11-connecting-the-grovepi-to-the-raspberry-pi", 
            "text": "First, mount your GrovePi+ on the Raspberry Pi. The GrovePi+ slides over top of the\nRaspberry Pi as shown in the picture below.   Ensure that the pins are properly aligned when stacking the GrovePi+.", 
            "title": "1.1  Connecting the GrovePi+ to the Raspberry Pi"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#powering-up-the-raspberry-pi", 
            "text": "To power the GrovePi+ and the Raspberry Pi, you can use the micro USB power port on the Raspberry Pi.\nRemember to use a good power adapter capable of supplying 2A at 5V. If you want to run the GrovePi+ in a standalone configuration, then you might find a USB power bank.", 
            "title": "Powering up the Raspberry Pi"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#install-grovepi-c-library-for-raspberry-pi", 
            "text": "The GrovePi can be programed in C#, but first you should install the Windows 10 IoT C# driver library for GrovePi, There\u2019re two ways to do this: install the NuGet package and use the GrovePi C# library code powered by Dexter .", 
            "title": "Install GrovePi C# library for Raspberry Pi"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#install-the-nuget-package", 
            "text": "The GrovePi NuGet package for the current release is available. \nTo install GrovePi for Windows IoT follow the following steps.", 
            "title": "Install the NuGet package"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#step1", 
            "text": "From the Tools menu, select Library Package Manager and then click Package Manager Console.   The  Package Manager Console window  is displayed.", 
            "title": "STEP1."
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#step2", 
            "text": "Run the following command in the Package Manager Console.  PM  Install-Package GrovePi  More details at  https://www.nuget.org/packages/GrovePi/ .", 
            "title": "STEP2."
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#use-the-grovepi-c-library-code", 
            "text": "If you\u2019re a senior programmer or you can\u2019t install the GrovePi NuGet package successfully, you can download the library code by click this  https://github.com/DexterInd/GrovePi/tree/master/Software/CSharp .", 
            "title": "Use the GrovePi C# library code"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#step1_1", 
            "text": "Move the two C# library projects \u201cGrovePi\u201d and \u201cDriver\u201d to the folder where your project resides. And add them to your project in Solution Explorer. \nFor example, right click the Solution \u201cGrovePiExamples \u201d, Add | Existing Project, as below shows.   Then add \u201cGrovePi\u201d and \u201cDriver\u201d to the Solution Explorer.", 
            "title": "STEP1."
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#step2_1", 
            "text": "Set the C# library as the reference projects. Right click References and click Add References   Click Projects | Solution, and check box as shown in the red box below. Then click OK.   Now, you have already install the GrovePi C# library successfully.  All supported sensors are available through the DeviceFactory class.", 
            "title": "STEP2."
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#examples", 
            "text": "Below are some simple examples of how to use the library.   Measure Distance   Ultrasonic sensor plugged into digital pin 2 (D2)  var distance = DeviceFactory.Build.UltraSonicSensor(Pin.DigitalPin2).MeasureInCentimeters();    Display Hello World  DeviceFactory.Build.RgbLcdDisplay().SetText( Hello World ).SetBacklightRgb(0, 255, 255);    Sound the buzzer    Sound the buzzer plugged into digital pin 2 (D2).  DeviceFactory.Build.Buzzer(Pin.DigitalPin2).ChangeState(SensorStatus.On);", 
            "title": "Examples"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#running-win10-iot-examples-on-rpi3", 
            "text": "Here we have a list of example projects that show just how easy it is to start a project with the Raspberry Pi. These Raspberry Pi projects combine easy-to-use Grove sensors with the powerful Raspberry Pi.\nYou can click  here  to download the GrovePi Example code for win10. You will need to press the green button \u201cClone or download\u201d on the right and choose \u201cDownload ZIP\u201d. Then you need to extract the ZIP in a location of your choice.\nOpen the GrovePiExamples(win10).sln with your Visual Studio 2015, you can see there\u2019re 12 projects in the Solution Explorer as the picture below shows.   Before you get started, please build  GrovePi  project first. This is because the other projects depend on it.", 
            "title": "Running Win10 IoT Examples on Rpi3"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#hello-world-from-rgb-lcd", 
            "text": "This example is meant to be your first project with the GrovePi+. All the parts used in this project are available in the GrovePi+ Starter Kit. Once mastered, you can move on to more complicated projects like connecting a display or other sensors to the Raspberry Pi.", 
            "title": "Hello World from RGB LCD"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#step1-set-the-helloworldlcd-project-as-startup-project", 
            "text": "", 
            "title": "Step1: Set the HelloWorld(LCD) project as StartUp Project."
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#step2-hardware-connection", 
            "text": "Connect the RGB LCD to Port I2C-1 and power on the Raspberry Pi using the Grove wire connector.", 
            "title": "Step2: Hardware connection."
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#step3-deploy-your-app", 
            "text": "1)  With the application open in Visual Studio, set the architecture in the toolbar dropdown. Select ARM.  2)  Next, in the Visual Studio toolbar, click on the Local Machine dropdown and select Remote Machine.   3)  At this point, Visual Studio will present the Remote Connections dialog. If you previously used  PowerShell  to set a unique name for your device, you can enter it here (in this example, we\u2019re using my-device). Otherwise, use the IP address of your Windows IoT Core device. After entering the device name/IP select None for Windows Authentication, then click Select.   4)  You can verify or modify these values by navigating to the project properties (select Properties in the Solution Explorer) and choosing the Debug tab on the left.  When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe HelloWorld app will deploy and start on the Windows IoT device, and you will see the HelloWorld form the Grove RGB LCD.", 
            "title": "Step3:  Deploy your app."
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#grove-rotary-angle-sensor", 
            "text": "This example can be set up the same way as HelloWorld(LCD).   Step1:  Set the GroveAngleSensor project as StartUp Project.  Step2:  Hardware connection.\nConnect the Grove Angle Sensor to Port A0 and connect Raspberry Pi to LCD screen by HDMI cable.  Step3:  Deploy your app. Refer to the HelloWorld(LCD) example of Step3.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveAngleSensor app will deploy and start on the Windows IoT device. You can see the Grove Angle Sensor value on the LCD Screen.", 
            "title": "Grove Rotary Angle Sensor"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#grove-led-bar", 
            "text": "This example can be set up the same way as HelloWorld(LCD).   Step1:  Set the GroveLedBar project as StartUp Project.  Step2:  Hardware connection.\nConnect the Grove Led Bar to Port D5.  Step3:  Deploy your app. Refer to the HelloWorld(LCD) example of Step3.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveLedBar app will deploy and start on the Windows IoT device. You can see the Grove Led Bar will be lighted up in cycle.", 
            "title": "Grove LED Bar"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#grove-light-sensor", 
            "text": "This example is the same use as HelloWorld(LCD).   Step1 : Set the GroveLightSensor project as StartUp Project.  Step2 : Hardware connection.\nConnect the Grove Light Sensor to Port A2 and connect Raspberry Pi to LCD screen by HDMI cable.  Step3 : Deploy your app. Refer to the HelloWorld(LCD) example of Step3.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveLightSensor app will deploy and start on the Windows IoT device. You can see the Grove Light Sensor value on the LCD Screen.", 
            "title": "Grove - Light Sensor"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#grove-relay", 
            "text": "This example is the same use as HelloWorld(LCD).   Step1 : Set the GroveRelay project as StartUp Project.  Step2 : Hardware connection.\nConnect the Grove Relay to Port D2.  Step3 : Deploy your app. Refer to the HelloWorld(LCD) example of Step3.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveRelay app will deploy and start on the Windows IoT device. You can see the Grove Relay will open and close every 1 second.", 
            "title": "Grove - Relay"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#grove-sound-sensor", 
            "text": "This example is the same use as HelloWorld(LCD).   Step1 : Set the GroveSoundSensor project as StartUp Project.  Step2 : Hardware connection.\nConnect the Grove Sound Sensor to Port A1 and connect Raspberry Pi to LCD screen by HDMI cable.  Step3 : Deploy your app. Refer to the HelloWorld(LCD) example of Step3.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveSoundSensor app will deploy and start on the Windows IoT device. You can see the Grove Sound Sensor value on the LCD Screen.", 
            "title": "Grove - Sound Sensor"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#grove-temperature-and-humidity-sensor", 
            "text": "This example is the same use as HelloWorld(LCD).   Step1 : Set the GroveTempAndHumi project as StartUp Project.  Step2 : Hardware connection.\nConnect the Grove Temp   Humi Sensor to Port D3 and connect Raspberry Pi to LCD screen by HDMI cable.  Step3 : Deploy your app. Refer to the HelloWorld(LCD) example of Step3.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveTempAndHumi app will deploy and start on the Windows IoT device. You can see the Temperature and Humidity value on the LCD Screen.", 
            "title": "Grove - Temperature and Humidity Sensor"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#grove-ultrasonic-ranger", 
            "text": "This example is the same use as HelloWorld(LCD).   Step1 : Set the GroveUltrasonicSensor project as StartUp Project.  Step2 : Hardware connection.\nConnect the Grove Ultrasonic Ranger to Port D4 and connect Raspberry Pi to LCD screen by HDMI cable.  Step3 : Deploy your app. Refer to the HelloWorld(LCD) example of Step3.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe GroveUltrasonicSensor app will deploy and start on the Windows IoT device. You can see the Distance value on the LCD Screen.", 
            "title": "Grove - Ultrasonic Ranger"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#home-weather-display", 
            "text": "This example is the same use as HelloWorld(LCD).   Step1 : Set the HomeWeatherDisplay project as StartUp Project.  Step2 : Hardware connection.\nConnect the Grove Temp and Humi Sensor to Port D3, RGB LCD to Port I2C using the Grove wire connector.   Step3 : Deploy your app. Refer to the Blink example of Step5.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe Home Weather Display app will deploy and start on the Windows IoT device, and you can see the temperature on the RGB LCD.", 
            "title": "Home Weather Display"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#all-modules-in-one-project", 
            "text": "This example is the same use as HelloWorld(LCD).   Step1 : Set the All_in_One project as StartUp Project.  Step2 : Hardware connection.  Grove - Relay   D2  Grove - Temp Humi Sensor   D3  Grove - Ultrasonic Ranger   D4  Grove - LED Bar V2.0   D5  Grove - Buzer   D6  Grove - Button   D7  Grove - Rotary Angle Sensor   A0  Grove - Sound Sensor   A1  Grove - Light Sensor   A2     Connect the Grove Modules to GrovePi+ as the table shows. And connect Raspberry Pi to LCD screen by HDMI cable.   Step3 : Deploy your app. Refer to the HelloWorld(LCD) example of Step3.   When everything is set up, you should be able to press F5 from Visual Studio. If there are any missing packages that you did not install during setup, Visual Studio may prompt you to acquire those now. \nThe All_in_One app will deploy and start on the Windows IoT device.\nYou can see the Distance Sound Light value and relay state on the LCD Screen. The angle sensor will be shown as the chart on the screen. The Led Bar indicates the value of angle sensor. Press the Button and hold it, the Grove Relay will open.", 
            "title": "All Modules in One Project"
        }, 
        {
            "location": "/Microsoft_IoT_Grove_Kit/#see-also", 
            "text": "Windows Dev Center  GrovePi C# Library Code  Example Code", 
            "title": "See Also"
        }, 
        {
            "location": "/survey_end/", 
            "text": "", 
            "title": "Survey"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/", 
            "text": "RePhone can be a learning tool for you to start interesting projects. Currently, RePhone supports various development environments and development languages, you can build applications either with C/C++ based on Eclipse IDE, Arduino IDE, or with Lua and JavaScript.\n\n\nThis wiki is a User Guide to help you start your RePhone project with Arduino IDE.\n\n\nDownload Arduino IDE for RePhone\n\uf0c1\n\n\nBefore you download the Arduino IDE for RePhone, make sure you have an operation system as follows:\n\n\nWindows XP/Vista/7/8/8.1\n\n\nWe have put the Arduino IDE for RePhone on our GitHub, and you are quite welcome to send us a \npull request\n to help us optimize and improve it.\n\n\nIf you ever used the Arduino IDE before, then this should be just a piece of cake. If you are not familiar with Arduino, which is fine as well, just follow the instructions, and you will be getting started with Arduino IDE easily and quickly.\n\n\nNow click on\n\n\n\n\nOn the Github page, click the \nDownload ZIP\n to download the file as shown in the image below:\n\n\n\n\nWhen the download is complete, unzip the file to a proper location.\n\n\nInstall the Driver\n\uf0c1\n\n\nDisable Driver Signature Enforcement under Windows 8 / 8.1\n\uf0c1\n\n\nIf you are using the Windows8/8.1, you would need to disable \nDriver Signature Enforcement\n first to be able to install the driver.\n\n\nYou should save the files you are editing before trying to turn off the \nDriver Signature Enforcement\n as your system will be shut down during the operation.\n\n\nNow follow the instructions below to disable the \nDriver Signature Enforcement.\n\n\n\n\nPress \u201cWindows Key\u201d +\nR\n\n\nEnter shutdown.exe /r /o /f /t 00\n\n\nClick the \nOK\n button.\n\n\nSystem will restart to a \nChoose an option\n screen\n\n\nSelect \nTroubleshoot\n from \nChoose an option\n screen\n\n\nSelect \nAdvanced options\n from \nTroubleshoot\n screen\n\n\nSelect \nWindows Startup Settings\n from \nAdvanced options\n screen\n\n\nClick \nRestart\n button\n\n\nSystem will restart to \nAdvanced Boot Options\n screen\n\n\nSelect \nDisable Driver Signature Enforcement\n\n\nOnce the system starts, you can install the Arduino drivers as same as Windows\n\n\n\n\nNormal Driver Installation\n\uf0c1\n\n\n\n\n\n\nFirst, power up your RePhone by \nplugging in the battery\n or \npower it with external power sources (3.3 ~ 4.2V(no SIM)/3.5 ~ 4.2V(with SIM)) \nto the battery socket on the Xadow GSM+BLE, \npress and hold the power key (PWR) for 2 seconds to\n \nturn it ON\n (LED indicator shows \nGREEN\n), then connect your RePhone to PC with a Micro USB cable.\n\n\n\n\n\n\n\n\nOpen \nDevice Manager\n by clicking the \nStart\n button, clicking \nControl Panel\n, clicking \nSystem and Security\n, and then, under \nSystem\n, clicking \nDevice Manager\n. If you\nre prompted for an administrator password or confirmation, type the password or provide confirmation.\nIn the \nDevice Manager\n, you will be seeing unknown devices as shown below:\n\n\n\n\n\n\n\n\nRight click on one of the unknown devices, choose \nUpdate Driver Software\n.\n\n\n\n\n\n\n\n\nChoose \nBrowse my computer for driver software\n.\n\n\n\n\n\n\n\n\nClick \nBrowse\n and the locate the folder which you\nve unzipped the Arduino IDE for RePhone .. \\Arduino_IDE_for_RePhone\\drivers\\mtk . Click \nNext\n to start the driver installation.\n\n\n\n\n\n\n\n\nWhen the driver software is successfully installed, you will be able to see the following \ncomplete\n page, click \nClose\n and \nstart over from step 1 to 6 to install the driver for another unknown device\n.\n\n\n\n\n\n\n\n\nInstall the Driver Manually\n\uf0c1\n\n\nYou can also install the driver manually:\n\n\n\n\n\n\nIn \nBrowse for driver software on your computer\n window, click \nLet me pick from a list of device drivers on my computer\n\n\n\n\n\n\nThen click \nPorts(COM\nLPT)\n and go \nnext\n\n\n\n\n\n\nClick \nHave Disk\n\n\n\n\n\n\nAfterwards,\n\n\n\n\n\n\n if you are using \nWindows Vista 64bit\n, locate \nArduino_IDE_for_RePhone-master\\drivers\\mtk\\Vista\\usb2ser_Vista64.inf\\\n\n\n if you are using \nWindows 7 or higher with 64bit\n, locate \nArduino_IDE_for_RePhone-master\\drivers\\mtk\\Win7\\usb2ser_Win764.inf\n\n\nInstall the Driver with LinkIt Assist 2502 SDK 2.0.46\n\uf0c1\n\n\nLinkIt Assist 2502 SDK 2.0.46 also provides a driver installation program.\n\n\n\n\nThen find the driver installer in the path \nMediaTek_LinkIt_Assist_2502_SDK_2_0_46\\LINKIT_ASSIST_SDK\\Driver\\InstallMTKUSBCOMPortDriver.exe\n\n\nUpdate/Flash the Firmware\n\uf0c1\n\n\n\n\nNote\n\nPlease note that flashing the firmware will delete all the settings and files(images, musics) stored in the RePhone. Take a data backup before you flash/update the firmware.\n\n\n\n\nTo make use of the Arduino IDE for RePhone, you have to update/flash the firmware as well. The process is as simple as follows:\n\n\n\n\n\n\nDisconnect your RePhone with PC\n, \npress and hold the power key(PWR) for 2 seconds to turn it OFF\n (LED indicator turn \nRED\n and then goes out)\n\n\n\n\n\n\nOpen the \nFirmwareUpdater.exe\n under the path \nArduino_IDE_for_RePhone\\hardware\\tools\\mtk\\FirmwareUpdater.exe\n, be sure your platform on the Firmware Updater is \nRePhone\n as showing below, if not, click \nOthers\n and locate to \nArduino_IDE_for_RePhone\\hardware\\tools\\mtk\\firmware\\LinkIt_Device\\RePhone\\W15.19.p2-uart\\SEEED02A_DEMO_BB.cfg\n, then click \nDownload (The Green Button)\n.\n\n\n\n\n\n\n\n\nNow you will be asked to connect your RePhone to PC via USB cable, make sure your RePhone has been turned \nOFF\n and meantime a functional battery should be always connected ( Powered Up).\n\n\n\n\n\n\n\n\nWait until the downloading finishes. This might take about 1min, so it may remain stuck at 50% for quite a while, please \nbe patient\n.\n\n\n\n\n\n\n\n\nIn the \nComplete\n page click \nOK\n to finish the firmware update.\n\n\n\n\n\n\n\n\nReset to default\n\uf0c1\n\n\n\n\nNote\n\nPlease note that resetting your Rephone to default will delete all the settings and files(images, musics) in the RePhone. Take a data backup before you reset it to default.**\n\n\n\n\nTo reset your RePhone to \nDEFAULT\n:\n\n\n\n\n\n\nFollow the instructions in \nUpdate/Flash the Firmware\n section to flash the firmware\n\n\n\n\n\n\nDownload the RePhone_Create_Kit_VXP file\n\n\n\n\n\n\n\n\nEnter the \nRePhone Mass Storage Mode\n\n\n\n\n\n\nCopy everything under the file named \nRePhone Create Kit VXP\n into the RePhone 5MB mass storage.\n\n\n\n\n\n\nRestart your RePhone then its done. As reset would have deleted all the files, you would have to put an mp3 file in the mass storage as well for the use of ringtone.\n\n\n\n\n\n\nA demo: Hello World\n\uf0c1\n\n\nNow you have prepared things required, we are ready to rock on with RePhone.\n\n\nLet us start with a simple program \nHello World\n\n\n\n\n\n\nPress and hold the power key (PWR) for 2 seconds to turn it ON (LED indicator shows GREEN)\n\n\n\n\n\n\nOpen the \nArduino_IDE_for_RePhone.exe\n in the folder where you unzipped the Arduino IDE for RePhone, the software interface is as follows:\n\n\n\n\n\n\n\n\nOpen \nDevice Manager\n to check for the COM ports. There will be \ntwo COM ports\n:\n\n\n\n\nMTK USB Debug Port is used for uploading code\n\n\nMTK USB Modem Port is used for logs, like printing messages in the serial monitor with \nSerial.println()\n\n\n\n\n\n\n\n\n\n\nOn the Arduino IDE window, click \nTool =\n Port\n, select \nMTK USB Debug Port\n, which is \nCOM20\n in this case, the COM number might be different in your PC, just make sure it corresponds to the Debug Port.\n\n\n\n\n\n\n\n\nOn the Arduino IDE window, click \nTool =\n Board\n, select \nRePhone\n\n\n\n\n\n\n\n\nNow copy the following code to your Arduino IDE:\n\n\n// hello world for test RePhone\n// loovee@10-18-2015\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\u00a0\nvoid loop() {\n    // put your main code here, to run repeatedly:\n    Serial.println(\"Hello World, Hello RePhone!\");\n    delay(100);\n}\n\n\n\n\n\n\n\nNow press the \nUpload\n button to upload the code to your RePhone. You will see the \nDone uploading\n when the code is successfully uploaded.\n\n\n\n\n\n\n\n\nAs RePhone uses different COM ports for uploading software and logs, to read the logs, we need to switch the selected COM Port to \nMTK USB Modem Port\n. On the Arduino IDE window, click \nTool =\n Port\n, select \nMTK USB Modem Port\n, which is \nCOM48\n in this case.\n\n\nThen open the \nSerial Monitor\n.\n\n\n\n\n\n\n\n\nNow we can see the \nHello World\n we have printed with \nSerial.println()\n .\n\n\n\n\n\n\n\n\nMore Example Code\n\uf0c1\n\n\nPlaying with some example code would be a good start if you are heading into some even more interesting projects.\n\n\n\n\n\n\nSimply setup your \nsketchbook location\n in the \npreference\n as \nArduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\n (where you install the Arduino IDE for RePhone)\n\n\n\n\nthen restart the \nArduino_IDE_for_RePhone.exe\n, you will be able to see the example codes.\n\n\n\n\n\n\n\nYou can also find the Arduino example coded manually for all the RePhone modules in the following path:\n\nArduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\\libraries\n\n\n\n\n\n\n\n\nRePhone Community\n\uf0c1\n\n\n\n\nWe have been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the RePhone Community.\n\n\nNow join us in the \nRePhone Community\n!\n\n\nTogether we seek answers, make interesting stuff, care about each other, and share our experiences.\n\n\nMore\n\uf0c1\n\n\nYou have done a great job so far! RePhone comes with a big family of modules with different features and functionalities. Go to check the wiki for modules for more applications!", 
            "title": "Arduino IDE for RePhone Kit"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#download-arduino-ide-for-rephone", 
            "text": "Before you download the Arduino IDE for RePhone, make sure you have an operation system as follows:  Windows XP/Vista/7/8/8.1  We have put the Arduino IDE for RePhone on our GitHub, and you are quite welcome to send us a  pull request  to help us optimize and improve it.  If you ever used the Arduino IDE before, then this should be just a piece of cake. If you are not familiar with Arduino, which is fine as well, just follow the instructions, and you will be getting started with Arduino IDE easily and quickly.  Now click on   On the Github page, click the  Download ZIP  to download the file as shown in the image below:   When the download is complete, unzip the file to a proper location.", 
            "title": "Download Arduino IDE for RePhone"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver", 
            "text": "", 
            "title": "Install the Driver"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#disable-driver-signature-enforcement-under-windows-8-81", 
            "text": "If you are using the Windows8/8.1, you would need to disable  Driver Signature Enforcement  first to be able to install the driver.  You should save the files you are editing before trying to turn off the  Driver Signature Enforcement  as your system will be shut down during the operation.  Now follow the instructions below to disable the  Driver Signature Enforcement.   Press \u201cWindows Key\u201d + R  Enter shutdown.exe /r /o /f /t 00  Click the  OK  button.  System will restart to a  Choose an option  screen  Select  Troubleshoot  from  Choose an option  screen  Select  Advanced options  from  Troubleshoot  screen  Select  Windows Startup Settings  from  Advanced options  screen  Click  Restart  button  System will restart to  Advanced Boot Options  screen  Select  Disable Driver Signature Enforcement  Once the system starts, you can install the Arduino drivers as same as Windows", 
            "title": "Disable Driver Signature Enforcement under Windows 8 / 8.1"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#normal-driver-installation", 
            "text": "First, power up your RePhone by  plugging in the battery  or  power it with external power sources (3.3 ~ 4.2V(no SIM)/3.5 ~ 4.2V(with SIM))  to the battery socket on the Xadow GSM+BLE,  press and hold the power key (PWR) for 2 seconds to   turn it ON  (LED indicator shows  GREEN ), then connect your RePhone to PC with a Micro USB cable.     Open  Device Manager  by clicking the  Start  button, clicking  Control Panel , clicking  System and Security , and then, under  System , clicking  Device Manager . If you re prompted for an administrator password or confirmation, type the password or provide confirmation.\nIn the  Device Manager , you will be seeing unknown devices as shown below:     Right click on one of the unknown devices, choose  Update Driver Software .     Choose  Browse my computer for driver software .     Click  Browse  and the locate the folder which you ve unzipped the Arduino IDE for RePhone .. \\Arduino_IDE_for_RePhone\\drivers\\mtk . Click  Next  to start the driver installation.     When the driver software is successfully installed, you will be able to see the following  complete  page, click  Close  and  start over from step 1 to 6 to install the driver for another unknown device .", 
            "title": "Normal Driver Installation"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver-manually", 
            "text": "You can also install the driver manually:    In  Browse for driver software on your computer  window, click  Let me pick from a list of device drivers on my computer    Then click  Ports(COM LPT)  and go  next    Click  Have Disk    Afterwards,     if you are using  Windows Vista 64bit , locate  Arduino_IDE_for_RePhone-master\\drivers\\mtk\\Vista\\usb2ser_Vista64.inf\\   if you are using  Windows 7 or higher with 64bit , locate  Arduino_IDE_for_RePhone-master\\drivers\\mtk\\Win7\\usb2ser_Win764.inf", 
            "title": "Install the Driver Manually"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver-with-linkit-assist-2502-sdk-2046", 
            "text": "LinkIt Assist 2502 SDK 2.0.46 also provides a driver installation program.   Then find the driver installer in the path  MediaTek_LinkIt_Assist_2502_SDK_2_0_46\\LINKIT_ASSIST_SDK\\Driver\\InstallMTKUSBCOMPortDriver.exe", 
            "title": "Install the Driver with LinkIt Assist 2502 SDK 2.0.46"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#updateflash-the-firmware", 
            "text": "Note \nPlease note that flashing the firmware will delete all the settings and files(images, musics) stored in the RePhone. Take a data backup before you flash/update the firmware.  To make use of the Arduino IDE for RePhone, you have to update/flash the firmware as well. The process is as simple as follows:    Disconnect your RePhone with PC ,  press and hold the power key(PWR) for 2 seconds to turn it OFF  (LED indicator turn  RED  and then goes out)    Open the  FirmwareUpdater.exe  under the path  Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\FirmwareUpdater.exe , be sure your platform on the Firmware Updater is  RePhone  as showing below, if not, click  Others  and locate to  Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\firmware\\LinkIt_Device\\RePhone\\W15.19.p2-uart\\SEEED02A_DEMO_BB.cfg , then click  Download (The Green Button) .     Now you will be asked to connect your RePhone to PC via USB cable, make sure your RePhone has been turned  OFF  and meantime a functional battery should be always connected ( Powered Up).     Wait until the downloading finishes. This might take about 1min, so it may remain stuck at 50% for quite a while, please  be patient .     In the  Complete  page click  OK  to finish the firmware update.", 
            "title": "Update/Flash the Firmware"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#reset-to-default", 
            "text": "Note \nPlease note that resetting your Rephone to default will delete all the settings and files(images, musics) in the RePhone. Take a data backup before you reset it to default.**  To reset your RePhone to  DEFAULT :    Follow the instructions in  Update/Flash the Firmware  section to flash the firmware    Download the RePhone_Create_Kit_VXP file     Enter the  RePhone Mass Storage Mode    Copy everything under the file named  RePhone Create Kit VXP  into the RePhone 5MB mass storage.    Restart your RePhone then its done. As reset would have deleted all the files, you would have to put an mp3 file in the mass storage as well for the use of ringtone.", 
            "title": "Reset to default"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#a-demo-hello-world", 
            "text": "Now you have prepared things required, we are ready to rock on with RePhone.  Let us start with a simple program  Hello World    Press and hold the power key (PWR) for 2 seconds to turn it ON (LED indicator shows GREEN)    Open the  Arduino_IDE_for_RePhone.exe  in the folder where you unzipped the Arduino IDE for RePhone, the software interface is as follows:     Open  Device Manager  to check for the COM ports. There will be  two COM ports :   MTK USB Debug Port is used for uploading code  MTK USB Modem Port is used for logs, like printing messages in the serial monitor with  Serial.println()      On the Arduino IDE window, click  Tool =  Port , select  MTK USB Debug Port , which is  COM20  in this case, the COM number might be different in your PC, just make sure it corresponds to the Debug Port.     On the Arduino IDE window, click  Tool =  Board , select  RePhone     Now copy the following code to your Arduino IDE:  // hello world for test RePhone\n// loovee@10-18-2015\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\u00a0\nvoid loop() {\n    // put your main code here, to run repeatedly:\n    Serial.println(\"Hello World, Hello RePhone!\");\n    delay(100);\n}    Now press the  Upload  button to upload the code to your RePhone. You will see the  Done uploading  when the code is successfully uploaded.     As RePhone uses different COM ports for uploading software and logs, to read the logs, we need to switch the selected COM Port to  MTK USB Modem Port . On the Arduino IDE window, click  Tool =  Port , select  MTK USB Modem Port , which is  COM48  in this case.  Then open the  Serial Monitor .     Now we can see the  Hello World  we have printed with  Serial.println()  .", 
            "title": "A demo: Hello World"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#more-example-code", 
            "text": "Playing with some example code would be a good start if you are heading into some even more interesting projects.    Simply setup your  sketchbook location  in the  preference  as  Arduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk  (where you install the Arduino IDE for RePhone)   then restart the  Arduino_IDE_for_RePhone.exe , you will be able to see the example codes.    You can also find the Arduino example coded manually for all the RePhone modules in the following path: Arduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\\libraries", 
            "title": "More Example Code"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#rephone-community", 
            "text": "We have been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the RePhone Community.  Now join us in the  RePhone Community !  Together we seek answers, make interesting stuff, care about each other, and share our experiences.", 
            "title": "RePhone Community"
        }, 
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#more", 
            "text": "You have done a great job so far! RePhone comes with a big family of modules with different features and functionalities. Go to check the wiki for modules for more applications!", 
            "title": "More"
        }, 
        {
            "location": "/How_to_Install_an_Arduino_Library/", 
            "text": "Note\n\n\nThis tutorial is based on Arduino 1.6.9.\n\n\n\n\nHere we will show you how to install an Arduino library. You should notice that almost all of our library was stored at \nGithub\n. We will provide Arduino library when a product need a library. For some simple product, it\ns no need to write a library such as Grove - Button. \n\n\nFirstly, there\ns a download library button at the page of product. Similar to the below:\n\n\n\n\nClick on the button to start downloading. Seconds you will get a package. \n\n\nIf you get a Github page after click on the button, then you can click on the \nClond or download \n Download ZIP\n button to get the library package.\n\n\n\n\nThen open your Arduino IDE, click on \nSketch \n Include Library \n Aee .ZIP Library\n.\n\n\n\n\nThen let\ns check if the library install correctly.\n\n\nClick on \nFile \n Example \n OLED_Display_96x96-master \n OLED_Hello_World\n to open an example, click on the Verify button, if there\ns no error, congratulation, the library is installed perfectly.", 
            "title": "How to install an Arduino library"
        }, 
        {
            "location": "/MakerPro/", 
            "text": "// to be continued", 
            "title": "Maker Pro"
        }
    ]
}