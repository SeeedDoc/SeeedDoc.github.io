{
    "docs": [
        {
            "location": "/",
            "text": "Seeed Wiki\n\n\nPreview site\n\n\nNot for production use. Internal links to other Wiki pages that are not yet migrated will be inaccessible.",
            "title": "Home"
        },
        {
            "location": "/#seeed-wiki",
            "text": "",
            "title": "Seeed Wiki"
        },
        {
            "location": "/#preview-site",
            "text": "Not for production use. Internal links to other Wiki pages that are not yet migrated will be inaccessible.",
            "title": "Preview site"
        },
        {
            "location": "/Arch_BLE/",
            "text": "Arch BLE\n\n\n\n\nIntroduction\n\n\nArch BLE is an mbed enabled development board based Nordic nRF51822. With Arduino form factor and Grove connectors, it is extremely easy to create a bluetooth low energy device.\n\n\nThe nRF51822 is a powerful multi-protocol single chip solution for ULP wireless applications. It incorporates Nordic\u2019s latest best-in-class performance radio transceiver, an ARM Cortex M0 MCU and 256kB flash + 16kB RAM memory. The nRF51822 supports Bluetooth\u00ae low energy and 2.4 GHz protocol stacks.\n\n\n\n\nFeatures\n\n\n\n\nmbed enabled\n\n\nOnline IDE\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\nCMSIS DAP based on LPC11U35\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS DAP standard\n\n\nUSB virtual serial for communication\n\n\n\n\n\n\nArduino form factor with Grove connectors\n\n\nNordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC\n\n\nARM Cortex M0 processor\n\n\n256kB flash/16kB RAM\n\n\nConfigurable I/O mapping for digital I/O\n\n\n\n\n\n\nUSB Micro B connector\n\n\n\n\nHardware Overview\n\n\n\n\nGet Started\n\n\n\n\n\n\nClick \nthis link\n to \nlogin or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download a compiled hex file.\n\n\nDrag-n-drop the downloaded hex file into the MBED disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1s\n\n\n    #include \"mbed.h\"\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\n\n\nNote\n\nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.\n\n\n\n\nApplications\n\n\n\n\n\n\nColor Pixels, a colorful LED strip, can be controlled by mobile phone.\n\n\n\n\nHardware\n\n\nArch BLE\n\n\nDigital RGB LED Strip\n\n\nAndroid device with BLE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it run\n\n\n\n\nDownload \nBLE_Color_Pixels_Arch_BLE.hex\n\n\nCopy the hex file to the MBED disk of your Arch BLE\n\n\nDownload \nthe Color Pixels Android app\n\n\n\n\n\n\n\n\n\n\n\n\nIf you want to change the program, click \nthis link\n to import the Color Pixels program to mbed online IDE.\n\n\nIf the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)\n\n\n#define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**< Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**< Maximum acceptable connection interval */\n\n\n\n\nUpdate or Restore Firmware\n\n\nThe latest firmware version for the Arch BLE is v0203 built at Oct 08 2014. To check your firmware version and built date, open the MBED.HTM file of your MBED disk in a text editor.\n\n\nChange log:\n\n\n\n\n2014-06-26: First version\n\n\n2014-08-25: Support to drag-n-drop hex file generated by gcc toolchain and without softdevice\n\n\n2014-10-08: Use USB EJECT INSET instead of reconnecting USB, increase intel hex data line buffer (from 64 bytes to 128 bytes)\n\n\n\n\nKnown issues:\n\n\n\n\nIssues when \ndirectly\n downloading the hex file into the MBED disk with the Chrome browser. The reason is Chrome creates a temporary file while downloading. If you are using Chrome, please save the hex file to a different location and \nthen\n copy it to the MBED disk.\n\n\n\n\nFirmware:\n\n\n\n\nThe firmware v0203 2014-10-08 for Arch BLE\n\n\nThe firmware v0203 2014-08-25 for Arch BLE\n\n\n\n\nTo flash a new firmware:\n\n\n\n\nHold the Arch BLE's button and power it ON.\n\n\nA CRP DISABLD disk will pop up.\n\n\nOn Windows, replace firmware.bin with the above firmware.\n\n\nOn Linux/Mac, use command: \ndd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nSchematic pdf\n\n\nEagle file\n\n\nLPC11U35 Firmware\n\n\nSeeed ble color pixels app for Android\n\n\nSources of ble color pixels app\n\n\n\n\nHelp us make it better",
            "title": "Arch BLE"
        },
        {
            "location": "/Arch_BLE/#arch-ble",
            "text": "",
            "title": "Arch BLE"
        },
        {
            "location": "/Arch_BLE/#introduction",
            "text": "Arch BLE is an mbed enabled development board based Nordic nRF51822. With Arduino form factor and Grove connectors, it is extremely easy to create a bluetooth low energy device.  The nRF51822 is a powerful multi-protocol single chip solution for ULP wireless applications. It incorporates Nordic\u2019s latest best-in-class performance radio transceiver, an ARM Cortex M0 MCU and 256kB flash + 16kB RAM memory. The nRF51822 supports Bluetooth\u00ae low energy and 2.4 GHz protocol stacks.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_BLE/#features",
            "text": "mbed enabled  Online IDE  Easy to use C/C++ SDK  Handy libraries    CMSIS DAP based on LPC11U35  Drag-n-drop programming  Debug using CMSIS DAP standard  USB virtual serial for communication    Arduino form factor with Grove connectors  Nordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC  ARM Cortex M0 processor  256kB flash/16kB RAM  Configurable I/O mapping for digital I/O    USB Micro B connector",
            "title": "Features"
        },
        {
            "location": "/Arch_BLE/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_BLE/#get-started",
            "text": "Click  this link  to  login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download a compiled hex file.  Drag-n-drop the downloaded hex file into the MBED disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1s      #include \"mbed.h\"\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }   Note \nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.",
            "title": "Get Started"
        },
        {
            "location": "/Arch_BLE/#applications",
            "text": "Color Pixels, a colorful LED strip, can be controlled by mobile phone.   Hardware  Arch BLE  Digital RGB LED Strip  Android device with BLE         Make it run   Download  BLE_Color_Pixels_Arch_BLE.hex  Copy the hex file to the MBED disk of your Arch BLE  Download  the Color Pixels Android app       If you want to change the program, click  this link  to import the Color Pixels program to mbed online IDE.  If the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)  #define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**< Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**< Maximum acceptable connection interval */",
            "title": "Applications"
        },
        {
            "location": "/Arch_BLE/#update-or-restore-firmware",
            "text": "The latest firmware version for the Arch BLE is v0203 built at Oct 08 2014. To check your firmware version and built date, open the MBED.HTM file of your MBED disk in a text editor.  Change log:   2014-06-26: First version  2014-08-25: Support to drag-n-drop hex file generated by gcc toolchain and without softdevice  2014-10-08: Use USB EJECT INSET instead of reconnecting USB, increase intel hex data line buffer (from 64 bytes to 128 bytes)   Known issues:   Issues when  directly  downloading the hex file into the MBED disk with the Chrome browser. The reason is Chrome creates a temporary file while downloading. If you are using Chrome, please save the hex file to a different location and  then  copy it to the MBED disk.   Firmware:   The firmware v0203 2014-10-08 for Arch BLE  The firmware v0203 2014-08-25 for Arch BLE   To flash a new firmware:   Hold the Arch BLE's button and power it ON.  A CRP DISABLD disk will pop up.  On Windows, replace firmware.bin with the above firmware.  On Linux/Mac, use command:  dd if={new_firmware.bin} of={firmware.bin} conv=notrunc",
            "title": "Update or Restore Firmware"
        },
        {
            "location": "/Arch_BLE/#resources",
            "text": "Schematic pdf  Eagle file  LPC11U35 Firmware  Seeed ble color pixels app for Android  Sources of ble color pixels app",
            "title": "Resources"
        },
        {
            "location": "/Arch_BLE/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_GPRS_V2/",
            "text": "Arch GPRS V2\n\n\n\n\nIntroduction\n\n\nArch GPRS V2 is the new and improved version of the \nArch GPRS\n development board from \nSeeed Studio\n. Like the original \nArch GPRS\n, it is also an \nmbed\n enabled development board that houses a cellular networking module along with a microcontroller. Arch GPRS V2 uses the LPC11U37 Microcontroller instead of the LPC11U24 used in the \nArch GPRS\n. You can use the mbed C/C++ SDK, libraries and optimizing online development tools to rapidly build your Arch GPRS V2 based prototype. The cellular networking module on the Arch GPRS is based on the SIM900 Quad-band GSM/GRPS engine from SIMCom. With this, data collection functions can be performed easily using the 2G GSM/GPRS based cellular network.\nArch GPRS V2 has a standard \nArduino\n interface as well as \nGrove\n connectors on board. It is convenient to connect existing Shields and \nGrove\n products to Arch GPRS V2. You can even connect a solar panel directly to the board to allow the battery to charge from it. A low-power design guarantees easy charging and long hour operations when outdoors!\n\n\n\n\n\n\nNote\n\nArch GPRS V2 does not come with \nan mbed interface\n. To output debug messages, please try \nUSBSerial\n.\n\n\n\n\nFeatures\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nOnline development tools\n\n\nEasy to use C/C++ SDK\n\n\nLots of published libraries, projects\n\n\n\n\n\n\n\n\nNXP LPC11U37 Controller\n\n\n\n\nLow power ARM Cortex-M0 Core\n\n\nOn chip 128KB Flash, 12KB SRAM, 4KB EEPROM\n\n\nUSB Device, UART, I2C\n\n\n\n\n\n\n\n\nSIM900 Module\n\n\n\n\nQuad-band (850/900/1800/1900MHz) GSM/GPRS support\n\n\nSupports external SIM card\uff1a 1.8V/3V\n\n\nControl with standard AT Commands\n\n\n\n\n\n\n\n\nSelect automatically USB5V or Solar panel to charge a battery\n\n\n\n\n\n\nArch GPRS V2 vs Arch GPRS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArch GPRS V2\n\n\nArch GPRS\n\n\n\n\n\n\nMCU\n\n\nLPC11U27\n\n\nLPC11U24\n\n\n\n\n\n\nGSM/GPRS Module\n\n\nSIM900\n\n\nEG-10\n\n\n\n\n\n\nMicroSD Card\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nGetting Started\n\n\n\n\n\n\nLogin into the mbed environment from \nhere\n\n\nImport the \nmbed_blinky\n program\n\n\nVerify that the code imported in main.cpp in the mbed_blinky folder in the mbed online Compiler environment is as indicated in the figure above under Step 3. Ensure that the platform selected for compiling the code for is the Seeeduino-Arch. Now go ahead and compile the code. When asked to save the resultant binary file (.bin), save it to a designated folder on your PC.\n\n\nNow connect your Arch board to your PC and long press the reset button. A removable USB drive named CRP DISABLD should automatically appear on your PC. Go to the CRP DISABLD drive, delete the existing firmware file that you see in the folder and copy the downloaded binary file to CRP DISABLD. Quick press the reset button to run the new binary.\n\n\nVerify that your code is running successfully by looking at the Arch GPRS V2 board. If the right-most LED from the Pinout shown above is blinking and the other 3 LEDs next to it are all ON, this implies that your code is working.\n\n\n\n\nYou can change the code to the following and see what happens:\n\n\n\n    #include \"mbed.h\"\n\n    DigitalOut myled1(LED2); //left most LED if board is held as shown in Pinout diagram above\n    DigitalOut myled2(LED3); //2nd from left\n    DigitalOut myled3(LED4); //3rd from left\n    DigitalOut myled4(LED1); //4th from left (right most)\n\n    int main() {\n        while(1) {\n\n            myled1 = 1; //left most LED turns ON, rest off\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1); //1 sec wait time\n            myled1 = 0;\n            myled2 = 1; //2nd from left LED turns ON, rest off\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 1; //3rd from left LED turns ON, rest off\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 1; //4th from left (right most) LED turns ON, rest off\n\n            wait(1);\n        }\n    }\n\n\n\n\nWhen you Compile and Run the above code on the Arch GPRS V2 board, you should see that the LEDs now blink in sequence.\n\n\nIf you get through the above steps successfully, this means that:\n\n\n\n\nYour Arch GPRS V2 is powering up correctly.\n\n\nYour code is being downloaded and run by the Arch GPRS V2 module correctly.\n\n\nYou are ready to take on more complex projects now!\n\n\n\n\nProgramming Arch on Windows, Linux or Mac\n\n\nArch does not have an mbed interface. It uses USB In-System-Programming (ISP) to upgrade the firmware.\n\n\nTo enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \"CRP DISABLD\" will appear.\n\n\n\n\n\n\nOn windows\n\n\n\n\ndelete firmware.bin in the \"CRP DISABLD\" disk.\n\n\ncopy a new firmware into the disk.\n\n\n\n\n\n\n\n\nOn linux\n\n\n\n\nif the disk is not mounted, mount the disk at \n{mnt_dir}\n\n\ndd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nOn mac you'll need to use Terminal to run the following script to copy you're .bin file to your Arch\n\n\n\n\ndd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nIf you are so inclined, you can also create an \nAutomator\n application to support drag-and-drop of the file to your board. Just create a \"\nRun Shell Script\n\" with the following command:\n\n\ndd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nYou will also need to change the \n\"Pass Input\"\n option from \n\"to stdin\"\n to \n\"as arguments\"\n--without this you will get an error \n\"The action 'Run Shell Script' encountered an error\"\n or \n\"dd: no value specified for if (1)\"\n in the log.\n\n\nAlso, an improved form of the script is:\n\ndd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nWhich should handle spaces in the file path and only uses the first file supplied.\nQuick press the button to run the new firmware.\n\n\nResources\n\n\nSchematic\n\n\n\n\nEagle file for Arch_GPRS_v2.0\n\n\nArch GPRS_v2.0.PDF\n\n\n\n\nApplications and Library\n\n\n\n\nGPRS library\n\n\nUse Seeeduino Arch as a debug adapter to debug another Seeeduino Arch\n\n\nSense environment\n\n\nPlay with Grove RTC\n\n\nPlay with Grove - Ultrasonic ranger\n\n\n\n\nSee also\n\n\n\n\nSIM900 GPRS Module Information\n\n\n\n\nHelp us make it better",
            "title": "Arch GPRS V2"
        },
        {
            "location": "/Arch_GPRS_V2/#arch-gprs-v2",
            "text": "",
            "title": "Arch GPRS V2"
        },
        {
            "location": "/Arch_GPRS_V2/#introduction",
            "text": "Arch GPRS V2 is the new and improved version of the  Arch GPRS  development board from  Seeed Studio . Like the original  Arch GPRS , it is also an  mbed  enabled development board that houses a cellular networking module along with a microcontroller. Arch GPRS V2 uses the LPC11U37 Microcontroller instead of the LPC11U24 used in the  Arch GPRS . You can use the mbed C/C++ SDK, libraries and optimizing online development tools to rapidly build your Arch GPRS V2 based prototype. The cellular networking module on the Arch GPRS is based on the SIM900 Quad-band GSM/GRPS engine from SIMCom. With this, data collection functions can be performed easily using the 2G GSM/GPRS based cellular network.\nArch GPRS V2 has a standard  Arduino  interface as well as  Grove  connectors on board. It is convenient to connect existing Shields and  Grove  products to Arch GPRS V2. You can even connect a solar panel directly to the board to allow the battery to charge from it. A low-power design guarantees easy charging and long hour operations when outdoors!    Note \nArch GPRS V2 does not come with  an mbed interface . To output debug messages, please try  USBSerial .",
            "title": "Introduction"
        },
        {
            "location": "/Arch_GPRS_V2/#features",
            "text": "mbed enabled   Online development tools  Easy to use C/C++ SDK  Lots of published libraries, projects     NXP LPC11U37 Controller   Low power ARM Cortex-M0 Core  On chip 128KB Flash, 12KB SRAM, 4KB EEPROM  USB Device, UART, I2C     SIM900 Module   Quad-band (850/900/1800/1900MHz) GSM/GPRS support  Supports external SIM card\uff1a 1.8V/3V  Control with standard AT Commands     Select automatically USB5V or Solar panel to charge a battery",
            "title": "Features"
        },
        {
            "location": "/Arch_GPRS_V2/#arch-gprs-v2-vs-arch-gprs",
            "text": "Arch GPRS V2  Arch GPRS    MCU  LPC11U27  LPC11U24    GSM/GPRS Module  SIM900  EG-10    MicroSD Card  Yes  No",
            "title": "Arch GPRS V2 vs Arch GPRS"
        },
        {
            "location": "/Arch_GPRS_V2/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_GPRS_V2/#getting-started",
            "text": "Login into the mbed environment from  here  Import the  mbed_blinky  program  Verify that the code imported in main.cpp in the mbed_blinky folder in the mbed online Compiler environment is as indicated in the figure above under Step 3. Ensure that the platform selected for compiling the code for is the Seeeduino-Arch. Now go ahead and compile the code. When asked to save the resultant binary file (.bin), save it to a designated folder on your PC.  Now connect your Arch board to your PC and long press the reset button. A removable USB drive named CRP DISABLD should automatically appear on your PC. Go to the CRP DISABLD drive, delete the existing firmware file that you see in the folder and copy the downloaded binary file to CRP DISABLD. Quick press the reset button to run the new binary.  Verify that your code is running successfully by looking at the Arch GPRS V2 board. If the right-most LED from the Pinout shown above is blinking and the other 3 LEDs next to it are all ON, this implies that your code is working.   You can change the code to the following and see what happens:  \n    #include \"mbed.h\"\n\n    DigitalOut myled1(LED2); //left most LED if board is held as shown in Pinout diagram above\n    DigitalOut myled2(LED3); //2nd from left\n    DigitalOut myled3(LED4); //3rd from left\n    DigitalOut myled4(LED1); //4th from left (right most)\n\n    int main() {\n        while(1) {\n\n            myled1 = 1; //left most LED turns ON, rest off\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1); //1 sec wait time\n            myled1 = 0;\n            myled2 = 1; //2nd from left LED turns ON, rest off\n            myled3 = 0;\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 1; //3rd from left LED turns ON, rest off\n            myled4 = 0;\n\n            wait(1);\n            myled1 = 0;\n            myled2 = 0;\n            myled3 = 0;\n            myled4 = 1; //4th from left (right most) LED turns ON, rest off\n\n            wait(1);\n        }\n    }  When you Compile and Run the above code on the Arch GPRS V2 board, you should see that the LEDs now blink in sequence.  If you get through the above steps successfully, this means that:   Your Arch GPRS V2 is powering up correctly.  Your code is being downloaded and run by the Arch GPRS V2 module correctly.  You are ready to take on more complex projects now!",
            "title": "Getting Started"
        },
        {
            "location": "/Arch_GPRS_V2/#programming-arch-on-windows-linux-or-mac",
            "text": "Arch does not have an mbed interface. It uses USB In-System-Programming (ISP) to upgrade the firmware.  To enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \"CRP DISABLD\" will appear.    On windows   delete firmware.bin in the \"CRP DISABLD\" disk.  copy a new firmware into the disk.     On linux   if the disk is not mounted, mount the disk at  {mnt_dir}  dd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc     On mac you'll need to use Terminal to run the following script to copy you're .bin file to your Arch   dd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc     If you are so inclined, you can also create an  Automator  application to support drag-and-drop of the file to your board. Just create a \" Run Shell Script \" with the following command:  dd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  You will also need to change the  \"Pass Input\"  option from  \"to stdin\"  to  \"as arguments\" --without this you will get an error  \"The action 'Run Shell Script' encountered an error\"  or  \"dd: no value specified for if (1)\"  in the log.  Also, an improved form of the script is: dd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  Which should handle spaces in the file path and only uses the first file supplied.\nQuick press the button to run the new firmware.",
            "title": "Programming Arch on Windows, Linux or Mac"
        },
        {
            "location": "/Arch_GPRS_V2/#resources",
            "text": "Schematic   Eagle file for Arch_GPRS_v2.0  Arch GPRS_v2.0.PDF   Applications and Library   GPRS library  Use Seeeduino Arch as a debug adapter to debug another Seeeduino Arch  Sense environment  Play with Grove RTC  Play with Grove - Ultrasonic ranger   See also   SIM900 GPRS Module Information",
            "title": "Resources"
        },
        {
            "location": "/Arch_GPRS_V2/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_Link/",
            "text": "Arch Link\n\n\n\n\nIntroduction\n\n\nArch Link is an mbed enabled development board based on Nordic nRF51822 and WIZnet W5500 ethernet interface. With Arduino form factor, Grove connectors and micro SD interface, it is extremely easy to create a bluetooth low energy device.\n\n\n\n\nFeatures\n\n\n\n\nmbed enabled\n\n\nOnline IDE\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\nCMSIS DAP based on LPC11U35\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS DAP standard\n\n\nUSB virtual serial for communication\n\n\n\n\n\n\nArduino form factor with Grove connectors\n\n\nI2C and UART connecter on board\n\n\n\n\n\n\nNordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC\n\n\nARM Cortex M0 processor\n\n\n256kB flash/16kB RAM\n\n\nConfigurable I/O mapping for digital I/O\n\n\n\n\n\n\nWIZnet W5500 Ethernet\n\n\nSupports following Hardwired TCP/IP Protocols\u00a0: TCP, UDP, ICMP, IPv4, ARP, IGMP, PPPoE\n\n\nSupports Power down mode\n\n\nSupports Wake on LAN over UDP\n\n\nSupports High Speed Serial Peripheral Interface(SPI MODE 0, 3)\n\n\nInternal 32Kbytes Memory for Tx/Rx Buffers\n\n\n10BaseT/100BaseTX Ethernet PHY embedded\n\n\nwith RJ45 connector\n\n\n\n\n\n\nUSB Micro B connector\n\n\nMicro SD Card connector\n\n\n\n\nHardware Overview\n\n\n\n\nGet Started\n\n\n\n\n\n\nClick \nthis link\n to \nlogin or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download a compiled hex file.\n\n\nDrag-n-drop the downloaded hex file into the MBED disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1s\n\n\n    #include \"mbed.h\"\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\n\n\nNote\n\nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.\n\n\n\n\nApplications\n\n\n\n\n\n\nColor Pixels, a colorful LED strip, can be controlled by mobile phone.\n\n\n\n\nHardware\n\n\nArch Link\n\n\nDigital RGB LED Strip\n\n\nAndroid device with BLE\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMake it run\n\n\n\n\nDownload \nBLE_Color_Pixels_Arch_BLE.hex\n\n\nCopy the hex file to the MBED disk of your Arch BLE\n\n\nDownload \nthe Color Pixels Android app\n\n\n\n\n\n\n\n\nIf you want to change the program, click \nthis link\n to import the Color Pixels program to mbed online IDE.\n\n\nIf the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)\n\n\n#define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**< Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**< Maximum acceptable connection interval */\n\n\n\n\n\n\n\nYou can use the Arch Link as a web dashboard.\n\n\n\n\n\n\n\n\nYou can also use the Arch Link as a Mobile APP dashboard.\n\n\n\n\n\n\n\n\nUpdate or Restore Firmware\n\n\nThe latest firmware version for the Arch Link is v0203 built at Jun 4 2015. To check your firmware version and built date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.\n\n\nChangelog:\n\n\n\n\n2015-06-4 first version\n\n\n\n\nFirmware:\n\n\nThe firmware v0203 2015-06-04 for Arch Link\nTo flash a new firmware:\n\n\n\n\nHold the Arch Link's button and power it ON\n\n\nA CRP DISABLD disk will show up\n\n\nOn Windows, replace firmware.bin with the above firmware\n\n\nOn Linux/Mac, use command: dd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nSchematic pdf\n\n\nEagle file\n\n\nLPC11U35 Firmware\n\n\nSeeed ble color pixels app for android\n\n\nSources of ble color pixels app\n\n\n\n\nSee Also\n\n\n\n\nArch BLE\n\n\nW5500 Ethernet Shield\n\n\n\n\nHelp us make it better",
            "title": "Arch Link"
        },
        {
            "location": "/Arch_Link/#arch-link",
            "text": "",
            "title": "Arch Link"
        },
        {
            "location": "/Arch_Link/#introduction",
            "text": "Arch Link is an mbed enabled development board based on Nordic nRF51822 and WIZnet W5500 ethernet interface. With Arduino form factor, Grove connectors and micro SD interface, it is extremely easy to create a bluetooth low energy device.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_Link/#features",
            "text": "mbed enabled  Online IDE  Easy to use C/C++ SDK  Handy libraries    CMSIS DAP based on LPC11U35  Drag-n-drop programming  Debug using CMSIS DAP standard  USB virtual serial for communication    Arduino form factor with Grove connectors  I2C and UART connecter on board    Nordic nRF51822 Multi-protocol Bluetooth\u00ae 4.0 low energy/2.4GHz RF SoC  ARM Cortex M0 processor  256kB flash/16kB RAM  Configurable I/O mapping for digital I/O    WIZnet W5500 Ethernet  Supports following Hardwired TCP/IP Protocols\u00a0: TCP, UDP, ICMP, IPv4, ARP, IGMP, PPPoE  Supports Power down mode  Supports Wake on LAN over UDP  Supports High Speed Serial Peripheral Interface(SPI MODE 0, 3)  Internal 32Kbytes Memory for Tx/Rx Buffers  10BaseT/100BaseTX Ethernet PHY embedded  with RJ45 connector    USB Micro B connector  Micro SD Card connector",
            "title": "Features"
        },
        {
            "location": "/Arch_Link/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_Link/#get-started",
            "text": "Click  this link  to  login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download a compiled hex file.  Drag-n-drop the downloaded hex file into the MBED disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1s      #include \"mbed.h\"\n\n    DigitalOut led(p30);           // on-board led is connected to p30\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }   Note \nIf you are get a compiling error that 'device.h' is not found, try to update the mbed library to the latest revision in your program.",
            "title": "Get Started"
        },
        {
            "location": "/Arch_Link/#applications",
            "text": "Color Pixels, a colorful LED strip, can be controlled by mobile phone.   Hardware  Arch Link  Digital RGB LED Strip  Android device with BLE         Make it run   Download  BLE_Color_Pixels_Arch_BLE.hex  Copy the hex file to the MBED disk of your Arch BLE  Download  the Color Pixels Android app     If you want to change the program, click  this link  to import the Color Pixels program to mbed online IDE.  If the BLE device is disconnected frequently, we can improve the stability by changing the BLE parameters - Advertising Duration (main.cpp), Min Interval and Max Interval (nRF51822/projectconfig.h)  #define CFG_GAP_CONNECTION_MIN_INTERVAL_MS           20                     /**< Minimum acceptable connection interval */\n#define CFG_GAP_CONNECTION_MAX_INTERVAL_MS          200                     /**< Maximum acceptable connection interval */    You can use the Arch Link as a web dashboard.     You can also use the Arch Link as a Mobile APP dashboard.",
            "title": "Applications"
        },
        {
            "location": "/Arch_Link/#update-or-restore-firmware",
            "text": "The latest firmware version for the Arch Link is v0203 built at Jun 4 2015. To check your firmware version and built date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.  Changelog:   2015-06-4 first version   Firmware:  The firmware v0203 2015-06-04 for Arch Link\nTo flash a new firmware:   Hold the Arch Link's button and power it ON  A CRP DISABLD disk will show up  On Windows, replace firmware.bin with the above firmware  On Linux/Mac, use command: dd if={new_firmware.bin} of={firmware.bin} conv=notrunc",
            "title": "Update or Restore Firmware"
        },
        {
            "location": "/Arch_Link/#resources",
            "text": "Schematic pdf  Eagle file  LPC11U35 Firmware  Seeed ble color pixels app for android  Sources of ble color pixels app",
            "title": "Resources"
        },
        {
            "location": "/Arch_Link/#see-also",
            "text": "Arch BLE  W5500 Ethernet Shield",
            "title": "See Also"
        },
        {
            "location": "/Arch_Link/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_Max_v1.1/",
            "text": "Arch Max v1.1\n\n\n\n\nIntroduction\n\n\nThe Arch Max is a mbed enabled development board for rapid prototyping. It is based on an STM32F407VET6 microcontroller with an ARM Cortex-M4F core running at 168MHz. It provides \nSerial Wire Debug\n(SWD) debug, drag-and-drop programming and USB serial communication.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nName\n\n\nVersion\n\n\nNote\n\n\n\n\n\n\n\n\n\n\nArch Max v1.0\n\n\nv1.0\n\n\n5V cannot be powered by USB, user should connect to ext-power\n\n\n\n\n\n\nArch Max v1.1\n\n\nv1.1\n\n\n5V cannot be powered by USB\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nmbed enabled\n\n\nOnline development tools(include IDE)\n\n\nComplete and straightforward C/C++ SDK\n\n\nMassive examples and tutorials\n\n\n\n\n\n\nHigh-performance STM32F407VET6\n\n\nARM Cortex-M4 MCU with FPU of 168MHz\n\n\n512 KB Flash memory, 192 KB RAM\n\n\n\n\n\n\nOn-board programming and debug\n\n\nDrag-and-drop programming\n\n\nUSB serial communication\n\n\nSWD debug with GDB+ pyOCD/OpenOCD, Keil or IAR\n\n\n\n\n\n\nArduino form factor, compatible with lots of shields\n\n\nBuilt-in Ethernet port, USB and SD card slot for Internet connectivity and data exchange\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nParameter/Item\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nWork Voltage\n\n\n5V\n\n\n\n\n\n\nMicrocontroller\n\n\nSTM32F407VET6\n\n\n\n\n\n\nFlash Memory\n\n\n512KB\n\n\n\n\n\n\nRAM\n\n\n192KB\n\n\n\n\n\n\nUART\n\n\n4\n\n\n\n\n\n\nI2C\n\n\n3\n\n\n\n\n\n\nSPI\n\n\n3\n\n\n\n\n\n\nCAN\n\n\n2\n\n\n\n\n\n\nSDIO\n\n\n1\n\n\n\n\n\n\nCamera interface\n\n\n1\n\n\n\n\n\n\nEth\n\n\n1\n\n\n\n\n\n\nADC Channels\n\n\n8\n\n\n\n\n\n\nI/O pins\n\n\n40\n\n\n\n\n\n\nDigital I/O Max Input Voltage\n\n\n5.0V\n\n\n\n\n\n\nDiameter\n\n\n90mm x 44mm\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nUsage\n\n\n\n\n\n\nClick \nhere\n to login or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nClick the \nCompile\n icon of the top toolbar to compile the program, then download a compiled hex file.\n\n\nDrag-n-drop the downloaded bin file into the mbed disk\n\n\n\n\nYou can open \nmain.cpp\n to change the program. For example, use the following code to blink the LED every 0.1 second\n\n\n    #include \"mbed.h\"\n\n    DigitalOut led(LED1);          // on-board led is connected to D13\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }\n\n\n\n\nDebug\n\n\nTo enable SWD debug or to get debug message through USB Virtual serial, please install \na driver from mbed\n.\n\n\nUpdate or Restore Firmware\n\n\nThe latest firmware version for the Arch Max is v0203 built at Oct 8, 2014. To check your firmware version and built date, open the mbed.HTM file of your mbed disk in a text editor.\n\n\nThe firmware v0203 2014-10-08 for Arch Max\n\n\n\n\nPress and hold the Arch Max's button to power it on.\n\n\nA CRP DISABLD disk will show\n\n\nOn Windows, replace firmware.bin with the above firmware\n\n\nOn Linux/Mac, enter command: \ndd if={new_firmware.bin} of={firmware.bin} conv=notrunc\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nSchematics Eagle file for ARCH Max\n\n\nSchematics PDF file for ARCH Max\n\n\nSTM32F407 datasheet\n\n\n\n\nHelp us make it better",
            "title": "Arch Max v1.1"
        },
        {
            "location": "/Arch_Max_v1.1/#arch-max-v11",
            "text": "",
            "title": "Arch Max v1.1"
        },
        {
            "location": "/Arch_Max_v1.1/#introduction",
            "text": "The Arch Max is a mbed enabled development board for rapid prototyping. It is based on an STM32F407VET6 microcontroller with an ARM Cortex-M4F core running at 168MHz. It provides  Serial Wire Debug (SWD) debug, drag-and-drop programming and USB serial communication.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_Max_v1.1/#version-tracker",
            "text": "Name  Version  Note      Arch Max v1.0  v1.0  5V cannot be powered by USB, user should connect to ext-power    Arch Max v1.1  v1.1  5V cannot be powered by USB",
            "title": "Version Tracker"
        },
        {
            "location": "/Arch_Max_v1.1/#features",
            "text": "mbed enabled  Online development tools(include IDE)  Complete and straightforward C/C++ SDK  Massive examples and tutorials    High-performance STM32F407VET6  ARM Cortex-M4 MCU with FPU of 168MHz  512 KB Flash memory, 192 KB RAM    On-board programming and debug  Drag-and-drop programming  USB serial communication  SWD debug with GDB+ pyOCD/OpenOCD, Keil or IAR    Arduino form factor, compatible with lots of shields  Built-in Ethernet port, USB and SD card slot for Internet connectivity and data exchange",
            "title": "Features"
        },
        {
            "location": "/Arch_Max_v1.1/#specifications",
            "text": "Parameter/Item  Value      Work Voltage  5V    Microcontroller  STM32F407VET6    Flash Memory  512KB    RAM  192KB    UART  4    I2C  3    SPI  3    CAN  2    SDIO  1    Camera interface  1    Eth  1    ADC Channels  8    I/O pins  40    Digital I/O Max Input Voltage  5.0V    Diameter  90mm x 44mm",
            "title": "Specifications"
        },
        {
            "location": "/Arch_Max_v1.1/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_Max_v1.1/#usage",
            "text": "Click  here  to login or signup to mbed  Import the mbed_blinky program  Click the  Compile  icon of the top toolbar to compile the program, then download a compiled hex file.  Drag-n-drop the downloaded bin file into the mbed disk   You can open  main.cpp  to change the program. For example, use the following code to blink the LED every 0.1 second      #include \"mbed.h\"\n\n    DigitalOut led(LED1);          // on-board led is connected to D13\n\n    int main()\n    {\n        while (true) {\n            led =\u00a0!led;\n            wait(0.1);\n        }\n    }",
            "title": "Usage"
        },
        {
            "location": "/Arch_Max_v1.1/#debug",
            "text": "To enable SWD debug or to get debug message through USB Virtual serial, please install  a driver from mbed .",
            "title": "Debug"
        },
        {
            "location": "/Arch_Max_v1.1/#update-or-restore-firmware",
            "text": "The latest firmware version for the Arch Max is v0203 built at Oct 8, 2014. To check your firmware version and built date, open the mbed.HTM file of your mbed disk in a text editor.  The firmware v0203 2014-10-08 for Arch Max   Press and hold the Arch Max's button to power it on.  A CRP DISABLD disk will show  On Windows, replace firmware.bin with the above firmware  On Linux/Mac, enter command:  dd if={new_firmware.bin} of={firmware.bin} conv=notrunc",
            "title": "Update or Restore Firmware"
        },
        {
            "location": "/Arch_Max_v1.1/#resources",
            "text": "Schematics Eagle file for ARCH Max  Schematics PDF file for ARCH Max  STM32F407 datasheet",
            "title": "Resources"
        },
        {
            "location": "/Arch_Max_v1.1/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_Pro/",
            "text": "Arch Pro\n\n\n\n\nIntroduction\n\n\nArch Pro is an mbed enabled development board for rapid prototyping. It is a variant of mbed LPC1768 with built-in Ethernet, USB Host/Device, Grove connectors and Arduino form factor. With a variety of Shield and Grove modules and lots of software libraries for Arch Pro, you can implement Ethernet, USB Host/Device and NFC applications rapidly and easily.\n\n\n\n\nFeatures\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nOnline development tools\n\n\nEasy to use C/C++ SDK\n\n\nHandy libraries\n\n\n\n\n\n\n\n\nArduino form factor with two Grove connectors\n\n\n\n\nDrag-n-drop programming\n\n\nDebug using CMSIS-DAP\n\n\nUSB virtual serial for communication\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nParameter\n\n\nValue/Availability\n\n\n\n\n\n\n\n\n\n\nMCU\n\n\nNXP LPC1768 variant (with ARM Cortex-M3 core)\n\n\n\n\n\n\nClock Speed\n\n\n100 MHz\n\n\n\n\n\n\nFlash\n\n\n512 KB\n\n\n\n\n\n\nRAM\n\n\n64KB\n\n\n\n\n\n\nUART\n\n\n4 No.s\n\n\n\n\n\n\nI2C\n\n\n3 No.s\n\n\n\n\n\n\nSPI\n\n\n2 No.s\n\n\n\n\n\n\nEthernet\n\n\nYes\n\n\n\n\n\n\nUSB Host/Device\n\n\nYes\n\n\n\n\n\n\n\n\nPlatforms Supported\n\n\n\n\nmbed.\n\n\n\n\nApplication Ideas\n\n\n\n\nEthernet\n\n\nUSB Host\n or \nDevice\n\n\nNFC\n\n\nRTOS\n\n\nLua\n\n\n\n\nHardware Overview\n\n\n\n\nThere is \na monochrome version\n for you to print.\n\n\n\n\nNote\n\nThe Arch Pro silkscreen for the Grove connectors is labeled 3V3 on top of the PCB and 5V on the underside. Grove Vcc is by default 3V3, but can be changed to 5V by moving R50 to R51. SPI Vcc pin can be set by populating R52 (3V3) or R53 (5V) with 0R - neither populated by default.\n\n\n\n\nGetting Started\n\n\nAs the Arch Pro is compatible with mbed LPC1768, one can use the mbed C/C++ SDK, libraries and online development tools to rapidly build a prototype.\nHere we show how to light up an LED. This can be done in less than 10 minutes.\n\n\nStep one\uff1a Sign up for an mbed account.\n\n\n\n\nOpen \nmbed.org\n, click Login or signup. If you have already registered, please click login directly.\n\n\n\n\nStep two\uff1a Enter online development tools.\n\n\n\n\nClick Compiler\uff0c it opens the online mbed IDE. Before programming, it is better to read the mbed Complier \nGetting started\n.\n\n\n\n\n\n\nStep three\uff1aEdit code.\n\n\n\n\nClick \"New\" in the left top corner to create a Program and edit a blink program in main.cpp file.\n\n\n\n\n#include \"mbed.h\"\n\u00a0\nDigitalOut  led1(LED1);\n\u00a0\nint main() {\n    while(1) {\n        led1 = !led1; \n        wait(0.5); \n    }\n}\n\n\n\n\nStep four\uff1a Add a device.\n\n\n\n\nClick \u201dNo device selected\u201d in the top right corner, then click \u201dAdd a device\u201d button in the bottom left as seen in the picture below.\n\n\n\n\n\n\nNote\n\nIf you have already used an mbed device, it will be seen in the top right corner instead of \u201dNo device selected\u201d.\n\n\n\n\n\n\n\n\nA pop-up page appears with a list of devices as shown below. Select \u201dmbed LPC1768\u201d.\n\n\n\n\n\n\n\n\nEnter mbed LPC1768 page and click \u201dAdd to mbed Compiler\u201d. Now you have successfully added Mbed LPU1768. Return to mbed compiler page and click \u201dNo device selected\u201d. After you click \"LPC1768\" in the bottom left corner, a screen appears as shown below.\n\n\n\n\n\n\n\n\nYou can see the selected board in mbed online compiler after clicking \u201dSelect Platform\u201d.\n\n\n\n\nStep five\uff1a Compile, download.\n\n\n\n\nClick \"Compile\". On successful compilation, the mbed IDE generates a bin file. Save the bin file on your PC.\n\n\n\n\nStep six\uff1a Update firmware.\n\n\n\n\nConnect the USB interface (next to 'BUTTON') of Arch Pro to your PC using a USB Micro B cable; It automatically appears as a USB device named MBED.\n\n\nCopy the generated bin file to MBED device (on your PC). Now the USB device disappears and reappears.\n\n\nPress BUTTON of Arch Pro, you will see an LED flashing.\n\n\n\n\nDebug\n\n\nTo enable SWD debug or to get debug message through USB Virtual serial, please install \nthe driver from mbed\n.\n\n\nUpdate or Restore Firmware\n\n\nThe latest firmware version for the Arch Pro is v0221 built on Jan 28 2015. To check your firmware version and build date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.\n\n\n\n\n[\nFirmware v221 2015-01-28 for Arch Pro\n] Fix Mac OS X 10.10 Yosemite read only file system bug\n\n\n[\nFirmware v0203 2014-09-02 for Arch Pro\n]\n\n\n\n\nTo update:\n\n\n\n\nA Windows or Linux computer is needed.\n\n\nDownload the latest firmware.\n\n\nPress and hold the Arch Pro's BUTTON and power it ON.\n\n\nA disk named MBED LOADER will appear.\n\n\nDrag-n-drop the downloaded firmware into the disk.\n\n\n\n\n\n\nNotes\n\n\n 1. LocalFileSystem does not work:\nAs the Arch Pro does not have external flash to store files, the LocalFileSystem is not available for this board.\n\n\n\n 2. P0\\_27 & P0\\_28 do not work with DigitalOut:\nP0\\_28 & P0\\_27 are open-drain digital I/O for compatible with I2C. External pull-up resistors are needed to provide output functionality.\n\n\n\n 3. USB Serial Communication:\nIn Windows, install the mbed Windows serial port driver to use USB Serial Communication. Have a look at [Windows Serial Configuration](https://developer.mbed.org/handbook/Windows-serial-configuration)\n\n\n\n\n\nResources\n\n\n\n\nArch Pro V1.0 Schematic PDF\n\n\nArch Pro V1.0 Eagle Files\n\n\nLPC1768 datasheet\n\n\nLPC17xx User Manual\n\n\n\n\nHelp us make it better",
            "title": "Arch Pro"
        },
        {
            "location": "/Arch_Pro/#arch-pro",
            "text": "",
            "title": "Arch Pro"
        },
        {
            "location": "/Arch_Pro/#introduction",
            "text": "Arch Pro is an mbed enabled development board for rapid prototyping. It is a variant of mbed LPC1768 with built-in Ethernet, USB Host/Device, Grove connectors and Arduino form factor. With a variety of Shield and Grove modules and lots of software libraries for Arch Pro, you can implement Ethernet, USB Host/Device and NFC applications rapidly and easily.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_Pro/#features",
            "text": "mbed enabled   Online development tools  Easy to use C/C++ SDK  Handy libraries     Arduino form factor with two Grove connectors   Drag-n-drop programming  Debug using CMSIS-DAP  USB virtual serial for communication",
            "title": "Features"
        },
        {
            "location": "/Arch_Pro/#specifications",
            "text": "Parameter  Value/Availability      MCU  NXP LPC1768 variant (with ARM Cortex-M3 core)    Clock Speed  100 MHz    Flash  512 KB    RAM  64KB    UART  4 No.s    I2C  3 No.s    SPI  2 No.s    Ethernet  Yes    USB Host/Device  Yes",
            "title": "Specifications"
        },
        {
            "location": "/Arch_Pro/#platforms-supported",
            "text": "mbed.",
            "title": "Platforms Supported"
        },
        {
            "location": "/Arch_Pro/#application-ideas",
            "text": "Ethernet  USB Host  or  Device  NFC  RTOS  Lua",
            "title": "Application Ideas"
        },
        {
            "location": "/Arch_Pro/#hardware-overview",
            "text": "There is  a monochrome version  for you to print.   Note \nThe Arch Pro silkscreen for the Grove connectors is labeled 3V3 on top of the PCB and 5V on the underside. Grove Vcc is by default 3V3, but can be changed to 5V by moving R50 to R51. SPI Vcc pin can be set by populating R52 (3V3) or R53 (5V) with 0R - neither populated by default.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_Pro/#getting-started",
            "text": "As the Arch Pro is compatible with mbed LPC1768, one can use the mbed C/C++ SDK, libraries and online development tools to rapidly build a prototype.\nHere we show how to light up an LED. This can be done in less than 10 minutes.  Step one\uff1a Sign up for an mbed account.   Open  mbed.org , click Login or signup. If you have already registered, please click login directly.   Step two\uff1a Enter online development tools.   Click Compiler\uff0c it opens the online mbed IDE. Before programming, it is better to read the mbed Complier  Getting started .    Step three\uff1aEdit code.   Click \"New\" in the left top corner to create a Program and edit a blink program in main.cpp file.   #include \"mbed.h\"\n\u00a0\nDigitalOut  led1(LED1);\n\u00a0\nint main() {\n    while(1) {\n        led1 = !led1; \n        wait(0.5); \n    }\n}  Step four\uff1a Add a device.   Click \u201dNo device selected\u201d in the top right corner, then click \u201dAdd a device\u201d button in the bottom left as seen in the picture below.    Note \nIf you have already used an mbed device, it will be seen in the top right corner instead of \u201dNo device selected\u201d.    A pop-up page appears with a list of devices as shown below. Select \u201dmbed LPC1768\u201d.     Enter mbed LPC1768 page and click \u201dAdd to mbed Compiler\u201d. Now you have successfully added Mbed LPU1768. Return to mbed compiler page and click \u201dNo device selected\u201d. After you click \"LPC1768\" in the bottom left corner, a screen appears as shown below.     You can see the selected board in mbed online compiler after clicking \u201dSelect Platform\u201d.   Step five\uff1a Compile, download.   Click \"Compile\". On successful compilation, the mbed IDE generates a bin file. Save the bin file on your PC.   Step six\uff1a Update firmware.   Connect the USB interface (next to 'BUTTON') of Arch Pro to your PC using a USB Micro B cable; It automatically appears as a USB device named MBED.  Copy the generated bin file to MBED device (on your PC). Now the USB device disappears and reappears.  Press BUTTON of Arch Pro, you will see an LED flashing.",
            "title": "Getting Started"
        },
        {
            "location": "/Arch_Pro/#debug",
            "text": "To enable SWD debug or to get debug message through USB Virtual serial, please install  the driver from mbed .",
            "title": "Debug"
        },
        {
            "location": "/Arch_Pro/#update-or-restore-firmware",
            "text": "The latest firmware version for the Arch Pro is v0221 built on Jan 28 2015. To check your firmware version and build date, open the MBED.HTM or DETAILS.TXT of your MBED disk in a text editor.   [ Firmware v221 2015-01-28 for Arch Pro ] Fix Mac OS X 10.10 Yosemite read only file system bug  [ Firmware v0203 2014-09-02 for Arch Pro ]   To update:   A Windows or Linux computer is needed.  Download the latest firmware.  Press and hold the Arch Pro's BUTTON and power it ON.  A disk named MBED LOADER will appear.  Drag-n-drop the downloaded firmware into the disk.    Notes   1. LocalFileSystem does not work:\nAs the Arch Pro does not have external flash to store files, the LocalFileSystem is not available for this board.   2. P0\\_27 & P0\\_28 do not work with DigitalOut:\nP0\\_28 & P0\\_27 are open-drain digital I/O for compatible with I2C. External pull-up resistors are needed to provide output functionality.   3. USB Serial Communication:\nIn Windows, install the mbed Windows serial port driver to use USB Serial Communication. Have a look at [Windows Serial Configuration](https://developer.mbed.org/handbook/Windows-serial-configuration)",
            "title": "Update or Restore Firmware"
        },
        {
            "location": "/Arch_Pro/#resources",
            "text": "Arch Pro V1.0 Schematic PDF  Arch Pro V1.0 Eagle Files  LPC1768 datasheet  LPC17xx User Manual",
            "title": "Resources"
        },
        {
            "location": "/Arch_Pro/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arch_V1.1/",
            "text": "Arch V1.1\n\n\n\n\nIntroduction\n\n\nArch V1.1 is an mbed enabled development board with Arduino form factor and Grove connectors for rapid prototyping. With a variety of Shield and Grove modules, mbed SDK and lots of software libraries, you can rapidly build a prototype.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRevision\n\n\nDescription\n\n\nRelease Date\n\n\n\n\n\n\n\n\n\n\nSeeeduino Arch V1.0\n\n\n\n\nInitial public release\n\n\n\n\n2013-6-17\n\n\n\n\n\n\nArch V1.1\n\n\n\n\nChange name from Seeeduino Arch to Arch\n\n\nSwitch D13 and D11\n\n\nAdd one Grove connector\n\n\nRemove dual diode\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\n\n\nmbed enabled\n\n\n\n\nonline development tools\n\n\neasy to use C/C++ SDK\n\n\nlots of published libraries, projects\n\n\n\n\n\n\n\n\nArduino form factor, three Grove connectors\n\n\n\n\navailable with 3.3V compatible shields\n\n\na large number of grove modules\n\n\n\n\n\n\nDrag-n-drop programming\n\n\nNXP LPC11U24 MCU\n\n\nLow power ARM Cortex-M0 Core\n\n\n48MHz, 32KB Flash, 8KB RAM, 4KB EEPROM\n\n\nUSB Device, 2xSPI, UART, I2C\n\n\n\n\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\n\n\n\n\n\n\n\n\nWork Voltage\n\n\n7 ~ 12V\n\n\n\n\n\n\nMicrocontroller\n\n\nLPC11U24\n\n\n\n\n\n\nFlash Memory\n\n\n32KB\n\n\n\n\n\n\nEEPROM\n\n\n4KB\n\n\n\n\n\n\nRAM\n\n\n8KB\n\n\n\n\n\n\nUART\n\n\n1\n\n\n\n\n\n\nI2C\n\n\n1\n\n\n\n\n\n\nADC Channels\n\n\n8\n\n\n\n\n\n\nI/O pins\n\n\n40\n\n\n\n\n\n\nDigital I/O Max input voltage\n\n\n5.0V\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nThere is \na monochrome version\n for you to print.\n\n\nGet Started\n\n\n\n\n\n\nClick \nthis link\n to login or signup to mbed\n\n\nImport the mbed_blinky program\n\n\nCoding! Then you can compile the code and download the output binary.\n\n\nNow connect your Arch board to your pc and long press the reset button, it will automatically appear as a USB driver named CRP DISABLD. Go to the CRP DISABLD, delete the firmware file and copy the download binary file to CRP DISABLD. Quick press the reset button to run the new binary.\n\n\n\n\nYou can change the code as following and try again.\n\n\n    #include \"mbed.h\"\n\n    BusOut leds(LED1, LED2, LED3, LED4);\n\n    int main() {\n        uint8_t count = 0;\n        while(1) {\n            leds = count++;\n            wait(1);\n        }\n    }\n\n\n\n\nProgramming Arch on Windows, Linux or Mac\n\n\nArch does not have an mbed interface. It uses USB In-System-Programming(ISP) to upgrade the firmware.\n\n\nTo enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \"CRP DISABLD\" will appear.\n\n\n\n\n\n\nOn Windows\n\n\n\n\ndelete firmware.bin in the \"CRP DISABLD\" disk.\n\n\ncopy a new firmware into the disk.\n\n\n\n\n\n\n\n\nOn Linux\n\n\n\n\nif the disk is not mounted, mount the disk at \n{mnt_dir}\n\n\ndd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nOn Mac you will need to use Terminal to run the following script to copy you're .bin file to your Arch\n\n\n\n\ndd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\n\n\n\n\n\n\nIf you are so inclined, you can also create an \nAutomator\n application to support drag-and-drop of the file to your board. Just create a \"\nRun Shell Script\n\" with the following command:\n\n\ndd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nYou will also need to change the \n\"Pass Input\"\n option from \n\"to stdin\"\n to \n\"as arguments\"\n--without this you will get an error \n\"The action 'Run Shell Script' encountered an error\"\n or \n\"dd: no value specified for if (1)\"\n in the log.\n\n\nAlso, an improved form of the script is:\n\n\ndd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc\n\n\nWhich should handle spaces in the file path and only uses the first file supplied.\n\n\nQuick press the button to run the new firmware.\n\n\nApplications\n\n\n\n\nUse Seeeduino Arch as a debug adapter to debug another Seeeduino Arch\n\n\nSense environment\n\n\nPlay with Grove RTC\n\n\nPlay with Grove - Ultrasonic ranger\n\n\n\n\nResources\n\n\n\n\nSchematics of Arch V1.1\n\n\n\n\nHelp us make it better",
            "title": "Arch V1.1"
        },
        {
            "location": "/Arch_V1.1/#arch-v11",
            "text": "",
            "title": "Arch V1.1"
        },
        {
            "location": "/Arch_V1.1/#introduction",
            "text": "Arch V1.1 is an mbed enabled development board with Arduino form factor and Grove connectors for rapid prototyping. With a variety of Shield and Grove modules, mbed SDK and lots of software libraries, you can rapidly build a prototype.",
            "title": "Introduction"
        },
        {
            "location": "/Arch_V1.1/#version-tracker",
            "text": "Revision  Description  Release Date      Seeeduino Arch V1.0   Initial public release   2013-6-17    Arch V1.1   Change name from Seeeduino Arch to Arch  Switch D13 and D11  Add one Grove connector  Remove dual diode",
            "title": "Version Tracker"
        },
        {
            "location": "/Arch_V1.1/#features",
            "text": "mbed enabled   online development tools  easy to use C/C++ SDK  lots of published libraries, projects     Arduino form factor, three Grove connectors   available with 3.3V compatible shields  a large number of grove modules    Drag-n-drop programming  NXP LPC11U24 MCU  Low power ARM Cortex-M0 Core  48MHz, 32KB Flash, 8KB RAM, 4KB EEPROM  USB Device, 2xSPI, UART, I2C",
            "title": "Features"
        },
        {
            "location": "/Arch_V1.1/#specifications",
            "text": "Item  Typical      Work Voltage  7 ~ 12V    Microcontroller  LPC11U24    Flash Memory  32KB    EEPROM  4KB    RAM  8KB    UART  1    I2C  1    ADC Channels  8    I/O pins  40    Digital I/O Max input voltage  5.0V",
            "title": "Specifications"
        },
        {
            "location": "/Arch_V1.1/#hardware-overview",
            "text": "There is  a monochrome version  for you to print.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Arch_V1.1/#get-started",
            "text": "Click  this link  to login or signup to mbed  Import the mbed_blinky program  Coding! Then you can compile the code and download the output binary.  Now connect your Arch board to your pc and long press the reset button, it will automatically appear as a USB driver named CRP DISABLD. Go to the CRP DISABLD, delete the firmware file and copy the download binary file to CRP DISABLD. Quick press the reset button to run the new binary.   You can change the code as following and try again.      #include \"mbed.h\"\n\n    BusOut leds(LED1, LED2, LED3, LED4);\n\n    int main() {\n        uint8_t count = 0;\n        while(1) {\n            leds = count++;\n            wait(1);\n        }\n    }",
            "title": "Get Started"
        },
        {
            "location": "/Arch_V1.1/#programming-arch-on-windows-linux-or-mac",
            "text": "Arch does not have an mbed interface. It uses USB In-System-Programming(ISP) to upgrade the firmware.  To enter the USB ISP mode, connect the Arch with your computer and long press its button, and then a disk named \"CRP DISABLD\" will appear.    On Windows   delete firmware.bin in the \"CRP DISABLD\" disk.  copy a new firmware into the disk.     On Linux   if the disk is not mounted, mount the disk at  {mnt_dir}  dd if={new_firmware.bin} of={mnt_dir}/firmware.bin conv=notrunc     On Mac you will need to use Terminal to run the following script to copy you're .bin file to your Arch   dd if={new_firmare.bin} of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc     If you are so inclined, you can also create an  Automator  application to support drag-and-drop of the file to your board. Just create a \" Run Shell Script \" with the following command:  dd if=$* of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  You will also need to change the  \"Pass Input\"  option from  \"to stdin\"  to  \"as arguments\" --without this you will get an error  \"The action 'Run Shell Script' encountered an error\"  or  \"dd: no value specified for if (1)\"  in the log.  Also, an improved form of the script is:  dd if=\"${1}\" of=/Volumes/CRP\\ DISABLD/firmware.bin conv=notrunc  Which should handle spaces in the file path and only uses the first file supplied.  Quick press the button to run the new firmware.",
            "title": "Programming Arch on Windows, Linux or Mac"
        },
        {
            "location": "/Arch_V1.1/#applications",
            "text": "Use Seeeduino Arch as a debug adapter to debug another Seeeduino Arch  Sense environment  Play with Grove RTC  Play with Grove - Ultrasonic ranger",
            "title": "Applications"
        },
        {
            "location": "/Arch_V1.1/#resources",
            "text": "Schematics of Arch V1.1",
            "title": "Resources"
        },
        {
            "location": "/Arch_V1.1/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/",
            "text": "Arduino IDE for RePhone Kit\n\n\n\n\nIntroduction\n\n\nRePhone can be a learning tool for you to start interesting projects. Currently, RePhone supports various development environments and development languages, you can build applications either with C/C++ based on Eclipse IDE, Arduino IDE, or with Lua and JavaScript.\n\n\nThis wiki is a User Guide to help you start your RePhone project with Arduino IDE.\n\n\nDownload Arduino IDE for RePhone\n\n\nBefore you download the Arduino IDE for RePhone, make sure you have an operation system as follows:\n\n\nWindows XP/Vista/7/8/8.1\n\n\nWe have put the Arduino IDE for RePhone on our GitHub, and you are quite welcome to send us a 'pull request' to help us optimize and improve it.\n\n\nIf you ever used the Arduino IDE before, then this should be just a piece of cake. If you are not familiar with Arduino, which is fine as well, just follow the instructions, and you will be getting started with Arduino IDE easily and quickly.\n\n\nNow click on\n\n\n\n\nOn the Github page, click the \nDownload ZIP\n to download the file as shown in the image below:\n\n\n\n\nWhen the download is complete, unzip the file to a proper location.\n\n\nInstall the Driver\n\n\nDisable Driver Signature Enforcement under Windows 8 / 8.1\n\n\nIf you are using the Windows8/8.1, you would need to disable \nDriver Signature Enforcement\n first to be able to install the driver.\n\n\nYou should save the files you are editing before trying to turn off the 'Driver Signature Enforcement' as your system will be shut down during the operation.\n\n\nNow follow the instructions below to disable the 'Driver Signature Enforcement.'\n\n\n\n\nPress \u201cWindows Key\u201d +\"R\"\n\n\nEnter shutdown.exe /r /o /f /t 00\n\n\nClick the \"OK\" button.\n\n\nSystem will restart to a \"Choose an option\" screen\n\n\nSelect \"Troubleshoot\" from \"Choose an option\" screen\n\n\nSelect \"Advanced options\" from \"Troubleshoot\" screen\n\n\nSelect \"Windows Startup Settings\" from \"Advanced options\" screen\n\n\nClick \"Restart\" button\n\n\nSystem will restart to \"Advanced Boot Options\" screen\n\n\nSelect \"Disable Driver Signature Enforcement\"\n\n\nOnce the system starts, you can install the Arduino drivers as same as Windows\n\n\n\n\nNormal Driver Installation\n\n\n\n\n\n\nFirst, power up your RePhone by \nplugging in the battery\n or \npower it with external power sources (3.3 ~ 4.2V(no SIM)/3.5 ~ 4.2V(with SIM)) \nto the battery socket on the Xadow GSM+BLE, \npress and hold the power key (PWR) for 2 seconds to\n \nturn it ON\n (LED indicator shows \nGREEN\n), then connect your RePhone to PC with a Micro USB cable.\n\n\n\n\n\n\n\n\nOpen \nDevice Manager\n by clicking the \nStart\n button, clicking \nControl Panel\n, clicking \nSystem and Security\n, and then, under \nSystem\n, clicking \nDevice Manager\n. If you're prompted for an administrator password or confirmation, type the password or provide confirmation.\nIn the \nDevice Manager\n, you will be seeing unknown devices as shown below:\n\n\n\n\n\n\n\n\nRight click on one of the unknown devices, choose \nUpdate Driver Software\n.\n\n\n\n\n\n\n\n\nChoose \nBrowse my computer for driver software\n.\n\n\n\n\n\n\n\n\nClick \nBrowse\n and the locate the folder which you've unzipped the Arduino IDE for RePhone .. \\Arduino_IDE_for_RePhone\\drivers\\mtk . Click \nNext\n to start the driver installation.\n\n\n\n\n\n\n\n\nWhen the driver software is successfully installed, you will be able to see the following \ncomplete\n page, click \nClose\n and \nstart over from step 1 to 6 to install the driver for another unknown device\n.\n\n\n\n\n\n\n\n\nInstall the Driver Manually\n\n\nYou can also install the driver manually:\n\n\n\n\n\n\nIn \"\nBrowse for driver software on your computer\n\" window, click \n\"Let me pick from a list of device drivers on my computer\n\"\n\n\n\n\n\n\nThen click \"\nPorts(COM&LPT)\n\" and go \"\nnext\n\"\n\n\n\n\n\n\nClick \"\nHave Disk\n\"\n\n\n\n\n\n\nAfterwards,\n\n\n\n\n\n\n-- if you are using \nWindows Vista 64bit\n, locate \"\nArduino_IDE_for_RePhone-master\\drivers\\mtk\\Vista\\usb2ser_Vista64.inf\\\n\"\n\n\n-- if you are using \nWindows 7 or higher with 64bit\n, locate \"\nArduino_IDE_for_RePhone-master\\drivers\\mtk\\Win7\\usb2ser_Win764.inf\n\"\n\n\nInstall the Driver with LinkIt Assist 2502 SDK 2.0.46\n\n\nLinkIt Assist 2502 SDK 2.0.46 also provides a driver installation program.\n\n\n\n\nThen find the driver installer in the path \n\"MediaTek_LinkIt_Assist_2502_SDK_2_0_46\\LINKIT_ASSIST_SDK\\Driver\\InstallMTKUSBCOMPortDriver.exe\"\n\n\nUpdate/Flash the Firmware\n\n\n\n\nNote\n\nPlease note that flashing the firmware will delete all the settings and files(images, musics) stored in the RePhone. Take a data backup before you flash/update the firmware.\n\n\n\n\nTo make use of the Arduino IDE for RePhone, you have to update/flash the firmware as well. The process is as simple as follows:\n\n\n\n\n\n\nDisconnect your RePhone with PC\n, \npress and hold the power key(PWR) for 2 seconds to turn it OFF\n (LED indicator turn \nRED\n and then goes out)\n\n\n\n\n\n\nOpen the \nFirmwareUpdater.exe\n under the path \n...Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\FirmwareUpdater.exe\n, be sure your platform on the Firmware Updater is \"\nRePhone\n\" as showing below, if not, click \"\nOthers\n\" and locate to \n...Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\firmware\\LinkIt_Device\\RePhone\\W15.19.p2-uart\\SEEED02A_DEMO_BB.cfg\n, then click \nDownload (The Green Button)\n.\n\n\n\n\n\n\n\n\nNow you will be asked to connect your RePhone to PC via USB cable, make sure your RePhone has been turned \nOFF\n and meantime a functional battery should be always connected ( Powered Up).\n\n\n\n\n\n\n\n\nWait until the downloading finishes. This might take about 1min, so it may remain stuck at 50% for quite a while, please \nbe patient\n.\n\n\n\n\n\n\n\n\nIn the \nComplete\n page click \nOK\n to finish the firmware update.\n\n\n\n\n\n\n\n\nReset to default\n\n\n\n\nNote\n\nPlease note that resetting your Rephone to default will delete all the settings and files(images, musics) in the RePhone. Take a data backup before you reset it to default.**\n\n\n\n\nTo reset your RePhone to \nDEFAULT\n:\n\n\n\n\n\n\nFollow the instructions in \"Update/Flash the Firmware\" section to flash the firmware\n\n\n\n\n\n\nDownload the RePhone_Create_Kit_VXP file\n\n\n\n\n\n\n\n\nEnter the \nRePhone Mass Storage Mode\n\n\n\n\n\n\nCopy everything under the file named \"RePhone Create Kit VXP\" into the RePhone 5MB mass storage.\n\n\n\n\n\n\nRestart your RePhone then its done. As reset would have deleted all the files, you would have to put an mp3 file in the mass storage as well for the use of ringtone.\n\n\n\n\n\n\nA demo: Hello World\n\n\nNow you have prepared things required, we are ready to rock on with RePhone.\n\n\nLet us start with a simple program \nHello World\n\n\n\n\n\n\nPress and hold the power key (PWR) for 2 seconds to turn it ON (LED indicator shows GREEN)\n\n\n\n\n\n\nOpen the \nArduino_IDE_for_RePhone.exe\n in the folder where you unzipped the Arduino IDE for RePhone, the software interface is as follows:\n\n\n\n\n\n\n\n\nOpen \nDevice Manager\n to check for the COM ports. There will be \ntwo COM ports\n:\n\n\n\n\nMTK USB Debug Port is used for uploading code\n\n\nMTK USB Modem Port is used for logs, like printing messages in the serial monitor with \nSerial.println()\n\n\n\n\n\n\n\n\n\n\nOn the Arduino IDE window, click \nTool => Port\n, select \nMTK USB Debug Port\n, which is \nCOM20\n in this case, the COM number might be different in your PC, just make sure it corresponds to the Debug Port.\n\n\n\n\n\n\n\n\nOn the Arduino IDE window, click \nTool => Board\n, select \nRePhone\n\n\n\n\n\n\n\n\nNow copy the following code to your Arduino IDE:\n\n\n// hello world for test RePhone\n// loovee@10-18-2015\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\u00a0\nvoid loop() {\n    // put your main code here, to run repeatedly:\n    Serial.println(\"Hello World, Hello RePhone!\");\n    delay(100);\n}\n\n\n\n\n\n\n\nNow press the \nUpload\n button to upload the code to your RePhone. You will see the \nDone uploading\n when the code is successfully uploaded.\n\n\n\n\n\n\n\n\nAs RePhone uses different COM ports for uploading software and logs, to read the logs, we need to switch the selected COM Port to \nMTK USB Modem Port\n. On the Arduino IDE window, click \nTool => Port\n, select \nMTK USB Modem Port\n, which is \nCOM48\n in this case.\n\n\nThen open the \nSerial Monitor\n.\n\n\n\n\n\n\n\n\nNow we can see the \nHello World\n we have printed with \nSerial.println()\n .\n\n\n\n\n\n\n\n\nMore Example Code\n\n\nPlaying with some example code would be a good start if you are heading into some even more interesting projects.\n\n\n\n\n\n\nSimply setup your \nsketchbook location\n in the \npreference\n as \nArduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\n (where you install the Arduino IDE for RePhone)\n\n\n\n\nthen restart the \nArduino_IDE_for_RePhone.exe\n, you will be able to see the example codes.\n\n\n\n\n\n\n\nYou can also find the Arduino example coded manually for all the RePhone modules in the following path:\n\nArduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\\libraries\n\n\n\n\n\n\n\n\nRePhone Community\n\n\n\n\nWe have been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the RePhone Community.\n\n\nNow join us in the \nRePhone Community\n!\n\n\nTogether we seek answers, make interesting stuff, care about each other, and share our experiences.\n\n\nMore\n\n\nYou have done a great job so far! RePhone comes with a big family of modules with different features and functionalities. Go to check the wiki for modules for more applications!\n\n\nHelp us make it better",
            "title": "Arduino IDE for RePhone Kit"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#arduino-ide-for-rephone-kit",
            "text": "",
            "title": "Arduino IDE for RePhone Kit"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#introduction",
            "text": "RePhone can be a learning tool for you to start interesting projects. Currently, RePhone supports various development environments and development languages, you can build applications either with C/C++ based on Eclipse IDE, Arduino IDE, or with Lua and JavaScript.  This wiki is a User Guide to help you start your RePhone project with Arduino IDE.",
            "title": "Introduction"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#download-arduino-ide-for-rephone",
            "text": "Before you download the Arduino IDE for RePhone, make sure you have an operation system as follows:  Windows XP/Vista/7/8/8.1  We have put the Arduino IDE for RePhone on our GitHub, and you are quite welcome to send us a 'pull request' to help us optimize and improve it.  If you ever used the Arduino IDE before, then this should be just a piece of cake. If you are not familiar with Arduino, which is fine as well, just follow the instructions, and you will be getting started with Arduino IDE easily and quickly.  Now click on   On the Github page, click the  Download ZIP  to download the file as shown in the image below:   When the download is complete, unzip the file to a proper location.",
            "title": "Download Arduino IDE for RePhone"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver",
            "text": "",
            "title": "Install the Driver"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#disable-driver-signature-enforcement-under-windows-8-81",
            "text": "If you are using the Windows8/8.1, you would need to disable  Driver Signature Enforcement  first to be able to install the driver.  You should save the files you are editing before trying to turn off the 'Driver Signature Enforcement' as your system will be shut down during the operation.  Now follow the instructions below to disable the 'Driver Signature Enforcement.'   Press \u201cWindows Key\u201d +\"R\"  Enter shutdown.exe /r /o /f /t 00  Click the \"OK\" button.  System will restart to a \"Choose an option\" screen  Select \"Troubleshoot\" from \"Choose an option\" screen  Select \"Advanced options\" from \"Troubleshoot\" screen  Select \"Windows Startup Settings\" from \"Advanced options\" screen  Click \"Restart\" button  System will restart to \"Advanced Boot Options\" screen  Select \"Disable Driver Signature Enforcement\"  Once the system starts, you can install the Arduino drivers as same as Windows",
            "title": "Disable Driver Signature Enforcement under Windows 8 / 8.1"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#normal-driver-installation",
            "text": "First, power up your RePhone by  plugging in the battery  or  power it with external power sources (3.3 ~ 4.2V(no SIM)/3.5 ~ 4.2V(with SIM))  to the battery socket on the Xadow GSM+BLE,  press and hold the power key (PWR) for 2 seconds to   turn it ON  (LED indicator shows  GREEN ), then connect your RePhone to PC with a Micro USB cable.     Open  Device Manager  by clicking the  Start  button, clicking  Control Panel , clicking  System and Security , and then, under  System , clicking  Device Manager . If you're prompted for an administrator password or confirmation, type the password or provide confirmation.\nIn the  Device Manager , you will be seeing unknown devices as shown below:     Right click on one of the unknown devices, choose  Update Driver Software .     Choose  Browse my computer for driver software .     Click  Browse  and the locate the folder which you've unzipped the Arduino IDE for RePhone .. \\Arduino_IDE_for_RePhone\\drivers\\mtk . Click  Next  to start the driver installation.     When the driver software is successfully installed, you will be able to see the following  complete  page, click  Close  and  start over from step 1 to 6 to install the driver for another unknown device .",
            "title": "Normal Driver Installation"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver-manually",
            "text": "You can also install the driver manually:    In \" Browse for driver software on your computer \" window, click  \"Let me pick from a list of device drivers on my computer \"    Then click \" Ports(COM&LPT) \" and go \" next \"    Click \" Have Disk \"    Afterwards,    -- if you are using  Windows Vista 64bit , locate \" Arduino_IDE_for_RePhone-master\\drivers\\mtk\\Vista\\usb2ser_Vista64.inf\\ \"  -- if you are using  Windows 7 or higher with 64bit , locate \" Arduino_IDE_for_RePhone-master\\drivers\\mtk\\Win7\\usb2ser_Win764.inf \"",
            "title": "Install the Driver Manually"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#install-the-driver-with-linkit-assist-2502-sdk-2046",
            "text": "LinkIt Assist 2502 SDK 2.0.46 also provides a driver installation program.   Then find the driver installer in the path  \"MediaTek_LinkIt_Assist_2502_SDK_2_0_46\\LINKIT_ASSIST_SDK\\Driver\\InstallMTKUSBCOMPortDriver.exe\"",
            "title": "Install the Driver with LinkIt Assist 2502 SDK 2.0.46"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#updateflash-the-firmware",
            "text": "Note \nPlease note that flashing the firmware will delete all the settings and files(images, musics) stored in the RePhone. Take a data backup before you flash/update the firmware.  To make use of the Arduino IDE for RePhone, you have to update/flash the firmware as well. The process is as simple as follows:    Disconnect your RePhone with PC ,  press and hold the power key(PWR) for 2 seconds to turn it OFF  (LED indicator turn  RED  and then goes out)    Open the  FirmwareUpdater.exe  under the path  ...Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\FirmwareUpdater.exe , be sure your platform on the Firmware Updater is \" RePhone \" as showing below, if not, click \" Others \" and locate to  ...Arduino_IDE_for_RePhone\\hardware\\tools\\mtk\\firmware\\LinkIt_Device\\RePhone\\W15.19.p2-uart\\SEEED02A_DEMO_BB.cfg , then click  Download (The Green Button) .     Now you will be asked to connect your RePhone to PC via USB cable, make sure your RePhone has been turned  OFF  and meantime a functional battery should be always connected ( Powered Up).     Wait until the downloading finishes. This might take about 1min, so it may remain stuck at 50% for quite a while, please  be patient .     In the  Complete  page click  OK  to finish the firmware update.",
            "title": "Update/Flash the Firmware"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#reset-to-default",
            "text": "Note \nPlease note that resetting your Rephone to default will delete all the settings and files(images, musics) in the RePhone. Take a data backup before you reset it to default.**  To reset your RePhone to  DEFAULT :    Follow the instructions in \"Update/Flash the Firmware\" section to flash the firmware    Download the RePhone_Create_Kit_VXP file     Enter the  RePhone Mass Storage Mode    Copy everything under the file named \"RePhone Create Kit VXP\" into the RePhone 5MB mass storage.    Restart your RePhone then its done. As reset would have deleted all the files, you would have to put an mp3 file in the mass storage as well for the use of ringtone.",
            "title": "Reset to default"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#a-demo-hello-world",
            "text": "Now you have prepared things required, we are ready to rock on with RePhone.  Let us start with a simple program  Hello World    Press and hold the power key (PWR) for 2 seconds to turn it ON (LED indicator shows GREEN)    Open the  Arduino_IDE_for_RePhone.exe  in the folder where you unzipped the Arduino IDE for RePhone, the software interface is as follows:     Open  Device Manager  to check for the COM ports. There will be  two COM ports :   MTK USB Debug Port is used for uploading code  MTK USB Modem Port is used for logs, like printing messages in the serial monitor with  Serial.println()      On the Arduino IDE window, click  Tool => Port , select  MTK USB Debug Port , which is  COM20  in this case, the COM number might be different in your PC, just make sure it corresponds to the Debug Port.     On the Arduino IDE window, click  Tool => Board , select  RePhone     Now copy the following code to your Arduino IDE:  // hello world for test RePhone\n// loovee@10-18-2015\n\nvoid setup() {\n    Serial.begin(115200);\n}\n\u00a0\nvoid loop() {\n    // put your main code here, to run repeatedly:\n    Serial.println(\"Hello World, Hello RePhone!\");\n    delay(100);\n}    Now press the  Upload  button to upload the code to your RePhone. You will see the  Done uploading  when the code is successfully uploaded.     As RePhone uses different COM ports for uploading software and logs, to read the logs, we need to switch the selected COM Port to  MTK USB Modem Port . On the Arduino IDE window, click  Tool => Port , select  MTK USB Modem Port , which is  COM48  in this case.  Then open the  Serial Monitor .     Now we can see the  Hello World  we have printed with  Serial.println()  .",
            "title": "A demo: Hello World"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#more-example-code",
            "text": "Playing with some example code would be a good start if you are heading into some even more interesting projects.    Simply setup your  sketchbook location  in the  preference  as  Arduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk  (where you install the Arduino IDE for RePhone)   then restart the  Arduino_IDE_for_RePhone.exe , you will be able to see the example codes.    You can also find the Arduino example coded manually for all the RePhone modules in the following path: Arduino_IDE_for_RePhone-master\\hardware\\arduino\\mtk\\libraries",
            "title": "More Example Code"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#rephone-community",
            "text": "We have been looking for a better place where our backers (RePhone Users) can sit together, warmly and comfortably, have conversations about RePhone, discuss technical problems, share ideas/projects, and give feedback on the modules\u2019 development in the future. And then here we go, the RePhone Community.  Now join us in the  RePhone Community !  Together we seek answers, make interesting stuff, care about each other, and share our experiences.",
            "title": "RePhone Community"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#more",
            "text": "You have done a great job so far! RePhone comes with a big family of modules with different features and functionalities. Go to check the wiki for modules for more applications!",
            "title": "More"
        },
        {
            "location": "/Arduino_IDE_for_RePhone_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/",
            "text": "Battery Detector with Polymer Lithium Ion 1050mAh 3.7V\n\n\nIntroduction\n\n\n\n\nBattery Detector with Polymer Lithium Ion 1050mAh 3.8V contains two items: a 1050 mAh lithium-ion battery and a battery power detector to measure the power remain in a li-ion battery.\n\n\nThe li-ion battery is very slim, light and cost effective. It output 3.7 V voltage(nominal). You can also charge it with a specialized charger which has maximum input current 1050 mA and maximum input voltage 4.2V. This battery comes with pre-attached JST 2.0 connector which is handy to click in and out. It also has built-in overcurrent protection to protect against output short circuit. \nAlthough, please still take caution and do not abuse the battery in usage. Never charge or use it unattended.\n\n\nThe battery power detector can detect the input voltage range of 3\u20134.2 volts. There are three JST sockets (JST 1.0, JST 2.0 and JST 2.0) and two battery-soldering pads will adapt to those batteries with a different connector. As you connect a battery to this battery power detector, the on-board four LEDs will indicate remaining power in percentage (0\u201325%, 26\u201350%, 51\u201375%, 76\u2013100%). Another LED will be on if you plug the connector of battery in the wrong way.\n\n\n\n\n\n\nNotes\n\n\n 1. There is only one battery reliable to be tested at the same time.\n\n\n 2. It will damage this battery power detector as the input voltage is above 9 volts.\n\n\n 3. Never use the battery when it is being charged.\n\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nProduct revision\n\n\nRelease date\n\n\nSupport status\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nBattery Detector with Polymer Lithium Ion 1050mAh 3.8V(current version)\n\n\nMay 2016\n\n\nSupported\n\n\nNone\n\n\n\n\n\n\n\n\nFeatures\n\n\nFor battery\n\n\n\n\nFor Pre-attached JST 2.0 connector\n\n\nShort circuit protection for output circuit\n\n\nCost-effective\n\n\n\n\nFor battery power detector\n\n\n\n\nVisual indication on remaining power of a battery\n\n\nDifferent JST sockets for different battery connectors\n\n\n\n\nSpecifications\n\n\nFor battery\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCapacity\n\n\n1050 mAh\n\n\n\n\n\n\nNominal output voltage(DC)\n\n\n3.7 volts\n\n\n\n\n\n\nConnector\n\n\nJST 2.0\n\n\n\n\n\n\nMaximum Charge Current\n\n\n1050 mA\n\n\n\n\n\n\nProtection\n\n\nShort circuit protection for output circuit\n\n\n\n\n\n\nWeight\n\n\n19 g, the whole package weighs 33.5 g.\n\n\n\n\n\n\nDimensions\n\n\n48(width)\u00d74.9(height)\u00d745(depth) mm\n\n\n\n\n\n\n\n\nFor battery power detector\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput voltage\n\n\n3 \u2013 4.2V\n\n\n\n\n\n\nOperating current\n\n\n15 mA\n\n\n\n\n\n\nIndication manner\n\n\nFour LEDs (we will detail it later)\n\n\n\n\n\n\nSockets\n\n\nThree sockets for different battery connector and two battery-soldering pads (we will detail it later)\n\n\n\n\n\n\nDimensions\n\n\n30(width)\u00d725(depth) mm\n\n\n\n\n\n\nCN1185\n\n\nDatasheet\n\n\n\n\n\n\nWeight\n\n\n3.2 g\n\n\n\n\n\n\nNotes\n\n\nOnly connect a single battery to this module; The input voltage to this module should be less than 9 volts, or it will damage this module.\n\n\n\n\n\n\n\n\nPlatforms supported(only for battery)\n\n\n\n\n\n\n\nPlatform\n\n\n\n\nSeeeduino/Arduino\n\n\n\n\nRasberry Pi\n\n\n\n\nBeaglebone\n\n\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\nSupported status\n\n\n\n\nSupported\n\n\n\n\nNot supported\n\n\n\n\nSupported(only with \nGrove Base Cape for Beaglebone\n)\n\n\n\n\nNot supported\n\n\n\n\n\n\n\n\nNotes\n\n\n\n\nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform.\n\n\n\n\n\n\n\nHardware Overview\n\n\nThis section shows descriptions for components on battery power detector.\n\n\n\n\n\n\nCN1185\n, a voltage monitoring circuit.\n\n\nBattery-soldering pads\n, to solder battery's leads on.\n\n\n\n\nPackage includes\n(main parts)\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nLi-ion battery\n\n\n1 piece\n\n\n\n\n\n\nBattery power detector\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\n\nConnect battery and battery power detector as in the following image. You can see LEDs are \nON\n indicates actual power remains.\n\n\n\n\nResources\n\n\n\n\nSchematic(Eagle) file\n\n\nCN1185 Datasheet\n\n\nBattery Usage Datasheet\n\n\nBattery Safety Datasheet and Certificates\n\n\n\n\nHelp us make it better",
            "title": "Battery Detector with Polymer Lithium Ion 1050mAh 3.7V"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#battery-detector-with-polymer-lithium-ion-1050mah-37v",
            "text": "",
            "title": "Battery Detector with Polymer Lithium Ion 1050mAh 3.7V"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#introduction",
            "text": "Battery Detector with Polymer Lithium Ion 1050mAh 3.8V contains two items: a 1050 mAh lithium-ion battery and a battery power detector to measure the power remain in a li-ion battery.  The li-ion battery is very slim, light and cost effective. It output 3.7 V voltage(nominal). You can also charge it with a specialized charger which has maximum input current 1050 mA and maximum input voltage 4.2V. This battery comes with pre-attached JST 2.0 connector which is handy to click in and out. It also has built-in overcurrent protection to protect against output short circuit.  Although, please still take caution and do not abuse the battery in usage. Never charge or use it unattended.  The battery power detector can detect the input voltage range of 3\u20134.2 volts. There are three JST sockets (JST 1.0, JST 2.0 and JST 2.0) and two battery-soldering pads will adapt to those batteries with a different connector. As you connect a battery to this battery power detector, the on-board four LEDs will indicate remaining power in percentage (0\u201325%, 26\u201350%, 51\u201375%, 76\u2013100%). Another LED will be on if you plug the connector of battery in the wrong way.    Notes   1. There is only one battery reliable to be tested at the same time.   2. It will damage this battery power detector as the input voltage is above 9 volts.   3. Never use the battery when it is being charged.",
            "title": "Introduction"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#version-tracker",
            "text": "Product revision  Release date  Support status  Notes      Battery Detector with Polymer Lithium Ion 1050mAh 3.8V(current version)  May 2016  Supported  None",
            "title": "Version Tracker"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#features",
            "text": "For battery   For Pre-attached JST 2.0 connector  Short circuit protection for output circuit  Cost-effective   For battery power detector   Visual indication on remaining power of a battery  Different JST sockets for different battery connectors",
            "title": "Features"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#specifications",
            "text": "For battery           Capacity  1050 mAh    Nominal output voltage(DC)  3.7 volts    Connector  JST 2.0    Maximum Charge Current  1050 mA    Protection  Short circuit protection for output circuit    Weight  19 g, the whole package weighs 33.5 g.    Dimensions  48(width)\u00d74.9(height)\u00d745(depth) mm     For battery power detector           Input voltage  3 \u2013 4.2V    Operating current  15 mA    Indication manner  Four LEDs (we will detail it later)    Sockets  Three sockets for different battery connector and two battery-soldering pads (we will detail it later)    Dimensions  30(width)\u00d725(depth) mm    CN1185  Datasheet    Weight  3.2 g    Notes  Only connect a single battery to this module; The input voltage to this module should be less than 9 volts, or it will damage this module.",
            "title": "Specifications"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#platforms-supportedonly-for-battery",
            "text": "Platform  \nSeeeduino/Arduino  \nRasberry Pi  \nBeaglebone  \nLinkIt ONE    \nSupported status  \nSupported  \nNot supported  \nSupported(only with  Grove Base Cape for Beaglebone )  \nNot supported    \nNotes  \nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform.",
            "title": "Platforms supported(only for battery)"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#hardware-overview",
            "text": "This section shows descriptions for components on battery power detector.    CN1185 , a voltage monitoring circuit.  Battery-soldering pads , to solder battery's leads on.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#package-includesmain-parts",
            "text": "Parts name  Quantity      Li-ion battery  1 piece    Battery power detector  1 piece",
            "title": "Package includes(main parts)"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#getting-started",
            "text": "Connect battery and battery power detector as in the following image. You can see LEDs are  ON  indicates actual power remains.",
            "title": "Getting Started"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#resources",
            "text": "Schematic(Eagle) file  CN1185 Datasheet  Battery Usage Datasheet  Battery Safety Datasheet and Certificates",
            "title": "Resources"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_1050mAh_3.7V/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/",
            "text": "Battery Detector with Polymer Lithium Ion 5100mAh 3.8V\n\n\nIntroduction\n\n\n\n\nBattery Detector with Polymer Lithium Ion 5100mAh 3.8V contains two items: a 1050 mAh lithium-ion battery and a battery power detector to measure the power remain in a li-ion battery.\n\n\nThe li-ion battery is very slim, light and cost effective. It output 3.8 V voltage(nominal). You can also charge it with a specialized charger which has maximum input current 5100 mA and maximum input voltage 4.2V. This battery comes with pre-attached JST 2.0 connector which is handy to click in and out. It also has built-in overcurrent protection to protect against output short circuit. \nAlthough, please still take caution and do not abuse the battery in usage. Never charge or use it unattended.\n\n\nThe battery power detector can detect the input voltage range of 3\u20134.2 volts. There are three JST sockets (JST 1.0, JST 2.0 and JST 2.0) and two battery-soldering pads will adapt to those batteries with a different connector. As you connect a battery to this battery power detector, the on-board four LEDs will indicate remaining power in percentage (0\u201325%, 26\u201350%, 51\u201375%, 76\u2013100%). Another LED will be on if you plug the connector of battery in the wrong way.\n\n\n\n\n\n\nNotes\n\n\n 1. There is only one battery reliable to be tested at the same time.\n\n\n 2. It will damage this battery power detector as the input voltage is above 9 volts.\n\n\n 3. Never use the battery when it is being charged.\n\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nProduct revision\n\n\nRelease date\n\n\nSupport status\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nBattery Detector with Polymer Lithium Ion 1050mAh 3.8V(current version)\n\n\nMay 2016\n\n\nSupported\n\n\nNone\n\n\n\n\n\n\n\n\nFeatures\n\n\nFor battery\n\n\n\n\nFor Pre-attached JST 2.0 connector\n\n\nShort circuit protection for output circuit\n\n\nCost-effective\n\n\n\n\nFor battery power detector\n\n\n\n\nVisual indication on remaining power of a battery\n\n\nDifferent JST sockets for different battery connectors\n\n\n\n\nSpecifications\n\n\nFor battery\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCapacity\n\n\n5100 mAh\n\n\n\n\n\n\nNominal output voltage(DC)\n\n\n3.8 volts\n\n\n\n\n\n\nConnector\n\n\nJST 2.0\n\n\n\n\n\n\nMaximum Charge Current\n\n\n2500 mA\n\n\n\n\n\n\nProtection\n\n\nShort circuit protection for output circuit\n\n\n\n\n\n\nWeight\n\n\n76 g, the whole package weighs 91 g.\n\n\n\n\n\n\nDimensions\n\n\n59.8(width)\u00d710.8(height)\u00d759.5(depth) mm\n\n\n\n\n\n\n\n\nFor battery power detector\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput voltage\n\n\n3 \u2013 4.2V\n\n\n\n\n\n\nOperating current\n\n\n15 mA\n\n\n\n\n\n\nIndication manner\n\n\nFour LEDs (we will detail it later)\n\n\n\n\n\n\nSockets\n\n\nThree sockets for different battery connector and two battery-soldering pads (we will detail it later)\n\n\n\n\n\n\nDimensions\n\n\n30(width)\u00d725(depth) mm\n\n\n\n\n\n\nCN1185\n\n\nDatasheet\n\n\n\n\n\n\nWeight\n\n\n3.2 g\n\n\n\n\n\n\nNotes\n\n\nOnly connect a single battery to this module; The input voltage to this module should be less than 9 volts, or it will damage this module.\n\n\n\n\n\n\n\n\nPlatforms supported(only for battery)\n\n\n\n\n\n\n\nPlatform\n\n\n\n\nSeeeduino/Arduino\n\n\n\n\nRasberry Pi\n\n\n\n\nBeaglebone\n\n\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\nSupported status\n\n\n\n\nSupported\n\n\n\n\nNot supported\n\n\n\n\nSupported(only with \nGrove Base Cape for Beaglebone\n)\n\n\n\n\nNot supported\n\n\n\n\n\n\n\n\nNotes\n\n\n\n\nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform.\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\n\n\nCN1185\n, a voltage monitoring circuit.\n\n\nBattery-soldering pads\n, to solder battery's leads on.\n\n\n\n\nPackage includes\n(main parts)\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nLi-ion battery\n\n\n1 piece\n\n\n\n\n\n\nBattery power detector\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\n\nConnect battery and battery power detector as in the following image. You can see LEDs are \nON\n indicates actual power remains.\n\n\n\n\n\n\n\nResources\n\n\n\n\nSchematic(Eagle) file\n\n\nCN1185 Datasheet\n\n\nBattery Datasheet\n\n\nCertifications and Test Report for this Battery\n\n\n\n\nHelp us make it better",
            "title": "Battery Detector with Polymer Lithium Ion 5100mAh 3.8V"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#battery-detector-with-polymer-lithium-ion-5100mah-38v",
            "text": "",
            "title": "Battery Detector with Polymer Lithium Ion 5100mAh 3.8V"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#introduction",
            "text": "Battery Detector with Polymer Lithium Ion 5100mAh 3.8V contains two items: a 1050 mAh lithium-ion battery and a battery power detector to measure the power remain in a li-ion battery.  The li-ion battery is very slim, light and cost effective. It output 3.8 V voltage(nominal). You can also charge it with a specialized charger which has maximum input current 5100 mA and maximum input voltage 4.2V. This battery comes with pre-attached JST 2.0 connector which is handy to click in and out. It also has built-in overcurrent protection to protect against output short circuit.  Although, please still take caution and do not abuse the battery in usage. Never charge or use it unattended.  The battery power detector can detect the input voltage range of 3\u20134.2 volts. There are three JST sockets (JST 1.0, JST 2.0 and JST 2.0) and two battery-soldering pads will adapt to those batteries with a different connector. As you connect a battery to this battery power detector, the on-board four LEDs will indicate remaining power in percentage (0\u201325%, 26\u201350%, 51\u201375%, 76\u2013100%). Another LED will be on if you plug the connector of battery in the wrong way.    Notes   1. There is only one battery reliable to be tested at the same time.   2. It will damage this battery power detector as the input voltage is above 9 volts.   3. Never use the battery when it is being charged.",
            "title": "Introduction"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#version-tracker",
            "text": "Product revision  Release date  Support status  Notes      Battery Detector with Polymer Lithium Ion 1050mAh 3.8V(current version)  May 2016  Supported  None",
            "title": "Version Tracker"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#features",
            "text": "For battery   For Pre-attached JST 2.0 connector  Short circuit protection for output circuit  Cost-effective   For battery power detector   Visual indication on remaining power of a battery  Different JST sockets for different battery connectors",
            "title": "Features"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#specifications",
            "text": "For battery           Capacity  5100 mAh    Nominal output voltage(DC)  3.8 volts    Connector  JST 2.0    Maximum Charge Current  2500 mA    Protection  Short circuit protection for output circuit    Weight  76 g, the whole package weighs 91 g.    Dimensions  59.8(width)\u00d710.8(height)\u00d759.5(depth) mm     For battery power detector           Input voltage  3 \u2013 4.2V    Operating current  15 mA    Indication manner  Four LEDs (we will detail it later)    Sockets  Three sockets for different battery connector and two battery-soldering pads (we will detail it later)    Dimensions  30(width)\u00d725(depth) mm    CN1185  Datasheet    Weight  3.2 g    Notes  Only connect a single battery to this module; The input voltage to this module should be less than 9 volts, or it will damage this module.",
            "title": "Specifications"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#platforms-supportedonly-for-battery",
            "text": "Platform  \nSeeeduino/Arduino  \nRasberry Pi  \nBeaglebone  \nLinkIt ONE    \nSupported status  \nSupported  \nNot supported  \nSupported(only with  Grove Base Cape for Beaglebone )  \nNot supported    \nNotes  \nIf no version number is mentioned for a specific platform, it means this product supports all versions within this platform.",
            "title": "Platforms supported(only for battery)"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#hardware-overview",
            "text": "CN1185 , a voltage monitoring circuit.  Battery-soldering pads , to solder battery's leads on.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#package-includesmain-parts",
            "text": "Parts name  Quantity      Li-ion battery  1 piece    Battery power detector  1 piece",
            "title": "Package includes(main parts)"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#getting-started",
            "text": "Connect battery and battery power detector as in the following image. You can see LEDs are  ON  indicates actual power remains.",
            "title": "Getting Started"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#resources",
            "text": "Schematic(Eagle) file  CN1185 Datasheet  Battery Datasheet  Certifications and Test Report for this Battery",
            "title": "Resources"
        },
        {
            "location": "/Battery_Detector_with_Polymer_Lithium_Ion_5100mAh_3.8V/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/",
            "text": "BeagleBone Green HDMI Cape\n\n\nIntroduction\n\n\n\n\nBeagleBone Green HDMI Cape\n is a general integrated HDMI connector for expanding your BeagleBone to a rich variety of peripherals such as computer monitor, video projector, digital television, or digital audio device. This board features a standard HDMI receptacle that can be connected to a monitor with a standard HDMI-to-HDMI cable. All HD signals are supported, and the output resolution is 1280\u00d7720. It also can be used to transmit audio information. This product will make your applications based on BeagleBone board more versatile for different circumstances.\n\n\n\n\nFeatures\n\n\n\n\nPlug and play.\n\n\nAdapter to different input signal.\n\n\n720P(1280\u00d7720) output resolution.\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput voltage\n\n\n5V/3.3V\n\n\n\n\n\n\nMaxium operating current\n\n\n80 mA\n\n\n\n\n\n\nHDMI version\n\n\nVersion 1.2\n\n\n\n\n\n\nMaxium Output resolution\n\n\n1280x720 @60Hz\n\n\n\n\n\n\nAudio transmission\n\n\nAvailable\n\n\n\n\n\n\nChip\n\n\nIT66121 HDMI Framer(\nDatasheet\n)\n\n\n\n\n\n\n\n\nPlatforms supported\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlatform\n\n\nSupported status\n\n\n\n\n\n\nBeagleBone\n\n\nSupported\n\n\n\n\n\n\n\n\nApplication ideas\n\n\nYou can expand your BeagleBone to more multimedia peripherals such computer monitor, video projector, digital television, or digital audio device.\n\n\nHardware Overview\n\n\n\n\nIT66121 HDMI Framer\n\n\n\n\nHDMI Transmitter\n\n\n\n\nCape I2C address Switch\n\n\n\n\nTo switch between different cape address identifier.\n\n\n\n\nCape EEPROM\n\n\n\n\nEEPROM memory for this cape.\n\n\n\n\nHDMI Connector\n\n\nParts list\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\nBeagleBone Green HDMI Cape\n\n\n1\n\n\n\n\n\n\n\n\nGet started\n\n\nThis part will show you how to start with this product in a few steps.\n\n\nPreparations\n\n\n\n\nBeagleBone Green board(with OS \nInstalled first\n) \u00d7 1.\n\n\nUSB cable (type A to micro type B) \u00d7 1.\n\n\nStandard HDMI cable(type A to type A) \u00d7 1.\n\n\n\n\nHardware Connection\n\n\n\n\n\n\nNote\n\nWe use Windows 7 in this case. After connection work is done, plug a computer mouse into USB interface on BeagleBone Green board.\n\n\n\n\nPlug USB cable(type C end) to your PC, you will find that a BeagleBone desktop is shown on your computer monitor.\n\n\nThen you can use BeagleBone like a PC or a Mac.\n\n\n\n\nTrouble shooting\n\n\n\n\n\n\nNo BeagleBone desktop operation system is shown on the computer monitor? Try one of following steps.\n\n\n\n\nPower down the monitor and restart it.\n\n\nPress RESET button on BeagleBone Green board.\n\n\nPress POWER button on BeagleBone Green board and then press it again.\n\n\n\n\n\n\n\n\n\n\nThe computer mouse does not work(not powered)?\n\n\n\n\nPress RESET button on BeagleBone Green board and wait it to launch.\n\n\n\n\n\n\n\n\nHow disassemble BeagleBone Green HDMI Cape quickly?\n\n\n\n\nPull(with your hand) the end with HDMI receptacle out first, then pull the other end out. Repeat previous two steps again if it is necessary.\n\n\n\n\n\n\n\n\nDemo\n\n\nThis \nvideo\n shows how to use BeagleBone Green HDMI Cape to surfing Internet and play audio.\n\n\nResources\n\n\n\n\nSchematic files\n\n\n\n\nHelp us make it better",
            "title": "BeagleBone Green HDMI Cape"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#beaglebone-green-hdmi-cape",
            "text": "",
            "title": "BeagleBone Green HDMI Cape"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#introduction",
            "text": "BeagleBone Green HDMI Cape  is a general integrated HDMI connector for expanding your BeagleBone to a rich variety of peripherals such as computer monitor, video projector, digital television, or digital audio device. This board features a standard HDMI receptacle that can be connected to a monitor with a standard HDMI-to-HDMI cable. All HD signals are supported, and the output resolution is 1280\u00d7720. It also can be used to transmit audio information. This product will make your applications based on BeagleBone board more versatile for different circumstances.",
            "title": "Introduction"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#features",
            "text": "Plug and play.  Adapter to different input signal.  720P(1280\u00d7720) output resolution.",
            "title": "Features"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#specifications",
            "text": "Input voltage  5V/3.3V    Maxium operating current  80 mA    HDMI version  Version 1.2    Maxium Output resolution  1280x720 @60Hz    Audio transmission  Available    Chip  IT66121 HDMI Framer( Datasheet )",
            "title": "Specifications"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#platforms-supported",
            "text": "Platform  Supported status    BeagleBone  Supported",
            "title": "Platforms supported"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#application-ideas",
            "text": "You can expand your BeagleBone to more multimedia peripherals such computer monitor, video projector, digital television, or digital audio device.",
            "title": "Application ideas"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#hardware-overview",
            "text": "IT66121 HDMI Framer   HDMI Transmitter   Cape I2C address Switch   To switch between different cape address identifier.   Cape EEPROM   EEPROM memory for this cape.   HDMI Connector",
            "title": "Hardware Overview"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#parts-list",
            "text": "Parts name  Quantity    BeagleBone Green HDMI Cape  1",
            "title": "Parts list"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#get-started",
            "text": "This part will show you how to start with this product in a few steps.",
            "title": "Get started"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#preparations",
            "text": "BeagleBone Green board(with OS  Installed first ) \u00d7 1.  USB cable (type A to micro type B) \u00d7 1.  Standard HDMI cable(type A to type A) \u00d7 1.",
            "title": "Preparations"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#hardware-connection",
            "text": "Note \nWe use Windows 7 in this case. After connection work is done, plug a computer mouse into USB interface on BeagleBone Green board.  Plug USB cable(type C end) to your PC, you will find that a BeagleBone desktop is shown on your computer monitor.  Then you can use BeagleBone like a PC or a Mac.",
            "title": "Hardware Connection"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#trouble-shooting",
            "text": "No BeagleBone desktop operation system is shown on the computer monitor? Try one of following steps.   Power down the monitor and restart it.  Press RESET button on BeagleBone Green board.  Press POWER button on BeagleBone Green board and then press it again.      The computer mouse does not work(not powered)?   Press RESET button on BeagleBone Green board and wait it to launch.     How disassemble BeagleBone Green HDMI Cape quickly?   Pull(with your hand) the end with HDMI receptacle out first, then pull the other end out. Repeat previous two steps again if it is necessary.",
            "title": "Trouble shooting"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#demo",
            "text": "This  video  shows how to use BeagleBone Green HDMI Cape to surfing Internet and play audio.",
            "title": "Demo"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#resources",
            "text": "Schematic files",
            "title": "Resources"
        },
        {
            "location": "/BeagleBone_Green_HDMI_Cape/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/",
            "text": "Beagle Bone Green and Grove IoT Starter Kit Powered by AWS\n\n\nIntroduction\n\n\n\n\nMain articles: Start here \nGrove IoT Starter Kits Powered by AWS\n , \nBeaglebone Green\n\n\nBeagleBone Green\n (BBG) is a joint effort by BeagleBoard.org and Seeed Studio. It is based on the open-source hardware design of \nBeagleBone Black\n and has added two Grove connectors. The kit contains the new BBG, 10 Grove modules as well as step-by-step tutorials to hook them up quickly. The Grove IoT Starter Kit includes most frequently used sensors and actuators to turn your ideas into tangible applications with AWS Cloud computing.\n\n\n\n\nFeatures\n\n\n\n\nOut-of-box, plug and play, no breadboard or soldering\n\n\nFully compliant with AWS Services and AWS best practices\n\n\nStep-by-step tutorials for developers and makers to get started quickly\n\n\n\n\nIncluded in the Box\n\n\n\n\n\n\n\n\n\n\nBoard/Part\n\n\nQty\n\n\nDocumentation\n\n\n\n\n\n\n\n\n\n\nBeagleBone Green\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - I2C ADC\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - I2C Hub\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Relay\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Buzzer\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - OLED Display 0.96'\n'\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Button\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Temperature Sensor\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Sound Sensor\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b116g)\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nGrove - Chainable RGB LED\n\n\n1\n\n\nRead Here\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1\n\n\n\n\n\n\n\n\n\n\nGetting Started\n\n\nConfigure Your AWS IoT Service\n\n\nAt the very beginning, we need to get an AWS IoT service account, and do some configuring.\n\n\n\n\nCreate an \nAWS Account\n\n\n\n\nGo to \nAWS IoT Console\n and open the AWS IoT Dashboard\n\n\n1.Click the \nServices\n on the top-left corner, and then click on AWS IoT, as shown in the image below.\n\n\n\n\n\n\n2.Click \nGet started\n button.\n\n\n\n\n3.Click on \nCreate a Resource\n and then click \nCreat a thing\n.\n\n\n\n\n\n\n\n\n4.Enter a name, whatever you like, here we name it temperature.\n\n\n\n\n5.Click \nCreate\n to complete it and then click on \nView thing\n to get information of the thing you create.\n\n\n\n\n6.Click on \nConnect a device\n.\n\n\n\n\n7.Choose Node JS and Click on \nGenerate certificate and policy\n.\n\n\n\n\n8.You will find 3 files. Download the file, we need them later. And click on \nConfirm & start connecting\n.\n\n\n\n\n9.Then we should download the AWS IoT Node.js SDK and click on \nReturn to Thing Detail\n.\n\n\n\n\n\n\n\n\nNow, this step is done. Let's move to the next step.\n\n\nSetup your BeagleBone Green\n\n\nConnect BBG to your PC via micro USB cable, and let BBG access the Internet. If this is your first time to use BBG/BBB, maybe you can follow \nhere\n to get started.\n\n\nConnect Grove modules to BBG as the picture below shows.\n\n\n\n\nSoftware Works\n\n\nUpload SDK and keys file to Cloud9 examples folder\n\n\n1.Do you still remember the 3 key files and Node JS SDK that you have already download before.\n\n\n\n\n2.Now, upload the SDK and keys file to your Cloud9 examples folder.\n\n\n\n\n\n\nOpen a new terminal\n\n\nWe need unzip the SDK and move the keys to right place.\n\n\n\n\n# cd examples\n\n\n\n\nAnd unzip the SDK file.\n\n\n# unzip aws-iot-device-sdk-js-latest.zip\n\n\n\n\nThen entering the unziped folder.\n\n\n#cd aws-iot-device-sdk-js\n\n\n\n\nInstall the dependent packages.\n\n\n# npm install\n\n\n\n\n\n\nCreate a new folder named awsCerts.\n\n\n# mkdir awsCerts && cd awsCerts\n\n\n\n\nAnd then move the 3 key files to the new folder.\n\n\n# mv ../../31f2fd2680-* .\n\n\n\n\nPlease note that 31f2fd2680 should be replaced by your own key files number.\n\n\nAnd rename the key files\n\n\n# mv 31f2fd2680-certificate.pem.crt.txt  certificate.pem.crt\n# mv 31f2fd2680-private.pem.key   private.pem.key\n\n\n\n\nDownload a file from the internet.\n\n\n# wget https://www.symantec.com/content/en/us/enterprise/verisign/roots/VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem\n\n\n\n\nAnd rename the downloaded file as root-CA.crt.\n\n\n#mv VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem root-CA.crt\n\n\n\n\n\n\nProgramming on BBG\n\n\nEnter the examples folder.\n\n\n# cd .. && cd examples/\n\n\n\n\n\nCreate a new file named grove_temperature_sensor.py.\n\n\n# vim grove_temperature_sensor.py\n\n\n\nAnd copy the following code to the file.\n\n\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n\u00a0\nimport time\nimport math\nimport Adafruit_BBIO.GPIO as GPIO\nfrom Adafruit_I2C import Adafruit_I2C\nBUZZER = \"P9_22\"            # GPIO P9_22\nGPIO.setup(BUZZER, GPIO.OUT)\n\u00a0\n# The threshold to turn the buzzer on 28 Celsius\nTHRESHOLD_TEMPERATURE = 28\nADDR_ADC121 = 0x50\n\u00a0\nREG_ADDR_RESULT = 0x00\nREG_ADDR_ALERT = 0x01\nREG_ADDR_CONFIG = 0x02\nREG_ADDR_LIMITL = 0x03\nREG_ADDR_LIMITH = 0x04\nREG_ADDR_HYST = 0x05\nREG_ADDR_CONVL = 0x06\nREG_ADDR_CONVH = 0x07\n\u00a0\ni2c = Adafruit_I2C(ADDR_ADC121)           \n\u00a0\nclass I2cAdc:\n    def __init__(self):\n        i2c.write8(REG_ADDR_CONFIG, 0x20)\n\u00a0\n    def read_adc(self):\n        \"Read ADC data 0-4095.\"\n        data_list = i2c.readList(REG_ADDR_RESULT, 2)\n        #print 'data list', data_list\n        data = ((data_list[0] & 0x0f) << 8 | data_list[1]) & 0xfff\n        return data\nadc = I2cAdc()\n\u00a0\n#   The argument in the read_temperature() method defines which Grove board(Grove Temperature Sensor) version you have connected.\n#   Defaults to 'v1.2'. eg.\n#       temp = read_temperature('v1.0')          # B value = 3975\n#       temp = read_temperature('v1.1')          # B value = 4250\n#       temp = read_temperature('v1.2')          # B value = 4250\ndef read_temperature(model = 'v1.2'):\n    \"Read temperature values in Celsius from Grove Temperature Sensor\"\n    # each of the sensor revisions use different thermistors, each with their own B value constant\n    if model == 'v1.2':\n        bValue = 4250  # sensor v1.2 uses thermistor\u00a0??? (assuming NCP18WF104F03RC until SeeedStudio clarifies)\n    elif model == 'v1.1':\n        bValue = 4250  # sensor v1.1 uses thermistor NCP18WF104F03RC\n    else:\n        bValue = 3975  # sensor v1.0 uses thermistor TTC3A103*39H\n\u00a0\n    total_value = 0\n    for index in range(20):\n        sensor_value = adc.read_adc()\n        total_value += sensor_value\n        time.sleep(0.05)\n    average_value = float(total_value / 20)\n\u00a0\n    # Transform the ADC data into the data of Arduino platform.\n    sensor_value_tmp = (float)(average_value / 4095 * 2.95 * 2 / 3.3 * 1023)\n    resistance = (float)(1023 - sensor_value_tmp) * 10000 / sensor_value_tmp\n    temperature = round((float)(1 / (math.log(resistance / 10000) / bValue + 1 / 298.15) - 273.15), 2)\n    return temperature\n\u00a0\n# Function: If the temperature sensor senses the temperature that is up to the threshold you set in the code, the buzzer is ringing for 1s.\n# Hardware: Grove - I2C ADC, Grove - Temperature Sensor, Grove - Buzzer\n# Note: Use P9_22(UART2_RXD) as GPIO.\n# Connect the Grove Buzzer to UART Grove port of Beaglebone Green.\n# Connect the Grove - I2C ADC to I2C Grove port of Beaglebone Green, and then connect the Grove - Temperature Sensor to Grove - I2C ADC.\nif __name__ == '__main__':\n\u00a0\n    while True:\n        try:\n            # Read temperature values in Celsius from Grove Temperature Sensor\n            temperature = read_temperature('v1.2')\n\u00a0\n            # When the temperature reached predetermined value, buzzer is ringing.\n            if temperature > THRESHOLD_TEMPERATURE:\n                # Send HIGH to switch on BUZZER\n                GPIO.output(BUZZER, GPIO.HIGH)\n            else:\n                # Send LOW to switch off BUZZER\n                GPIO.output(BUZZER, GPIO.LOW)\n\u00a0\n            print \"temperature = \", temperature\n\u00a0\n        except KeyboardInterrupt:\n            GPIO.output(BUZZER, GPIO.LOW)\n            break\n\u00a0\n        except IOError:\n            print \"Error\"\n\n\n\n\nCreate a new file named python_sensor.py.\n\n\n#vim  python_sensor.py\n\n\n\nCopy the following code to the new file.\n\n\nimport socket\nimport grove_temperature_sensor\nif __name__ == \"__main__\":\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('127.0.0.1', 7000))\n\u00a0\n    while True:\n        temperature = grove_temperature_sensor.read_temperature('v1.2')\n    print temperature\n        client.sendall(str('%.2f'%temperature))\n    data = client.recv(1024)\n    print data\n    client.close()\n\u00a0\n    print 'Received', repr(data)\n\n\n\n\nCreate a new file named rgbled.js.\n\n\n#vim rgbled.js\n\n\n\nAnd copy the following code to the new file.\n\n\nvar exec = require('child_process').exec; \nvar value = 0;\n\u00a0\nexports.initpins = function(){\n    exec(\"echo 3 > /sys/class/gpio/export\",function(error,stdout,stderr){\n        if(error) \n                console.info('stderr\u00a0: '+stderr);\n    });\n    exec(\"echo out > /sys/class/gpio/gpio3/direction\",function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n    exec(\"echo 2 > /sys/class/gpio/export\",function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n    exec(\"echo out > /sys/class/gpio/gpio2/direction\",function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n}\ndigitalwrite = function(pin,state){\n    exec(\"echo \"+state.toString()+\" > /sys/class/gpio/gpio\"+pin.toString()+\"/value\",\n        function(error,stdout,stderr){\n                    if(error) \n                            console.log('stderr\u00a0: '+stderr);\n        });\n\u00a0\n}\nsleep = function(sleepTime) {\n    for(var start = +new Date; +new Date - start <= sleepTime; ) { }\n}\nclk = function(){\n        digitalwrite(2,0);\n        sleep(2);\n                digitalwrite(2,1);\n        sleep(2);\n}\nsendByte = function(b){\n    for(var i = 0 ; i < 8 ;i++){\n        if((b & 0x80) != 0)\n            digitalwrite(3,1);\n        else\n            digitalwrite(3,0);\n        clk();\n        b = b << 1; \n    }\n}\nsetColor = function(red,green,blue){\n    var prefix = 0xc0;\n    if((blue & 0x80) == 0)\n        prefix |= 0x20;\n    if((blue & 0x40) == 0)\n        prefix |= 0x10;\n    if((green & 0x80) == 0)\n        prefix |= 0x08;\n    if((green & 0x40) == 0)\n        prefix |= 0x04;\n    if((red & 0x80) == 0)\n        prefix |= 0x02;\n    if((red & 0x40) == 0)\n        prefix |= 0x01;\n    sendByte(prefix);\n    sendByte(blue);\n    sendByte(green);\n    sendByte(red);\n}\nexports.setColorRGB = function(led,red,green,blue){\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    for(var i = 0; i < led; i++ ){\n        setColor(red,green,blue);\n    }\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    console.log(\"set rgb\");\n}\ntest = function(){\n    initpins();\n    while(1){\n    console.log(\"loop\");\n        setColorRGB(1, 255, 0, 0)\n        setColorRGB(1, 0, 255, 0)\n        setColorRGB(1, 0, 0, 255)\n        setColorRGB(1, 0, 255, 255)\n        setColorRGB(1, 255, 0, 255)\n        setColorRGB(1, 255, 255, 0)\n        setColorRGB(1, 255, 255, 255)\n    }\n}\n\n\n\n\nCreate a new file named shadow.js.\n\n\n#vim shadow.js\n\n\n\nCopy the following code to the new file.\n\n\nvar awsIot = require('..');\nvar net = require('net');\nvar rgbled = require('./rgbled.js');\nvar exec = require('child_process').exec;    \nvar myThingName = 'temperature';\nvar thingShadows = awsIot.thingShadow({\n   keyPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/private.pem.key',\n  certPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/certificate.pem.crt',\n    caPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/root-CA.crt',\n  clientId: 'myAwsClientId',\n    region: 'us-west-2'\n});\nvar HOST = '127.0.0.1';\nvar PORT = 7000;\nvar temperature = 25;\nvar red = 0;\nvar green = 0;\nvar blue = 0;\n// Create a server instance, and chain the listen function to it\nnet.createServer(function(socket) {\n    console.log('CONNECTED: ' + socket.remoteAddress +':'+ socket.remotePort);\n            // Add a 'data' event handler to this instance of socket\n    socket.on('data', function(data) {\n        console.log('DATA ' + socket.remoteAddress + ': ' + data);\n        temperature = data.toString().substr(0,5);\n        socket.write('This is your request: \"' + data + '\"');\n    });\n    // Add a 'close' event handler to this instance of socket\n    socket.on('close', function(data) {\n        console.log('Socket connection closed... ');\n    });\n}).listen(PORT, HOST);\n//\n// Thing shadow state\n//\nvar rgbLedLampState = {\"state\":{\"desired\":{\"red\":187,\"green\":114,\"blue\":222,value:25}}};\n\u00a0\n//\n// Client token value returned from thingShadows.update() operation\n//\nvar clientTokenUpdate;\n\u00a0\nthingShadows.on('connect', function() {\n//\n// After connecting to the AWS IoT platform, register interest in the\n// Thing Shadow named 'RGBLedLamp'.\n//\n    thingShadows.register( myThingName );\n//\n// 2 seconds after registering, update the Thing Shadow named \n// 'RGBLedLamp' with the latest device state and save the clientToken\n// so that we can correlate it with status or timeout events.\n//\n// Note that the delay is not required for subsequent updates; only\n// the first update after a Thing Shadow registration using default\n// parameters requires a delay.  See API documentation for the update\n// method for more details.\n//\n    exec('python python_sensor.py',function(error,stdout,stderr){\n            if(stdout.length >1){\n                console.log('you offer args:',stdout);\n            }else {\n                console.log('you don\\'t offer args');\n            }\n            if(error) {\n                console.info('stderr\u00a0: '+stderr);\n            }});\n    rgbled.initpins();\n    setTimeout( function() {\n       clientTokenUpdate = thingShadows.update(myThingName, rgbLedLampState );\n       }, 2000 );\n    });\nsetInterval(function(){\n        new_data = {\"state\":{\"desired\":{\"red\":187,\"green\":114,\"blue\":222,value:temperature.toString()}}};\n        //new_data = {\"state\":{\"desired\":{\"value\":temperature.toString()}}};\n        console.log(new_data);\n       clientTokenUpdate = thingShadows.update(myThingName, new_data )\n},2000);\nthingShadows.on('status', \n    function(thingName, stat, clientToken, stateObject) {\n       console.log('received '+stat+' on '+thingName+': '+\n                   JSON.stringify(stateObject));\n    });\n\u00a0\nthingShadows.on('delta', \n    function(thingName, stateObject) {\n       console.log('received delta '+' on '+thingName+': '+\n                   JSON.stringify(stateObject));\n        //console.log(stateObject[\"state\"]);\n    if(stateObject[\"state\"][\"red\"]      != red ||\n       stateObject[\"state\"][\"green\"]  != green||\n      stateObject[\"state\"][\"blue\"]    != blue)\n            rgbled.setColorRGB(1,stateObject[\"state\"][\"red\"],\n                        stateObject[\"state\"][\"green\"],\n                        stateObject[\"state\"][\"blue\"]);\n\u00a0\n    red = stateObject[\"state\"][\"red\"];\n    green = stateObject[\"state\"][\"green\"];\n    blue = stateObject[\"state\"][\"blue\"];\n    });\n\u00a0\nthingShadows.on('timeout',\n    function(thingName, clientToken) {\n       console.log('received timeout '+' on '+thingName+': '+\n                   clientToken);\n    });\n\n\n\n\nPlease note that, the value of \nmyThingName\n in the 5 line should be the same as your Thing name that you have already create before in your AWS account.\n\n\nRun the Code\n\n\nWhen the BBG reboot done, run the code.\n\n\n# cd examples/aws-iot-device-sdk-js/examples/\n# node shadow.js\n\n\n\n\n\nView Result\n\n\nThen let's open \nAWS IoT\n website, sign in to your account. And click the thing you created minutes ago. Now you can see the temperature was upload to website.\n\n\n\n\nIf you want change the grove chainable led color. You can update the shadow value. eg:\n\n\n\n\nYou can see the BBG get the new RGB value.\n\n\n\n\nAnd the Grove - Chainable RGB LED alse turned into green.\n\n\n\n\nPut hand on \nAWS IoT Services Getting Started Guide\n to get more information about AWS IoT.\n\n\nTroubleshoot\n\n\nCan't open 192.168.7.2\n\n\nPlease update the latest software if you can't open 192.168.7.2.\n\n\nStep #1: Download the latest software image.\n\n\nUpdated time: 11/15/15\n\n\nDownload the latest image from \ngoogle drive\n\n\n\n\nStep #2: Install compression utility\n\n\nDownload and install \n7-zip\n.\n\n\n\n\nStep #3: Decompress the image\n\n\nUse 7-zip to decompress the .img file on the desktop or other folder.\n\n\nStep #4: Install SD card programming utility\n\n\nDownload and install \nImage Writer for Windows\n. Be sure to download the binary distribution.\n\n\n\n\nStep #5: Connect SD card to your computer\n\n\nUse an 8G microSD card at least to SD adapter or a USB adapter to connect the SD card to your computer.\n\n\nStep #6: Write the image to your SD card\n\n\nUse either the Ubuntu Image Writer or instructions on its page to write the decompressed image to your SD card.\n\n\n\n\n\n\nNotes\n\n\n 1. You may see a warning about damaging your device. This is fine to accept as long as you are pointing to your SD card for writing.\n\n\n 2. You should not have your BeagleBone connected to your computer at this time.\n\n\n\n\n\nStep #7: Eject the SD card\n\n\nEject the newly programmed SD card.\n\n\nStep #8: Boot your board off of the SD card\n\n\nInsert SD card into your (powered-down) board and apply power, either by the USB cable or 5V adapter. You'll see flash led if getting started, and this reboot will take up to 10 minutes. The latest Debian flasher images automatically power down the board upon completion. Power-down your board, remove the SD card and apply power again to be complete.\n\n\nGood Luck.\n\n\nTech Support\n\n\nPlease post any question on the \nforum\n.\n\n\nFirmware update\n\n\nUpdated by 11/15/15\n:\n\n\n\n\nFix the problem of not being able to access 192.168.7.2\n\n\nWin 10 supported now\n\n\n\n\nResources\n\n\n\n\n\u3010PDF\u3011AWS IoT Developer Guide\n\n\n\u3010PDF\u3011AWS User Guide for BBG\n\n\n\u3010Wiki\u3011Main Page for Grove IoT Starter Kits Powered by AWS\n\n\n\u3010Github\u3011AWS SDK for BeagleBone Green kit\n\n\n\u3010Github\u3011Libraries for BeagleBone Green kit\n\n\nWiki:BeagleBone Green\n\n\nMain page of Beagleboard\n\n\nWiki:Grove - I2C ADC\n\n\nWiki:Grove - I2C Hub\n\n\nWiki:Grove - Relay\n\n\nWiki:Grove - Buzzer\n\n\nWiki:Grove - OLED Display 96*96\n\n\nWiki:Grove - Button\n\n\nWiki:Grove - Temperature sensor v1.2\n\n\nWiki:Grove - Sound sensor\n\n\nWiki:Grove - 3-Axis Digital Accelerometer ADXL345\n\n\nWiki:Grove - Chainable RGB LED\n\n\n\n\nHelp us make it better",
            "title": "Beagle Bone Green and Grove IoT Starter Kit Powered by AWS"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#beagle-bone-green-and-grove-iot-starter-kit-powered-by-aws",
            "text": "",
            "title": "Beagle Bone Green and Grove IoT Starter Kit Powered by AWS"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#introduction",
            "text": "Main articles: Start here  Grove IoT Starter Kits Powered by AWS  ,  Beaglebone Green  BeagleBone Green  (BBG) is a joint effort by BeagleBoard.org and Seeed Studio. It is based on the open-source hardware design of  BeagleBone Black  and has added two Grove connectors. The kit contains the new BBG, 10 Grove modules as well as step-by-step tutorials to hook them up quickly. The Grove IoT Starter Kit includes most frequently used sensors and actuators to turn your ideas into tangible applications with AWS Cloud computing.",
            "title": "Introduction"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#features",
            "text": "Out-of-box, plug and play, no breadboard or soldering  Fully compliant with AWS Services and AWS best practices  Step-by-step tutorials for developers and makers to get started quickly",
            "title": "Features"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#included-in-the-box",
            "text": "Board/Part  Qty  Documentation      BeagleBone Green  1  Read Here    Grove - I2C ADC  1  Read Here    Grove - I2C Hub  1  Read Here    Grove - Relay  1  Read Here    Grove - Buzzer  1  Read Here    Grove - OLED Display 0.96' '  1  Read Here    Grove - Button  1  Read Here    Grove - Temperature Sensor  1  Read Here    Grove - Sound Sensor  1  Read Here    Grove - 3-Axis Digital Accelerometer(\u00b116g)  1  Read Here    Grove - Chainable RGB LED  1  Read Here    Micro USB Cable - 48cm  1",
            "title": "Included in the Box"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#configure-your-aws-iot-service",
            "text": "At the very beginning, we need to get an AWS IoT service account, and do some configuring.   Create an  AWS Account   Go to  AWS IoT Console  and open the AWS IoT Dashboard  1.Click the  Services  on the top-left corner, and then click on AWS IoT, as shown in the image below.    2.Click  Get started  button.   3.Click on  Create a Resource  and then click  Creat a thing .     4.Enter a name, whatever you like, here we name it temperature.   5.Click  Create  to complete it and then click on  View thing  to get information of the thing you create.   6.Click on  Connect a device .   7.Choose Node JS and Click on  Generate certificate and policy .   8.You will find 3 files. Download the file, we need them later. And click on  Confirm & start connecting .   9.Then we should download the AWS IoT Node.js SDK and click on  Return to Thing Detail .     Now, this step is done. Let's move to the next step.",
            "title": "Configure Your AWS IoT Service"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#setup-your-beaglebone-green",
            "text": "Connect BBG to your PC via micro USB cable, and let BBG access the Internet. If this is your first time to use BBG/BBB, maybe you can follow  here  to get started.  Connect Grove modules to BBG as the picture below shows.",
            "title": "Setup your BeagleBone Green"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#software-works",
            "text": "",
            "title": "Software Works"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#upload-sdk-and-keys-file-to-cloud9-examples-folder",
            "text": "1.Do you still remember the 3 key files and Node JS SDK that you have already download before.   2.Now, upload the SDK and keys file to your Cloud9 examples folder.",
            "title": "Upload SDK and keys file to Cloud9 examples folder"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#open-a-new-terminal",
            "text": "We need unzip the SDK and move the keys to right place.   # cd examples  And unzip the SDK file.  # unzip aws-iot-device-sdk-js-latest.zip  Then entering the unziped folder.  #cd aws-iot-device-sdk-js  Install the dependent packages.  # npm install   Create a new folder named awsCerts.  # mkdir awsCerts && cd awsCerts  And then move the 3 key files to the new folder.  # mv ../../31f2fd2680-* .  Please note that 31f2fd2680 should be replaced by your own key files number.  And rename the key files  # mv 31f2fd2680-certificate.pem.crt.txt  certificate.pem.crt\n# mv 31f2fd2680-private.pem.key   private.pem.key  Download a file from the internet.  # wget https://www.symantec.com/content/en/us/enterprise/verisign/roots/VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem  And rename the downloaded file as root-CA.crt.  #mv VeriSign-Class%203-Public-Primary-Certification-Authority-G5.pem root-CA.crt",
            "title": "Open a new terminal"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#programming-on-bbg",
            "text": "Enter the examples folder.  # cd .. && cd examples/   Create a new file named grove_temperature_sensor.py.  # vim grove_temperature_sensor.py  And copy the following code to the file.  #!/usr/bin/python\n# -*- coding: utf-8 -*-\n\u00a0\nimport time\nimport math\nimport Adafruit_BBIO.GPIO as GPIO\nfrom Adafruit_I2C import Adafruit_I2C\nBUZZER = \"P9_22\"            # GPIO P9_22\nGPIO.setup(BUZZER, GPIO.OUT)\n\u00a0\n# The threshold to turn the buzzer on 28 Celsius\nTHRESHOLD_TEMPERATURE = 28\nADDR_ADC121 = 0x50\n\u00a0\nREG_ADDR_RESULT = 0x00\nREG_ADDR_ALERT = 0x01\nREG_ADDR_CONFIG = 0x02\nREG_ADDR_LIMITL = 0x03\nREG_ADDR_LIMITH = 0x04\nREG_ADDR_HYST = 0x05\nREG_ADDR_CONVL = 0x06\nREG_ADDR_CONVH = 0x07\n\u00a0\ni2c = Adafruit_I2C(ADDR_ADC121)           \n\u00a0\nclass I2cAdc:\n    def __init__(self):\n        i2c.write8(REG_ADDR_CONFIG, 0x20)\n\u00a0\n    def read_adc(self):\n        \"Read ADC data 0-4095.\"\n        data_list = i2c.readList(REG_ADDR_RESULT, 2)\n        #print 'data list', data_list\n        data = ((data_list[0] & 0x0f) << 8 | data_list[1]) & 0xfff\n        return data\nadc = I2cAdc()\n\u00a0\n#   The argument in the read_temperature() method defines which Grove board(Grove Temperature Sensor) version you have connected.\n#   Defaults to 'v1.2'. eg.\n#       temp = read_temperature('v1.0')          # B value = 3975\n#       temp = read_temperature('v1.1')          # B value = 4250\n#       temp = read_temperature('v1.2')          # B value = 4250\ndef read_temperature(model = 'v1.2'):\n    \"Read temperature values in Celsius from Grove Temperature Sensor\"\n    # each of the sensor revisions use different thermistors, each with their own B value constant\n    if model == 'v1.2':\n        bValue = 4250  # sensor v1.2 uses thermistor\u00a0??? (assuming NCP18WF104F03RC until SeeedStudio clarifies)\n    elif model == 'v1.1':\n        bValue = 4250  # sensor v1.1 uses thermistor NCP18WF104F03RC\n    else:\n        bValue = 3975  # sensor v1.0 uses thermistor TTC3A103*39H\n\u00a0\n    total_value = 0\n    for index in range(20):\n        sensor_value = adc.read_adc()\n        total_value += sensor_value\n        time.sleep(0.05)\n    average_value = float(total_value / 20)\n\u00a0\n    # Transform the ADC data into the data of Arduino platform.\n    sensor_value_tmp = (float)(average_value / 4095 * 2.95 * 2 / 3.3 * 1023)\n    resistance = (float)(1023 - sensor_value_tmp) * 10000 / sensor_value_tmp\n    temperature = round((float)(1 / (math.log(resistance / 10000) / bValue + 1 / 298.15) - 273.15), 2)\n    return temperature\n\u00a0\n# Function: If the temperature sensor senses the temperature that is up to the threshold you set in the code, the buzzer is ringing for 1s.\n# Hardware: Grove - I2C ADC, Grove - Temperature Sensor, Grove - Buzzer\n# Note: Use P9_22(UART2_RXD) as GPIO.\n# Connect the Grove Buzzer to UART Grove port of Beaglebone Green.\n# Connect the Grove - I2C ADC to I2C Grove port of Beaglebone Green, and then connect the Grove - Temperature Sensor to Grove - I2C ADC.\nif __name__ == '__main__':\n\u00a0\n    while True:\n        try:\n            # Read temperature values in Celsius from Grove Temperature Sensor\n            temperature = read_temperature('v1.2')\n\u00a0\n            # When the temperature reached predetermined value, buzzer is ringing.\n            if temperature > THRESHOLD_TEMPERATURE:\n                # Send HIGH to switch on BUZZER\n                GPIO.output(BUZZER, GPIO.HIGH)\n            else:\n                # Send LOW to switch off BUZZER\n                GPIO.output(BUZZER, GPIO.LOW)\n\u00a0\n            print \"temperature = \", temperature\n\u00a0\n        except KeyboardInterrupt:\n            GPIO.output(BUZZER, GPIO.LOW)\n            break\n\u00a0\n        except IOError:\n            print \"Error\"  Create a new file named python_sensor.py.  #vim  python_sensor.py  Copy the following code to the new file.  import socket\nimport grove_temperature_sensor\nif __name__ == \"__main__\":\n    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    client.connect(('127.0.0.1', 7000))\n\u00a0\n    while True:\n        temperature = grove_temperature_sensor.read_temperature('v1.2')\n    print temperature\n        client.sendall(str('%.2f'%temperature))\n    data = client.recv(1024)\n    print data\n    client.close()\n\u00a0\n    print 'Received', repr(data)  Create a new file named rgbled.js.  #vim rgbled.js  And copy the following code to the new file.  var exec = require('child_process').exec; \nvar value = 0;\n\u00a0\nexports.initpins = function(){\n    exec(\"echo 3 > /sys/class/gpio/export\",function(error,stdout,stderr){\n        if(error) \n                console.info('stderr\u00a0: '+stderr);\n    });\n    exec(\"echo out > /sys/class/gpio/gpio3/direction\",function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n    exec(\"echo 2 > /sys/class/gpio/export\",function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n    exec(\"echo out > /sys/class/gpio/gpio2/direction\",function(error,stdout,stderr){\n                if(error) \n                        console.info('stderr\u00a0: '+stderr);\n        });\n\u00a0\n}\ndigitalwrite = function(pin,state){\n    exec(\"echo \"+state.toString()+\" > /sys/class/gpio/gpio\"+pin.toString()+\"/value\",\n        function(error,stdout,stderr){\n                    if(error) \n                            console.log('stderr\u00a0: '+stderr);\n        });\n\u00a0\n}\nsleep = function(sleepTime) {\n    for(var start = +new Date; +new Date - start <= sleepTime; ) { }\n}\nclk = function(){\n        digitalwrite(2,0);\n        sleep(2);\n                digitalwrite(2,1);\n        sleep(2);\n}\nsendByte = function(b){\n    for(var i = 0 ; i < 8 ;i++){\n        if((b & 0x80) != 0)\n            digitalwrite(3,1);\n        else\n            digitalwrite(3,0);\n        clk();\n        b = b << 1; \n    }\n}\nsetColor = function(red,green,blue){\n    var prefix = 0xc0;\n    if((blue & 0x80) == 0)\n        prefix |= 0x20;\n    if((blue & 0x40) == 0)\n        prefix |= 0x10;\n    if((green & 0x80) == 0)\n        prefix |= 0x08;\n    if((green & 0x40) == 0)\n        prefix |= 0x04;\n    if((red & 0x80) == 0)\n        prefix |= 0x02;\n    if((red & 0x40) == 0)\n        prefix |= 0x01;\n    sendByte(prefix);\n    sendByte(blue);\n    sendByte(green);\n    sendByte(red);\n}\nexports.setColorRGB = function(led,red,green,blue){\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    for(var i = 0; i < led; i++ ){\n        setColor(red,green,blue);\n    }\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    sendByte(0x00);\n    console.log(\"set rgb\");\n}\ntest = function(){\n    initpins();\n    while(1){\n    console.log(\"loop\");\n        setColorRGB(1, 255, 0, 0)\n        setColorRGB(1, 0, 255, 0)\n        setColorRGB(1, 0, 0, 255)\n        setColorRGB(1, 0, 255, 255)\n        setColorRGB(1, 255, 0, 255)\n        setColorRGB(1, 255, 255, 0)\n        setColorRGB(1, 255, 255, 255)\n    }\n}  Create a new file named shadow.js.  #vim shadow.js  Copy the following code to the new file.  var awsIot = require('..');\nvar net = require('net');\nvar rgbled = require('./rgbled.js');\nvar exec = require('child_process').exec;    \nvar myThingName = 'temperature';\nvar thingShadows = awsIot.thingShadow({\n   keyPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/private.pem.key',\n  certPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/certificate.pem.crt',\n    caPath: '/var/lib/cloud9/examples/aws-iot-device-sdk-js/awsCerts/root-CA.crt',\n  clientId: 'myAwsClientId',\n    region: 'us-west-2'\n});\nvar HOST = '127.0.0.1';\nvar PORT = 7000;\nvar temperature = 25;\nvar red = 0;\nvar green = 0;\nvar blue = 0;\n// Create a server instance, and chain the listen function to it\nnet.createServer(function(socket) {\n    console.log('CONNECTED: ' + socket.remoteAddress +':'+ socket.remotePort);\n            // Add a 'data' event handler to this instance of socket\n    socket.on('data', function(data) {\n        console.log('DATA ' + socket.remoteAddress + ': ' + data);\n        temperature = data.toString().substr(0,5);\n        socket.write('This is your request: \"' + data + '\"');\n    });\n    // Add a 'close' event handler to this instance of socket\n    socket.on('close', function(data) {\n        console.log('Socket connection closed... ');\n    });\n}).listen(PORT, HOST);\n//\n// Thing shadow state\n//\nvar rgbLedLampState = {\"state\":{\"desired\":{\"red\":187,\"green\":114,\"blue\":222,value:25}}};\n\u00a0\n//\n// Client token value returned from thingShadows.update() operation\n//\nvar clientTokenUpdate;\n\u00a0\nthingShadows.on('connect', function() {\n//\n// After connecting to the AWS IoT platform, register interest in the\n// Thing Shadow named 'RGBLedLamp'.\n//\n    thingShadows.register( myThingName );\n//\n// 2 seconds after registering, update the Thing Shadow named \n// 'RGBLedLamp' with the latest device state and save the clientToken\n// so that we can correlate it with status or timeout events.\n//\n// Note that the delay is not required for subsequent updates; only\n// the first update after a Thing Shadow registration using default\n// parameters requires a delay.  See API documentation for the update\n// method for more details.\n//\n    exec('python python_sensor.py',function(error,stdout,stderr){\n            if(stdout.length >1){\n                console.log('you offer args:',stdout);\n            }else {\n                console.log('you don\\'t offer args');\n            }\n            if(error) {\n                console.info('stderr\u00a0: '+stderr);\n            }});\n    rgbled.initpins();\n    setTimeout( function() {\n       clientTokenUpdate = thingShadows.update(myThingName, rgbLedLampState );\n       }, 2000 );\n    });\nsetInterval(function(){\n        new_data = {\"state\":{\"desired\":{\"red\":187,\"green\":114,\"blue\":222,value:temperature.toString()}}};\n        //new_data = {\"state\":{\"desired\":{\"value\":temperature.toString()}}};\n        console.log(new_data);\n       clientTokenUpdate = thingShadows.update(myThingName, new_data )\n},2000);\nthingShadows.on('status', \n    function(thingName, stat, clientToken, stateObject) {\n       console.log('received '+stat+' on '+thingName+': '+\n                   JSON.stringify(stateObject));\n    });\n\u00a0\nthingShadows.on('delta', \n    function(thingName, stateObject) {\n       console.log('received delta '+' on '+thingName+': '+\n                   JSON.stringify(stateObject));\n        //console.log(stateObject[\"state\"]);\n    if(stateObject[\"state\"][\"red\"]      != red ||\n       stateObject[\"state\"][\"green\"]  != green||\n      stateObject[\"state\"][\"blue\"]    != blue)\n            rgbled.setColorRGB(1,stateObject[\"state\"][\"red\"],\n                        stateObject[\"state\"][\"green\"],\n                        stateObject[\"state\"][\"blue\"]);\n\u00a0\n    red = stateObject[\"state\"][\"red\"];\n    green = stateObject[\"state\"][\"green\"];\n    blue = stateObject[\"state\"][\"blue\"];\n    });\n\u00a0\nthingShadows.on('timeout',\n    function(thingName, clientToken) {\n       console.log('received timeout '+' on '+thingName+': '+\n                   clientToken);\n    });  Please note that, the value of  myThingName  in the 5 line should be the same as your Thing name that you have already create before in your AWS account.",
            "title": "Programming on BBG"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#run-the-code",
            "text": "When the BBG reboot done, run the code.  # cd examples/aws-iot-device-sdk-js/examples/\n# node shadow.js",
            "title": "Run the Code"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#view-result",
            "text": "Then let's open  AWS IoT  website, sign in to your account. And click the thing you created minutes ago. Now you can see the temperature was upload to website.   If you want change the grove chainable led color. You can update the shadow value. eg:   You can see the BBG get the new RGB value.   And the Grove - Chainable RGB LED alse turned into green.   Put hand on  AWS IoT Services Getting Started Guide  to get more information about AWS IoT.",
            "title": "View Result"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#troubleshoot",
            "text": "",
            "title": "Troubleshoot"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#cant-open-19216872",
            "text": "Please update the latest software if you can't open 192.168.7.2.  Step #1: Download the latest software image.  Updated time: 11/15/15  Download the latest image from  google drive   Step #2: Install compression utility  Download and install  7-zip .   Step #3: Decompress the image  Use 7-zip to decompress the .img file on the desktop or other folder.  Step #4: Install SD card programming utility  Download and install  Image Writer for Windows . Be sure to download the binary distribution.   Step #5: Connect SD card to your computer  Use an 8G microSD card at least to SD adapter or a USB adapter to connect the SD card to your computer.  Step #6: Write the image to your SD card  Use either the Ubuntu Image Writer or instructions on its page to write the decompressed image to your SD card.    Notes   1. You may see a warning about damaging your device. This is fine to accept as long as you are pointing to your SD card for writing.   2. You should not have your BeagleBone connected to your computer at this time.   Step #7: Eject the SD card  Eject the newly programmed SD card.  Step #8: Boot your board off of the SD card  Insert SD card into your (powered-down) board and apply power, either by the USB cable or 5V adapter. You'll see flash led if getting started, and this reboot will take up to 10 minutes. The latest Debian flasher images automatically power down the board upon completion. Power-down your board, remove the SD card and apply power again to be complete.  Good Luck.",
            "title": "Can't open 192.168.7.2"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#tech-support",
            "text": "Please post any question on the  forum .",
            "title": "Tech Support"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#firmware-update",
            "text": "Updated by 11/15/15 :   Fix the problem of not being able to access 192.168.7.2  Win 10 supported now",
            "title": "Firmware update"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#resources",
            "text": "\u3010PDF\u3011AWS IoT Developer Guide  \u3010PDF\u3011AWS User Guide for BBG  \u3010Wiki\u3011Main Page for Grove IoT Starter Kits Powered by AWS  \u3010Github\u3011AWS SDK for BeagleBone Green kit  \u3010Github\u3011Libraries for BeagleBone Green kit  Wiki:BeagleBone Green  Main page of Beagleboard  Wiki:Grove - I2C ADC  Wiki:Grove - I2C Hub  Wiki:Grove - Relay  Wiki:Grove - Buzzer  Wiki:Grove - OLED Display 96*96  Wiki:Grove - Button  Wiki:Grove - Temperature sensor v1.2  Wiki:Grove - Sound sensor  Wiki:Grove - 3-Axis Digital Accelerometer ADXL345  Wiki:Grove - Chainable RGB LED",
            "title": "Resources"
        },
        {
            "location": "/Beagle_Bone_Green_and_Grove_IoT_Starter_Kit_Powered_by_AWS/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/EL_Shield/",
            "text": "EL Shield\n\n\n\n\nIntroduction\n\n\nThis shield is used to control EL devices. It can control 4 EL devices simultaneously. The controlling method is as simple as controlling an LED. Driven by PWM, it can create a colorful and florid effect by controlling each EL wire with a simple program. Combined with our EL Inverter, it can drive an EL wire as long as 15m, which provides infinite possibility for your design. Besides, the Shield is covered by Acrylic board, which enhances user's safety.\n\n\n\n\nSpecifications\n\n\n\n\nOperating Voltage: 5V\n\n\nInvertor interface: JST 2.0\n\n\nControl channel interface: 2P - 2.5SM socket\n\n\n\n\nHardware Overview\n\n\n\n\nDemonstration\n\n\nHere is a simple demo involving EL shield, 4 EL tapes and the custom invertor that accompanies EL shield.\nHook all things up as in the picture below.\n\n\n\n\nUpload the code below to your microcontroller.\n\n\n// EL test code \n\u00a0\nvoid setup(){\n for(int i = 4; i<8; i++)\n { \n  pinMode(i, OUTPUT);\n }\n}\n\u00a0\nvoid setEL(int ch) // set a certain EL on\n{ \n for(int i = 4; i<8; i++) // all off\n digitalWrite(i, LOW);\n digitalWrite(ch+3, HIGH); // ch on\n} \n\u00a0\nint count = 0; \n\u00a0\nvoid loop()\n{ \n setEL(count%4 + 1);\n delay(200);\n if(count++ == 1000)\n { \n  count = 0;\n } \n}\n\n\n\n\nResources\n\n\n\n\nEL Shield eagle file\n\n\nEL Shield Source code file for Arduino 1.0\n\n\nBT134W-600D datasheet\n\n\nMOC 3063 datasheet\n\n\n\n\nHelp us make it better",
            "title": "EL Shield"
        },
        {
            "location": "/EL_Shield/#el-shield",
            "text": "",
            "title": "EL Shield"
        },
        {
            "location": "/EL_Shield/#introduction",
            "text": "This shield is used to control EL devices. It can control 4 EL devices simultaneously. The controlling method is as simple as controlling an LED. Driven by PWM, it can create a colorful and florid effect by controlling each EL wire with a simple program. Combined with our EL Inverter, it can drive an EL wire as long as 15m, which provides infinite possibility for your design. Besides, the Shield is covered by Acrylic board, which enhances user's safety.",
            "title": "Introduction"
        },
        {
            "location": "/EL_Shield/#specifications",
            "text": "Operating Voltage: 5V  Invertor interface: JST 2.0  Control channel interface: 2P - 2.5SM socket",
            "title": "Specifications"
        },
        {
            "location": "/EL_Shield/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/EL_Shield/#demonstration",
            "text": "Here is a simple demo involving EL shield, 4 EL tapes and the custom invertor that accompanies EL shield.\nHook all things up as in the picture below.   Upload the code below to your microcontroller.  // EL test code \n\u00a0\nvoid setup(){\n for(int i = 4; i<8; i++)\n { \n  pinMode(i, OUTPUT);\n }\n}\n\u00a0\nvoid setEL(int ch) // set a certain EL on\n{ \n for(int i = 4; i<8; i++) // all off\n digitalWrite(i, LOW);\n digitalWrite(ch+3, HIGH); // ch on\n} \n\u00a0\nint count = 0; \n\u00a0\nvoid loop()\n{ \n setEL(count%4 + 1);\n delay(200);\n if(count++ == 1000)\n { \n  count = 0;\n } \n}",
            "title": "Demonstration"
        },
        {
            "location": "/EL_Shield/#resources",
            "text": "EL Shield eagle file  EL Shield Source code file for Arduino 1.0  BT134W-600D datasheet  MOC 3063 datasheet",
            "title": "Resources"
        },
        {
            "location": "/EL_Shield/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Energy_Shield/",
            "text": "Energy Shield\n\n\nIntroduction\n\n\n\n\nEnergy Shield is a LiPo battery based power shield that keeps your project alive. It keeps its battery charged whenever an available power source exists. It accepts a wide range of power sources, from common solar cells via JST connector and USB via USB port on microcontroller, to 9V and 12V DC adapters via DC Jack on your Arduino. Meanwhile it can not only provide power for your Arduino project, with a standard USB port populated on the shield, it\u2019s also capable of rescuing your mobile electric devices from dying batteries, such as mobile phone, mp3 and tablet.\n\n\n\n\nFeatures\n\n\n\n\nAccept wide range of power inputs\n\n\nOvervoltage protection\n\n\n85%+ high power conversion efficiency\n\n\nComprehensive LEDs indicators for charging and working status\n\n\n\n\nSpecifications\n\n\nPower Output Specifications\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nvoltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\ncurrent\n\n\n5\n\n\n/\n\n\n750\n\n\nmA\n\n\n\n\n\n\n\n\nPower Input Specifications via JST Connector\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nEffective Voltage\n\n\n4.5\n\n\n5\n\n\n5.5\n\n\nV\n\n\n\n\n\n\nCurrent\n\n\n1\n\n\n/\n\n\n800\n\n\nmA\n\n\n\n\n\n\nProtection Voltage\n\n\n/\n\n\n/\n\n\n12\n\n\nV\n\n\n\n\n\n\n\n\nWorking Mode Explanation\n\n\nEnergy shield can draw current from three different ports to charge the battery, including JST connector, USB port @ Arduino and DC jack. The voltage ranges vary as below:\n\n\n\n\nWhen input voltage is under 6.6V, you can switch the working mode of Energy Shield between \u201cCharge\u201d and \u201cON\u201d via the working mode select switch. In \u201cCharge\u201d condition, Lipo battery doesn\u2019t output but only pull current from any existing power source. In \u201cON\u201d condition, the battery gets charged as well as supplies power to the whole system.\n\n\nHowever when input voltage exceeds 6.6V, Energy Shield is forced to enter the \u201cCharge\u201d mode regardless of the switch status.\n\n\nHardware Overview\n\n\n\n\nHardware Config\n\n\nU1: ISL97516 IC, boost chip;\n\n\nU3: CN3065 IC, charge management chip;\n\n\nU4,U8: LM293D IC, dual differential comparators;\n\n\nCharge Indicator: it lights in charging status;\n\n\nCapacity Indicator: indicate the remaining life of battery;\n\n\nSW2 Button: check the capacity of battery;\n\n\nPins Used on Arduino\n\n\nVin pin: convey power from DC jack to charge battery;\n\n\n5V pin: convey power from USB port to charge battery;\n\n\nOther Interfaces\n\n\nJST socket\uff1aprovided for external power sources that requires JST connector, like solar panel;\n\n\nBattery socket: used to hook up LiPo battery;\n\n\nUSB port: output 5V for other devices;\n\n\nUsage\n\n\n1. Charge Examples\n\n\nYou can charge the Lipo battery with massive external power sources. Here we show you usages of two common powersources.\u00a0\n\n\n1) Solar Panel\n \u00a0 \u00a0\n\n\nSolar panel is one of the most common green power sources we use. The typical output of one unit is around 5V.\u00a0We provide \nlots of solar panels\n at our store. They are all pre-assembled with JST connencors which can seamlessly match up with Energy Shield.\u00a0\n\n\nPlug solar panel into JST socket on the shield as below.\n\n\n\n\nNote\n\nMake sure there is sufficient light to provide considerable current.\n\n\n\n\n\n\nNow, press down SW2. You will find the \"Charge\" indicator LED lights up. The other indicator \"Capacity\" indicates remaining power of battery. When the remaining power is below 30%, it turns red. When remaining power is between 30% - 80%, it turns yellow. Otherwise it's green.\n\n\n\n\n2) 9V Adaptor\n \u00a0 \u00a0\n\n\nIf you are using a DC adaptor to supply power to your project, then 9V adaptor won't be unfamiliar to you. By connecting a 9V adapter to DC Jack of Arduino, you can run your project as well as charge the battery simultaneously.\n\n\n\n\n2. Shield power for device\n\n\n1) Supply Power For Arduino\n\n\n\n\nSwitch the working mode select switch to \"ON\". Check on the power indicator LED on Arduino to see if it works appropriately.\n\n\n2) Supply Power For Mobile Devices\n\n\n\n\nUse the standard USB port on the shield to supply power to mobile devices.\n\n\n3. Conversion Efficiency\n\n\n\n\nThe graph above describes the conversion efficiency of boost circuit of Energy Shield. Boost circuit boosts the voltage of Lipo battery, which is typically 4.2V or 3.7V with the drop of remaining power, to 5V and supplies outward. You can find this conversion efficiency peaks when output current is around 200mA.\n\n\nResources\n\n\n\n\nEnergy Shield Eagle File\n\n\nCN3065 Datasheet\n\n\nISL97516 Datasheet\n\n\nLM293D Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Energy Shield"
        },
        {
            "location": "/Energy_Shield/#energy-shield",
            "text": "",
            "title": "Energy Shield"
        },
        {
            "location": "/Energy_Shield/#introduction",
            "text": "Energy Shield is a LiPo battery based power shield that keeps your project alive. It keeps its battery charged whenever an available power source exists. It accepts a wide range of power sources, from common solar cells via JST connector and USB via USB port on microcontroller, to 9V and 12V DC adapters via DC Jack on your Arduino. Meanwhile it can not only provide power for your Arduino project, with a standard USB port populated on the shield, it\u2019s also capable of rescuing your mobile electric devices from dying batteries, such as mobile phone, mp3 and tablet.",
            "title": "Introduction"
        },
        {
            "location": "/Energy_Shield/#features",
            "text": "Accept wide range of power inputs  Overvoltage protection  85%+ high power conversion efficiency  Comprehensive LEDs indicators for charging and working status",
            "title": "Features"
        },
        {
            "location": "/Energy_Shield/#specifications",
            "text": "Power Output Specifications     Item  Min  Typical  Max  Unit      voltage  4.9  5  5.1  V    current  5  /  750  mA     Power Input Specifications via JST Connector     Item  Min  Typical  Max  Unit      Effective Voltage  4.5  5  5.5  V    Current  1  /  800  mA    Protection Voltage  /  /  12  V     Working Mode Explanation  Energy shield can draw current from three different ports to charge the battery, including JST connector, USB port @ Arduino and DC jack. The voltage ranges vary as below:   When input voltage is under 6.6V, you can switch the working mode of Energy Shield between \u201cCharge\u201d and \u201cON\u201d via the working mode select switch. In \u201cCharge\u201d condition, Lipo battery doesn\u2019t output but only pull current from any existing power source. In \u201cON\u201d condition, the battery gets charged as well as supplies power to the whole system.  However when input voltage exceeds 6.6V, Energy Shield is forced to enter the \u201cCharge\u201d mode regardless of the switch status.",
            "title": "Specifications"
        },
        {
            "location": "/Energy_Shield/#hardware-overview",
            "text": "Hardware Config  U1: ISL97516 IC, boost chip;  U3: CN3065 IC, charge management chip;  U4,U8: LM293D IC, dual differential comparators;  Charge Indicator: it lights in charging status;  Capacity Indicator: indicate the remaining life of battery;  SW2 Button: check the capacity of battery;  Pins Used on Arduino  Vin pin: convey power from DC jack to charge battery;  5V pin: convey power from USB port to charge battery;  Other Interfaces  JST socket\uff1aprovided for external power sources that requires JST connector, like solar panel;  Battery socket: used to hook up LiPo battery;  USB port: output 5V for other devices;",
            "title": "Hardware Overview"
        },
        {
            "location": "/Energy_Shield/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/Energy_Shield/#1-charge-examples",
            "text": "You can charge the Lipo battery with massive external power sources. Here we show you usages of two common powersources.\u00a0  1) Solar Panel  \u00a0 \u00a0  Solar panel is one of the most common green power sources we use. The typical output of one unit is around 5V.\u00a0We provide  lots of solar panels  at our store. They are all pre-assembled with JST connencors which can seamlessly match up with Energy Shield.\u00a0  Plug solar panel into JST socket on the shield as below.   Note \nMake sure there is sufficient light to provide considerable current.   Now, press down SW2. You will find the \"Charge\" indicator LED lights up. The other indicator \"Capacity\" indicates remaining power of battery. When the remaining power is below 30%, it turns red. When remaining power is between 30% - 80%, it turns yellow. Otherwise it's green.   2) 9V Adaptor  \u00a0 \u00a0  If you are using a DC adaptor to supply power to your project, then 9V adaptor won't be unfamiliar to you. By connecting a 9V adapter to DC Jack of Arduino, you can run your project as well as charge the battery simultaneously.",
            "title": "1. Charge Examples"
        },
        {
            "location": "/Energy_Shield/#2-shield-power-for-device",
            "text": "1) Supply Power For Arduino   Switch the working mode select switch to \"ON\". Check on the power indicator LED on Arduino to see if it works appropriately.  2) Supply Power For Mobile Devices   Use the standard USB port on the shield to supply power to mobile devices.",
            "title": "2. Shield power for device"
        },
        {
            "location": "/Energy_Shield/#3-conversion-efficiency",
            "text": "The graph above describes the conversion efficiency of boost circuit of Energy Shield. Boost circuit boosts the voltage of Lipo battery, which is typically 4.2V or 3.7V with the drop of remaining power, to 5V and supplies outward. You can find this conversion efficiency peaks when output current is around 200mA.",
            "title": "3. Conversion Efficiency"
        },
        {
            "location": "/Energy_Shield/#resources",
            "text": "Energy Shield Eagle File  CN3065 Datasheet  ISL97516 Datasheet  LM293D Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Energy_Shield/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/",
            "text": "Grove - 125KHz RFID Reader\n\n\nIntroduction\n\n\n\n\nThis Grove-125KHz RFID Reader is a module used to read uem4100 RFID card information with two output formats: Uart and Wiegand. It has a sensitivity with maximum 7cm sensing distance. There is also \nthe electronic brick version\n of this module. It can help you with project like internet of thing and access control system.\n\n\nAnd you should use the module below while using RFID reader:\n\n\n\n\nRFID tag combo (125khz)\n\n\n\n\n\n\nSpecifications\n\n\n\n\nVoltage: 4.75-5.25V\n\n\nWorking Frequency: 125 KHz\n\n\nSensing Distance(Max): 70mm\n\n\nTTL Output: 9600 baudrate, 8 data bits, 1 stop bit, and no verify bit\n\n\nWiegand Output: 26 bits Wiegand format, 1 even verify bit, 24 data bits, and 1 odd verify bit\n\n\n\n\nDemonstration\n\n\nHere we show how to read RFID information using the Grove - 125KHz RFID Reader. Connect Grove - 125KHz RFID Reader to UART of Grove - Base Shield.\n\n\n\n\nUart Mode (Jumper set to the left two pins)\n\n\nYou would need to select the jumper to \"U\" to enter this mode, and the setting is: 9600bps, N, 8, 1, TTL output\n\n\n// link between the computer and the SoftSerial Shield\n//at 9600 bps 8-N-1\n//Computer is connected to Hardware UART\n//SoftSerial Shield is connected to the Software UART:D2&D3\n\u00a0\n#include <SoftwareSerial.h>\n\u00a0\nSoftwareSerial SoftSerial(2, 3);\nunsigned char buffer[64]; // buffer array for data receive over serial port\nint count=0;     // counter for buffer array\n\u00a0\nvoid setup()\n{\n    SoftSerial.begin(9600);               // the SoftSerial baud rate\n    Serial.begin(9600);             // the Serial port of Arduino baud rate.\n}\n\u00a0\nvoid loop()\n{\n    if (SoftSerial.available())              // if date is coming from software serial port ==> data is coming from SoftSerial shield\n    {\n        while(SoftSerial.available())          // reading data into char array\n        {\n            buffer[count++]=SoftSerial.read();     // writing data into array\n            if(count == 64)break;\n        }\n        Serial.write(buffer,count);            // if no data transmission ends, write buffer to hardware serial port\n        clearBufferArray();              // call clearBufferArray function to clear the stored data from the array\n        count = 0;                       // set counter of while loop to zero\n    }\n    if (Serial.available())            // if data is available on hardware serial port ==> data is coming from PC or notebook\n    SoftSerial.write(Serial.read());       // write it to the SoftSerial shield\n}\nvoid clearBufferArray()              // function to clear buffer array\n{\n    for (int i=0; i<count;i++)\n    {\n        buffer[i]=NULL;\n    }                  // clear all index of array with command NULL\n}\n\n\n\n\nOpen the Serial Monitor, the card information can be displayed as shown below:\n\n\n\n\nWiegand Mode (Jumper Set to the Right two Pins)\n\n\nYou would need to select the jumper to \"W\" to enter this mode.\nThe \nWiegand demo code\n for Seeeduino is designed to read Wiegand data in interrupt mode.\n\n\nIn Wiegand Mode, output data is formatted with 26bits including 24bits card info and 2 bits parity.\n\n\n\n\n\n\n\nbit\n\n\n\n\n0\n\n\n\n\n1\n\n\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n5\n\n\n\n\n6\n\n\n\n\n7\n\n\n\n\n8\n\n\n\n\n9\n\n\n\n\n10\n\n\n\n\n11\n\n\n\n\n12\n\n\n\n\n13\n\n\n\n\n14\n\n\n\n\n15\n\n\n\n\n16\n\n\n\n\n17\n\n\n\n\n18\n\n\n\n\n19\n\n\n\n\n20\n\n\n\n\n21\n\n\n\n\n22\n\n\n\n\n23\n\n\n\n\n24\n\n\n\n\n25\n\n\n\n\n\n\n\n\n-\n\n\n\n\nPE\n\n\n\n\nD\n\n\n\n\nP0\n\n\n\n\n\n\n\n\n-\n\n\n\n\n-\n\n\n\n\nE\n\n\n\n\n0\n\n\n\n\n-\n\n\n\n\n\n\n\n\n-\n\n\n\n\n-\n\n\n\n\nD2[7..0]\n\n\n\n\nD1[7..0]\n\n\n\n\nD0[7..0]\n\n\n\n\n-\n\n\n\n\n\n\n\n\n\n\nPE is even bit, PO is odd bit;\n\n\nE is the data bit which was involved in even, O is the data bit which was involved in odd;\n\n\nDX[7..0] is the data bit which correspond to Mifare@ Standard & Light card read only ID;\n\n\n\n\nHow to convert the output to Card Number\n\n\nTake ID: 0009776930 for example:\n\n\n\n\nCard Number ID: 0009776930 ------- Decimalism [Start Bit(00) + Card Number(8 numbers)]\n\n\nOutput: 0700952F229F ------------- Hex [[Start Bit(07h) + Card Number(8 numbers) + Checksum]\n\n\nThe calculator for decimal and hex numbers is available online.\n\n\n\n\nHelp us make it better",
            "title": "Grove 125KHz RFID Reader"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/#grove-125khz-rfid-reader",
            "text": "",
            "title": "Grove - 125KHz RFID Reader"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/#introduction",
            "text": "This Grove-125KHz RFID Reader is a module used to read uem4100 RFID card information with two output formats: Uart and Wiegand. It has a sensitivity with maximum 7cm sensing distance. There is also  the electronic brick version  of this module. It can help you with project like internet of thing and access control system.  And you should use the module below while using RFID reader:   RFID tag combo (125khz)",
            "title": "Introduction"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/#specifications",
            "text": "Voltage: 4.75-5.25V  Working Frequency: 125 KHz  Sensing Distance(Max): 70mm  TTL Output: 9600 baudrate, 8 data bits, 1 stop bit, and no verify bit  Wiegand Output: 26 bits Wiegand format, 1 even verify bit, 24 data bits, and 1 odd verify bit",
            "title": "Specifications"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/#demonstration",
            "text": "Here we show how to read RFID information using the Grove - 125KHz RFID Reader. Connect Grove - 125KHz RFID Reader to UART of Grove - Base Shield.",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/#uart-mode-jumper-set-to-the-left-two-pins",
            "text": "You would need to select the jumper to \"U\" to enter this mode, and the setting is: 9600bps, N, 8, 1, TTL output  // link between the computer and the SoftSerial Shield\n//at 9600 bps 8-N-1\n//Computer is connected to Hardware UART\n//SoftSerial Shield is connected to the Software UART:D2&D3\n\u00a0\n#include <SoftwareSerial.h>\n\u00a0\nSoftwareSerial SoftSerial(2, 3);\nunsigned char buffer[64]; // buffer array for data receive over serial port\nint count=0;     // counter for buffer array\n\u00a0\nvoid setup()\n{\n    SoftSerial.begin(9600);               // the SoftSerial baud rate\n    Serial.begin(9600);             // the Serial port of Arduino baud rate.\n}\n\u00a0\nvoid loop()\n{\n    if (SoftSerial.available())              // if date is coming from software serial port ==> data is coming from SoftSerial shield\n    {\n        while(SoftSerial.available())          // reading data into char array\n        {\n            buffer[count++]=SoftSerial.read();     // writing data into array\n            if(count == 64)break;\n        }\n        Serial.write(buffer,count);            // if no data transmission ends, write buffer to hardware serial port\n        clearBufferArray();              // call clearBufferArray function to clear the stored data from the array\n        count = 0;                       // set counter of while loop to zero\n    }\n    if (Serial.available())            // if data is available on hardware serial port ==> data is coming from PC or notebook\n    SoftSerial.write(Serial.read());       // write it to the SoftSerial shield\n}\nvoid clearBufferArray()              // function to clear buffer array\n{\n    for (int i=0; i<count;i++)\n    {\n        buffer[i]=NULL;\n    }                  // clear all index of array with command NULL\n}  Open the Serial Monitor, the card information can be displayed as shown below:",
            "title": "Uart Mode (Jumper set to the left two pins)"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/#wiegand-mode-jumper-set-to-the-right-two-pins",
            "text": "You would need to select the jumper to \"W\" to enter this mode.\nThe  Wiegand demo code  for Seeeduino is designed to read Wiegand data in interrupt mode.  In Wiegand Mode, output data is formatted with 26bits including 24bits card info and 2 bits parity.    \nbit  \n0  \n1  \n2  \n3  \n4  \n5  \n6  \n7  \n8  \n9  \n10  \n11  \n12  \n13  \n14  \n15  \n16  \n17  \n18  \n19  \n20  \n21  \n22  \n23  \n24  \n25    \n-  \nPE  \nD  \nP0    \n-  \n-  \nE  \n0  \n-    \n-  \n-  \nD2[7..0]  \nD1[7..0]  \nD0[7..0]  \n-     PE is even bit, PO is odd bit;  E is the data bit which was involved in even, O is the data bit which was involved in odd;  DX[7..0] is the data bit which correspond to Mifare@ Standard & Light card read only ID;",
            "title": "Wiegand Mode (Jumper Set to the Right two Pins)"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/#how-to-convert-the-output-to-card-number",
            "text": "Take ID: 0009776930 for example:   Card Number ID: 0009776930 ------- Decimalism [Start Bit(00) + Card Number(8 numbers)]  Output: 0700952F229F ------------- Hex [[Start Bit(07h) + Card Number(8 numbers) + Checksum]  The calculator for decimal and hex numbers is available online.",
            "title": "How to convert the output to Card Number"
        },
        {
            "location": "/Grove-125KHz_RFID_Reader/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/",
            "text": "Grove - 2-Coil Latching Relay\n\n\nIntroduction\n\n\n\n\nThis module is based on 2-Coil Latching Relay. Contrast to the ordinary relay, this latching relay does not need continuous power to keep the state, only a rising/falling pulse is needed to change the work state. Even the power can be removed when the work state do not need to change, making this module especially suitable for low-power projects.\n\n\n\n\nFeatures\n\n\n\n\nGrove Connector\n\n\nLow power consumption\n\n\nDual Switch\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n4.7\n\n\n\n\n5.0\n\n\n\n\n5.3\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nSet/Reset Voltage(Max)\n\n\n\n\n4.0\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCoil Resistance\n\n\n\n\n151\n\n\n\n\n167\n\n\n\n\n183\n\n\n\n\n\u03a9\n\n\n\n\n\n\n\n\nSwitching Voltage(Max)\n\n\n\n\n35VAC/35VDC\n\n\n\n\n/\n\n\n\n\n\n\n\n\nSwitching Current(Max)\n\n\n\n\n3\n\n\n\n\nA\n\n\n\n\n\n\n\n\nSet Time(Latching)\n\n\n\n\n4.5(max)\n\n\n\n\nms\n\n\n\n\n\n\n\n\nReset Time(Latching)\n\n\n\n\n3.5(max)\n\n\n\n\nms\n\n\n\n\n\n\n\n\nUsage\n\n\nWith \nArduino\n\n\nThe latching relay only draws power during the changing of state. A rising/falling voltage pulse on the signal pin changes it's working state. This is very useful in situations where energy efficiency is important, and also in situations where you need the relay to remember its state.\n\n\nLet's begin to use it.\n\n\n\n\nConnect the module to D3 port of \nGrove - Base Shield\n.\n\n\nThe relay hold in \"set\" status(Comm and NO connected) in default, when there is a rising edge on the SIG pin. It turns the \"reset\" state(Comm and NC connected). The reference code is shown below:\n\n\n\n\n    #define LatchingRelay 3\n    void setup()\n    {\n    pinMode(LatchingRelay,OUTPUT);\n\n    digitalWrite(LatchingRelay,LOW);\n    delay(1000);\n    digitalWrite(LatchingRelay,HIGH);\n    delay(1000);\n\n    }\n    void loop()\n    {\n\n    }\n\n\n\n\n\n\nThe relay hold in \"reset\" status(Comm and NC Connected), when there is a falling edge on the SIG pin. It turns the \"set\" state(Comm and NO connected). The reference code is shown below:\n\n\n\n\n    #define LatchingRelay 3\n    void setup()\n    {\n    pinMode(LatchingRelay,OUTPUT);\n\n    digitalWrite(3,HIGH);\n    delay(1000);\n    digitalWrite(3,LOW);\n    delay(1000);\n    }\n    void loop()\n    {\n\n    }\n\n\n\n\n\n\nThis module consumes little power when working state doesn't change. After setting the relay state, you do not need to supply power for the Latching Relay any more, which makes it especially low power consumption.\n\n\n\n\n\n\nNote\n\nRelay is on the \"reset\" status when being released from stock.\n\n\n\n\n\n\n\n\nNotes\n\n\n 1. The two-way relays are controlled at the same time.\n\n\n 2. The NO(NC) indicator will flash once when switch to \"set\"(\"reset\") status.\n\n\n\n\n\nWith \nRaspberry Pi\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D4 by using a grove cable.\n\n\n\n\n4.Navigate to the demos' directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_2_coil_latching_relay.py   # \"Ctrl+x\" to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove 2-Coil Latching Relay to digital port D4\n    # SIG,NC,VCC,GND\n    relay = 4\n\n    grovepi.pinMode(relay,\"OUTPUT\")\n\n    while True:\n        try:\n            # switch on for 5 seconds\n            grovepi.digitalWrite(relay,1)\n            print \"on\"\n            time.sleep(5)\n\n            # switch off for 5 seconds\n            grovepi.digitalWrite(relay,0)\n            print \"off\"\n            time.sleep(5)\n\n        except KeyboardInterrupt:\n            grovepi.digitalWrite(relay,0)\n            break\n        except IOError:\n            print \"Error\"\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_2_coil_latching_relay.py\n\n\n\n\nResources\n\n\n\n\nGrove - 2-Coil Latching Relay Eagle File\n\n\nLatching_Relay_Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove 2 Coil Latching Relay"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#grove-2-coil-latching-relay",
            "text": "",
            "title": "Grove - 2-Coil Latching Relay"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#introduction",
            "text": "This module is based on 2-Coil Latching Relay. Contrast to the ordinary relay, this latching relay does not need continuous power to keep the state, only a rising/falling pulse is needed to change the work state. Even the power can be removed when the work state do not need to change, making this module especially suitable for low-power projects.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#features",
            "text": "Grove Connector  Low power consumption  Dual Switch",
            "title": "Features"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#specifications",
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n4.7  \n5.0  \n5.3  \nVDC    \nSet/Reset Voltage(Max)  \n4.0  \nVDC    \nCoil Resistance  \n151  \n167  \n183  \n\u03a9    \nSwitching Voltage(Max)  \n35VAC/35VDC  \n/    \nSwitching Current(Max)  \n3  \nA    \nSet Time(Latching)  \n4.5(max)  \nms    \nReset Time(Latching)  \n3.5(max)  \nms",
            "title": "Specifications"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#with-arduino",
            "text": "The latching relay only draws power during the changing of state. A rising/falling voltage pulse on the signal pin changes it's working state. This is very useful in situations where energy efficiency is important, and also in situations where you need the relay to remember its state.  Let's begin to use it.   Connect the module to D3 port of  Grove - Base Shield .  The relay hold in \"set\" status(Comm and NO connected) in default, when there is a rising edge on the SIG pin. It turns the \"reset\" state(Comm and NC connected). The reference code is shown below:       #define LatchingRelay 3\n    void setup()\n    {\n    pinMode(LatchingRelay,OUTPUT);\n\n    digitalWrite(LatchingRelay,LOW);\n    delay(1000);\n    digitalWrite(LatchingRelay,HIGH);\n    delay(1000);\n\n    }\n    void loop()\n    {\n\n    }   The relay hold in \"reset\" status(Comm and NC Connected), when there is a falling edge on the SIG pin. It turns the \"set\" state(Comm and NO connected). The reference code is shown below:       #define LatchingRelay 3\n    void setup()\n    {\n    pinMode(LatchingRelay,OUTPUT);\n\n    digitalWrite(3,HIGH);\n    delay(1000);\n    digitalWrite(3,LOW);\n    delay(1000);\n    }\n    void loop()\n    {\n\n    }   This module consumes little power when working state doesn't change. After setting the relay state, you do not need to supply power for the Latching Relay any more, which makes it especially low power consumption.    Note \nRelay is on the \"reset\" status when being released from stock.    Notes   1. The two-way relays are controlled at the same time.   2. The NO(NC) indicator will flash once when switch to \"set\"(\"reset\") status.",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#with-raspberry-pi",
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D4 by using a grove cable.   4.Navigate to the demos' directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_2_coil_latching_relay.py   # \"Ctrl+x\" to exit #      import time\n    import grovepi\n\n    # Connect the Grove 2-Coil Latching Relay to digital port D4\n    # SIG,NC,VCC,GND\n    relay = 4\n\n    grovepi.pinMode(relay,\"OUTPUT\")\n\n    while True:\n        try:\n            # switch on for 5 seconds\n            grovepi.digitalWrite(relay,1)\n            print \"on\"\n            time.sleep(5)\n\n            # switch off for 5 seconds\n            grovepi.digitalWrite(relay,0)\n            print \"off\"\n            time.sleep(5)\n\n        except KeyboardInterrupt:\n            grovepi.digitalWrite(relay,0)\n            break\n        except IOError:\n            print \"Error\"  5.Run the demo.      sudo python grove_2_coil_latching_relay.py",
            "title": "With Raspberry Pi"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#resources",
            "text": "Grove - 2-Coil Latching Relay Eagle File  Latching_Relay_Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-2-Coil_Latching_Relay/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/",
            "text": "Grove - 3-Axis Analog Accelerometer\n\n\nIntroduction\n\n\n\n\nThe ADXL335 is a small, thin, low power, complete 3-axis accelerometer with signal conditioned voltage outputs. The product measures acceleration with a minimum full-scale range of \u00b13 g.\nThe module was designed as breakout board because ADXL335's signal is analog( more ports requested ). But the board outline is grove module that you can fix it conveniently like other groves. The sensor combined 3.3 and 5V power supply, can be used in standard Arduino device and Seeeduino Stalker. The following program code includes first-order filter which can make the output smoothly if the sensor was used in robot or toy car.\n\n\n\n\nFeatures\n\n\n\n\nWide power range DC3V to 5V\n\n\nGrove outline\n\n\n3 axis sensing\n\n\nSmall, low-profile package: 4\u00d74\u00d71.45mm LFCSP\n\n\nLow power 350\u00b5A at 3V (typical)\n\n\nHigh sensitive\n\n\n10,000 g shock survival\n\n\nBW adjustment with a single capacitor per axis\n\n\nRoHS/WEEE lead-free compliant\n\n\n\n\nApplication Ideas\n\n\n\n\nMotion Sensor\n\n\nShock detector\n\n\nVibration sensor\n\n\nToy car\n\n\nRobot\n\n\n\n\nUsage\n\n\nThe sensor's outline is breakout board, you can welding wire in the board or use jumper wire to connect the sensor.\n\n\n\n\nThe VCC connect to power source\uff08DC5V or DC3.3V\uff09, GND to ground, X to Arduino analog port A0, Y to A1, Z to A2.\n    \n\n\nDownload the \n3-Axis Analog Accelerometer Library\n and Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\nRegulate the sensor\n\n\n\n\nThe sensor is analog device, you should regulate the sensor before combining it with your system.\n\n\nStep 1:\n Open the Demo: Calibration and upload it to Arduino.Please click \nhere\n if you do not know how to upload.\n\n\nStep 2:\n Open your serial monitor, make sure the sensor is connected. Follow the axis institutions printed on sensor's board. First, make sure that Z-axis direction is straight up, please type any character if you are ready. Change the sensor position, repeat the above operation to obtain X-axis and Y-axis direction are straight up .\n\n\n\n\nStep 3:\n You can get the values as shown above. Please modify the macro definitions with these results in ADXL335.h\n\n\n\n\nNow the calibration has been completed.\n\n\n\n\nDownloading the demo code: Measuring Acceleration, then open serial monitor, turn the sensor any angle, you can see the digital angle value sent from the accelerometer to the monitor.\n\n\n\n\n\n\nResources\n\n\n\n\n\n\nGrove - 3-Axis Analog Accelerometer Eagle File\n\n\n\n\n\n\n3-Axis Analog Accelerometer Library\n\n\n\n\n\n\ngithub repository for 3-Axis Analog Accelerometer\n\n\n\n\n\n\nADXL335 datasheet.pdf\n\n\n\n\n\n\nHelp us make it better",
            "title": "Grove 3 Axis Analog Accelerometer"
        },
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#grove-3-axis-analog-accelerometer",
            "text": "",
            "title": "Grove - 3-Axis Analog Accelerometer"
        },
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#introduction",
            "text": "The ADXL335 is a small, thin, low power, complete 3-axis accelerometer with signal conditioned voltage outputs. The product measures acceleration with a minimum full-scale range of \u00b13 g.\nThe module was designed as breakout board because ADXL335's signal is analog( more ports requested ). But the board outline is grove module that you can fix it conveniently like other groves. The sensor combined 3.3 and 5V power supply, can be used in standard Arduino device and Seeeduino Stalker. The following program code includes first-order filter which can make the output smoothly if the sensor was used in robot or toy car.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#features",
            "text": "Wide power range DC3V to 5V  Grove outline  3 axis sensing  Small, low-profile package: 4\u00d74\u00d71.45mm LFCSP  Low power 350\u00b5A at 3V (typical)  High sensitive  10,000 g shock survival  BW adjustment with a single capacitor per axis  RoHS/WEEE lead-free compliant",
            "title": "Features"
        },
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#application-ideas",
            "text": "Motion Sensor  Shock detector  Vibration sensor  Toy car  Robot",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#usage",
            "text": "The sensor's outline is breakout board, you can welding wire in the board or use jumper wire to connect the sensor.   The VCC connect to power source\uff08DC5V or DC3.3V\uff09, GND to ground, X to Arduino analog port A0, Y to A1, Z to A2.\n      Download the  3-Axis Analog Accelerometer Library  and Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  Regulate the sensor   The sensor is analog device, you should regulate the sensor before combining it with your system.  Step 1:  Open the Demo: Calibration and upload it to Arduino.Please click  here  if you do not know how to upload.  Step 2:  Open your serial monitor, make sure the sensor is connected. Follow the axis institutions printed on sensor's board. First, make sure that Z-axis direction is straight up, please type any character if you are ready. Change the sensor position, repeat the above operation to obtain X-axis and Y-axis direction are straight up .   Step 3:  You can get the values as shown above. Please modify the macro definitions with these results in ADXL335.h   Now the calibration has been completed.   Downloading the demo code: Measuring Acceleration, then open serial monitor, turn the sensor any angle, you can see the digital angle value sent from the accelerometer to the monitor.",
            "title": "Usage"
        },
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#resources",
            "text": "Grove - 3-Axis Analog Accelerometer Eagle File    3-Axis Analog Accelerometer Library    github repository for 3-Axis Analog Accelerometer    ADXL335 datasheet.pdf",
            "title": "Resources"
        },
        {
            "location": "/Grove-3-Axis_Analog_Accelerometer/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/",
            "text": "Grove - 3-Axis Compass V1.0\n\n\nIntroduction\n\n\n\n\nThis 3-axis digital compass features a low field magnetic sensing multi-chip module HMC5883L, which provides up to 1\u00b0 to 2\u00b0 heading accuracy. HMC5883L consists of high-resolution HMC118X series magneto-resistive sensors, as well as Honeywell developed ASIC containing amplification, automatic degaussing strap drivers, offset cancellation and 12 bit ADC. With peripheral power management circuit added, this is an easy to use and reliable compass module for low cost compassing and magnetometry.\n\n\n\n\nSpecifications\n\n\n\n\nInput Voltage: 3.3V, 5V\n\n\nSleep Mode Current: 2.5uA\n\n\nMeasurement Mode Current: 640uA\n\n\nHigh resolution\n\n\nEasy to control I2C interface\n\n\nCompatible with either 3.3V or 5.0V development platform\n\n\nMax 116Hz output rate\n\n\nHigh heading accuracy\n\n\n\n\nDemonstration\n\n\nWith \nArduino\n\n\nThis demo is going to show you how to read raw data, how to calibrate the data with your local magnetic declination angle and how to get heading angle.\n\n\nFirst off, before any action you are going to take, you need to prepare a parameter you are going to use in your demo. That's your local magnetic declination.\n\n\nYou can find it out in degree via \nthe magnetic declination webpage\n. For example, mine is -2\u00b037\u2019, which is -2.617 degree.\n\n\nThen transfer it from degree to radians, and there you get the \"declinationAngle\". For example, in my case, declinationAngle = -2.617 * \u03c0 / 180 = -0.0456752665 rad. Three significant figures are enough. So I would shorten it into -0.0456 rad. And this is the parameter you are going to replace the value of \"declinationAngle\" in the demo code with.\n\n\nNow let's start to run your compass.\n\n\n\n\n\n\nPlug the 3-axis compass into the I2C port of Grove - Base Shield.\n\n\n\n\n\n\nDownload the library file: \nDigital Compass Library\n. Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n\n\n\n\nOpen the demo\u00a0by the path:File ->Example ->Digital Compass ->HMC5883L_Example.\n\n\n\n\n\n\n\n\nReplace the value of variable \"declinitionAngle\" with the one you've figured out already.\n\n\n\n\n\n\nUpload the Code. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n\nCheck the output result by opening the serial monitor.\n\n\n\n\n\n\n\n\nWith \nRaspberry Pi\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.\n\n\n\n\n4.Navigate to the demos' directory:\n\n\n   cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_compass_lib.py       \n    nano grove_compass_example.py    \n\n\n\n\n    import grove_compass_lib\n    c=grove_compass_lib.compass()\n    while True:\n            print \"X:\",c.x,\"Y:\",c.y,\"X:\",c.z,\"Heading:\",c.headingDegrees\n            c.update()\n            time.sleep(.1)\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_compass_example.py\n\n\n\n\nResources\n\n\n\n\nGrove-3-Axis Digital Compass Eagle File\n\n\nHMC5883.pdf\n\n\nDigital Compass Library\n\n\n\n\nHelp us make it better",
            "title": "Grove 3 Axis Compass V1.0"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#grove-3-axis-compass-v10",
            "text": "",
            "title": "Grove - 3-Axis Compass V1.0"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#introduction",
            "text": "This 3-axis digital compass features a low field magnetic sensing multi-chip module HMC5883L, which provides up to 1\u00b0 to 2\u00b0 heading accuracy. HMC5883L consists of high-resolution HMC118X series magneto-resistive sensors, as well as Honeywell developed ASIC containing amplification, automatic degaussing strap drivers, offset cancellation and 12 bit ADC. With peripheral power management circuit added, this is an easy to use and reliable compass module for low cost compassing and magnetometry.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#specifications",
            "text": "Input Voltage: 3.3V, 5V  Sleep Mode Current: 2.5uA  Measurement Mode Current: 640uA  High resolution  Easy to control I2C interface  Compatible with either 3.3V or 5.0V development platform  Max 116Hz output rate  High heading accuracy",
            "title": "Specifications"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#demonstration",
            "text": "",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#with-arduino",
            "text": "This demo is going to show you how to read raw data, how to calibrate the data with your local magnetic declination angle and how to get heading angle.  First off, before any action you are going to take, you need to prepare a parameter you are going to use in your demo. That's your local magnetic declination.  You can find it out in degree via  the magnetic declination webpage . For example, mine is -2\u00b037\u2019, which is -2.617 degree.  Then transfer it from degree to radians, and there you get the \"declinationAngle\". For example, in my case, declinationAngle = -2.617 * \u03c0 / 180 = -0.0456752665 rad. Three significant figures are enough. So I would shorten it into -0.0456 rad. And this is the parameter you are going to replace the value of \"declinationAngle\" in the demo code with.  Now let's start to run your compass.    Plug the 3-axis compass into the I2C port of Grove - Base Shield.    Download the library file:  Digital Compass Library . Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.    Open the demo\u00a0by the path:File ->Example ->Digital Compass ->HMC5883L_Example.     Replace the value of variable \"declinitionAngle\" with the one you've figured out already.    Upload the Code. Please click  here  if you do not know how to upload.    Check the output result by opening the serial monitor.",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#with-raspberry-pi",
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.   4.Navigate to the demos' directory:     cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_compass_lib.py       \n    nano grove_compass_example.py          import grove_compass_lib\n    c=grove_compass_lib.compass()\n    while True:\n            print \"X:\",c.x,\"Y:\",c.y,\"X:\",c.z,\"Heading:\",c.headingDegrees\n            c.update()\n            time.sleep(.1)  5.Run the demo.      sudo python grove_compass_example.py",
            "title": "With Raspberry Pi"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#resources",
            "text": "Grove-3-Axis Digital Compass Eagle File  HMC5883.pdf  Digital Compass Library",
            "title": "Resources"
        },
        {
            "location": "/Grove-3-Axis_Compass_V1.0/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/",
            "text": "Grove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\nIntroduction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer v1.2\n\n\n\n\nGrove - 3-Axis Digital Accelerometer v1.2b\n\n\n\n\n\n\n\n\n\n\n3-Axis Digital Accelerometer is the key part in projects like orientation detection, gesture detection and Motion detection. This 3-Axis Digital Accelerometer(\u00b11.5g) is based on Freescale's low power consumption module, MMA7660FC. It features up to 10,000g high shock survivability and configurable Samples per Second rate. For generous applications that don't require too large measurement range, this is a great choice because it's durable, energy saving and cost-efficient.\n\n\n\n\nSpecifications\n\n\n\n\nWorking voltage: 3.0 - 5.5V\n\n\nOff Mode Current: 0.4\u03bcA\n\n\nStandby Mode Current: 2\u03bcA\n\n\nActive Mode Current: 47 \u03bcA at 1 ODR\n\n\nTest Range: \u00b11.5g\n\n\nSensitivity: 21LSB/g\n\n\nSuli-compatible Library\n\n\n\n\n\n\nNote\n\nFor more details about Suli-compatible Library, please refer to \nSuli\n.\n\n\n\n\nDemonstration\n\n\nWith \nArduino\n\n\nHere we are going to show you how to get raw data and data measured by \"g\" from this sensor.\u00a0\n\n\nConnect this module to the I2C port of Grove - Base Shield\u00a0via a Grove cable.\n\n\n\n\nNote\n\nIf you want to activate the Interrupt function of this module, you need to connect the INT soldering pad we broke out on the board with a pin of Arduino that's capable of Interrupt Service Routine.\u00a0\n\n\n\n\n\n\nInstall the library we provide in the \nResources\n section.\n\n\nOpen the code directly by the path:File -> Example ->DigitalAccelerometer_MMA7660FC ->MMA7660FC_Demo.\n\n\nIn this program, acceleration information are sent from the sensor to Seeeduino via I2C bus and then Seeeduino printed them onto the serial monitor.\nOpen the serial monitor to check the result.\n\n\n\n\nThe outputs of this sensor consist of two parts: raw data and 3-axis acceleration info converted into the unit of gravity, \"g\".\n\n\nWith \nRaspberry Pi\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.\n\n\n\n\n4.Navigate to the demos' directory:\n\n\n   cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_i2c_accelerometer.py   # \"Ctrl+x\" to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Accelerometer (+/- 1.5g) to any I2C port eg. I2C-1\n    # Can be found at I2C address 0x4c\n    # SCL,SDA,VCC,GND\n\n    while True:\n        try:\n            print grovepi.acc_xyz()\n            time.sleep(.5)\n\n        except IOError:\n            print \"Error\"\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_i2c_accelerometer.py\n\n\n\n\nReference\n\n\nBelow are two figures helping you understand the physical meaning of the result.\n\n\nThe first figure is about the direction of each axis:\n\n\n\nThe second figure gives some examples:\n\n\n\n\nResources\n\n\n\n\nDatasheet of MMA7660FC\n\n\nGrove - 3-Axis Digital Accelerometer Eagle File\n\n\nDigitalAccelerometer_MMA7660FC Library\n\n\ngithub repository for 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\n\n\nHelp us make it better",
            "title": "Grove 3 Axis Digital Accelerometer 1.5g"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#grove-3-axis-digital-accelerometer15g",
            "text": "",
            "title": "Grove - 3-Axis Digital Accelerometer(\u00b11.5g)"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#introduction",
            "text": "Grove - 3-Axis Digital Accelerometer v1.2  \nGrove - 3-Axis Digital Accelerometer v1.2b     3-Axis Digital Accelerometer is the key part in projects like orientation detection, gesture detection and Motion detection. This 3-Axis Digital Accelerometer(\u00b11.5g) is based on Freescale's low power consumption module, MMA7660FC. It features up to 10,000g high shock survivability and configurable Samples per Second rate. For generous applications that don't require too large measurement range, this is a great choice because it's durable, energy saving and cost-efficient.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#specifications",
            "text": "Working voltage: 3.0 - 5.5V  Off Mode Current: 0.4\u03bcA  Standby Mode Current: 2\u03bcA  Active Mode Current: 47 \u03bcA at 1 ODR  Test Range: \u00b11.5g  Sensitivity: 21LSB/g  Suli-compatible Library    Note \nFor more details about Suli-compatible Library, please refer to  Suli .",
            "title": "Specifications"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#demonstration",
            "text": "",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#with-arduino",
            "text": "Here we are going to show you how to get raw data and data measured by \"g\" from this sensor.\u00a0  Connect this module to the I2C port of Grove - Base Shield\u00a0via a Grove cable.   Note \nIf you want to activate the Interrupt function of this module, you need to connect the INT soldering pad we broke out on the board with a pin of Arduino that's capable of Interrupt Service Routine.\u00a0   Install the library we provide in the  Resources  section.  Open the code directly by the path:File -> Example ->DigitalAccelerometer_MMA7660FC ->MMA7660FC_Demo.  In this program, acceleration information are sent from the sensor to Seeeduino via I2C bus and then Seeeduino printed them onto the serial monitor.\nOpen the serial monitor to check the result.   The outputs of this sensor consist of two parts: raw data and 3-axis acceleration info converted into the unit of gravity, \"g\".",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#with-raspberry-pi",
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.   4.Navigate to the demos' directory:     cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_i2c_accelerometer.py   # \"Ctrl+x\" to exit #      import time\n    import grovepi\n\n    # Connect the Grove Accelerometer (+/- 1.5g) to any I2C port eg. I2C-1\n    # Can be found at I2C address 0x4c\n    # SCL,SDA,VCC,GND\n\n    while True:\n        try:\n            print grovepi.acc_xyz()\n            time.sleep(.5)\n\n        except IOError:\n            print \"Error\"  5.Run the demo.      sudo python grove_i2c_accelerometer.py",
            "title": "With Raspberry Pi"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#reference",
            "text": "Below are two figures helping you understand the physical meaning of the result.  The first figure is about the direction of each axis:  The second figure gives some examples:",
            "title": "Reference"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#resources",
            "text": "Datasheet of MMA7660FC  Grove - 3-Axis Digital Accelerometer Eagle File  DigitalAccelerometer_MMA7660FC Library  github repository for 3-Axis Digital Accelerometer(\u00b11.5g)",
            "title": "Resources"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-1.5g/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/",
            "text": "Grove - 3-Axis Digital Accelerometer(\u00b1400g)\n\n\nIntroduction\n\n\n\n\nThe H3LIS331DL is a low power high performance 3-axis linear accelerometer belonging to the \u201cnano\u201d family, with digital I2C serial interface standard output. The device features ultra low power operational modes that allow advanced power saving and smart sleep to wake-up functions. The H3LIS331DL has dynamically user selectable full scales of \u00b1100g/\u00b1200 g/\u00b1400 g and it is capable of measuring accelerations with output data rates from 0.5 Hz to 1 kHz.\n\n\n\n\nFeatures\n\n\n\n\nWide power range DC3.3V to 5V\n\n\nGrove outline\n\n\n3 axis sensing\n\n\nSmall, low-profile package: 3\u00d73\u00d71mm TFLGA\n\n\nLow power 300\u00b5A at 3.3V (typical)\n\n\n\u00b1100g /\u00b1200 g /\u00b1400 g dynamically selectable full scale\n\n\nI2C digital output interface\n\n\n10000 g high shock survivability\n\n\nECOPACK\u00aeRoHS and \u201cGreen\u201d compliant\n\n\n\n\nApplication Ideas\n\n\n\n\nShock detector\n\n\nImpact recognition and logging\n\n\nConcussion detection\n\n\n\n\nUsage\n\n\nHere below we show you how to read the raw data from this accelerometer.\n\n\n\n\n\n\nPlug it onto the I2C port of your\u00a0\nGrove - Base Shield\n.\n\n\n\n\n\n\n\nDownload the \nDigital Accelerometer(\u00b1400g) Library\n and unpack it into arduino-1.0\\libraries in your Arduino installation folder.\n\n\n\n\n\n\nOpen the demo code directly by the path:File -> Example ->Grove_3Axis_Digital_Accelerometer_H3LIS331DL->H3LIS331DL_AdjVal. It is a sketch to adjust the raw data of H3LIS331DL to make it more precise.\n\n\n\n\n\n\nUpload the code and open the serial monitor. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n\nOpen the serial monitor to get the adjust value of reference as the steps described in serial output.\n\n\n\n\n\n\n\nOpen the demo code directly by the path:File -> Example ->Grove_3Axis_Digital_Accelerometer_H3LIS331DL->H3LIS331DL_Demo. Then modify the VAL_X_AXIS/VAL_Y_AXIS/VAL_Z_AXIS according to what you get from H3LIS331DL_AdjVal Sketch.\n\n\n\n\n\n\n\nUpload the code and open the serial monitor and open the serial monitor to check the result.\n\n\n\n\n\n\n\nResources\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b1400g) Eagle File\n\n\ngithub repository for 3-Axis Digital Accelerometer(\u00b1400g)\n\n\nH3LIS331DL Datasheet PDF\n\n\n\n\nHelp us make it better",
            "title": "Grove 3 Axis Digital Accelerometer 400g"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#grove-3-axis-digital-accelerometer400g",
            "text": "",
            "title": "Grove - 3-Axis Digital Accelerometer(\u00b1400g)"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#introduction",
            "text": "The H3LIS331DL is a low power high performance 3-axis linear accelerometer belonging to the \u201cnano\u201d family, with digital I2C serial interface standard output. The device features ultra low power operational modes that allow advanced power saving and smart sleep to wake-up functions. The H3LIS331DL has dynamically user selectable full scales of \u00b1100g/\u00b1200 g/\u00b1400 g and it is capable of measuring accelerations with output data rates from 0.5 Hz to 1 kHz.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#features",
            "text": "Wide power range DC3.3V to 5V  Grove outline  3 axis sensing  Small, low-profile package: 3\u00d73\u00d71mm TFLGA  Low power 300\u00b5A at 3.3V (typical)  \u00b1100g /\u00b1200 g /\u00b1400 g dynamically selectable full scale  I2C digital output interface  10000 g high shock survivability  ECOPACK\u00aeRoHS and \u201cGreen\u201d compliant",
            "title": "Features"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#application-ideas",
            "text": "Shock detector  Impact recognition and logging  Concussion detection",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#usage",
            "text": "Here below we show you how to read the raw data from this accelerometer.    Plug it onto the I2C port of your\u00a0 Grove - Base Shield .    Download the  Digital Accelerometer(\u00b1400g) Library  and unpack it into arduino-1.0\\libraries in your Arduino installation folder.    Open the demo code directly by the path:File -> Example ->Grove_3Axis_Digital_Accelerometer_H3LIS331DL->H3LIS331DL_AdjVal. It is a sketch to adjust the raw data of H3LIS331DL to make it more precise.    Upload the code and open the serial monitor. Please click  here  if you do not know how to upload.    Open the serial monitor to get the adjust value of reference as the steps described in serial output.    Open the demo code directly by the path:File -> Example ->Grove_3Axis_Digital_Accelerometer_H3LIS331DL->H3LIS331DL_Demo. Then modify the VAL_X_AXIS/VAL_Y_AXIS/VAL_Z_AXIS according to what you get from H3LIS331DL_AdjVal Sketch.    Upload the code and open the serial monitor and open the serial monitor to check the result.",
            "title": "Usage"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#resources",
            "text": "Grove - 3-Axis Digital Accelerometer(\u00b1400g) Eagle File  github repository for 3-Axis Digital Accelerometer(\u00b1400g)  H3LIS331DL Datasheet PDF",
            "title": "Resources"
        },
        {
            "location": "/Grove-3-Axis_Digital_Accelerometer-400g/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/",
            "text": "Grove - 3-Axis Digital Gyro\n\n\n\n\nIntroduction\n\n\nGrove - 3-Axis Digital Gyro module based on ITG 3200. It is the world\u2019s first single-chip, digital-output, 3-axis MEMS motion processing gyro optimised for gaming, 3D mice, and motion-based remote control applications for Internet connected Digital TVs and Set Top Boxes. The ITG-3200 features three 16-bit analog-to-digital converters (ADCs) for digitising the gyro outputs, a user-selectable internal low-pass filter bandwidth, and a Fast-Mode \nI2C\n (400kHz) interface.\n\n\n\n\nFeatures\n\n\n\n\nSupply Voltage: 3.3V, 5V\n\n\nOperation Current: 6.5mA\n\n\nStandby current: 5\u03bcA\n\n\nSensitivity: 14 LSBs per \u00b0/sec\n\n\nFull scale range: \u00b12000\u00b0/sec\n\n\nAcceleration: 10,000g for 0.3ms\n\n\nI2C Interface\n\n\n\u00b12000\u00b0/s full scale range and 14.375 LSBs per \u00b0/s sensitivity\n\n\nThree integrated 16-bit ADCs\n\n\nOn-chip temperature sensor\n\n\nIntegrated amplifiers and low-pass filters\n\n\nHermetically sealed for temp and humidity resistance\n\n\nRoHS and Green compliant\n\n\n\n\nDemonstration\n\n\nThis demo will show you how to get data from this digital gyro, the data is in the unit of rad/s.\n\n\nHere we need a Grove - 3-Axis Digital Gyro and a Seeeduino V3.0.\n\n\nHardware Installation\n\n\nHardware installation is very easy, because there's an I2C Grove in Seeeduino,\n\n\nSo, what we need to do is connect it to I2C Grove via a Grove cable.\n\n\n\n\nDownload Code and Upload\n\n\nYou can download the library in github, click \nhere\n, then extract it to libraries folder of Arduino.\n\n\nThen open File -> examples -> Grove_3_Digital_Gyro -> ITG3200_gyro, you can open the demo code.\n\n\n\n\nClick Upload to upload the code, if you have any problem about how to start Arduino, please click \nhere\n for some help.\n\n\nCheck the result\n\n\nNow, you can open the serial monitor to check the result.\n\n\n\n\nReference\n\n\nThe diagram below shows the orientations of the 3 axes. You can use it to understand the physical meanings of the result.\n\n\n\n\nResources\n\n\n\n\nDatasheet of ITG-3200.\n\n\nGrove - 3-Axis Digital Gyro Eagle File\n\n\nDigital Gyro Library\n\n\n\n\nHelp us make it better",
            "title": "Grove 3 Axis Digital Gyro"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#grove-3-axis-digital-gyro",
            "text": "",
            "title": "Grove - 3-Axis Digital Gyro"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#introduction",
            "text": "Grove - 3-Axis Digital Gyro module based on ITG 3200. It is the world\u2019s first single-chip, digital-output, 3-axis MEMS motion processing gyro optimised for gaming, 3D mice, and motion-based remote control applications for Internet connected Digital TVs and Set Top Boxes. The ITG-3200 features three 16-bit analog-to-digital converters (ADCs) for digitising the gyro outputs, a user-selectable internal low-pass filter bandwidth, and a Fast-Mode  I2C  (400kHz) interface.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#features",
            "text": "Supply Voltage: 3.3V, 5V  Operation Current: 6.5mA  Standby current: 5\u03bcA  Sensitivity: 14 LSBs per \u00b0/sec  Full scale range: \u00b12000\u00b0/sec  Acceleration: 10,000g for 0.3ms  I2C Interface  \u00b12000\u00b0/s full scale range and 14.375 LSBs per \u00b0/s sensitivity  Three integrated 16-bit ADCs  On-chip temperature sensor  Integrated amplifiers and low-pass filters  Hermetically sealed for temp and humidity resistance  RoHS and Green compliant",
            "title": "Features"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#demonstration",
            "text": "This demo will show you how to get data from this digital gyro, the data is in the unit of rad/s.  Here we need a Grove - 3-Axis Digital Gyro and a Seeeduino V3.0.",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#hardware-installation",
            "text": "Hardware installation is very easy, because there's an I2C Grove in Seeeduino,  So, what we need to do is connect it to I2C Grove via a Grove cable.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#download-code-and-upload",
            "text": "You can download the library in github, click  here , then extract it to libraries folder of Arduino.  Then open File -> examples -> Grove_3_Digital_Gyro -> ITG3200_gyro, you can open the demo code.   Click Upload to upload the code, if you have any problem about how to start Arduino, please click  here  for some help.",
            "title": "Download Code and Upload"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#check-the-result",
            "text": "Now, you can open the serial monitor to check the result.",
            "title": "Check the result"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#reference",
            "text": "The diagram below shows the orientations of the 3 axes. You can use it to understand the physical meanings of the result.",
            "title": "Reference"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#resources",
            "text": "Datasheet of ITG-3200.  Grove - 3-Axis Digital Gyro Eagle File  Digital Gyro Library",
            "title": "Resources"
        },
        {
            "location": "/Grove-3-Axis_Digital_Gyro/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/",
            "text": "Grove - 315MHz RF Kit\n\n\nIntroduction\n\n\n\n\nThis kit is used for one way wireless communication at a frequency of 315MHz and includes a transmitter module and a receiver module. The twig configuration of this kit allows for around 40 meters of transmitting distance indoors, or around 100 meters outside. The 315 MHz frequency is suitable for use without a license in the United States. For use in Europe, please see the 433 MHz version of this product.\n\n\n\n\nFeatures\n\n\n\n\nGROVE compatible interface.\n\n\nUses ASK (Amplitude Shift Keying) Modulation.\n\n\nOne way communication.\n\n\n\n\nApplication Ideas\n\n\n\n\nRemote control\n\n\nRemote automation\n\n\nAlarm\n\n\n\n\nMechanical Dimensions\n\n\n\n\nReceiver: 24mm by 42mm\n\n\nTransmitter: 20mm by 24mm\n\n\n\n\nUsage\n\n\nThe transmitter and receiver modules both rely on a single wire for communication. Though using the UART supplied by the arduino platform can work, it is recommended, instead, to use the VirtualWire library which uses Amplitude Shift Keying for modulation which provides better communication.\n\n\nBoth the transmitter and receiver modules require three wires: Vcc, Ground, and signal. Pin 2 of both parts of the kit are not connected.\n\n\nHardware Installation\n\n\nConnect the Transmitter module to Digital I/O 2 of the \nStem_-_Base_Shield\n on the arduino being used for transmission.\n\n\nConnect the Transmitter module to Digital I/O 2 of the \nStem_-_Base_Shield\n on the receiving arduino.\n\n\nProgramming\n\n\nSample code for Transmitter:\n\n\n#include <VirtualWire.h>\n\u00a0\nint RF_TX_PIN = 2;\n\u00a0\nvoid setup()\n{\n  vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n  vw_setup(2000); // Transmission speed in bits per second.\n}\n\u00a0\nvoid loop()\n{\n  const char *msg = \"hello\";\n  vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n  delay(400);\n\u00a0\n}\n\n\n\n\nSample code for Receiver:\n\n\n#include <VirtualWire.h>\n\u00a0\nint RF_RX_PIN = 2;\n\u00a0\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\"setup\");\n  vw_set_rx_pin(RF_RX_PIN);  // Setup receive pin.\n  vw_setup(2000); // Transmission speed in bits per second.\n  vw_rx_start(); // Start the PLL receiver.\n}\n\u00a0\nvoid loop()\n{\n  uint8_t buf[VW_MAX_MESSAGE_LEN];\n  uint8_t buflen = VW_MAX_MESSAGE_LEN;\n  if(vw_get_message(buf, &buflen)) // non-blocking I/O\n  {\n    int i;\n    // Message with a good checksum received, dump HEX\n    Serial.print(\"Got: \");\n    for(i = 0; i < buflen; ++i)\n    {\n      Serial.print(buf[i], HEX);\n      Serial.print(\" \");\n    }\n    Serial.println(\"\");\n  }\n}\n\n\n\n\nResources\n\n\n\n\nDemo code: \n433MHz demo.zip\n\n\nVirtualWire 1.20\n\n\nVirtualWire Documentation\n\n\nTI:LM358PSR\n\n\n\n\nHelp us make it better",
            "title": "Grove 315MHz RF Kit"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#grove-315mhz-rf-kit",
            "text": "",
            "title": "Grove - 315MHz RF Kit"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#introduction",
            "text": "This kit is used for one way wireless communication at a frequency of 315MHz and includes a transmitter module and a receiver module. The twig configuration of this kit allows for around 40 meters of transmitting distance indoors, or around 100 meters outside. The 315 MHz frequency is suitable for use without a license in the United States. For use in Europe, please see the 433 MHz version of this product.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#features",
            "text": "GROVE compatible interface.  Uses ASK (Amplitude Shift Keying) Modulation.  One way communication.",
            "title": "Features"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#application-ideas",
            "text": "Remote control  Remote automation  Alarm",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#mechanical-dimensions",
            "text": "Receiver: 24mm by 42mm  Transmitter: 20mm by 24mm",
            "title": "Mechanical Dimensions"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#usage",
            "text": "The transmitter and receiver modules both rely on a single wire for communication. Though using the UART supplied by the arduino platform can work, it is recommended, instead, to use the VirtualWire library which uses Amplitude Shift Keying for modulation which provides better communication.  Both the transmitter and receiver modules require three wires: Vcc, Ground, and signal. Pin 2 of both parts of the kit are not connected.",
            "title": "Usage"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#hardware-installation",
            "text": "Connect the Transmitter module to Digital I/O 2 of the  Stem_-_Base_Shield  on the arduino being used for transmission.  Connect the Transmitter module to Digital I/O 2 of the  Stem_-_Base_Shield  on the receiving arduino.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#programming",
            "text": "Sample code for Transmitter:  #include <VirtualWire.h>\n\u00a0\nint RF_TX_PIN = 2;\n\u00a0\nvoid setup()\n{\n  vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n  vw_setup(2000); // Transmission speed in bits per second.\n}\n\u00a0\nvoid loop()\n{\n  const char *msg = \"hello\";\n  vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n  delay(400);\n\u00a0\n}  Sample code for Receiver:  #include <VirtualWire.h>\n\u00a0\nint RF_RX_PIN = 2;\n\u00a0\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\"setup\");\n  vw_set_rx_pin(RF_RX_PIN);  // Setup receive pin.\n  vw_setup(2000); // Transmission speed in bits per second.\n  vw_rx_start(); // Start the PLL receiver.\n}\n\u00a0\nvoid loop()\n{\n  uint8_t buf[VW_MAX_MESSAGE_LEN];\n  uint8_t buflen = VW_MAX_MESSAGE_LEN;\n  if(vw_get_message(buf, &buflen)) // non-blocking I/O\n  {\n    int i;\n    // Message with a good checksum received, dump HEX\n    Serial.print(\"Got: \");\n    for(i = 0; i < buflen; ++i)\n    {\n      Serial.print(buf[i], HEX);\n      Serial.print(\" \");\n    }\n    Serial.println(\"\");\n  }\n}",
            "title": "Programming"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#resources",
            "text": "Demo code:  433MHz demo.zip  VirtualWire 1.20  VirtualWire Documentation  TI:LM358PSR",
            "title": "Resources"
        },
        {
            "location": "/Grove-315MHz_RF_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-4-Digit_Display/",
            "text": "Grove - 4-Digit Display\n\n\nIntroduction\n\n\n\n\nGrove - 4-Digit Display module is a 12-pin module. In this module, we utilise a TM1637 to scale down the number of controlling pins to 2. That is to say, it controls both the content and the luminance via only 2 digital pins of Arduino or Seeeduino. For projects that require alpha-numeric display, this can be a nice choice.\n\n\n\n\nFeatures\n\n\n\n\n4 digit red alpha-numeric display\n\n\nGrove compatible interface (3.3V/5V)\n\n\n8 adjustable luminance levels\n\n\n\n\nApplication Ideas\n\n\n\n\nTime display\n\n\nStopwatch\n\n\nSensors' input display\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3.3\n\n\n\n\n5.0\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n0.2\n\n\n\n\n27\n\n\n\n\n80\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nDimensions\n\n\n\n\n42x24x14\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nNet Weight\n\n\n\n\n7\u00b11\n\n\n\n\ng\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nGrove interface\n - Can be connected to digital port on Grove - Base Shield.\n\n\n4 - digit display\n - Common anode digital tube.\n\n\nPin definition:\n CLK DIO VCC GND\n\n\nGetting Started\n\n\nWith \nTI LaunchPad\n\n\nDisplaying the Numbers (4-Digital-Display)\n\n\nThis example demonstrates how to display some digital numbers using a Grove-4-Digital Display.\n\n\n\n\n/*\n * TM1637.cpp\n * A library for the 4 digit display\n */\n#include \"TM1637.h\"\n#define CLK 39 //pins definitions for TM1637 and can be changed to other ports\n#define DIO 38\nTM1637 tm1637(CLK,DIO);\nvoid setup()\n{\n    tm1637.init();\n    tm1637.set(BRIGHT_TYPICAL);//BRIGHT_TYPICAL = 2,BRIGHT_DARKEST = 0,BRIGHTEST = 7;\n}\nvoid loop()\n{\n    int8_t NumTab[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};//0~9,A,b,C,d,E,F\n    int8_t ListDisp[4];\n    unsigned char i = 0;\n    unsigned char count = 0;\n    delay(150);\n    while(1)\n    {\n        i = count;\n        count ++;\n        if(count == sizeof(NumTab)) count = 0;\n        for(unsigned char BitSelect = 0;BitSelect < 4;BitSelect ++)\n        {\n            ListDisp[BitSelect] = NumTab[i];\n            i ++;\n            if(i == sizeof(NumTab)) i = 0;\n        }\n        tm1637.display(0,ListDisp[0]);\n        tm1637.display(1,ListDisp[1]);\n        tm1637.display(2,ListDisp[2]);\n        tm1637.display(3,ListDisp[3]);\n        delay(300);\n    }\n}\n\n\n\n\nWith \nArduino\n\n\nThe module uses an LED drive chip - TM1637 to control the contents and change the luminance. Here we drive it to display time.\n\n\n\n\n\n\nConnect the Grove socket marked \"IN\" on the LED Strip Driver and digital port 2 of the \nGrove - Base Shield\n with a Grove cable. You can change to the digital port as you like. But don't forget to change the port number in the definition of the demo code at the same time.\n\n\n\n\n\n\nPlug onto Arduino/Seeeduino or plug \nGrove - Mega Shield\n onto Arduino Mega.\n\n\nSeeeduino and Grove - 4-digit display:\n\n\n\n\nArduino Mega and Grove - 4-digit display:\n\n\n\n\n\n\n\nConnect Arduino/Seeeduino to PC via a USB cable.\n\n\n\n\n\n\nDownload \nthe 4-Digit Display library\n and \nTimerOne library\n. Unzip and put them in the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries.\n\n\n\n\n\n\nRestart the Arduino IDE, open one demo code you like, for example ClockDisplay directly by the path:File -> Example ->DigitalTube->ClockDisplay.\n\n\n\n\n\n\n\n\nUpload the demo code and the clock will be ticking in a few seconds. Please click \nhere\n if you do not know how to upload.\n\n\nYou can see this:\n\n\n\n\n\n\n\nWith \nRaspberry Pi\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket D5 by using a grove cable.\n\n\n\n\n4.Navigate to the demos' directory:\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_4_digit_display.py   # \"Ctrl+x\" to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove 4 Digit Display to digital port D5\n    # CLK,DIO,VCC,GND\n    display = 5\n    grovepi.pinMode(display,\"OUTPUT\")\n\n    # If you have an analog sensor connect it to A0 so you can monitor it below\n    sensor = 0\n    grovepi.pinMode(sensor,\"INPUT\")\n\n    time.sleep(.5)\n\n    # 4 Digit Display methods\n    # grovepi.fourDigit_init(pin)\n    # grovepi.fourDigit_number(pin,value,leading_zero)\n    # grovepi.fourDigit_brightness(pin,brightness)\n    # grovepi.fourDigit_digit(pin,segment,value)\n    # grovepi.fourDigit_segment(pin,segment,leds)\n    # grovepi.fourDigit_score(pin,left,right)\n    # grovepi.fourDigit_monitor(pin,analog,duration)\n    # grovepi.fourDigit_on(pin)\n    # grovepi.fourDigit_off(pin)\n\n    while True:\n        try:\n            print \"Test 1) Initialise\"\n            grovepi.fourDigit_init(display)\n            time.sleep(.5)\n\n            print \"Test 2) Set brightness\"\n            for i in range(0,8):\n                grovepi.fourDigit_brightness(display,i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n            # set to lowest brightness level\n            grovepi.fourDigit_brightness(display,0)\n            time.sleep(.5)\n\n            print \"Test 3) Set number without leading zeros\"\n            leading_zero = 0\n            grovepi.fourDigit_number(display,1,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,12,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,123,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,1234,leading_zero)\n            time.sleep(.5)\n\n            print \"Test 4) Set number with leading zeros\"\n            leading_zero = 1\n            grovepi.fourDigit_number(display,5,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,56,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,567,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,5678,leading_zero)\n            time.sleep(.5)\n\n            print \"Test 5) Set individual digit\"\n            grovepi.fourDigit_digit(display,0,2)\n            grovepi.fourDigit_digit(display,1,6)\n            grovepi.fourDigit_digit(display,2,9)\n            grovepi.fourDigit_digit(display,3,15) # 15 = F\n            time.sleep(.5)\n\n            print \"Test 6) Set individual segment\"\n            grovepi.fourDigit_segment(display,0,118) # 118 = H\n            grovepi.fourDigit_segment(display,1,121) # 121 = E\n            grovepi.fourDigit_segment(display,2,118) # 118 = H\n            grovepi.fourDigit_segment(display,3,121) # 121 = E\n            time.sleep(.5)\n\n            grovepi.fourDigit_segment(display,0,57) # 57 = C\n            grovepi.fourDigit_segment(display,1,63) # 63 = O\n            grovepi.fourDigit_segment(display,2,63) # 63 = O\n            grovepi.fourDigit_segment(display,3,56) # 56 = L\n            time.sleep(.5)\n\n            print \"Test 7) Set score\"\n            grovepi.fourDigit_score(display,0,0)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,0)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,1)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,2)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,3)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,4)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,5)\n            time.sleep(.5)\n\n            print \"Test 8) Set time\"\n            grovepi.fourDigit_score(display,12,59)\n            time.sleep(.5)\n\n            print \"Test 9) Monitor analog pin\"\n            seconds = 10\n            grovepi.fourDigit_monitor(display,sensor,seconds)\n            time.sleep(.5)\n\n            print \"Test 10) Switch all on\"\n            grovepi.fourDigit_on(display)\n            time.sleep(.5)\n\n            print \"Test 11) Switch all off\"\n            grovepi.fourDigit_off(display)\n            time.sleep(.5)\n\n        except KeyboardInterrupt:\n            grovepi.fourDigit_off(display)\n            break\n        except IOError:\n            print \"Error\"\n\n\n\n\n5.Run the demo.\n\n\n   sudo python grove_4_digit_display.py\n\n\n\n6.This demo may not work if your grovepi doesn't have the newest firmware, update the firmware.\n\n\ncd yourpath/GrovePi/Firmware\nsudo ./firmware_update.sh\n\n\n\nResources\n\n\n\n\nGrove - 4-Digit Display V1.0 eagle files\n\n\nSchematic in PDF\n\n\n4-Digit Display library\n\n\nTimerOne library\n\n\nFour-Digit Display Suli Library\n\n\nTM1637 datasheet\n\n\n\n\nRelated Projects\n\n\nIf you want to make some awesome projects by 4-Digit Display, here's one project for reference.\n\n\n\n\nAir Quality Box\n\n\n\n\n\n\nWith this demo, we can see the air quality data on 4-Digit Display.\n\n\n\n\nHelp us make it better",
            "title": "Grove 4 Digit Display"
        },
        {
            "location": "/Grove-4-Digit_Display/#grove-4-digit-display",
            "text": "",
            "title": "Grove - 4-Digit Display"
        },
        {
            "location": "/Grove-4-Digit_Display/#introduction",
            "text": "Grove - 4-Digit Display module is a 12-pin module. In this module, we utilise a TM1637 to scale down the number of controlling pins to 2. That is to say, it controls both the content and the luminance via only 2 digital pins of Arduino or Seeeduino. For projects that require alpha-numeric display, this can be a nice choice.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-4-Digit_Display/#features",
            "text": "4 digit red alpha-numeric display  Grove compatible interface (3.3V/5V)  8 adjustable luminance levels",
            "title": "Features"
        },
        {
            "location": "/Grove-4-Digit_Display/#application-ideas",
            "text": "Time display  Stopwatch  Sensors' input display",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-4-Digit_Display/#specifications",
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3.3  \n5.0  \n5.5  \nVDC    \nCurrent  \n0.2  \n27  \n80  \nmA    \nDimensions  \n42x24x14  \nmm    \nNet Weight  \n7\u00b11  \ng",
            "title": "Specifications"
        },
        {
            "location": "/Grove-4-Digit_Display/#hardware-overview",
            "text": "Grove interface  - Can be connected to digital port on Grove - Base Shield.  4 - digit display  - Common anode digital tube.  Pin definition:  CLK DIO VCC GND",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-4-Digit_Display/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-4-Digit_Display/#with-ti-launchpad",
            "text": "Displaying the Numbers (4-Digital-Display)  This example demonstrates how to display some digital numbers using a Grove-4-Digital Display.   /*\n * TM1637.cpp\n * A library for the 4 digit display\n */\n#include \"TM1637.h\"\n#define CLK 39 //pins definitions for TM1637 and can be changed to other ports\n#define DIO 38\nTM1637 tm1637(CLK,DIO);\nvoid setup()\n{\n    tm1637.init();\n    tm1637.set(BRIGHT_TYPICAL);//BRIGHT_TYPICAL = 2,BRIGHT_DARKEST = 0,BRIGHTEST = 7;\n}\nvoid loop()\n{\n    int8_t NumTab[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};//0~9,A,b,C,d,E,F\n    int8_t ListDisp[4];\n    unsigned char i = 0;\n    unsigned char count = 0;\n    delay(150);\n    while(1)\n    {\n        i = count;\n        count ++;\n        if(count == sizeof(NumTab)) count = 0;\n        for(unsigned char BitSelect = 0;BitSelect < 4;BitSelect ++)\n        {\n            ListDisp[BitSelect] = NumTab[i];\n            i ++;\n            if(i == sizeof(NumTab)) i = 0;\n        }\n        tm1637.display(0,ListDisp[0]);\n        tm1637.display(1,ListDisp[1]);\n        tm1637.display(2,ListDisp[2]);\n        tm1637.display(3,ListDisp[3]);\n        delay(300);\n    }\n}",
            "title": "With TI LaunchPad"
        },
        {
            "location": "/Grove-4-Digit_Display/#with-arduino",
            "text": "The module uses an LED drive chip - TM1637 to control the contents and change the luminance. Here we drive it to display time.    Connect the Grove socket marked \"IN\" on the LED Strip Driver and digital port 2 of the  Grove - Base Shield  with a Grove cable. You can change to the digital port as you like. But don't forget to change the port number in the definition of the demo code at the same time.    Plug onto Arduino/Seeeduino or plug  Grove - Mega Shield  onto Arduino Mega.  Seeeduino and Grove - 4-digit display:   Arduino Mega and Grove - 4-digit display:    Connect Arduino/Seeeduino to PC via a USB cable.    Download  the 4-Digit Display library  and  TimerOne library . Unzip and put them in the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries.    Restart the Arduino IDE, open one demo code you like, for example ClockDisplay directly by the path:File -> Example ->DigitalTube->ClockDisplay.     Upload the demo code and the clock will be ticking in a few seconds. Please click  here  if you do not know how to upload.  You can see this:",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-4-Digit_Display/#with-raspberry-pi",
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket D5 by using a grove cable.   4.Navigate to the demos' directory:      cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_4_digit_display.py   # \"Ctrl+x\" to exit #      import time\n    import grovepi\n\n    # Connect the Grove 4 Digit Display to digital port D5\n    # CLK,DIO,VCC,GND\n    display = 5\n    grovepi.pinMode(display,\"OUTPUT\")\n\n    # If you have an analog sensor connect it to A0 so you can monitor it below\n    sensor = 0\n    grovepi.pinMode(sensor,\"INPUT\")\n\n    time.sleep(.5)\n\n    # 4 Digit Display methods\n    # grovepi.fourDigit_init(pin)\n    # grovepi.fourDigit_number(pin,value,leading_zero)\n    # grovepi.fourDigit_brightness(pin,brightness)\n    # grovepi.fourDigit_digit(pin,segment,value)\n    # grovepi.fourDigit_segment(pin,segment,leds)\n    # grovepi.fourDigit_score(pin,left,right)\n    # grovepi.fourDigit_monitor(pin,analog,duration)\n    # grovepi.fourDigit_on(pin)\n    # grovepi.fourDigit_off(pin)\n\n    while True:\n        try:\n            print \"Test 1) Initialise\"\n            grovepi.fourDigit_init(display)\n            time.sleep(.5)\n\n            print \"Test 2) Set brightness\"\n            for i in range(0,8):\n                grovepi.fourDigit_brightness(display,i)\n                time.sleep(.2)\n            time.sleep(.3)\n\n            # set to lowest brightness level\n            grovepi.fourDigit_brightness(display,0)\n            time.sleep(.5)\n\n            print \"Test 3) Set number without leading zeros\"\n            leading_zero = 0\n            grovepi.fourDigit_number(display,1,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,12,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,123,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,1234,leading_zero)\n            time.sleep(.5)\n\n            print \"Test 4) Set number with leading zeros\"\n            leading_zero = 1\n            grovepi.fourDigit_number(display,5,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,56,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,567,leading_zero)\n            time.sleep(.5)\n            grovepi.fourDigit_number(display,5678,leading_zero)\n            time.sleep(.5)\n\n            print \"Test 5) Set individual digit\"\n            grovepi.fourDigit_digit(display,0,2)\n            grovepi.fourDigit_digit(display,1,6)\n            grovepi.fourDigit_digit(display,2,9)\n            grovepi.fourDigit_digit(display,3,15) # 15 = F\n            time.sleep(.5)\n\n            print \"Test 6) Set individual segment\"\n            grovepi.fourDigit_segment(display,0,118) # 118 = H\n            grovepi.fourDigit_segment(display,1,121) # 121 = E\n            grovepi.fourDigit_segment(display,2,118) # 118 = H\n            grovepi.fourDigit_segment(display,3,121) # 121 = E\n            time.sleep(.5)\n\n            grovepi.fourDigit_segment(display,0,57) # 57 = C\n            grovepi.fourDigit_segment(display,1,63) # 63 = O\n            grovepi.fourDigit_segment(display,2,63) # 63 = O\n            grovepi.fourDigit_segment(display,3,56) # 56 = L\n            time.sleep(.5)\n\n            print \"Test 7) Set score\"\n            grovepi.fourDigit_score(display,0,0)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,0)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,1)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,2)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,3)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,4)\n            time.sleep(.2)\n            grovepi.fourDigit_score(display,1,5)\n            time.sleep(.5)\n\n            print \"Test 8) Set time\"\n            grovepi.fourDigit_score(display,12,59)\n            time.sleep(.5)\n\n            print \"Test 9) Monitor analog pin\"\n            seconds = 10\n            grovepi.fourDigit_monitor(display,sensor,seconds)\n            time.sleep(.5)\n\n            print \"Test 10) Switch all on\"\n            grovepi.fourDigit_on(display)\n            time.sleep(.5)\n\n            print \"Test 11) Switch all off\"\n            grovepi.fourDigit_off(display)\n            time.sleep(.5)\n\n        except KeyboardInterrupt:\n            grovepi.fourDigit_off(display)\n            break\n        except IOError:\n            print \"Error\"  5.Run the demo.     sudo python grove_4_digit_display.py  6.This demo may not work if your grovepi doesn't have the newest firmware, update the firmware.  cd yourpath/GrovePi/Firmware\nsudo ./firmware_update.sh",
            "title": "With Raspberry Pi"
        },
        {
            "location": "/Grove-4-Digit_Display/#resources",
            "text": "Grove - 4-Digit Display V1.0 eagle files  Schematic in PDF  4-Digit Display library  TimerOne library  Four-Digit Display Suli Library  TM1637 datasheet   Related Projects  If you want to make some awesome projects by 4-Digit Display, here's one project for reference.   Air Quality Box    With this demo, we can see the air quality data on 4-Digit Display.",
            "title": "Resources"
        },
        {
            "location": "/Grove-4-Digit_Display/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/",
            "text": "Grove - 433MHz Simple RF Link Kit\n\n\nIntroduction\n\n\n\n\nThis kit is used for one way wireless communication at a frequency of 433MHz and includes a transmitter module and a receiver module. The twig configuration of this kit allows for around 40 meters of transmitting distance indoors, or around 100 meters outside.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescription\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv0.9b\n\n\nInitial public release\n\n\n03,Oct,2011\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nGROVE compatible interface.\n\n\nUses ASK (Amplitude Shift Keying) Modulation.\n\n\nOne way communication.\n\n\n\n\nSpecifications\n\n\nTransmitter Module\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n3.0\n\n\n\n\n5.0\n\n\n\n\n12.0\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n3\n\n\n\n\n/\n\n\n\n\n10\n\n\n\n\nmA\n\n\n\n\n\n\n\n\nWork Mode\n\n\n\n\nASK\n\n\n\n\n/\n\n\n\n\n\n\n\n\nTransmit Power(Max)\n\n\n\n\n15\n\n\n\n\nmW\n\n\n\n\n\n\n\n\nWorking Distance\n\n\n\n\n40\n\n\n\n\n/\n\n\n\n\n100\n\n\n\n\nm\n\n\n\n\n\n\n\n\nReceiver Module\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n5\n\n\nVDC\n\n\n\n\n\n\nQuiescent Current\n\n\n5\n\n\nmA\n\n\n\n\n\n\nReceiver Sensitivity\n\n\n-105\n\n\ndBm\n\n\n\n\n\n\nOperating frequency\n\n\n433.92\n\n\nMHz\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nRemote control\n\n\nRemote automation\n\n\nAlarm\n\n\n\n\nUsage\n\n\nThe transmitter and receiver modules both rely on a single wire for communication. Though using the UART supplied by the Arduino platform can work, it is recommended, instead, to use the VirtualWire library which uses Amplitude Shift Keying for modulation which provides better communication.\n\n\nBoth the transmitter and receiver modules require three wires: Vcc, Ground, and signal. Pin 2 of both parts of the kit are not connected.\n\n\n\n\nConnect the Transmitter module to Digital I/O 2 of the \nGrove_-_Base_Shield\n on the Arduino being used for transmission.\n\n\n\n\nError creating thumbnail: Invalid thumbnail parameters\n\n\n\n\nConnect the Receiver module to Digital I/O 2 of the \nGrove_-_Base_Shield\n on the receiving Arduino.\n\n\n\n\nError creating thumbnail: Invalid thumbnail parameters\n\n\n\n\nDownload the \nVirtualWire library\n and unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries. Please reference \nhere\n.\n\n\nUpload the code below for transmitter module:\n\n\n\n\n    #include <VirtualWire.h>\n\n    //Grove - 315(433) RF link kit Demo v1.0\n    //by\u00a0:http://www.seeedstudio.com/\n    //connect the sent module to D2 to use  \n    #include <VirtualWire.h>\n\n    int RF_TX_PIN = 2;\n\n    void setup()\n    {\n      vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n      vw_setup(2000); // Transmission speed in bits per second.\n    }\n\n    void loop()\n    {\n      const char *msg = \"hello\";\n      vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n      delay(400);\n\n    }\n\n\n\n\n\n\nUpload the code below for receiver module:\n\n\n\n\n    //Grove - 315(433) RF link kit Demo v1.0\n    //by\u00a0:http://www.seeedstudio.com/\n    //connect the receive module to D2 to use ..\n    #include <VirtualWire.h>\n\n    int RF_RX_PIN = 2;\n\n    void setup()\n    {\n      Serial.begin(9600);\n      Serial.println(\"setup\");\n      vw_set_rx_pin(RF_RX_PIN);  // Setup receive pin.\n      vw_setup(2000); // Transmission speed in bits per second.\n      vw_rx_start(); // Start the PLL receiver.\n    }\n\n    void loop()\n    {\n      uint8_t buf[VW_MAX_MESSAGE_LEN];\n      uint8_t buflen = VW_MAX_MESSAGE_LEN;\n      if(vw_get_message(buf, &buflen)) // non-blocking I/O\n      {\n        int i;\n        // Message with a good checksum received, dump HEX\n        Serial.print(\"Got: \");\n        for(i = 0; i < buflen; ++i)\n        {\n          Serial.print(buf[i], HEX);\n          Serial.print(\" \");\n          //Serial.print(buf[i]);\n        }\n        Serial.println(\"\");\n      }\n    }\n\n\n\n\n\n\nOpen the serial monitor of receiver module to see the result.\n\n\n\n\n\n\nThis is just a simple transmitter and receiver instance as a reference.\n\n\nResources\n\n\n\n\nVirtualWire Library.zip\n\n\n433MHz_demo.zip\n\n\nVirtualWire Documentation\n\n\nTI:LM358PSR\n\n\nR433A Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove 433MHz Simple RF Link Kit"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#grove-433mhz-simple-rf-link-kit",
            "text": "",
            "title": "Grove - 433MHz Simple RF Link Kit"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#introduction",
            "text": "This kit is used for one way wireless communication at a frequency of 433MHz and includes a transmitter module and a receiver module. The twig configuration of this kit allows for around 40 meters of transmitting distance indoors, or around 100 meters outside.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#version-tracker",
            "text": "Revision  Description  Release      v0.9b  Initial public release  03,Oct,2011",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#features",
            "text": "GROVE compatible interface.  Uses ASK (Amplitude Shift Keying) Modulation.  One way communication.",
            "title": "Features"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#specifications",
            "text": "",
            "title": "Specifications"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#transmitter-module",
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n3.0  \n5.0  \n12.0  \nVDC    \nCurrent  \n3  \n/  \n10  \nmA    \nWork Mode  \nASK  \n/    \nTransmit Power(Max)  \n15  \nmW    \nWorking Distance  \n40  \n/  \n100  \nm",
            "title": "Transmitter Module"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#receiver-module",
            "text": "Item  Typical  Unit      Working Voltage  5  VDC    Quiescent Current  5  mA    Receiver Sensitivity  -105  dBm    Operating frequency  433.92  MHz",
            "title": "Receiver Module"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#application-ideas",
            "text": "Remote control  Remote automation  Alarm",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#usage",
            "text": "The transmitter and receiver modules both rely on a single wire for communication. Though using the UART supplied by the Arduino platform can work, it is recommended, instead, to use the VirtualWire library which uses Amplitude Shift Keying for modulation which provides better communication.  Both the transmitter and receiver modules require three wires: Vcc, Ground, and signal. Pin 2 of both parts of the kit are not connected.   Connect the Transmitter module to Digital I/O 2 of the  Grove_-_Base_Shield  on the Arduino being used for transmission.   Error creating thumbnail: Invalid thumbnail parameters   Connect the Receiver module to Digital I/O 2 of the  Grove_-_Base_Shield  on the receiving Arduino.   Error creating thumbnail: Invalid thumbnail parameters   Download the  VirtualWire library  and unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries. Please reference  here .  Upload the code below for transmitter module:       #include <VirtualWire.h>\n\n    //Grove - 315(433) RF link kit Demo v1.0\n    //by\u00a0:http://www.seeedstudio.com/\n    //connect the sent module to D2 to use  \n    #include <VirtualWire.h>\n\n    int RF_TX_PIN = 2;\n\n    void setup()\n    {\n      vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n      vw_setup(2000); // Transmission speed in bits per second.\n    }\n\n    void loop()\n    {\n      const char *msg = \"hello\";\n      vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n      delay(400);\n\n    }   Upload the code below for receiver module:       //Grove - 315(433) RF link kit Demo v1.0\n    //by\u00a0:http://www.seeedstudio.com/\n    //connect the receive module to D2 to use ..\n    #include <VirtualWire.h>\n\n    int RF_RX_PIN = 2;\n\n    void setup()\n    {\n      Serial.begin(9600);\n      Serial.println(\"setup\");\n      vw_set_rx_pin(RF_RX_PIN);  // Setup receive pin.\n      vw_setup(2000); // Transmission speed in bits per second.\n      vw_rx_start(); // Start the PLL receiver.\n    }\n\n    void loop()\n    {\n      uint8_t buf[VW_MAX_MESSAGE_LEN];\n      uint8_t buflen = VW_MAX_MESSAGE_LEN;\n      if(vw_get_message(buf, &buflen)) // non-blocking I/O\n      {\n        int i;\n        // Message with a good checksum received, dump HEX\n        Serial.print(\"Got: \");\n        for(i = 0; i < buflen; ++i)\n        {\n          Serial.print(buf[i], HEX);\n          Serial.print(\" \");\n          //Serial.print(buf[i]);\n        }\n        Serial.println(\"\");\n      }\n    }   Open the serial monitor of receiver module to see the result.    This is just a simple transmitter and receiver instance as a reference.",
            "title": "Usage"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#resources",
            "text": "VirtualWire Library.zip  433MHz_demo.zip  VirtualWire Documentation  TI:LM358PSR  R433A Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-433MHz_Simple_RF_Link_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/",
            "text": "Grove - 6-Axis Accelerometer&Compass V2.0\n\n\nIntroduction\n\n\n\n\nThe Grove \u20136-Axis Accelerometer&Compass V2.0 is a 3-axis accelerometer combined with a 3-axis magnetic sensor. It is an upgraded version of \nGrove - 6-Axis Accelerometer&Compass V1.0\n and based on the sensor module LSM303D which has a selectable linear acceleration full scale range of \u00b12g / \u00b14g / \u00b18g / \u00b116g and a selectable magnetic field full scale range of \u00b12 /\u00b14 / \u00b18 / \u00b112 gauss. Both the magnetic parts and the accelerometer parts can be powered down separately to reduce the power consumption. The Arduino can get these data via the I2C interface with the given library for this module.\n\n\n\n\nSpecifications\n\n\n\n\nInput Voltage: 5V\n\n\nI2C Interface and selectable SPI Interface\n\n\nMeasuring scale selectable\n\n\n6D orientation detection\n\n\n2 independent programmable interrupt generators\n\n\nPower-down mode\n\n\n\n\nHardware Overview\n\n\n\n\n\n\n\u2460Grove interface,connect to I2C\n\n\n\u2461SPI Interface\n\n\n\u2462I2C or SPI select pad(default is I2C), if want to use SPI, disconnect this pad\n\n\n\u2463Interrupt digital output\n\n\n\u2464Address select pad, default connected b and a address is 0x1E, if connect b and c address is 0x1D, if want to use SPI, disconnect this pad to either side.\n\n\n\n\nDemonstration\n\n\nThe LSM303D is a 6D sensor module that contains a 3D accelerometer and a 3D magnetic sensor. It has an I2C digital interface so that the analog to digital converter is avoided.\n\n\nThe MCU can collect 6D sensor data directly through the I2C interface.OK, let's start on using this LSM303D 6D sensor module.\n\n\nHardware Installation\n\n\n\n\nHardware installation is very easy, because there's an I2C Grove in Seeeduino, so what we need to do is connect it to I2C Grove via a Grove cable.\n\n\nConnect the Seeeduino to PC via a USB cable to power up this system.\n\n\n\n\n\n\nDownload Code and Upload\n\n\n\n\nDownload \ndemo_code\n which shows how to calculate level and 6-Axis Accelerometer&Compass heading using the LSM303D.\n\n\nUpload the Code. Please click \nhere\n if you do not know how to upload.\n\n\n\n\nOpen the serial monitor, you will see the output result of Color Sensor as shown below:\n\n\n\n\n\n\n\n\nYou can see the acceleration values and the clockwise angle between the magnetic north and x-axis.\n\n\n\n\n\n\nThe X/Y/Z shows the 3 axis acceleration; and then the angle between the magnetic north and x-axis calculated.\n\n\nAnd also the the angle between the magnetic north and the projection of positive x-axis calculated.\n\n\nPlease refer \nhere\n to know more about this parameter.\n\n\n\n\n\n\n\n\nNotes\n\n\n1.  All ST MEMS accelerometers are factory calibrated, allowing the user to avoid any further calibration for most of the applications. However, to reach a heading accuracy of below 2\u00b0, an easy calibration procedure is needed.\n\n\n2.  When test The clockwise angle between the magnetic north and x-axis, you can align the device Xa axis to any direction, but do not make it face down. Refer to the below picture:\n\n\n\n\n\n\n\nResources\n\n\n\n\n6-Axis Accelerometer&Compass v2.0 Library\n\n\nLSM303D_datashet\n\n\n6-Axis_Accelerometer%26Compass_v2.0 eagle file\n\n\n\n\nHelp us make it better",
            "title": "Grove 6 Axis AccelerometerAndCompass V2.0"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#grove-6-axis-accelerometercompass-v20",
            "text": "",
            "title": "Grove - 6-Axis Accelerometer&amp;Compass V2.0"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#introduction",
            "text": "The Grove \u20136-Axis Accelerometer&Compass V2.0 is a 3-axis accelerometer combined with a 3-axis magnetic sensor. It is an upgraded version of  Grove - 6-Axis Accelerometer&Compass V1.0  and based on the sensor module LSM303D which has a selectable linear acceleration full scale range of \u00b12g / \u00b14g / \u00b18g / \u00b116g and a selectable magnetic field full scale range of \u00b12 /\u00b14 / \u00b18 / \u00b112 gauss. Both the magnetic parts and the accelerometer parts can be powered down separately to reduce the power consumption. The Arduino can get these data via the I2C interface with the given library for this module.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#specifications",
            "text": "Input Voltage: 5V  I2C Interface and selectable SPI Interface  Measuring scale selectable  6D orientation detection  2 independent programmable interrupt generators  Power-down mode",
            "title": "Specifications"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#hardware-overview",
            "text": "\u2460Grove interface,connect to I2C  \u2461SPI Interface  \u2462I2C or SPI select pad(default is I2C), if want to use SPI, disconnect this pad  \u2463Interrupt digital output  \u2464Address select pad, default connected b and a address is 0x1E, if connect b and c address is 0x1D, if want to use SPI, disconnect this pad to either side.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#demonstration",
            "text": "The LSM303D is a 6D sensor module that contains a 3D accelerometer and a 3D magnetic sensor. It has an I2C digital interface so that the analog to digital converter is avoided.  The MCU can collect 6D sensor data directly through the I2C interface.OK, let's start on using this LSM303D 6D sensor module.",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#hardware-installation",
            "text": "Hardware installation is very easy, because there's an I2C Grove in Seeeduino, so what we need to do is connect it to I2C Grove via a Grove cable.  Connect the Seeeduino to PC via a USB cable to power up this system.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#download-code-and-upload",
            "text": "Download  demo_code  which shows how to calculate level and 6-Axis Accelerometer&Compass heading using the LSM303D.  Upload the Code. Please click  here  if you do not know how to upload.   Open the serial monitor, you will see the output result of Color Sensor as shown below:     You can see the acceleration values and the clockwise angle between the magnetic north and x-axis.    The X/Y/Z shows the 3 axis acceleration; and then the angle between the magnetic north and x-axis calculated.  And also the the angle between the magnetic north and the projection of positive x-axis calculated.  Please refer  here  to know more about this parameter.     Notes  1.  All ST MEMS accelerometers are factory calibrated, allowing the user to avoid any further calibration for most of the applications. However, to reach a heading accuracy of below 2\u00b0, an easy calibration procedure is needed.  2.  When test The clockwise angle between the magnetic north and x-axis, you can align the device Xa axis to any direction, but do not make it face down. Refer to the below picture:",
            "title": "Download Code and Upload"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#resources",
            "text": "6-Axis Accelerometer&Compass v2.0 Library  LSM303D_datashet  6-Axis_Accelerometer%26Compass_v2.0 eagle file",
            "title": "Resources"
        },
        {
            "location": "/Grove-6-Axis_AccelerometerAndCompass_V2.0/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Alcohol_Sensor/",
            "text": "Grove - Alcohol Sensor\n\n\nIntroduction\n\n\n\n\nGrove - Alcohol Sensor is a complete alcohol sensor module for Arduino or Seeeduino. It is built with \nMQ303A\n semiconductor alcohol sensor. It has good sensitivity and fast response to alcohol. It is suitable for making Breathalyzer. This Grove implements all the necessary circuitry for MQ303A like power conditioning and heater power supply. This sensor outputs a voltage inversely proportional to the alcohol concentration in air.\n\n\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\nFeatures\n\n\n\n\nInput Voltage: 5V\n\n\nWorking Current: 120mA\n\n\nDetectable Concentration: 20-1000ppm\n\n\nGrove Compatible connector\n\n\nHighly sensitive to alcohol.\n\n\nFast response and resumes quickly after alcohol exposure.\n\n\nLong life.\n\n\nCompact form factor.\n\n\n\n\nUsage\n\n\nHardware Installation\n\n\nGrove products have a eco system and all have a same connector which can plug onto the \nBase Shield\n. Connect this module to the A0 port of Base Shield, however, you can also connect Gas sensor to Arduino without Base Shield by jumper wires.\n\n\n\n\n\n\n\n\nArduino UNO\n\n\nAlcohol Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nAnalog A1\n\n\nSCL\n\n\n\n\n\n\nAnalog A0\n\n\nDAT\n\n\n\n\n\n\n\n\nYou can gain the present voltage through the DAT pin of sensor. Sensitivity can be regulated by rotating the potentiometer. \nPlease note the best preheat time of the sensor is above 48 hours\n. For the detailed information about the Alcohol sensor please refer to the datasheet.\n\n\n\n\nDownload Code and Upload\n\n\nThere are two steps you need to do before getting the concentration of gas.\n\n\nFirst, connect the module with Grove Shield using A0 like the picture above. And put the sensor in a clear air and use the program below.\n\n\n#define heaterSelPin 15\n\u00a0\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(heaterSelPin,OUTPUT);   // set the heaterSelPin as digital output.\n  digitalWrite(heaterSelPin,LOW); // Start to heat the sensor\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float sensorValue;\n\u00a0\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\u00a0\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = sensor_volt/(5.0-sensor_volt); // omit *R16\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  Serial.print(\"RS_air = \");\n  Serial.println(RS_air);\n  delay(1000);\n\u00a0\n}\n\n\n\n\nThen, open the monitor of Arduino IDE, you can see some data are printed, write down the value of RS_air and you need to use it in the following program. During this step, you may pay a while time to test the value of RS_air.\n\n\n#define heaterSelPin 15\n\u00a0\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(heaterSelPin,OUTPUT);   // set the heaterSelPin as digital output.\n  digitalWrite(heaterSelPin,LOW); // Start to heat the sensor  \n}\n\u00a0\nvoid loop() {\n\u00a0\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = sensor_volt/5.0-sensor_volt; // omit *R16\n\u00a0\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/RS_air;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\u00a0\n  Serial.print(\"\\n\\n\");\n\u00a0\n  delay(1000);\n\u00a0\n}\n\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 20ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.002% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\nNotes\n\n\n a. The value varies between 500 - 905. Hence any value above 650 indicates alcohol vapor in the vicinity.\n\n\n b. Once exposed to alcohol vapor, it takes some time for the sensor value to decrease completely.\n\n\n c. Yet, any new exposure will show instant increase in sensor value.\n\n\n\n\n\n\n\nCaution\n\n\n a. Alcohol sensor is very sensitive semiconductor device. Handle with care.\n\n\n b. Do not expose to organic silicon steam, alkali or corrosive gases.\n\n\n c. Do not use freeze or spill water.\n\n\n d. Maintain proper working voltage.\n\n\n\n\n\nResources\n\n\n\n\nGrove-Alcohol Sensor Eagle File\n\n\nGrove-Alcohol Sensor v1.2 Eagle File\n\n\nSchematics in PDF Format\n\n\nHow to Choose A Gas Sensor\n\n\nMQ303A\n\n\n\n\nHelp us make it better",
            "title": "Grove Alcohol Sensor"
        },
        {
            "location": "/Grove-Alcohol_Sensor/#grove-alcohol-sensor",
            "text": "",
            "title": "Grove - Alcohol Sensor"
        },
        {
            "location": "/Grove-Alcohol_Sensor/#introduction",
            "text": "Grove - Alcohol Sensor is a complete alcohol sensor module for Arduino or Seeeduino. It is built with  MQ303A  semiconductor alcohol sensor. It has good sensitivity and fast response to alcohol. It is suitable for making Breathalyzer. This Grove implements all the necessary circuitry for MQ303A like power conditioning and heater power supply. This sensor outputs a voltage inversely proportional to the alcohol concentration in air.    Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Alcohol_Sensor/#features",
            "text": "Input Voltage: 5V  Working Current: 120mA  Detectable Concentration: 20-1000ppm  Grove Compatible connector  Highly sensitive to alcohol.  Fast response and resumes quickly after alcohol exposure.  Long life.  Compact form factor.",
            "title": "Features"
        },
        {
            "location": "/Grove-Alcohol_Sensor/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/Grove-Alcohol_Sensor/#hardware-installation",
            "text": "Grove products have a eco system and all have a same connector which can plug onto the  Base Shield . Connect this module to the A0 port of Base Shield, however, you can also connect Gas sensor to Arduino without Base Shield by jumper wires.     Arduino UNO  Alcohol Sensor      5V  VCC    GND  GND    Analog A1  SCL    Analog A0  DAT     You can gain the present voltage through the DAT pin of sensor. Sensitivity can be regulated by rotating the potentiometer.  Please note the best preheat time of the sensor is above 48 hours . For the detailed information about the Alcohol sensor please refer to the datasheet.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-Alcohol_Sensor/#download-code-and-upload",
            "text": "There are two steps you need to do before getting the concentration of gas.  First, connect the module with Grove Shield using A0 like the picture above. And put the sensor in a clear air and use the program below.  #define heaterSelPin 15\n\u00a0\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(heaterSelPin,OUTPUT);   // set the heaterSelPin as digital output.\n  digitalWrite(heaterSelPin,LOW); // Start to heat the sensor\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float sensorValue;\n\u00a0\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\u00a0\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = sensor_volt/(5.0-sensor_volt); // omit *R16\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  Serial.print(\"RS_air = \");\n  Serial.println(RS_air);\n  delay(1000);\n\u00a0\n}  Then, open the monitor of Arduino IDE, you can see some data are printed, write down the value of RS_air and you need to use it in the following program. During this step, you may pay a while time to test the value of RS_air.  #define heaterSelPin 15\n\u00a0\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(heaterSelPin,OUTPUT);   // set the heaterSelPin as digital output.\n  digitalWrite(heaterSelPin,LOW); // Start to heat the sensor  \n}\n\u00a0\nvoid loop() {\n\u00a0\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = sensor_volt/5.0-sensor_volt; // omit *R16\n\u00a0\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/RS_air;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\u00a0\n  Serial.print(\"\\n\\n\");\n\u00a0\n  delay(1000);\n\u00a0\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 20ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.002% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.   Notes   a. The value varies between 500 - 905. Hence any value above 650 indicates alcohol vapor in the vicinity.   b. Once exposed to alcohol vapor, it takes some time for the sensor value to decrease completely.   c. Yet, any new exposure will show instant increase in sensor value.    Caution   a. Alcohol sensor is very sensitive semiconductor device. Handle with care.   b. Do not expose to organic silicon steam, alkali or corrosive gases.   c. Do not use freeze or spill water.   d. Maintain proper working voltage.",
            "title": "Download Code and Upload"
        },
        {
            "location": "/Grove-Alcohol_Sensor/#resources",
            "text": "Grove-Alcohol Sensor Eagle File  Grove-Alcohol Sensor v1.2 Eagle File  Schematics in PDF Format  How to Choose A Gas Sensor  MQ303A",
            "title": "Resources"
        },
        {
            "location": "/Grove-Alcohol_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/",
            "text": "Grove - Barometer (High-Accuracy)\n\n\nIntroduction\n\n\n\n\nThis Grove - Barometer (High-Accuracy) Sensor features a HP206C high-accuracy chip to detect barometric pressure ,Altimeter and temperature. It can widely measure pressure ranging from 300mbar~1200mbar, with a super high accuracy of 0.01mbar(0.1m) in ultra-high resolution mode.The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification.It is designed to be connected directly to a micro-controller via the I2C bus.\n\n\n\n\nFeatures\n\n\n\n\nDigital two wire (I2C) interface\n\n\nCommand-based Reading, Compensated (Optional)\n\n\nProgrammable Events and Interrupt Controls\n\n\nFull Data Compensation\n\n\nWide barometric pressure range\n\n\nFlexible supply voltage range\n\n\nUltra-low power consumption\n\n\nAltitude Resolution down to 0.01 meter\n\n\nTemperature measurement included\n\n\n\n\nApplication Ideas\n\n\n\n\nHigh Precision Mobile Altimeter / Barometer\n\n\nIndustrial Pressure and Temperature Sensor System\n\n\nAutomotive Systems\n\n\nPersonal Electronics Altimetry\n\n\nAdventure and Sports watches\n\n\nMedical Gas Control System\n\n\nWeather Station Equipment\n\n\nIndoor Navigation and Map Assist\n\n\nHeating, Ventilation, Air Conditioning\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3.3\n\n\n\n\n5\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n635\n\n\n\n\n/\n\n\n\n\n1100\n\n\n\n\nuA\n\n\n\n\n\n\n\n\nPressure Range\n\n\n\n\n300\n\n\n\n\n/\n\n\n\n\n1200\n\n\n\n\nhPa\n\n\n\n\n\n\n\n\nFaster I2C data transfer\n\n\n\n\n/\n\n\n\n\n/\n\n\n\n\n10\n\n\n\n\nMHz\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n20.4*41.8*9.7\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nWeight\n\n\n\n\n/\n\n\n\n\ng\n\n\n\n\n\n\n\n\nUsage\n\n\nWith \nArduino\n\n\nBarometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor.\n\n\n1.Connect it to I2C port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.\n\n\n\n\n2.Download the library \nGrove_Barometer_HP20x\n;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -> Example ->Barometer_Sensor->Barometer_Sensor.\n\n\n    /*\n     * Demo name  \u00a0: HP20x_dev demo \n     * Usage      \u00a0: I2C PRECISION BAROMETER AND ALTIMETER [HP206C hopeRF] \n     * Author     \u00a0: Oliver Wang from Seeed Studio\n     * Version    \u00a0: V0.1\n     * Change log \u00a0: Add kalman filter 2014/04/04\n    */\n\n    #include <HP20x_dev.h>\n    #include \"Arduino.h\"\n    #include \"Wire.h\" \n    #include <KalmanFilter.h>\n    unsigned char ret = 0;\n\n    /* Instance */\n    KalmanFilter t_filter;    //temperature filter\n    KalmanFilter p_filter;    //pressure filter\n    KalmanFilter a_filter;    //altitude filter\n\n\n    void setup()\n    {  \n      Serial.begin(9600);        // start serial for output\n\n      Serial.println(\"****HP20x_dev demo by seeed studio****\\n\");\n      Serial.println(\"Calculation formula: H = [8.5(101325-P)]/100 \\n\");\n      /* Power up,delay 150ms,until voltage is stable */\n      delay(150);\n      /* Reset HP20x_dev */\n      HP20x.begin();\n      delay(100);\n\n      /* Determine HP20x_dev is available or not */\n      ret = HP20x.isAvailable();\n      if(OK_HP20X_DEV == ret)\n      {\n        Serial.println(\"HP20x_dev is available.\\n\");    \n      }\n      else\n      {\n        Serial.println(\"HP20x_dev isn't available.\\n\");\n      }\n\n    }\n\n\n    void loop()\n    {\n        char display[40];\n        if(OK_HP20X_DEV == ret)\n        { \n          Serial.println(\"------------------\\n\");\n          long Temper = HP20x.ReadTemperature();\n          Serial.println(\"Temper:\");\n          float t = Temper/100.0;\n          Serial.print(t);    \n          Serial.println(\"C.\\n\");\n          Serial.println(\"Filter:\");\n          Serial.print(t_filter.Filter(t));\n          Serial.println(\"C.\\n\");\n\n          long Pressure = HP20x.ReadPressure();\n          Serial.println(\"Pressure:\");\n          t = Pressure/100.0;\n          Serial.print(t);\n          Serial.println(\"hPa.\\n\");\n          Serial.println(\"Filter:\");\n          Serial.print(p_filter.Filter(t));\n          Serial.println(\"hPa\\n\");\n\n          long Altitude = HP20x.ReadAltitude();\n          Serial.println(\"Altitude:\");\n          t = Altitude/100.0;\n          Serial.print(t);\n          Serial.println(\"m.\\n\");\n          Serial.println(\"Filter:\");\n          Serial.print(a_filter.Filter(t));\n          Serial.println(\"m.\\n\");\n          Serial.println(\"------------------\\n\");\n          delay(1000);\n        }\n    }\n\n\n\n\n4.Open the serial monitor to receive the sensor's data including temperature, barometric pressure value, relative atmosphere pressure and altitude.\n\n\n\n\nThe following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.\n\n\n\n\nResources\n\n\n\n\nGrove_Barometer_High-Accuracy_v1.0_sch_pcb Eagle File\n\n\nHP206C Datasheet\n\n\nGithub repository for Grove_Barometer_HP20x\n\n\n\n\nHelp us make it better",
            "title": "Grove Barometer High Accuracy"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#grove-barometer-high-accuracy",
            "text": "",
            "title": "Grove - Barometer (High-Accuracy)"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#introduction",
            "text": "This Grove - Barometer (High-Accuracy) Sensor features a HP206C high-accuracy chip to detect barometric pressure ,Altimeter and temperature. It can widely measure pressure ranging from 300mbar~1200mbar, with a super high accuracy of 0.01mbar(0.1m) in ultra-high resolution mode.The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification.It is designed to be connected directly to a micro-controller via the I2C bus.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#features",
            "text": "Digital two wire (I2C) interface  Command-based Reading, Compensated (Optional)  Programmable Events and Interrupt Controls  Full Data Compensation  Wide barometric pressure range  Flexible supply voltage range  Ultra-low power consumption  Altitude Resolution down to 0.01 meter  Temperature measurement included",
            "title": "Features"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#application-ideas",
            "text": "High Precision Mobile Altimeter / Barometer  Industrial Pressure and Temperature Sensor System  Automotive Systems  Personal Electronics Altimetry  Adventure and Sports watches  Medical Gas Control System  Weather Station Equipment  Indoor Navigation and Map Assist  Heating, Ventilation, Air Conditioning",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#specifications",
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3.3  \n5  \n5.5  \nVDC    \nCurrent  \n635  \n/  \n1100  \nuA    \nPressure Range  \n300  \n/  \n1200  \nhPa    \nFaster I2C data transfer  \n/  \n/  \n10  \nMHz    \nDimension  \n20.4*41.8*9.7  \nmm    \nWeight  \n/  \ng",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#with-arduino",
            "text": "Barometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor.  1.Connect it to I2C port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.   2.Download the library  Grove_Barometer_HP20x ;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -> Example ->Barometer_Sensor->Barometer_Sensor.      /*\n     * Demo name  \u00a0: HP20x_dev demo \n     * Usage      \u00a0: I2C PRECISION BAROMETER AND ALTIMETER [HP206C hopeRF] \n     * Author     \u00a0: Oliver Wang from Seeed Studio\n     * Version    \u00a0: V0.1\n     * Change log \u00a0: Add kalman filter 2014/04/04\n    */\n\n    #include <HP20x_dev.h>\n    #include \"Arduino.h\"\n    #include \"Wire.h\" \n    #include <KalmanFilter.h>\n    unsigned char ret = 0;\n\n    /* Instance */\n    KalmanFilter t_filter;    //temperature filter\n    KalmanFilter p_filter;    //pressure filter\n    KalmanFilter a_filter;    //altitude filter\n\n\n    void setup()\n    {  \n      Serial.begin(9600);        // start serial for output\n\n      Serial.println(\"****HP20x_dev demo by seeed studio****\\n\");\n      Serial.println(\"Calculation formula: H = [8.5(101325-P)]/100 \\n\");\n      /* Power up,delay 150ms,until voltage is stable */\n      delay(150);\n      /* Reset HP20x_dev */\n      HP20x.begin();\n      delay(100);\n\n      /* Determine HP20x_dev is available or not */\n      ret = HP20x.isAvailable();\n      if(OK_HP20X_DEV == ret)\n      {\n        Serial.println(\"HP20x_dev is available.\\n\");    \n      }\n      else\n      {\n        Serial.println(\"HP20x_dev isn't available.\\n\");\n      }\n\n    }\n\n\n    void loop()\n    {\n        char display[40];\n        if(OK_HP20X_DEV == ret)\n        { \n          Serial.println(\"------------------\\n\");\n          long Temper = HP20x.ReadTemperature();\n          Serial.println(\"Temper:\");\n          float t = Temper/100.0;\n          Serial.print(t);    \n          Serial.println(\"C.\\n\");\n          Serial.println(\"Filter:\");\n          Serial.print(t_filter.Filter(t));\n          Serial.println(\"C.\\n\");\n\n          long Pressure = HP20x.ReadPressure();\n          Serial.println(\"Pressure:\");\n          t = Pressure/100.0;\n          Serial.print(t);\n          Serial.println(\"hPa.\\n\");\n          Serial.println(\"Filter:\");\n          Serial.print(p_filter.Filter(t));\n          Serial.println(\"hPa\\n\");\n\n          long Altitude = HP20x.ReadAltitude();\n          Serial.println(\"Altitude:\");\n          t = Altitude/100.0;\n          Serial.print(t);\n          Serial.println(\"m.\\n\");\n          Serial.println(\"Filter:\");\n          Serial.print(a_filter.Filter(t));\n          Serial.println(\"m.\\n\");\n          Serial.println(\"------------------\\n\");\n          delay(1000);\n        }\n    }  4.Open the serial monitor to receive the sensor's data including temperature, barometric pressure value, relative atmosphere pressure and altitude.   The following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#resources",
            "text": "Grove_Barometer_High-Accuracy_v1.0_sch_pcb Eagle File  HP206C Datasheet  Github repository for Grove_Barometer_HP20x",
            "title": "Resources"
        },
        {
            "location": "/Grove-Barometer-High-Accuracy/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/",
            "text": "Grove - Barometer Sensor (BMP180)\n\n\nIntroduction\n\n\n\n\nThis is a Grove module for the Bosch BMP180 high-precision, low-power digital barometer. The BMP180 offers a pressure measuring range of 300 to 1100 hPa with an accuracy down to 0.02 hPa in advanced resolution mode. It\u2019s based on piezo-resistive technology for high accuracy, ruggedness and long term stability. The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification.It is designed to be connected directly to a micro-controller via the I2C bus.\n\n\n\n\nFeatures\n\n\n\n\nDigital two wire (I2C) interface\n\n\nWide barometric pressure range\n\n\nFlexible supply voltage range\n\n\nUltra-low power consumption\n\n\nLow noise measurement\n\n\nFactory-calibrated\n\n\n-40 to +85\u00b0C operational range, \u00b12\u00b0C temperature accuracy\n\n\nI2C address: 0x77\n\n\n\n\nApplication Ideas\n\n\n\n\nEnhancement of GPS navigation\n\n\nIndoor and outdoor navigation\n\n\nLeisure and sports\n\n\nWeather forecast\n\n\nVertical velocity indication (rise/sink speed)\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3\n\n\n\n\n5\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n1.1\n\n\n\n\n/\n\n\n\n\n20\n\n\n\n\nuA\n\n\n\n\n\n\n\n\nPressure Range\n\n\n\n\n300\n\n\n\n\n/\n\n\n\n\n1100\n\n\n\n\nhPa\n\n\n\n\n\n\n\n\nFaster I2C data transfer\n\n\n\n\n/\n\n\n\n\n/\n\n\n\n\n3.4\n\n\n\n\nMHZ\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n40.1*20.2*9.7\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nUsage\n\n\nWith \nArduino\n\n\nBarometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor (BMP180).\n\n\n1.Connect it to IIC port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.\n\n\n2.Download \nthe library\n(the barometer library is shared by Grove - Barometer Sensor (BMP180) and Grove - Barometer Sensor(BMP085));Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -> Example ->Barometer_Sensor->Barometer_Sensor.\n\n\n    /* Barometer demo V1.0\n    * Based largely on code by  Jim Lindblom\n    * Get pressure, altitude, and temperature from the BMP085.\n    * Serial.print it out at 9600 baud to serial monitor.\n    *\n    * By:http://www.seeedstudio.com\n    */\n    #include \"Barometer.h\"\n    #include <Wire.h>\n    float temperature;\n    float pressure;\n    float atm;\n    float altitude;\n    Barometer myBarometer;\n    void setup(){\n      Serial.begin(9600);\n      myBarometer.init();\n\n    }\n\n    void loop()\n    {\n       temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n       pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n       altitude = myBarometer.calcAltitude(pressure); //Uncompensated calculation - in Meters \n       atm = pressure / 101325; \n\n      Serial.print(\"Temperature: \");\n      Serial.print(temperature, 2); //display 2 decimal places\n      Serial.println(\"deg C\");\n\n      Serial.print(\"Pressure: \");\n      Serial.print(pressure, 0); //whole number only.\n      Serial.println(\" Pa\");\n\n      Serial.print(\"Ralated Atmosphere: \");\n      Serial.println(atm, 4); //display 4 decimal places\n\n      Serial.print(\"Altitude: \");\n      Serial.print(altitude, 2); //display 2 decimal places\n      Serial.println(\" m\");\n\n      Serial.println();\n\n      delay(1000); //wait a second and get values again.\n    }\n\n\n\n\n4.Open the serial monitor to receive the sensor's data including temperature, barometric pressure value, relative atmosphere pressure and altitude.\n\n\n\n\nThe following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.\n\n\n\n\nWith \nRaspberry Pi\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.\n\n\n\n\n4.Navigate to the demos' directory:\n\n\n   cd yourpath/GrovePi/Software/Python/grove_barometer/adafruit\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_i2c_barometic_sensor_example.py   # \"Ctrl+x\" to exit #\n\n\n\n\n    #!/usr/bin/python\n\n    import smbus\n    import RPi.GPIO as GPIO\n    #import grovepi\n    from grove_i2c_barometic_sensor import BMP085\n\n    # ===========================================================================\n    # Example Code\n    # ===========================================================================\n\n    # Initialise the BMP085 and use STANDARD mode (default value)\n    # bmp = BMP085(0x77, debug=True)\n    bmp = BMP085(0x77, 1)\n\n    # To specify a different operating mode, uncomment one of the following:\n    # bmp = BMP085(0x77, 0)  # ULTRALOWPOWER Mode\n    # bmp = BMP085(0x77, 1)  # STANDARD Mode\n    # bmp = BMP085(0x77, 2)  # HIRES Mode\n    # bmp = BMP085(0x77, 3)  # ULTRAHIRES Mode\n\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        bus = smbus.SMBus(1)\n    else:\n        bus = smbus.SMBus(0)\n\n    temp = bmp.readTemperature()\n\n    # Read the current barometric pressure level\n    pressure = bmp.readPressure()\n\n    # To calculate altitude based on an estimated mean sea level pressure\n    # (1013.25 hPa) call the function as follows, but this won't be very accurate\n    # altitude = bmp.readAltitude()\n\n    # To specify a more accurate altitude, enter the correct mean sea level\n    # pressure level.  For example, if the current pressure level is 1023.50 hPa\n    # enter 102350 since we include two decimal places in the integer value\n    altitude = bmp.readAltitude(101560)\n\n    print \"Temperature:\u00a0%.2f C\"\u00a0% temp\n    print \"Pressure:   \u00a0%.2f hPa\"\u00a0% (pressure / 100.0)\n    print \"Altitude:   \u00a0%.2f m\"\u00a0% altitude\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_i2c_barometic_sensor_example.py\n\n\n\n\n6.Result\n\n\n\n\nResources\n\n\n\n\nGrove - Barometer Sensor(BMP180) Eagle File\n\n\nBarometer_Sensor Library\n\n\nBMP180 datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Barometer Sensor BMP180"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#grove-barometer-sensor-bmp180",
            "text": "",
            "title": "Grove - Barometer Sensor (BMP180)"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#introduction",
            "text": "This is a Grove module for the Bosch BMP180 high-precision, low-power digital barometer. The BMP180 offers a pressure measuring range of 300 to 1100 hPa with an accuracy down to 0.02 hPa in advanced resolution mode. It\u2019s based on piezo-resistive technology for high accuracy, ruggedness and long term stability. The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification.It is designed to be connected directly to a micro-controller via the I2C bus.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#features",
            "text": "Digital two wire (I2C) interface  Wide barometric pressure range  Flexible supply voltage range  Ultra-low power consumption  Low noise measurement  Factory-calibrated  -40 to +85\u00b0C operational range, \u00b12\u00b0C temperature accuracy  I2C address: 0x77",
            "title": "Features"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#application-ideas",
            "text": "Enhancement of GPS navigation  Indoor and outdoor navigation  Leisure and sports  Weather forecast  Vertical velocity indication (rise/sink speed)",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#specifications",
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3  \n5  \n5.5  \nVDC    \nCurrent  \n1.1  \n/  \n20  \nuA    \nPressure Range  \n300  \n/  \n1100  \nhPa    \nFaster I2C data transfer  \n/  \n/  \n3.4  \nMHZ    \nDimension  \n40.1*20.2*9.7  \nmm",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#with-arduino",
            "text": "Barometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor (BMP180).  1.Connect it to IIC port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.  2.Download  the library (the barometer library is shared by Grove - Barometer Sensor (BMP180) and Grove - Barometer Sensor(BMP085));Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -> Example ->Barometer_Sensor->Barometer_Sensor.      /* Barometer demo V1.0\n    * Based largely on code by  Jim Lindblom\n    * Get pressure, altitude, and temperature from the BMP085.\n    * Serial.print it out at 9600 baud to serial monitor.\n    *\n    * By:http://www.seeedstudio.com\n    */\n    #include \"Barometer.h\"\n    #include <Wire.h>\n    float temperature;\n    float pressure;\n    float atm;\n    float altitude;\n    Barometer myBarometer;\n    void setup(){\n      Serial.begin(9600);\n      myBarometer.init();\n\n    }\n\n    void loop()\n    {\n       temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n       pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n       altitude = myBarometer.calcAltitude(pressure); //Uncompensated calculation - in Meters \n       atm = pressure / 101325; \n\n      Serial.print(\"Temperature: \");\n      Serial.print(temperature, 2); //display 2 decimal places\n      Serial.println(\"deg C\");\n\n      Serial.print(\"Pressure: \");\n      Serial.print(pressure, 0); //whole number only.\n      Serial.println(\" Pa\");\n\n      Serial.print(\"Ralated Atmosphere: \");\n      Serial.println(atm, 4); //display 4 decimal places\n\n      Serial.print(\"Altitude: \");\n      Serial.print(altitude, 2); //display 2 decimal places\n      Serial.println(\" m\");\n\n      Serial.println();\n\n      delay(1000); //wait a second and get values again.\n    }  4.Open the serial monitor to receive the sensor's data including temperature, barometric pressure value, relative atmosphere pressure and altitude.   The following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#with-raspberry-pi",
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the sensor to grovepi socket i2c-x(1~3) by using a grove cable.   4.Navigate to the demos' directory:     cd yourpath/GrovePi/Software/Python/grove_barometer/adafruit   To see the code       nano grove_i2c_barometic_sensor_example.py   # \"Ctrl+x\" to exit #      #!/usr/bin/python\n\n    import smbus\n    import RPi.GPIO as GPIO\n    #import grovepi\n    from grove_i2c_barometic_sensor import BMP085\n\n    # ===========================================================================\n    # Example Code\n    # ===========================================================================\n\n    # Initialise the BMP085 and use STANDARD mode (default value)\n    # bmp = BMP085(0x77, debug=True)\n    bmp = BMP085(0x77, 1)\n\n    # To specify a different operating mode, uncomment one of the following:\n    # bmp = BMP085(0x77, 0)  # ULTRALOWPOWER Mode\n    # bmp = BMP085(0x77, 1)  # STANDARD Mode\n    # bmp = BMP085(0x77, 2)  # HIRES Mode\n    # bmp = BMP085(0x77, 3)  # ULTRAHIRES Mode\n\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        bus = smbus.SMBus(1)\n    else:\n        bus = smbus.SMBus(0)\n\n    temp = bmp.readTemperature()\n\n    # Read the current barometric pressure level\n    pressure = bmp.readPressure()\n\n    # To calculate altitude based on an estimated mean sea level pressure\n    # (1013.25 hPa) call the function as follows, but this won't be very accurate\n    # altitude = bmp.readAltitude()\n\n    # To specify a more accurate altitude, enter the correct mean sea level\n    # pressure level.  For example, if the current pressure level is 1023.50 hPa\n    # enter 102350 since we include two decimal places in the integer value\n    altitude = bmp.readAltitude(101560)\n\n    print \"Temperature:\u00a0%.2f C\"\u00a0% temp\n    print \"Pressure:   \u00a0%.2f hPa\"\u00a0% (pressure / 100.0)\n    print \"Altitude:   \u00a0%.2f m\"\u00a0% altitude  5.Run the demo.      sudo python grove_i2c_barometic_sensor_example.py  6.Result",
            "title": "With Raspberry Pi"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#resources",
            "text": "Grove - Barometer Sensor(BMP180) Eagle File  Barometer_Sensor Library  BMP180 datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP180/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/",
            "text": "Grove - Barometer Sensor (BMP280)\n\n\nIntroduction\n\n\n\n\nGrove - Barometer Sensor (BMP280)\n is a breakout board for Bosch BMP280 high-precision and low-power digital barometer. This module can be used to measure \ntemperature\n and \natmospheric pressure\n accurately. As the atmospheric pressure changes with altitude, it can also measure approximate \naltitude\n of a place. It can be connected to a microcontroller with I\n2\nC (integrated with Grove socket) or through SPI bus. We have also provided highly abstracted library to make this product easier to use.\n\n\nThe BMP280 is an upgraded version of BMP180. BMP280 gets dramatic improvements from BMP180. BMP280 comes with a smaller footprint, lower power consumption, lower noise measurements, higher resolutions for pressure and temperature, lower RMS noise, newly added interface SPI, more measuring modes, higher measuring rate and newly added filter against environmental interference. Since the atmosphere pressure reading is affected by altitude and temperature, we have added compensation features in the library. Hence, Grove - Barometer Sensor (BMP280) would be more reliable in providing precise temperature, atmospheric pressure values and approximate altitude data.\n\n\nUsing the sensor is easy. For \nSeeeduino\n (compliant with Arduino), just connect this breakout board using \nGrove cable\n to I2C Grove connector. Then, use the provided library and example code from GitHub. If you are using an Arduino either use Base Shield v2.0 or simply connect the VCC pin to the 5V voltage pin, GND to ground, SCL to I2C Clock (Analog 5) and SDA to I2C Data (Analog 4).\n\n\nTypical applications: Enhancement of GPS navigation, outdoor/indoor navigation, weather forecast, or any other project that requires an accurate atmospheric pressure reading.\n\n\n\n\nFeatures\n\n\n\n\nGet more precise temperature, atmospheric pressure values, and approximate altitude data.\n\n\nGrove compatible and easy to use\n\n\nHighly abstracted library for building projects quicker\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInput voltage\n\n\n3.3V or 5V\n\n\n\n\n\n\nI/O voltage\n\n\n3.3V or 5V\n\n\n\n\n\n\nOperating current\n\n\n0.6mA\n\n\n\n\n\n\nOperating temperature\n\n\n-40 - 85 \u2103\n\n\n\n\n\n\nEffective pressure measurement range\n\n\n300 - 1100 hPa (1 hPa= one hundred Pa) with \u00b11.0 hPa accuracy\n\n\n\n\n\n\nTemperature measurement accuracy\n\n\n\u00b11.0\u00b0C\n\n\n\n\n\n\nMeasurement modes\n\n\nPiezo & Temperature, forced or periodic\n\n\n\n\n\n\nChip\n\n\nBMP280 (\ndatasheet\n)\n\n\n\n\n\n\nPossible sampling rate\n\n\n182 Hz (typical)\n\n\n\n\n\n\nInterface Bus\n\n\nSPI, I\n2\nC (use either one of them)\n\n\n\n\n\n\nWeight\n\n\n3 g (for breakout board)\n\n\n\n\n\n\nDimensions\n\n\n40 (width) \u00d7 20 (depth) mm\n\n\n\n\n\n\n\n\n\n\nNotes\n\n\n 1. We will show/describe how to select interface bus soon.\n\n\n 2. The altitude is calculated by a combination of temperature and atmospheric pressure. No specialized components for altitude.\n\n\n\n\n\nPlatforms supported (only for battery)\n\n\n\n\n\n\n\nPlatform\n\n\n\n\nSeeeduino/Arduino\n\n\n\n\nRasberry Pi\n\n\n\n\nBeaglebone\n\n\n\n\nLinkIt ONE\n\n\n\n\n\n\n\n\nSupported status\n\n\n\n\nSupported\n\n\n\n\nNot supported\n\n\n\n\nSupported\n\n\n\n\nSupported\n\n\n\n\n\n\n\n\nNotes\n\n\n\n\nIf no version number is present for a specific platform, it means this product supports all versions within this platform.\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\n\n\nSPI soldering pads\n, a voltage monitoring circuit.\n\n\nInterface bus selection pads\n , to select I\n2\nC bus, connect the two pads by soldering (this is connected by default); to select SPI bus, cut the two pads with a sharp knife or a soldering iron.\n\n\nSlave board address selection pads\n, to select slave board address to avoid address collision.\n\n\n\n\nIf you have selected I2C bus, the default address for slave board is \n0x77\n(right-two pads are connected). If you want to use the address \n0x76\n, connect only left two (disconnect right two) by soldering. \n\n\nTips:\n You can disconnect pads with just a sharp knife.\n\n\nIf you have selected SPI bus, the default address for slave board is \n0x77\n(right-two pads are connected). If you want to use the address \n0x76\n, disconnect all three pads.\n\n\n\n\nNote\n\nDo not touch or shake or let this product in vibration when it works. This will cause interference and will affect the accuracy of data collected.\n\n\n\n\nPackage includes\n (main parts)\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Barometer Sensor (BMP280)\n\n\n1 piece\n\n\n\n\n\n\nGrove cable\n\n\n1 piece\n\n\n\n\n\n\n\n\nGetting Started\n\n\nNow let us run some basic examples with this module.\n\n\nWith Arduino\n\n\nThis section shows you how to build a simple project with Arduino platform. Even if you are using a different type of main control board, these instructions and source code are useful.\n\n\nMaterials required\n\n\n\n\nGrove - Barometer Sensor (BMP280) \u00d7 1\n\n\nSeeeduino 4.2\n (fully compatible with Arduino) or Arduino UNO (other models are also fine) \u00d7 1\n\n\nGrove - Base Shield\n \u00d7 1 (it is optional if you are using Seeeduino which has two I2C sockets on Seeeduino v4.2)\n\n\nUSB cable (type A to type B, for Arduino) \u00d7 1 or USB cable (Type-A to micro Type-B, for Seeeduino) \u00d7 1\n\n\nGrove cable\n \u00d7 1\n\n\n\n\nConnections\n\n\nConnect all parts as follows: the first picture shows connection with Seeeduino, the second one demonstrates connection with Arduino UNO:\n\n\n\n\n\n\nCoding\n\n\nYou can find more demo sketches \nhere\n and development library \nhere\n\n\n\n\n\n\nA typical demo code. You can upload code to main control board with \nCodebender\n.\n\n\n\n\n\n\n\n\n\n\nDownload and upload the code. If you do not know how to upload an Arduino sketch, please visit \nhttps://www.arduino.cc/en/Guide/Windows\n for Windows user or \nhttps://www.arduino.cc/en/Guide/MacOSX\n for Mac user. You can see the result as below.\n\n\n\n\n\n\nTips:\n if you use Seeeduino, please also select \nBoards\n under \nTools\n as you upload sketches.\n\n\nResources\n\n\n\n\nSchematic(Eagle) file\n\n\nBMP280 Datasheet\n\n\nLibrary and example code\n on GitHub\n\n\nI\n2\nC how-to for Arduino\n\n\n\n\nHelp us make it better",
            "title": "Grove Barometer Sensor BMP280"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#grove-barometer-sensor-bmp280",
            "text": "",
            "title": "Grove - Barometer Sensor (BMP280)"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#introduction",
            "text": "Grove - Barometer Sensor (BMP280)  is a breakout board for Bosch BMP280 high-precision and low-power digital barometer. This module can be used to measure  temperature  and  atmospheric pressure  accurately. As the atmospheric pressure changes with altitude, it can also measure approximate  altitude  of a place. It can be connected to a microcontroller with I 2 C (integrated with Grove socket) or through SPI bus. We have also provided highly abstracted library to make this product easier to use.  The BMP280 is an upgraded version of BMP180. BMP280 gets dramatic improvements from BMP180. BMP280 comes with a smaller footprint, lower power consumption, lower noise measurements, higher resolutions for pressure and temperature, lower RMS noise, newly added interface SPI, more measuring modes, higher measuring rate and newly added filter against environmental interference. Since the atmosphere pressure reading is affected by altitude and temperature, we have added compensation features in the library. Hence, Grove - Barometer Sensor (BMP280) would be more reliable in providing precise temperature, atmospheric pressure values and approximate altitude data.  Using the sensor is easy. For  Seeeduino  (compliant with Arduino), just connect this breakout board using  Grove cable  to I2C Grove connector. Then, use the provided library and example code from GitHub. If you are using an Arduino either use Base Shield v2.0 or simply connect the VCC pin to the 5V voltage pin, GND to ground, SCL to I2C Clock (Analog 5) and SDA to I2C Data (Analog 4).  Typical applications: Enhancement of GPS navigation, outdoor/indoor navigation, weather forecast, or any other project that requires an accurate atmospheric pressure reading.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#features",
            "text": "Get more precise temperature, atmospheric pressure values, and approximate altitude data.  Grove compatible and easy to use  Highly abstracted library for building projects quicker",
            "title": "Features"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#specifications",
            "text": "Input voltage  3.3V or 5V    I/O voltage  3.3V or 5V    Operating current  0.6mA    Operating temperature  -40 - 85 \u2103    Effective pressure measurement range  300 - 1100 hPa (1 hPa= one hundred Pa) with \u00b11.0 hPa accuracy    Temperature measurement accuracy  \u00b11.0\u00b0C    Measurement modes  Piezo & Temperature, forced or periodic    Chip  BMP280 ( datasheet )    Possible sampling rate  182 Hz (typical)    Interface Bus  SPI, I 2 C (use either one of them)    Weight  3 g (for breakout board)    Dimensions  40 (width) \u00d7 20 (depth) mm      Notes   1. We will show/describe how to select interface bus soon.   2. The altitude is calculated by a combination of temperature and atmospheric pressure. No specialized components for altitude.",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#platforms-supported-only-for-battery",
            "text": "Platform  \nSeeeduino/Arduino  \nRasberry Pi  \nBeaglebone  \nLinkIt ONE    \nSupported status  \nSupported  \nNot supported  \nSupported  \nSupported    \nNotes  \nIf no version number is present for a specific platform, it means this product supports all versions within this platform.",
            "title": "Platforms supported (only for battery)"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#hardware-overview",
            "text": "SPI soldering pads , a voltage monitoring circuit.  Interface bus selection pads  , to select I 2 C bus, connect the two pads by soldering (this is connected by default); to select SPI bus, cut the two pads with a sharp knife or a soldering iron.  Slave board address selection pads , to select slave board address to avoid address collision.   If you have selected I2C bus, the default address for slave board is  0x77 (right-two pads are connected). If you want to use the address  0x76 , connect only left two (disconnect right two) by soldering.   Tips:  You can disconnect pads with just a sharp knife.  If you have selected SPI bus, the default address for slave board is  0x77 (right-two pads are connected). If you want to use the address  0x76 , disconnect all three pads.   Note \nDo not touch or shake or let this product in vibration when it works. This will cause interference and will affect the accuracy of data collected.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#package-includes-main-parts",
            "text": "Parts name  Quantity      Grove - Barometer Sensor (BMP280)  1 piece    Grove cable  1 piece",
            "title": "Package includes (main parts)"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#getting-started",
            "text": "Now let us run some basic examples with this module.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#with-arduino",
            "text": "This section shows you how to build a simple project with Arduino platform. Even if you are using a different type of main control board, these instructions and source code are useful.",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#materials-required",
            "text": "Grove - Barometer Sensor (BMP280) \u00d7 1  Seeeduino 4.2  (fully compatible with Arduino) or Arduino UNO (other models are also fine) \u00d7 1  Grove - Base Shield  \u00d7 1 (it is optional if you are using Seeeduino which has two I2C sockets on Seeeduino v4.2)  USB cable (type A to type B, for Arduino) \u00d7 1 or USB cable (Type-A to micro Type-B, for Seeeduino) \u00d7 1  Grove cable  \u00d7 1",
            "title": "Materials required"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#connections",
            "text": "Connect all parts as follows: the first picture shows connection with Seeeduino, the second one demonstrates connection with Arduino UNO:",
            "title": "Connections"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#coding",
            "text": "You can find more demo sketches  here  and development library  here    A typical demo code. You can upload code to main control board with  Codebender .      Download and upload the code. If you do not know how to upload an Arduino sketch, please visit  https://www.arduino.cc/en/Guide/Windows  for Windows user or  https://www.arduino.cc/en/Guide/MacOSX  for Mac user. You can see the result as below.    Tips:  if you use Seeeduino, please also select  Boards  under  Tools  as you upload sketches.",
            "title": "Coding"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#resources",
            "text": "Schematic(Eagle) file  BMP280 Datasheet  Library and example code  on GitHub  I 2 C how-to for Arduino",
            "title": "Resources"
        },
        {
            "location": "/Grove-Barometer_Sensor-BMP280/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Barometer_Sensor/",
            "text": "Grove - Barometer Sensor\n\n\nIntroduction\n\n\n\n\nThis Grove - Barometer Sensor features a Bosch BMP085 high-accuracy chip to detect barometric pressure and temperature. It can widely measure pressure ranging from 300hPa to 1100hPa, AKA +9000m to -500m above sea level, with a super high accuracy of 0.03hPa(0.25m) in ultra-high resolution mode. The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification. It is designed to be connected directly to a micro-controller via the I2C bus.\n\n\n\n\nFeatures\n\n\n\n\nDigital two wire (I2C) interface\n\n\nWide barometric pressure range\n\n\nFlexible supply voltage range\n\n\nUltra-low power consumption\n\n\nLow noise measurement\n\n\nFully calibrated\n\n\nTemperature measurement included\n\n\n\n\nApplication Ideas\n\n\n\n\nEnhancement of GPS navigation\n\n\nIndoor and outdoor navigation\n\n\nLeisure and sports\n\n\nWeather forecast\n\n\nVertical velocity indication (rise/sink speed)\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nVoltage\n\n\n\n\n3\n\n\n\n\n5\n\n\n\n\n5.5\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nCurrent\n\n\n\n\n89\n\n\n\n\n/\n\n\n\n\n130\n\n\n\n\nuA\n\n\n\n\n\n\n\n\nPressure Range\n\n\n\n\n300\n\n\n\n\n/\n\n\n\n\n1100\n\n\n\n\nhPa\n\n\n\n\n\n\n\n\nFaster I2C data transfer\n\n\n\n\n/\n\n\n\n\n/\n\n\n\n\n3.4\n\n\n\n\nMHZ\n\n\n\n\n\n\n\n\nDimension\n\n\n\n\n20.4*24.3*9.7\n\n\n\n\nmm\n\n\n\n\n\n\n\n\nWeight\n\n\n\n\n2\n\n\n\n\ng\n\n\n\n\n\n\n\n\nUsage\n\n\nWith \nArduino\n\n\nBarometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor.\n\n\n1.Connect it to IIC port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.\n\n\n\n2.Download the library \nBarometer_Sensor Library\n;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.\n\n\n3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -> Example ->Barometer_Sensor->Barometer_Sensor.\n\n\n    /* Barometer demo V1.0\n    * Based largely on code by  Jim Lindblom\n    * Get pressure, altitude, and temperature from the BMP085.\n    * Serial.print it out at 9600 baud to serial monitor.\n    *\n    * By:http://www.seeedstudio.com\n    */\n    #include \"Barometer.h\"\n    #include <Wire.h>\n    float temperature;\n    float pressure;\n    float atm;\n    float altitude;\n    Barometer myBarometer;\n    void setup(){\n      Serial.begin(9600);\n      myBarometer.init();\n\n    }\n\n    void loop()\n    {\n       temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n       pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n       altitude = myBarometer.calcAltitude(pressure); //Uncompensated calculation - in Meters \n       atm = pressure / 101325; \n\n      Serial.print(\"Temperature: \");\n      Serial.print(temperature, 2); //display 2 decimal places\n      Serial.println(\"deg C\");\n\n      Serial.print(\"Pressure: \");\n      Serial.print(pressure, 0); //whole number only.\n      Serial.println(\" Pa\");\n\n      Serial.print(\"Ralated Atmosphere: \");\n      Serial.println(atm, 4); //display 4 decimal places\n\n      Serial.print(\"Altitude: \");\n      Serial.print(altitude, 2); //display 2 decimal places\n      Serial.println(\" m\");\n\n      Serial.println();\n\n      delay(1000); //wait a second and get values again.\n    }\n\n\n\n\n4.Open the serial monitor to receive the sensor's data including temperature, barometric pressure value, relative atmosphere pressure and altitude.\n\n\n\n\nThe following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.\n\n\n\nWith \nRaspberry Pi\n\n\n1.You should have got a raspberry pi and a grovepi or grovepi+.\n\n\n2.You should have completed configuring the development enviroment, otherwise follow \nhere\n.\n\n\n3.Connection\n\n\n\n\nPlug the barometer sensor into the i2c sockets on grovepi.\n\n\n\n\n4.Navigate to the demos' directory:\n\n\n    cd yourpath/GrovePi/Software/Python/grove_barometer/adafruit/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_i2c_barometic_sensor_example.py   # \"Ctrl+x\" to exit #\n\n\n\n\n    #!/usr/bin/python\n\n    import smbus\n    import RPi.GPIO as GPIO\n    #import grovepi\n    from grove_i2c_barometic_sensor import BMP085\n\n    # ===========================================================================\n    # Example Code\n    # ===========================================================================\n\n    # Initialise the BMP085 and use STANDARD mode (default value)\n    # bmp = BMP085(0x77, debug=True)\n    bmp = BMP085(0x77, 1)\n\n    # To specify a different operating mode, uncomment one of the following:\n    # bmp = BMP085(0x77, 0)  # ULTRALOWPOWER Mode\n    # bmp = BMP085(0x77, 1)  # STANDARD Mode\n    # bmp = BMP085(0x77, 2)  # HIRES Mode\n    # bmp = BMP085(0x77, 3)  # ULTRAHIRES Mode\n\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        bus = smbus.SMBus(1)\n    else:\n        bus = smbus.SMBus(0)\n\n    temp = bmp.readTemperature()\n\n    # Read the current barometric pressure level\n    pressure = bmp.readPressure()\n\n    # To calculate altitude based on an estimated mean sea level pressure\n    # (1013.25 hPa) call the function as follows, but this won't be very accurate\n    # altitude = bmp.readAltitude()\n\n    # To specify a more accurate altitude, enter the correct mean sea level\n    # pressure level.  For example, if the current pressure level is 1023.50 hPa\n    # enter 102350 since we include two decimal places in the integer value\n    altitude = bmp.readAltitude(101560)\n\n    print \"Temperature:\u00a0%.2f C\"\u00a0% temp\n    print \"Pressure:   \u00a0%.2f hPa\"\u00a0% (pressure / 100.0)\n    print \"Altitude:   \u00a0%.2f m\"\u00a0% altitude\n\n\n\n\n5.Run the demo.\n\n\n       sudo python grove_i2c_barometic_sensor_example.py\n\n\n\n\n6.Result\n\n\n\n\nResources\n\n\n\n\nGrove - Barometer Sensor Eagle File\n\n\nBarometer_Sensor Library\n\n\nGithub repository for Barometer Sensor Library\n\n\nBST-BMP085-DS000-06\n\n\n\n\nHelp us make it better",
            "title": "Grove Barometer Sensor"
        },
        {
            "location": "/Grove-Barometer_Sensor/#grove-barometer-sensor",
            "text": "",
            "title": "Grove - Barometer Sensor"
        },
        {
            "location": "/Grove-Barometer_Sensor/#introduction",
            "text": "This Grove - Barometer Sensor features a Bosch BMP085 high-accuracy chip to detect barometric pressure and temperature. It can widely measure pressure ranging from 300hPa to 1100hPa, AKA +9000m to -500m above sea level, with a super high accuracy of 0.03hPa(0.25m) in ultra-high resolution mode. The chip only accepts 1.8V to 3.6V input voltage. However, with outer circuit added, this module becomes compatible with 3.3V and 5V. Therefore, it can be used on Arduino/Seeeduino or Seeeduino Stalker without modification. It is designed to be connected directly to a micro-controller via the I2C bus.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Barometer_Sensor/#features",
            "text": "Digital two wire (I2C) interface  Wide barometric pressure range  Flexible supply voltage range  Ultra-low power consumption  Low noise measurement  Fully calibrated  Temperature measurement included",
            "title": "Features"
        },
        {
            "location": "/Grove-Barometer_Sensor/#application-ideas",
            "text": "Enhancement of GPS navigation  Indoor and outdoor navigation  Leisure and sports  Weather forecast  Vertical velocity indication (rise/sink speed)",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Barometer_Sensor/#specifications",
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nVoltage  \n3  \n5  \n5.5  \nVDC    \nCurrent  \n89  \n/  \n130  \nuA    \nPressure Range  \n300  \n/  \n1100  \nhPa    \nFaster I2C data transfer  \n/  \n/  \n3.4  \nMHZ    \nDimension  \n20.4*24.3*9.7  \nmm    \nWeight  \n2  \ng",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Barometer_Sensor/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/Grove-Barometer_Sensor/#with-arduino",
            "text": "Barometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Grove - Barometer Sensor.  1.Connect it to IIC port of Seeeduino or Grove - Base Shield via a Grove cable. And connect Arduino to PC via a USB cable.  2.Download the library  Barometer_Sensor Library ;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.  3.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -> Example ->Barometer_Sensor->Barometer_Sensor.      /* Barometer demo V1.0\n    * Based largely on code by  Jim Lindblom\n    * Get pressure, altitude, and temperature from the BMP085.\n    * Serial.print it out at 9600 baud to serial monitor.\n    *\n    * By:http://www.seeedstudio.com\n    */\n    #include \"Barometer.h\"\n    #include <Wire.h>\n    float temperature;\n    float pressure;\n    float atm;\n    float altitude;\n    Barometer myBarometer;\n    void setup(){\n      Serial.begin(9600);\n      myBarometer.init();\n\n    }\n\n    void loop()\n    {\n       temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n       pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n       altitude = myBarometer.calcAltitude(pressure); //Uncompensated calculation - in Meters \n       atm = pressure / 101325; \n\n      Serial.print(\"Temperature: \");\n      Serial.print(temperature, 2); //display 2 decimal places\n      Serial.println(\"deg C\");\n\n      Serial.print(\"Pressure: \");\n      Serial.print(pressure, 0); //whole number only.\n      Serial.println(\" Pa\");\n\n      Serial.print(\"Ralated Atmosphere: \");\n      Serial.println(atm, 4); //display 4 decimal places\n\n      Serial.print(\"Altitude: \");\n      Serial.print(altitude, 2); //display 2 decimal places\n      Serial.println(\" m\");\n\n      Serial.println();\n\n      delay(1000); //wait a second and get values again.\n    }  4.Open the serial monitor to receive the sensor's data including temperature, barometric pressure value, relative atmosphere pressure and altitude.   The following is a reference graph plotting out the relationship between altitude above sea level and barometric pressure.",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-Barometer_Sensor/#with-raspberry-pi",
            "text": "1.You should have got a raspberry pi and a grovepi or grovepi+.  2.You should have completed configuring the development enviroment, otherwise follow  here .  3.Connection   Plug the barometer sensor into the i2c sockets on grovepi.   4.Navigate to the demos' directory:      cd yourpath/GrovePi/Software/Python/grove_barometer/adafruit/   To see the code       nano grove_i2c_barometic_sensor_example.py   # \"Ctrl+x\" to exit #      #!/usr/bin/python\n\n    import smbus\n    import RPi.GPIO as GPIO\n    #import grovepi\n    from grove_i2c_barometic_sensor import BMP085\n\n    # ===========================================================================\n    # Example Code\n    # ===========================================================================\n\n    # Initialise the BMP085 and use STANDARD mode (default value)\n    # bmp = BMP085(0x77, debug=True)\n    bmp = BMP085(0x77, 1)\n\n    # To specify a different operating mode, uncomment one of the following:\n    # bmp = BMP085(0x77, 0)  # ULTRALOWPOWER Mode\n    # bmp = BMP085(0x77, 1)  # STANDARD Mode\n    # bmp = BMP085(0x77, 2)  # HIRES Mode\n    # bmp = BMP085(0x77, 3)  # ULTRAHIRES Mode\n\n    rev = GPIO.RPI_REVISION\n    if rev == 2 or rev == 3:\n        bus = smbus.SMBus(1)\n    else:\n        bus = smbus.SMBus(0)\n\n    temp = bmp.readTemperature()\n\n    # Read the current barometric pressure level\n    pressure = bmp.readPressure()\n\n    # To calculate altitude based on an estimated mean sea level pressure\n    # (1013.25 hPa) call the function as follows, but this won't be very accurate\n    # altitude = bmp.readAltitude()\n\n    # To specify a more accurate altitude, enter the correct mean sea level\n    # pressure level.  For example, if the current pressure level is 1023.50 hPa\n    # enter 102350 since we include two decimal places in the integer value\n    altitude = bmp.readAltitude(101560)\n\n    print \"Temperature:\u00a0%.2f C\"\u00a0% temp\n    print \"Pressure:   \u00a0%.2f hPa\"\u00a0% (pressure / 100.0)\n    print \"Altitude:   \u00a0%.2f m\"\u00a0% altitude  5.Run the demo.         sudo python grove_i2c_barometic_sensor_example.py  6.Result",
            "title": "With Raspberry Pi"
        },
        {
            "location": "/Grove-Barometer_Sensor/#resources",
            "text": "Grove - Barometer Sensor Eagle File  Barometer_Sensor Library  Github repository for Barometer Sensor Library  BST-BMP085-DS000-06",
            "title": "Resources"
        },
        {
            "location": "/Grove-Barometer_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-EL_Driver/",
            "text": "Grove - EL Driver\n\n\n\n\nIntroduction\n\n\nGrove - EL Driver is designed for driving EL Wires. It integrates a very small inverter to drive the EL Wire, so you can easily light up the EL Wire with just one single Grove cable.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv1.0\n\n\nInitial public release\n\n\nDec 11, 2014\n\n\n\n\n\n\n\n\nSupported EL Wires:\n\n\n\n\nEL Wire-Green 3m\n\n\nEL Wire-Red 3m\n\n\nEL Wire-Blue 3m\n\n\nEL Wire-Yellow 3m\n\n\nEL Wire-White 3m\n\n\n\n\nFeatures\n\n\n\n\nGrove compatible interface\n\n\n3.3V/5V Compatible\n\n\nIntegrated Inverter Transformer\n\n\nInput Current: 300mA Max (According to the load)\n\n\nSupported max EL Capacitance: 15nF\n\n\n\n\nUsage\n\n\nHere we show how to use Arduino to control the state of the LED.\n\n\n\n\n\n\nConnect the Grove - EL Driver to Base Shield's \ndigital port 2\n with 4pin Grove Cable. Of course you can change to other valid digital ports if it's necessary and the definitions of the port should be changed too. Connect a EL Wire to EL Driver \nJ1\n port with the given cable in product package.\n\n\n\n\n\n\nPlug it onto the Arduino/Seeeduino. Connect the board to PC using USB cable.\n\n\n\n\n\n\nCopy the demo code to your sketch, then upload to Arudino or Seeeduino board. Please click \nhere\n if you do not know how to upload.\nYou will see the EL Wire blink every second.\n\n\n\n\n\n\n/*************************   2014 Seeedstudio   **************************\n* File Name         \u00a0: GroveELDriverDemoCode.ino\n* Author            \u00a0: Seeedteam\n* Version           \u00a0: V1.0\n* Date              \u00a0: 11/12/2014\n* Description       \u00a0: Demo code for Grove - EL Driver\n*************************************************************************/\n\u00a0\n#define ELPin 2 //connect EL Driver to digital pin2\nvoid setup() {                \n  // initialize the digital pin2 as an output.\n  pinMode(ELPin, OUTPUT);     \n}\n\u00a0\nvoid loop() {\n  digitalWrite(ELPin, HIGH);   // set the EL Wire on\n  delay(500);               // for 500ms\n  digitalWrite(ELPin, LOW);   // set the EL Wire off\n  delay(500);\n}\n\n\n\n\n\n\nResources\n\n\n\n\nsch_pcb_eagle\n\n\nsch_pdf\n\n\n\n\nHelp us make it better",
            "title": "Grove EL Driver"
        },
        {
            "location": "/Grove-EL_Driver/#grove-el-driver",
            "text": "",
            "title": "Grove - EL Driver"
        },
        {
            "location": "/Grove-EL_Driver/#introduction",
            "text": "Grove - EL Driver is designed for driving EL Wires. It integrates a very small inverter to drive the EL Wire, so you can easily light up the EL Wire with just one single Grove cable.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-EL_Driver/#version-tracker",
            "text": "Revision  Descriptions  Release      v1.0  Initial public release  Dec 11, 2014",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-EL_Driver/#supported-el-wires",
            "text": "EL Wire-Green 3m  EL Wire-Red 3m  EL Wire-Blue 3m  EL Wire-Yellow 3m  EL Wire-White 3m",
            "title": "Supported EL Wires:"
        },
        {
            "location": "/Grove-EL_Driver/#features",
            "text": "Grove compatible interface  3.3V/5V Compatible  Integrated Inverter Transformer  Input Current: 300mA Max (According to the load)  Supported max EL Capacitance: 15nF",
            "title": "Features"
        },
        {
            "location": "/Grove-EL_Driver/#usage",
            "text": "Here we show how to use Arduino to control the state of the LED.    Connect the Grove - EL Driver to Base Shield's  digital port 2  with 4pin Grove Cable. Of course you can change to other valid digital ports if it's necessary and the definitions of the port should be changed too. Connect a EL Wire to EL Driver  J1  port with the given cable in product package.    Plug it onto the Arduino/Seeeduino. Connect the board to PC using USB cable.    Copy the demo code to your sketch, then upload to Arudino or Seeeduino board. Please click  here  if you do not know how to upload.\nYou will see the EL Wire blink every second.    /*************************   2014 Seeedstudio   **************************\n* File Name         \u00a0: GroveELDriverDemoCode.ino\n* Author            \u00a0: Seeedteam\n* Version           \u00a0: V1.0\n* Date              \u00a0: 11/12/2014\n* Description       \u00a0: Demo code for Grove - EL Driver\n*************************************************************************/\n\u00a0\n#define ELPin 2 //connect EL Driver to digital pin2\nvoid setup() {                \n  // initialize the digital pin2 as an output.\n  pinMode(ELPin, OUTPUT);     \n}\n\u00a0\nvoid loop() {\n  digitalWrite(ELPin, HIGH);   // set the EL Wire on\n  delay(500);               // for 500ms\n  digitalWrite(ELPin, LOW);   // set the EL Wire off\n  delay(500);\n}",
            "title": "Usage"
        },
        {
            "location": "/Grove-EL_Driver/#resources",
            "text": "sch_pcb_eagle  sch_pdf",
            "title": "Resources"
        },
        {
            "location": "/Grove-EL_Driver/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-EMG_Detector/",
            "text": "Grove - EMG Detector\n\n\n\n\nIntroduction\n\n\nEMG detector is a bridge connects human body and electrical, the sensor gathers small muscle signal then process with 2th amplify and filter, the output signal can be recognized by Arduino. You can add this signal into your control system. \n\n\n\n\nNote\n\nThe sensor cannot be used for medical purposes.\n\n\n\n\nIn standby mode, the output voltage is 1.5V. When detect muscle active, the output signal rise up, the maximum voltage is 3.3V. You can use this sensor in 3.3V or 5V system.\n\n\n\n\nFeatures\n\n\n\n\nGrove Compatible\n\n\n3.5mm Connector\n\n\n6 Disposable Surface Electrodes\n\n\nPower supply voltage: 3.3V-5V\n\n\n1000mm Cable Leads\n\n\nNo additional power supply\n\n\n\n\nHardware Overview\n\n\n\n\n\n\nJ2: grove interface, connect to analog I/O;\n\n\nJ1: EMG Disposable Surface Electrodes connector.\n\n\nU1: INA331IDGKT, difference amplifier.\n\n\nU2, U3: OPA333, Zero drift amplifier.\n\n\n\n\nDemonstration\n\n\nThis demonstration will show you how to use Grove - LCD RGB Backlight, we need a \nSeeeduino V3.0\n, a \nGrove - LED Bar\n and \nGrove - Base Shield\n.\n\n\nHardware Installation\n\n\nPlug Grove - Base Shield to Seeeduino, then connect Grove - LED Bar to D8, connect Grove - EMG Sensor to A0.\n\n\nFinally, tack the three electrodes to your muscle, and keep a distance between each electrodes.\n\n\n\n\nDownload Code and Upload\n\n\nYou can download the demo code in github, click \nhere\n, then extract it to anywhere.\n\n\nThen upload the code to Seeeduino, if you have any problem about code uploading, please refer to \nGetting Started With Seeeduino\n\n\n\n\nMove\n\n\nWhen finish downloading demo code, it'll take about 5s to initialize, you should keep static when initializing.\n\n\nYou can see that when initializing, the Led Bar will go form level 10 to level 0. When Led Bar All off, you can move now.\n\n\nWhen you are moving, you can find that the level of Led Bar will change.\n\n\n\n\nResources\n\n\n\n\nGrove-EMG Sensor v1.0 Eagle File\n\n\nGrove-EMG Sensor v1.1 Eagle File\n\n\nGrove-EMG Sensor v1.1 schematic PDF\n\n\nDemo Code\n\n\n\n\nHelp us make it better",
            "title": "Grove EMG Detector"
        },
        {
            "location": "/Grove-EMG_Detector/#grove-emg-detector",
            "text": "",
            "title": "Grove - EMG Detector"
        },
        {
            "location": "/Grove-EMG_Detector/#introduction",
            "text": "EMG detector is a bridge connects human body and electrical, the sensor gathers small muscle signal then process with 2th amplify and filter, the output signal can be recognized by Arduino. You can add this signal into your control system.    Note \nThe sensor cannot be used for medical purposes.  In standby mode, the output voltage is 1.5V. When detect muscle active, the output signal rise up, the maximum voltage is 3.3V. You can use this sensor in 3.3V or 5V system.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-EMG_Detector/#features",
            "text": "Grove Compatible  3.5mm Connector  6 Disposable Surface Electrodes  Power supply voltage: 3.3V-5V  1000mm Cable Leads  No additional power supply",
            "title": "Features"
        },
        {
            "location": "/Grove-EMG_Detector/#hardware-overview",
            "text": "J2: grove interface, connect to analog I/O;  J1: EMG Disposable Surface Electrodes connector.  U1: INA331IDGKT, difference amplifier.  U2, U3: OPA333, Zero drift amplifier.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-EMG_Detector/#demonstration",
            "text": "This demonstration will show you how to use Grove - LCD RGB Backlight, we need a  Seeeduino V3.0 , a  Grove - LED Bar  and  Grove - Base Shield .",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-EMG_Detector/#hardware-installation",
            "text": "Plug Grove - Base Shield to Seeeduino, then connect Grove - LED Bar to D8, connect Grove - EMG Sensor to A0.  Finally, tack the three electrodes to your muscle, and keep a distance between each electrodes.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-EMG_Detector/#download-code-and-upload",
            "text": "You can download the demo code in github, click  here , then extract it to anywhere.  Then upload the code to Seeeduino, if you have any problem about code uploading, please refer to  Getting Started With Seeeduino",
            "title": "Download Code and Upload"
        },
        {
            "location": "/Grove-EMG_Detector/#move",
            "text": "When finish downloading demo code, it'll take about 5s to initialize, you should keep static when initializing.  You can see that when initializing, the Led Bar will go form level 10 to level 0. When Led Bar All off, you can move now.  When you are moving, you can find that the level of Led Bar will change.",
            "title": "Move"
        },
        {
            "location": "/Grove-EMG_Detector/#resources",
            "text": "Grove-EMG Sensor v1.0 Eagle File  Grove-EMG Sensor v1.1 Eagle File  Grove-EMG Sensor v1.1 schematic PDF  Demo Code",
            "title": "Resources"
        },
        {
            "location": "/Grove-EMG_Detector/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-FM_Receiver/",
            "text": "Grove - FM Receiver\n\n\n\n\nIntroduction\n\n\nGrove - FM Receiver is a wideband FM receiver module, this module is base on SX6119, it offers true single-chip voice FM receiver, which is built-in amplifier, VCO, filter and demodulator. The multifunction button provides greater convenience for users to control.\n\n\n\n\nFeatures\n\n\n\n\nGrove interface\n\n\nFM receiver with a tuning range of 64 MHz to 108 MHz covering Eastern Europe (OIRT), Japan, Europe and US bands\n\n\nLower power consumption\n\n\nMultifunction button\n\n\nLED Indicator\n\n\nHeadsets interface\n\n\n\n\nHardware Overview\n\n\n\n\n\n\n\u2460\uff1aHeadsets interface:It can drive 16 ohm or 32 ohm earphone or audio\u3002\n\n\n\n\n\u2461\uff1aMultifunction button \uff1aChange volume and select channel\n\n\n\n\nCenter\uff1aOpen FM/Close FM\uff08Keeping press 1S\uff09\n\n\nUp\uff1avolume add\n\n\nDown\uff1avolume sub\n\n\nLeft\uff1asearching down\n\n\nRight\uff1asearching up\n\n\n\n\n\n\n\n\n\u2462\uff1aGrove Interface\n\n\n\n\n\n\n\u2463\uff1aLED Indicator\n\n\n\n\nFM Close\uff1aLED off\n\n\nFM Open\uff1aLED light\n\n\nFM Searching\uff1aLED flash\n\n\n\n\n\n\n\n\nUsage\n\n\nPart list\uff1a\n\n\n\n\nGrove - USB Power\n\n\nGrove - FM Receiver\n\n\nMini Cable\n\n\nAudio\n\n\n\n\n\n\nResources\n\n\n\n\nGrove - FM Receiver Eagle File\n\n\nSchematic in pdf\n\n\nDatasheet of SX6119\n\n\n\n\nHelp us make it better",
            "title": "Grove FM Receiver"
        },
        {
            "location": "/Grove-FM_Receiver/#grove-fm-receiver",
            "text": "",
            "title": "Grove - FM Receiver"
        },
        {
            "location": "/Grove-FM_Receiver/#introduction",
            "text": "Grove - FM Receiver is a wideband FM receiver module, this module is base on SX6119, it offers true single-chip voice FM receiver, which is built-in amplifier, VCO, filter and demodulator. The multifunction button provides greater convenience for users to control.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-FM_Receiver/#features",
            "text": "Grove interface  FM receiver with a tuning range of 64 MHz to 108 MHz covering Eastern Europe (OIRT), Japan, Europe and US bands  Lower power consumption  Multifunction button  LED Indicator  Headsets interface",
            "title": "Features"
        },
        {
            "location": "/Grove-FM_Receiver/#hardware-overview",
            "text": "\u2460\uff1aHeadsets interface:It can drive 16 ohm or 32 ohm earphone or audio\u3002   \u2461\uff1aMultifunction button \uff1aChange volume and select channel   Center\uff1aOpen FM/Close FM\uff08Keeping press 1S\uff09  Up\uff1avolume add  Down\uff1avolume sub  Left\uff1asearching down  Right\uff1asearching up     \u2462\uff1aGrove Interface    \u2463\uff1aLED Indicator   FM Close\uff1aLED off  FM Open\uff1aLED light  FM Searching\uff1aLED flash",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-FM_Receiver/#usage",
            "text": "Part list\uff1a   Grove - USB Power  Grove - FM Receiver  Mini Cable  Audio",
            "title": "Usage"
        },
        {
            "location": "/Grove-FM_Receiver/#resources",
            "text": "Grove - FM Receiver Eagle File  Schematic in pdf  Datasheet of SX6119",
            "title": "Resources"
        },
        {
            "location": "/Grove-FM_Receiver/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-GSR_Sensor/",
            "text": "Grove - GSR Sensor\n\n\n\n\nIntroduction\n\n\nGSR, standing for galvanic skin response, is a method of measuring the electrical conductance of the skin. Strong emotion can cause stimulus to your sympathetic nervous system, resulting more sweat being secreted by the sweat glands. Grove \u2013 GSR allows you to spot such strong emotions by simple attaching two electrodes to two fingers on one hand, an interesting gear to create emotion related projects, like sleep quality monitor.\n\n\n\n\nSpecifications\n\n\n\n\nInput Voltage: 5V/3.3V\n\n\nSensitivity adjustable via a potentiometer\n\n\nExternal measuring finger cots\n\n\n\n\nDemonstration\n\n\nIn the following we are showing you how to use the Grove - GSR.\nConnect Grove - GSR Sensor to the analog port A2 of Grove-Basic Shield and Grove - Buzzer to digital port 3. \n\nCopy and paste the code below to a new Arduino sketch and upload it to Arduino.\n\n\nconst int BUZZER=3;\nconst int GSR=A2;\nint threshold=0;\nint sensorValue;\n\nvoid setup(){\n  long sum=0;\n  Serial.begin(9600);\n  pinMode(BUZZER,OUTPUT);\n  digitalWrite(BUZZER,LOW);\n  delay(1000);\n\n  for(int i=0;i<500;i++)\n  {\n  sensorValue=analogRead(GSR);\n  sum += sensorValue;\n  delay(5);\n  }\n  threshold = sum/500;\n   Serial.print(\"threshold =\");\n   Serial.println(threshold);\n  }\n\nvoid loop(){\n  int temp;\n  sensorValue=analogRead(GSR);\n  Serial.print(\"sensorValue=\");\n  Serial.println(sensorValue);\n  temp = threshold - sensorValue;\n  if(abs(temp)>50)\n  {\n    sensorValue=analogRead(GSR);\n    temp = threshold - sensorValue;\n    if(abs(temp)>50){\n    digitalWrite(BUZZER,HIGH);\n    Serial.println(\"YES!\");\n    delay(3000);\n    digitalWrite(BUZZER,LOW);\n    delay(1000);}\n  }\n  }\n\n\n\nWear the finger sheath and relax, Now open serial monitor, we can see:\n\n\n\n\nThen take a deep breath. The buzzer should buzz now. And an obvious change in the output value should be observed.\nThe below is a graphs which is created in Excel using the data above. X axis represents time. and Y axis GSR data.\n\n\n\n\nReference\n\n\nThere are several graphs which are created in excel using GSR data.You can open the \nGSR sensor data.xls\n to see the detail data.\n\n\n\n\n\nResources\n\n\n\n\nGrove - GSR Eagle File\n\n\nLM324 datasheet\n\n\nGSR sensor data.xls\n\n\n\n\nHelp us make it better",
            "title": "Grove GSR Sensor"
        },
        {
            "location": "/Grove-GSR_Sensor/#grove-gsr-sensor",
            "text": "",
            "title": "Grove - GSR Sensor"
        },
        {
            "location": "/Grove-GSR_Sensor/#introduction",
            "text": "GSR, standing for galvanic skin response, is a method of measuring the electrical conductance of the skin. Strong emotion can cause stimulus to your sympathetic nervous system, resulting more sweat being secreted by the sweat glands. Grove \u2013 GSR allows you to spot such strong emotions by simple attaching two electrodes to two fingers on one hand, an interesting gear to create emotion related projects, like sleep quality monitor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-GSR_Sensor/#specifications",
            "text": "Input Voltage: 5V/3.3V  Sensitivity adjustable via a potentiometer  External measuring finger cots",
            "title": "Specifications"
        },
        {
            "location": "/Grove-GSR_Sensor/#demonstration",
            "text": "In the following we are showing you how to use the Grove - GSR.\nConnect Grove - GSR Sensor to the analog port A2 of Grove-Basic Shield and Grove - Buzzer to digital port 3.  \nCopy and paste the code below to a new Arduino sketch and upload it to Arduino.  const int BUZZER=3;\nconst int GSR=A2;\nint threshold=0;\nint sensorValue;\n\nvoid setup(){\n  long sum=0;\n  Serial.begin(9600);\n  pinMode(BUZZER,OUTPUT);\n  digitalWrite(BUZZER,LOW);\n  delay(1000);\n\n  for(int i=0;i<500;i++)\n  {\n  sensorValue=analogRead(GSR);\n  sum += sensorValue;\n  delay(5);\n  }\n  threshold = sum/500;\n   Serial.print(\"threshold =\");\n   Serial.println(threshold);\n  }\n\nvoid loop(){\n  int temp;\n  sensorValue=analogRead(GSR);\n  Serial.print(\"sensorValue=\");\n  Serial.println(sensorValue);\n  temp = threshold - sensorValue;\n  if(abs(temp)>50)\n  {\n    sensorValue=analogRead(GSR);\n    temp = threshold - sensorValue;\n    if(abs(temp)>50){\n    digitalWrite(BUZZER,HIGH);\n    Serial.println(\"YES!\");\n    delay(3000);\n    digitalWrite(BUZZER,LOW);\n    delay(1000);}\n  }\n  }  Wear the finger sheath and relax, Now open serial monitor, we can see:   Then take a deep breath. The buzzer should buzz now. And an obvious change in the output value should be observed.\nThe below is a graphs which is created in Excel using the data above. X axis represents time. and Y axis GSR data.",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-GSR_Sensor/#reference",
            "text": "There are several graphs which are created in excel using GSR data.You can open the  GSR sensor data.xls  to see the detail data.",
            "title": "Reference"
        },
        {
            "location": "/Grove-GSR_Sensor/#resources",
            "text": "Grove - GSR Eagle File  LM324 datasheet  GSR sensor data.xls",
            "title": "Resources"
        },
        {
            "location": "/Grove-GSR_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/",
            "text": "Grove - Gas Sensor(MQ2)\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor(MQ2) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nH2, LPG, CH4, CO, Alcohol, Smoke or Propane\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer. \n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n800\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n3\n\n\n-\n\n\n30\n\n\nk\u03a9\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-2 sensor, please refer the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\n\n\n\nConnect the Grove - Gas Sensor(MQ2) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\n\nThese examples demonstrate ways to know the approximate concentration of Gas. As per the data-sheet of the MQx sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.8; // The ratio of RS/R0 is 9.8 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the graph, we can see that the minimum concentration we can test is 100ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.01% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat's LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-2 Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Gas Sensor MQ2"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#grove-gas-sensormq2",
            "text": "",
            "title": "Grove - Gas Sensor(MQ2)"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#introduction",
            "text": "The Grove - Gas Sensor(MQ2) module is useful for gas leakage detection (in home and industry). It is suitable for detecting  H2, LPG, CH4, CO, Alcohol, Smoke or Propane . Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.    Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#features",
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity",
            "title": "Features"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#specification",
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  800  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33  -  \u03a9    Rs  Sensing Resistance  3  -  30  k\u03a9",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#application-ideas",
            "text": "Gas leakage detection.  Toys.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#hardware-overview",
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-2 sensor, please refer the data-sheet provided in  Resources  section.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#getting-started",
            "text": "Connect the Grove - Gas Sensor(MQ2) to A0 port as shown in the picture above.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#gas-detection-basic-example",
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}",
            "title": "Gas Detection\u00a0: Basic Example"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#measurement-approximation",
            "text": "These examples demonstrate ways to know the approximate concentration of Gas. As per the data-sheet of the MQx sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.8; // The ratio of RS/R0 is 9.8 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the graph, we can see that the minimum concentration we can test is 100ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.01% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.",
            "title": "Measurement\u00a0: Approximation"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#resources",
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What's LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-2 Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ2/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/",
            "text": "Grove - Gas Sensor(MQ3)\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor(MQ3) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nAlcohol, Benzine, CH4, Hexane, LPG, CO.\n Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\n\n\n\nHigh sensitivity to alcohol and small sensitivity to Benzine\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n750\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n1\n\n\n-\n\n\n8\n\n\nM\u03a9\n\n\n\n\n\n\nScope\n\n\nDetecting Concentration\n\n\n0.05\n\n\n-\n\n\n10\n\n\nmg/L\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nAlcohol checker.\n\n\nBreathalyser.\n\n\nToys.\n\n\n\n\nHardware Overview\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-3 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\n\n\n\nConnect the Grove - Gas Sensor(MQ3) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ3 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in Alcohol\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/60.0; // The ratio of RS/R0 is 60 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 0.1mg/L and the maximum is 10mg/L. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.But also, we can convert mg/L to ppm, it's may convenient for us to watch the value.\n\n\n\n\n\n\nResources\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat's LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-3 Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Gas Sensor MQ3"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#grove-gas-sensormq3",
            "text": "",
            "title": "Grove - Gas Sensor(MQ3)"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#introduction",
            "text": "The Grove - Gas Sensor(MQ3) module is useful for gas leakage detection (in home and industry). It is suitable for detecting  Alcohol, Benzine, CH4, Hexane, LPG, CO.  Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.   Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#features",
            "text": "High sensitivity to alcohol and small sensitivity to Benzine  Stable and long life  Fast response and High sensitivity",
            "title": "Features"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#specification",
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  750  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33  -  \u03a9    Rs  Sensing Resistance  1  -  8  M\u03a9    Scope  Detecting Concentration  0.05  -  10  mg/L",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#application-ideas",
            "text": "Alcohol checker.  Breathalyser.  Toys.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#hardware-overview",
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-3 sensor, please refer to the data-sheet provided in  Resources  section.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#getting-started",
            "text": "Connect the Grove - Gas Sensor(MQ3) to A0 port as shown in the picture above.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#gas-detection-basic-example",
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}",
            "title": "Gas Detection\u00a0: Basic Example"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#measurement-approximation",
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ3 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in Alcohol\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/60.0; // The ratio of RS/R0 is 60 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 0.1mg/L and the maximum is 10mg/L. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.But also, we can convert mg/L to ppm, it's may convenient for us to watch the value.",
            "title": "Measurement\u00a0: Approximation"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#resources",
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What's LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-3 Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ3/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/",
            "text": "Grove - Gas Sensor(MQ5)\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor(MQ5) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nH2, LPG, CH4, CO, Alcohol\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n800\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n31\u00b110%\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n10\n\n\n-\n\n\n60\n\n\nk\u03a9\n\n\n\n\n\n\nScope\n\n\nDetecting Concentration\n\n\n200\n\n\n-\n\n\n10000\n\n\nppm\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-5 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\n\n\n\nConnect the Grove - Gas Sensor(MQ5) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\n\n\nNote\n\nYou need an extra tool to find a certain threshold for various air condition. And then set the threshold in code.\n\n\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ5 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/6.5; // The ratio of RS/R0 is 6.5 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat's LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-5 Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Gas Sensor MQ5"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#grove-gas-sensormq5",
            "text": "",
            "title": "Grove - Gas Sensor(MQ5)"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#introduction",
            "text": "The Grove - Gas Sensor(MQ5) module is useful for gas leakage detection (in home and industry). It is suitable for detecting  H2, LPG, CH4, CO, Alcohol . Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.   Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#features",
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity",
            "title": "Features"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#specification",
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  800  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  31\u00b110%  -  \u03a9    Rs  Sensing Resistance  10  -  60  k\u03a9    Scope  Detecting Concentration  200  -  10000  ppm",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#application-ideas",
            "text": "Gas leakage detection.  Toys.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#hardware-overview",
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-5 sensor, please refer to the data-sheet provided in  Resources  section.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#getting-started",
            "text": "Connect the Grove - Gas Sensor(MQ5) to A0 port as shown in the picture above.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#gas-detection-basic-example",
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.   Note \nYou need an extra tool to find a certain threshold for various air condition. And then set the threshold in code.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}",
            "title": "Gas Detection\u00a0: Basic Example"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#measurement-approximation",
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ5 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/6.5; // The ratio of RS/R0 is 6.5 in a clear air from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.",
            "title": "Measurement\u00a0: Approximation"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#resources",
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What's LEL   Schematic   Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-5 Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ5/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/",
            "text": "Grove - Gas Sensor(MQ9)\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor(MQ9) module is useful for gas leakage detection (in home and industry). It is suitable for detecting \nLPG, CO, CH4\n. Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.\n\n\n\n\nNote\n\nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.\n\n\n\n\n\n\nFeatures\n\n\n\n\nWide detecting scope\n\n\nStable and long life\n\n\nFast response and High sensitivity\n\n\n\n\nSpecification\n\n\n\n\n\n\n\n\nItem\n\n\nParameter\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nVCC\n\n\nWorking Voltage\n\n\n4.9\n\n\n5\n\n\n5.1\n\n\nV\n\n\n\n\n\n\nPH\n\n\nHeating consumption\n\n\n0.5\n\n\n-\n\n\n340\n\n\nmW\n\n\n\n\n\n\nRL\n\n\nLoad resistance\n\n\n\n\nadjustable\n\n\n\n\n\n\n\n\n\n\nRH\n\n\nHeater resistance\n\n\n-\n\n\n33\u03a9\u00b15%\n\n\n-\n\n\n\u03a9\n\n\n\n\n\n\nRs\n\n\nSensing Resistance\n\n\n2\n\n\n-\n\n\n20000\n\n\n\u03a9\n\n\n\n\n\n\nCO/CH4/LPG Scope\n\n\nDetecting Concentration\n\n\n200\n\n\n-\n\n\n1000/10000/10000\n\n\nppm\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nGas leakage detection.\n\n\nToys.\n\n\n\n\nHardware Overview\n\n\nThis is an Analog output sensor. This needs to be connected to any one Analog socket in \nBase Shield\n. The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.\n\n\nIt is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:\n\n\n\n\n\n\n\n\nArduino\n\n\nGas Sensor\n\n\n\n\n\n\n\n\n\n\n5V\n\n\nVCC\n\n\n\n\n\n\nGND\n\n\nGND\n\n\n\n\n\n\nNC\n\n\nNC\n\n\n\n\n\n\nAnalog A0\n\n\nSIG\n\n\n\n\n\n\n\n\nThe output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer. \nPlease note that the best preheat time for the sensor is above 24 hours\n. For detailed information about the MQ-9 sensor, please refer to the data-sheet provided in \nResources\n section.\n\n\nGetting Started\n\n\n\n\nConnect the Grove - Gas Sensor(MQ9) to A0 port as shown in the picture above.\n\n\nGas Detection\u00a0: Basic Example\n\n\nIn this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n\n\n\n\nMeasurement\u00a0: Approximation\n\n\nThis examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ9 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.\n\n\n\n\n\n\nKeep the Gas Sensor in clean air environment. Upload the program below.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in LPG\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.9; // The ratio of RS/R0 is 9.9 in LPG gas from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n\n\n\n\n\n\n\nThen, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.\n\n\nReplace the R0 below with value of R0 tested above \n. Expose the sensor to any one of the gas listed above.\n\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n\n\n\nNow, we can get the concentration of gas from the figure below.\n\n\n\n\nAccording to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.\n\n\n\n\n\n\nResources\n\n\nSuggest Reading / References\n\n\n\n\nDownload Arduino and install Arduino driver\n\n\nGetting Started with Seeeduino\n\n\nHow to choose a Gas Sensor\n\n\nWhat's LEL\n\n\n\n\nSchematic\n\n\n\n\nGrove Gas Sensor - EAGLE (Schematic and Board) files\n\n\nGrove Gas Sensor - PDF Schematic\n\n\n\n\nDatasheet\n\n\n\n\nMQ-9 Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Gas Sensor MQ9"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#grove-gas-sensormq9",
            "text": "",
            "title": "Grove - Gas Sensor(MQ9)"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#introduction",
            "text": "The Grove - Gas Sensor(MQ9) module is useful for gas leakage detection (in home and industry). It is suitable for detecting  LPG, CO, CH4 . Due to its high sensitivity and fast response time, measurements can be taken as soon as possible. The sensitivity of the sensor can be adjusted by using the potentiometer.   Note \nThe sensor value only reflects the approximated trend of gas concentration in a permissible error range, it DOES NOT represent the exact gas concentration. The detection of certain components in the air usually requires a more precise and costly instrument, which cannot be done with a single gas sensor. If your project is aimed at obtaining the gas concentration at a very precise level, then we do not recommend this gas sensor.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#features",
            "text": "Wide detecting scope  Stable and long life  Fast response and High sensitivity",
            "title": "Features"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#specification",
            "text": "Item  Parameter  Min  Typical  Max  Unit      VCC  Working Voltage  4.9  5  5.1  V    PH  Heating consumption  0.5  -  340  mW    RL  Load resistance   adjustable      RH  Heater resistance  -  33\u03a9\u00b15%  -  \u03a9    Rs  Sensing Resistance  2  -  20000  \u03a9    CO/CH4/LPG Scope  Detecting Concentration  200  -  1000/10000/10000  ppm",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#application-ideas",
            "text": "Gas leakage detection.  Toys.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#hardware-overview",
            "text": "This is an Analog output sensor. This needs to be connected to any one Analog socket in  Base Shield . The examples used in this tutorial makes uses of A0 analog pin. Connect this module to the A0 port of Base Shield.  It is possible to connect the Grove module to Arduino directly by using jumper wires by using the connection as shown in the table below:     Arduino  Gas Sensor      5V  VCC    GND  GND    NC  NC    Analog A0  SIG     The output voltage from the Gas sensor increases when the concentration of gas increases. Sensitivity can be adjusted by varying the potentiometer.  Please note that the best preheat time for the sensor is above 24 hours . For detailed information about the MQ-9 sensor, please refer to the data-sheet provided in  Resources  section.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#getting-started",
            "text": "Connect the Grove - Gas Sensor(MQ9) to A0 port as shown in the picture above.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#gas-detection-basic-example",
            "text": "In this example, the sensor is connected to A0 pin. The voltage read from the sensor is displayed. This value can be used as a threshold to detect any increase/decrease in gas concentration.  void setup() {\n  Serial.begin(9600);\n}\n\u00a0\nvoid loop() {\n  float sensor_volt; \n  float sensorValue;\n\u00a0\n  sensorValue = analogRead(A0);\n  sensor_volt = sensorValue/1024*5.0;\n\u00a0\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}",
            "title": "Gas Detection\u00a0: Basic Example"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#measurement-approximation",
            "text": "This examples demonstrates a way to know the approximate concentration of Gas. As per the data-sheet of the MQ9 sensors, these equations are tested for standard conditions and are not calibrated. It may vary based on change in temperature or humidity.    Keep the Gas Sensor in clean air environment. Upload the program below.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in LPG\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0 ; x < 100 ; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.9; // The ratio of RS/R0 is 9.9 in LPG gas from Graph (Found using WebPlotDigitizer)\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}    Then, open the serial monitor of Arduino IDE. Write down the value of R0 and this needs to be used in the next program. Please node down the R0 after the reading stabilizes.  Replace the R0 below with value of R0 tested above  . Expose the sensor to any one of the gas listed above.  void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}  Now, we can get the concentration of gas from the figure below.   According to the figure, we can see that the minimum concentration we can test is 200ppm and the maximum is 10000ppm, in a other word, we can get a concentration of gas between 0.02% and 1%. However, we can't provide a formula because the relation between ratio and concentration is nonlinear.",
            "title": "Measurement\u00a0: Approximation"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#resources",
            "text": "Suggest Reading / References   Download Arduino and install Arduino driver  Getting Started with Seeeduino  How to choose a Gas Sensor  What's LEL",
            "title": "Resources"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#schematic",
            "text": "Grove Gas Sensor - EAGLE (Schematic and Board) files  Grove Gas Sensor - PDF Schematic   Datasheet   MQ-9 Datasheet",
            "title": "Schematic"
        },
        {
            "location": "/Grove-Gas_Sensor-MQ9/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Gas_Sensor/",
            "text": "Grove - Gas Sensor\n\n\n\n\nIntroduction\n\n\nThe Grove - Gas Sensor module is useful for gas leakage detecting(in home and industry). It can detect LPG, i-butane, methane, alcohol, Hydrogen, smoke and so on. Measurements can be taken as soon as possible based on its fast response time. Also the sensitivity can be adjusted by the potentiometer.\n\n\nEach Grove - Gas Sensor Kit consists of one gas sensor base and four detectors. You can switch the detector on the base according to specific target gases.\n\n\n\n\nGrove - Gas Sensor(MQ2)\n\uff1aCombustible Gas, Smoke\n\n\nGrove - Gas Sensor(MQ3)\n\uff1aAlcohol Vapor\n\n\nGrove - Gas Sensor(MQ5)\n\uff1aLPG, Natural Gas, Town Gas\n\n\nGrove - Gas Sensor(MQ9)\n\uff1aCarbon Monoxide, Coal Gas, Liquefied Gas\n\n\n\n\nSpecification\n\n\n\n\nWorking Voltage: 4.9-5.1V\n\n\nHeating consumption: 0.5-800mW\n\n\nLoad resistance: can adjust\n\n\nHeater resistance: 33\u03a9\n\n\nSensing Resistance: 3-30k\u03a9\n\n\nWorking Temperature: -25~70 \u2103\n\n\n\n\nDemonstration\n\n\nConnect the module with Grove Shield using A0 like following picture and use the program below to gain the voltage. The higher the concentration of the gas is, the bigger the output voltage of the SIG pin gets. Sensitivity can be regulated by rotating the potentiometer. Please note that the best preheat time of the sensor is about 24 hours. For the detailed information about the sensor, please refer to the datasheet.\n\n\n\n\nResources\n\n\n\n\nMQ-2 Datasheet\n\n\nMQ-3 Datasheet\n\n\nMQ-5 Datasheet\n\n\nMQ-9 Datasheet\n\n\nDemo code on github",
            "title": "Grove Gas Sensor"
        },
        {
            "location": "/Grove-Gas_Sensor/#grove-gas-sensor",
            "text": "",
            "title": "Grove - Gas Sensor"
        },
        {
            "location": "/Grove-Gas_Sensor/#introduction",
            "text": "The Grove - Gas Sensor module is useful for gas leakage detecting(in home and industry). It can detect LPG, i-butane, methane, alcohol, Hydrogen, smoke and so on. Measurements can be taken as soon as possible based on its fast response time. Also the sensitivity can be adjusted by the potentiometer.  Each Grove - Gas Sensor Kit consists of one gas sensor base and four detectors. You can switch the detector on the base according to specific target gases.   Grove - Gas Sensor(MQ2) \uff1aCombustible Gas, Smoke  Grove - Gas Sensor(MQ3) \uff1aAlcohol Vapor  Grove - Gas Sensor(MQ5) \uff1aLPG, Natural Gas, Town Gas  Grove - Gas Sensor(MQ9) \uff1aCarbon Monoxide, Coal Gas, Liquefied Gas",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Gas_Sensor/#specification",
            "text": "Working Voltage: 4.9-5.1V  Heating consumption: 0.5-800mW  Load resistance: can adjust  Heater resistance: 33\u03a9  Sensing Resistance: 3-30k\u03a9  Working Temperature: -25~70 \u2103",
            "title": "Specification"
        },
        {
            "location": "/Grove-Gas_Sensor/#demonstration",
            "text": "Connect the module with Grove Shield using A0 like following picture and use the program below to gain the voltage. The higher the concentration of the gas is, the bigger the output voltage of the SIG pin gets. Sensitivity can be regulated by rotating the potentiometer. Please note that the best preheat time of the sensor is about 24 hours. For the detailed information about the sensor, please refer to the datasheet.",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-Gas_Sensor/#resources",
            "text": "MQ-2 Datasheet  MQ-3 Datasheet  MQ-5 Datasheet  MQ-9 Datasheet  Demo code on github",
            "title": "Resources"
        },
        {
            "location": "/Grove-Hall_Sensor/",
            "text": "Grove - Hall Sensor\n\n\n\n\nIntroduction\n\n\nThe Hall sensor is based on Hall Effect, which is the production of a voltage difference across an electrical conductor, transverse to an electric current in the conductor and a magnetic field perpendicular to the current. There is a continuous-time switch on this Grove. The output of these devices switches low (turns on) when a magnetic field (south polarity) perpendicular to the Hall sensor exceeds the operate point threshold BOP, and it switches high (turn off) when the magnetic field disappears. The twig can be used to measure RPM.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv0.9b\n\n\nInitial public release\n\n\n3,Oct,2011\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nGrove Compatible Interface\n\n\n400ns transition period for rise and fall.\n\n\nContinuous-time hall effect sensor\n\n\nReverse battery protection\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nSupply Voltage\n\n\n3.8\n\n\n5.0\n\n\n24\n\n\nV\n\n\n\n\n\n\nSupply Current\n\n\n4.1\n\n\n-\n\n\n24\n\n\nmA\n\n\n\n\n\n\nOperating Temperature\n\n\n-40\n\n\n-\n\n\n85\n\n\n\u00baC\n\n\n\n\n\n\n\n\nApplication Ideas\n\n\n\n\nRPM meter.\n\n\nSimple dc motor.\n\n\n\n\nGetting Started\n\n\nThe Hall Sensor is used by utilizing the external interrupts available on the arduino/seeeduino. In this example we are using interrupt 0, found on digital pin 2. For other interrupts, see the \nattachInterrupt()\n.\n\n\n\n\nConnect the Hall Sensor to Digital port 2 of the \nGrove - Base Shield\n using a 4 pin cable and connect Grove-LED to Digital Port 4.\n\n\nThen connect Arduino to PC by using a USB cable.\n\n\nDownload the \nHall Sensor Code\n\n\nOpen one of two code. For example Demo \nMagnetControlLED\n\n\n\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n\n\nWhen a magnet whose south pole is facing up is approaching to the onboard sensor, the LED will be turned on. Otherwise, the LED will be turned off.\n\n\n\n\nResources\n\n\n\n\nGrove-Hall Sensor Eagle File\n\n\nHall Sensor Demo Code\n\n\nA1101 datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Hall Sensor"
        },
        {
            "location": "/Grove-Hall_Sensor/#grove-hall-sensor",
            "text": "",
            "title": "Grove - Hall Sensor"
        },
        {
            "location": "/Grove-Hall_Sensor/#introduction",
            "text": "The Hall sensor is based on Hall Effect, which is the production of a voltage difference across an electrical conductor, transverse to an electric current in the conductor and a magnetic field perpendicular to the current. There is a continuous-time switch on this Grove. The output of these devices switches low (turns on) when a magnetic field (south polarity) perpendicular to the Hall sensor exceeds the operate point threshold BOP, and it switches high (turn off) when the magnetic field disappears. The twig can be used to measure RPM.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Hall_Sensor/#version-tracker",
            "text": "Revision  Descriptions  Release      v0.9b  Initial public release  3,Oct,2011",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-Hall_Sensor/#features",
            "text": "Grove Compatible Interface  400ns transition period for rise and fall.  Continuous-time hall effect sensor  Reverse battery protection",
            "title": "Features"
        },
        {
            "location": "/Grove-Hall_Sensor/#specifications",
            "text": "Item  Min  Typical  Max  Unit      Supply Voltage  3.8  5.0  24  V    Supply Current  4.1  -  24  mA    Operating Temperature  -40  -  85  \u00baC",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Hall_Sensor/#application-ideas",
            "text": "RPM meter.  Simple dc motor.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Hall_Sensor/#getting-started",
            "text": "The Hall Sensor is used by utilizing the external interrupts available on the arduino/seeeduino. In this example we are using interrupt 0, found on digital pin 2. For other interrupts, see the  attachInterrupt() .   Connect the Hall Sensor to Digital port 2 of the  Grove - Base Shield  using a 4 pin cable and connect Grove-LED to Digital Port 4.  Then connect Arduino to PC by using a USB cable.  Download the  Hall Sensor Code  Open one of two code. For example Demo  MagnetControlLED     Upload the code, Please click  here  if you do not know how to upload.  When a magnet whose south pole is facing up is approaching to the onboard sensor, the LED will be turned on. Otherwise, the LED will be turned off.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-Hall_Sensor/#resources",
            "text": "Grove-Hall Sensor Eagle File  Hall Sensor Demo Code  A1101 datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Hall_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/",
            "text": "Grove - High Temperature Sensor\n\n\n\n\nIntroduction\n\n\nThermocouples are very sensitive devices. It requires a good amplifier with cold-junction compensation. The Grove - High Temperatire Sensor uses a K-Type themocouple and a thermocouple amplifier that measures ambient temperature using thermistor for cold-junction compensation. The detectable range of this Sensor is -50-600\u00b0C , and the accuracy is \u00b1(2.0% + 2\u00b0C)\n\n\n\n\nSpecifications\n\n\n\n\nVoltage\uff1a3.3 ~ 5V\n\n\nMax power rating at 25\u2103 \uff1a300mW\n\n\nOperating temperature range\uff1a-40 ~ +125 \u2103\n\n\nThe temperature measurement range is (-50 ~ +600\u2103)\n\n\nAmplifier output voltage range (0 ~ 3.3 V) mv\n\n\nCold junction compensation (environment temperature measurement)\n\n\nThermocouple temperature measurement accuracy of + / - 2.0% (+ 2 \u2103)\n\n\n\n\nGetting Started\n\n\nHere is an example to show you how to read temperature information from the sensor.\n\n\nWe need a Seeeduino V3.0 and a Grove - High Temperature Sensor.\n\n\nHardware Installation\n\n\nA4 and A5 are the I2C lines of Seeduino. Plug the sensor to the I2C port of Seeeduino to read data.\n\n\nDownload Code and Upload\n\n\nYou can download the library from \nhere\n\n\nThen extract the library to the Library folder of Arduino, open the demo in examples folder.\n\n\nThen upload it to your Seeeduino.\n\n\nOpen Serial Monitor and Get Data\n\n\nThen, open your Serial Monitor, you can find the temperature in Celsius here.\n\n\n\n\nK type thermocouple indexing table\n\n\nAs a reference, the following is K type thermocouple indexing table.\n\n\n\nResources\n\n\n\n\nGrove - High Temperature Sensor PDF\n\n\nGrove - High Temperature Sensor Eagle File\n\n\nHigh Temperature Sensor Library\n\n\nDatasheet OPA333 PDF\n\n\nDatasheet LMV358 PDF\n\n\n\n\nHelp us make it better",
            "title": "Grove High Temperature Sensor"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#grove-high-temperature-sensor",
            "text": "",
            "title": "Grove - High Temperature Sensor"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#introduction",
            "text": "Thermocouples are very sensitive devices. It requires a good amplifier with cold-junction compensation. The Grove - High Temperatire Sensor uses a K-Type themocouple and a thermocouple amplifier that measures ambient temperature using thermistor for cold-junction compensation. The detectable range of this Sensor is -50-600\u00b0C , and the accuracy is \u00b1(2.0% + 2\u00b0C)",
            "title": "Introduction"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#specifications",
            "text": "Voltage\uff1a3.3 ~ 5V  Max power rating at 25\u2103 \uff1a300mW  Operating temperature range\uff1a-40 ~ +125 \u2103  The temperature measurement range is (-50 ~ +600\u2103)  Amplifier output voltage range (0 ~ 3.3 V) mv  Cold junction compensation (environment temperature measurement)  Thermocouple temperature measurement accuracy of + / - 2.0% (+ 2 \u2103)",
            "title": "Specifications"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#getting-started",
            "text": "Here is an example to show you how to read temperature information from the sensor.  We need a Seeeduino V3.0 and a Grove - High Temperature Sensor.",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#hardware-installation",
            "text": "A4 and A5 are the I2C lines of Seeduino. Plug the sensor to the I2C port of Seeeduino to read data.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#download-code-and-upload",
            "text": "You can download the library from  here  Then extract the library to the Library folder of Arduino, open the demo in examples folder.  Then upload it to your Seeeduino.",
            "title": "Download Code and Upload"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#open-serial-monitor-and-get-data",
            "text": "Then, open your Serial Monitor, you can find the temperature in Celsius here.",
            "title": "Open Serial Monitor and Get Data"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#k-type-thermocouple-indexing-table",
            "text": "As a reference, the following is K type thermocouple indexing table.",
            "title": "K type thermocouple indexing table"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#resources",
            "text": "Grove - High Temperature Sensor PDF  Grove - High Temperature Sensor Eagle File  High Temperature Sensor Library  Datasheet OPA333 PDF  Datasheet LMV358 PDF",
            "title": "Resources"
        },
        {
            "location": "/Grove-High_Temperature_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/",
            "text": "Grove - I2C FM Receiver\n\n\n\n\nIntroduction\n\n\nGrove - I2C FM Receiver is a wideband FM receiver module, this module is based on RDA5807M. The RDA5807M series is the newest generation single-chip broadcast FM stereo radio tuner with fully integrated synthesizer. The RDA5807M series has a powerful low-IF digital audio processor. The Grove - I2C FM Receiver has a headset jack, so it can connect to earphones or audio.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescription\n\n\nRelease date\n\n\n\n\n\n\n\n\n\n\nGrove - I2C FM Receiver v1.0\n\n\nInitial public release\n\n\n\n\n\n\n\n\nGrove - I2C FM Receiver v1.1\n\n\nFixed bug - DFM for J3\n\n\nDec 2, 2011\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nGrove interface\n\n\nSupports worldwide frequency band: 50 - 115MHz\n\n\nSupport RDS/RBDS\n\n\nLower power consumption\n\n\nHeadset interface\n\n\nDigital auto gain control\n\n\nInput voltage: 3.3V - 5V\n\n\n\n\nUsage\n\n\nWe can change channel by Grove - Button and adjust volume by Grove - Rotary\n\n\nHardware Installation\n\n\nPart list\uff1a\n\n\n\n\nSeeeduino Lotus\n\n\nGrove - I2C FM Receiver\n\n\nGrove - Button\n\n\nGrove - Rotary\n\n\nEarphone\n\n\n\n\n\n\nSoftware Part\n\n\n\n\nDownload the code \nI2C FM Receiver\n.\n\n\nUnzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.\n\n\nOpen the code directly from the path: File -> Example -> I2C_FM_Receiver.\n\n\nUpload the code. Note that you should select the correct board type and COM port.\n\n\n\n\nYou can see Center Frequency:\n\n\n\n\nResources\n\n\n\n\nGrove - I2C FM Receiver v1.0 Eagle File\n\n\nv1.0 Schematic in pdf\n\n\nDatasheet of RDA5807M\n\n\nGrove - I2C FM Receiver v1.1 Eagle File\n\n\n\n\nHelp us make it better",
            "title": "Grove I2C FM Receiver"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#grove-i2c-fm-receiver",
            "text": "",
            "title": "Grove - I2C FM Receiver"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#introduction",
            "text": "Grove - I2C FM Receiver is a wideband FM receiver module, this module is based on RDA5807M. The RDA5807M series is the newest generation single-chip broadcast FM stereo radio tuner with fully integrated synthesizer. The RDA5807M series has a powerful low-IF digital audio processor. The Grove - I2C FM Receiver has a headset jack, so it can connect to earphones or audio.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#version-tracker",
            "text": "Revision  Description  Release date      Grove - I2C FM Receiver v1.0  Initial public release     Grove - I2C FM Receiver v1.1  Fixed bug - DFM for J3  Dec 2, 2011",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#features",
            "text": "Grove interface  Supports worldwide frequency band: 50 - 115MHz  Support RDS/RBDS  Lower power consumption  Headset interface  Digital auto gain control  Input voltage: 3.3V - 5V",
            "title": "Features"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#usage",
            "text": "We can change channel by Grove - Button and adjust volume by Grove - Rotary",
            "title": "Usage"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#hardware-installation",
            "text": "Part list\uff1a   Seeeduino Lotus  Grove - I2C FM Receiver  Grove - Button  Grove - Rotary  Earphone",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#software-part",
            "text": "Download the code  I2C FM Receiver .  Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.5\\libraries.  Open the code directly from the path: File -> Example -> I2C_FM_Receiver.  Upload the code. Note that you should select the correct board type and COM port.   You can see Center Frequency:",
            "title": "Software Part"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#resources",
            "text": "Grove - I2C FM Receiver v1.0 Eagle File  v1.0 Schematic in pdf  Datasheet of RDA5807M  Grove - I2C FM Receiver v1.1 Eagle File",
            "title": "Resources"
        },
        {
            "location": "/Grove-I2C_FM_Receiver/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-I2C_Hub/",
            "text": "Grove - I2C Hub\n\n\n\n\nIntroduction\n\n\nI2C Hub Grove is an extension Grove module for connecting multiply I2C devices to Grove Base Shield. It can use with \nUniversal 4 Pin to X2 4 Pin cable\n and connects up to 3 I2C devices which may cover most developing purpose.\n\n\n\n\nFeatures\n\n\n\n\nChainable\n\n\n\n\nApplication Ideas\n\n\n\n\nUsing more I2C devices than you otherwise have room for on your Grove platform.\n\n\n\n\nUsage\n\n\nIt does not conflict if you use the same I2C Socket simultaneously because every I2C device has its own address. Hardware installation is shown below.\n\n\n\n\nHere we do not list a specific example.\n\n\nResources\n\n\nI2C Hub Eagle File\n\n\nHelp us make it better",
            "title": "Grove I2C Hub"
        },
        {
            "location": "/Grove-I2C_Hub/#grove-i2c-hub",
            "text": "",
            "title": "Grove - I2C Hub"
        },
        {
            "location": "/Grove-I2C_Hub/#introduction",
            "text": "I2C Hub Grove is an extension Grove module for connecting multiply I2C devices to Grove Base Shield. It can use with  Universal 4 Pin to X2 4 Pin cable  and connects up to 3 I2C devices which may cover most developing purpose.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-I2C_Hub/#features",
            "text": "Chainable",
            "title": "Features"
        },
        {
            "location": "/Grove-I2C_Hub/#application-ideas",
            "text": "Using more I2C devices than you otherwise have room for on your Grove platform.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-I2C_Hub/#usage",
            "text": "It does not conflict if you use the same I2C Socket simultaneously because every I2C device has its own address. Hardware installation is shown below.   Here we do not list a specific example.",
            "title": "Usage"
        },
        {
            "location": "/Grove-I2C_Hub/#resources",
            "text": "I2C Hub Eagle File",
            "title": "Resources"
        },
        {
            "location": "/Grove-I2C_Hub/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-I2C_Motor_Driver/",
            "text": "Grove - I2C Motor Driver\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrove - I2C Motor Driver V1.0\n\n\n\n\n\n\nGrove - I2C Motor Driver V1.2\n\n\n\n\n\n\nGrove - I2C Motor Driver V1.3",
            "title": "Grove I2C Motor Driver"
        },
        {
            "location": "/Grove-I2C_Motor_Driver/#grove-i2c-motor-driver",
            "text": "Grove - I2C Motor Driver V1.0    Grove - I2C Motor Driver V1.2    Grove - I2C Motor Driver V1.3",
            "title": "Grove - I2C Motor Driver"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/",
            "text": "Grove - I2C Motor Driver V1.3\n\n\n\n\nIntroduction\n\n\nThe Grove - I2C Motor Driver V1.3 (latest version) can directly control Stepper Motor or DC Motor. Its heart is a dual channel H-bridge driver chip\uff08L298N\uff09that can handle current up to 2A per channel, controlled by an Atmel ATmega8L which handles the I2C communication with for example an Arduino. Both motors can be driven simultaneously while set to a different speed and direction. It can power two brushed DC motors or one 4-wire two-phase stepper motor. It requires a 6V to 15V power supply to power the motor and has an onboard 5V voltage regulator which can power the I2C bus and the Arduino(selectable by jumper). All driver lines are protected by diodes from back-EMF.\n\n\nContrast to the \nGrove - I2C motor driver V1.2\n, the V1.3 enables users to control the stepper more easily. You do not need to control the steppers all the time anymore, simply send a command to I2C motor driver V1.3 to drive a stepper, and it will act as your command, which would save your Arduino resource and simplify your code.\n\n\n\n\nVersion Tracker\n\n\n\n\n\n\n\n\nRevision\n\n\nDescriptions\n\n\nRelease\n\n\n\n\n\n\n\n\n\n\nv1.0\n\n\nInitial public release\n\n\nMay 17th, 2012\n\n\n\n\n\n\nv1.2\n\n\nModify the I2C address set by hardware\n\n\nJuly 2nd, 2012\n\n\n\n\n\n\nv1.3\n\n\nModify the firmware to support off-line Stepper\n\n\nFeb 18th, 2013\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nGrove Compatible\n\n\nI2C Interface\n\n\nAdjustable motor speed and rotation direction\n\n\nChangeable slave address by hardware\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\nItem\n\n\n\n\nMin\n\n\n\n\nTypical\n\n\n\n\nMax\n\n\n\n\nUnit\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n\n\n6\n\n\n\n\n-\n\n\n\n\n15\n\n\n\n\nVDC\n\n\n\n\n\n\n\n\nMax Output Current per channel\n\n\n\n\n0.5\n\n\n\n\nA\n\n\n\n\n\n\n\n\nMaximum Total current\n\n\n\n\n1.0\n\n\n\n\nA\n\n\n\n\n\n\n\n\nInput/output voltage on I2C bus\n\n\n\n\n5\n\n\n\n\nV\n\n\n\n\n\n\n\n\nCommunication protocol\n\n\n\n\nI2C\n\n\n\n\n/\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\n78M05 IC:\n 5V voltage regulator\n\n\nL298 IC:\n Dual full bridge driver\n\n\nATmega8 IC:\n Control Motor Rotate.\n\n\n\n\nNote\n\nInput voltage on screw terminals is regulated to 5V and connected to I2C +5V via a jumper (J4). Remove jumper if both external power via the screw terminals and power via the I2C header are used. Use jumper if 5V should be supplied to the I2C bus.\n\n\n\n\nApplication Ideas\n\n\n\n\nRobots\n\n\nHomebuilt RC cars\n\n\nCase fans\n\n\nHigh power LED illumination\n\n\n\n\n\n\nCaution\n\nThe board will be very hot while operating over 1Amp. Do keep your hands off!\n\n\n\n\nUsage\n\n\nThe I2C Motor Driver can control motor which is based on the chip L298. The L298 isn\u2019t just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. Hooking up to a motor means you can have it spin in both directions; and with PWM input, you can use your Arduino to make them spin at any speed. Because the L298 has 2 H-bridges, you can make a robot turn around by spinning each wheel in different directions, and of course go forwards and backwards.\n\n\nNow, let us use the I2C Motor Driver to control two DC motors or a stepper rotating clockwise and anticlockwise.\n\n\nSet the address of the I2C Motor Driver\n\n\n\n\nSet the address by dial switch is a new function added to the new I2C Motor Driver.\n\n\n\n\n\n\n\n\nThen keep the address setup in the program the same as the address setup on the I2C motor driver. The default address setup in the program is 0x0f.\n\n\n\n\n\n\n\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n\n\n\nHow to drive 2 DC motors\n\n\n\n\n\n\nNote\n\nThe first thing to notice however, is that you need an external power source for your DC motors. The 5V pin on the Arduino cannot provide enough power to drive 2 motors, you may damage your Arduino if you do so.\n\n\n\n\nAnd then program your Arduino as below:\n\n\n#include <Wire.h>\n     .......\n     .......\n    < Driver functions >\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n  while(1)  {\n    MotorSpeedSetAB(100,20);\n    delay(10); //this delay needed\n    MotorDirectionSet(0b1010);  //0b1010  Rotating in the positive direction \n    delay(1000); \n    MotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\n    delay(500);\n  }\n}\n\n\n\n\nIn this program, Arduino first set the speed of the 2 DC motors with the \nMotorSpeedSetAB()\ncommand, and then set the DC motors work directions with \nMotorDirectionSet()\n command. please refer to the \nFunction Reference\n for details, you can download all the demo code in the \nResources\n.\n\n\nHow to drive a stepper using I2C motor driver V1.3\n\n\nAs the upgraded version of \nI2C motor DriverV1.2\n, You can drive stepper via 2 methods for I2C motor driver V1.3.\n\n\n1. Control the stepper directly by Arduino\n\nThe I2C motor Driver can also be used to drive a 4-wire stepper. Connect your stepper to the output pins of I2C motor driver, and then connect motor driver to your Arduino/Seeeduino with I2C bus. Program your Arduino as below:\n\n\n#include <Wire.h>\n     .......\n     .......\n    < Driver functions >\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n while(1)  {\n    MotorSpeedSetAB(100,100);//when driving a stepper, the speed should be set to 100;\n    delay(10);\n    MotorDirectionSet(0b0001);\n    delay(4);\n      MotorDirectionSet(0b0011);\n    delay(4);  \n    MotorDirectionSet(0b0010);\n    delay(4);\n      MotorDirectionSet(0b0110);\n    delay(4);  \n    MotorDirectionSet(0b0100);\n    delay(4);  \n    MotorDirectionSet(0b1100);\n    delay(4);\n      MotorDirectionSet(0b1000);\n    delay(4);\n      MotorDirectionSet(0b1001);\n    delay(4);\n  }\n}\n\n\n\n\nThis connected 4-wire stepper will rotate; you can adjust the rotation speed or step number in your Arduino program. You can also use some other stepper libraries to control it. For all the demo code please refer to \nResources\n.\n\n\n\n\n2. Control the Stepper using the I2C motor Driver V1.3 on-chip ATmega8L.\n\n Take \n24BYJ48\n as an example, The hardware installation as shown below:\n\n\n\n\nThe connection between 24BYJ48 Stepper Motor and I2C Motor Driver is as shown below:\n\n\n\n\nDownload the \nGrove-I2C motor driver V1.3 demo code\n, and open the \nStepperControlMode2.ino\n:\n\n\n#include <Wire.h>\n#define MotorSpeedSet             0x82\n#define PWMFrequenceSet           0x84\n#define DirectionSet              0xaa\n#define MotorSetA                 0xa1\n#define MotorSetB                 0xa5\n#define Nothing                   0x01\n#define EnableStepper             0x1a\n#define UnenableStepper           0x1b\n#define Stepernu                  0x1c\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n// set the steps you want, if 255, the stepper will rotate continuously;\nvoid SteperStepset(unsigned char stepnu)\n{\n  Wire.beginTransmission(I2CMotorDriverAdd); // transmit to device I2CMotorDriverAdd\n  Wire.write(Stepernu);          // Send the stepernu command \n  Wire.write(stepnu);            // send the steps\n  Wire.write(Nothing);           // send nothing   \n  Wire.endTransmission();        // stop transmitting \n}\n     .......\n     .......\n     .......\n     .......\nvoid stepperrun()\n{\n Serial.println(\"sent command to + direction, very fast\");\n SteperStepset(255);\n StepperMotorEnable(1, 1);// ennable the i2c motor driver a stepper. \n  delay(5000);\n  Serial.println(\"sent command to - direction, slow\");\n  SteperStepset(255);\n  StepperMotorEnable(0, 20);\n  delay(5000);\n   Serial.println(\"sent command to - direction, fast\");\n  StepperMotorEnable(0, 2);// ennable the i2c motor driver a stepper. \n  delay(5000);\n Serial.println(\"sent command to + direction,100 steps, fast\");\n SteperStepset(100);\n  StepperMotorEnable(1,5);\n delay(3000);\n\u00a0\n Serial.println(\"sent command to shut down the stepper\");\n StepperMotorUnenable();\n delay(1000);\n\u00a0\n  Serial.println(\"sent command to - direction, slow, and 10 steps then stop\");\n SteperStepset(10);\n StepperMotorEnable(0,40);\n delay(5000);\n Serial.println(\"sent command to shut down the stepper\");\n StepperMotorUnenable();\n delay(5000);\n}\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000);\n  Serial.begin(9600);\n  Serial.println(\"setup begin\");\n  stepperrun();\n}\nvoid loop()  {\n\u00a0\n}\n\n\n\n\nIn this demo code, Arduino sends stepper-control command to I2C motor driver via I2C bus, with SteperStepset() to set the step number, and StepperMotorEnable() to set the direction and speed. Please refer to the \nFunction Reference\n for the details.\n\n\nNote that if you have I2C motor driver V1.2 and want to use the off-line Stepper control methods, you will need to upgrade your firmware in your V1.2 motor driver with a \nAVRISP\n and upload the .hex file to your I2C motor driver. Please download the .hex file and source code and related tips in the \nResources\n. \n\n\nFunction Reference\n\n\n1. void SteperStepset(unsigned char stepnu)\n\n\nDescription: Set the steps you want.\n\n\nstepnu: the Parameter can be 1~255. if 255, the stepper will rotate continuously;\n\n\nUsage:\n\n\nSerial.println(\"sent command to + direction,100 steps, fast\");\nSteperStepset(100);\n\n\n\n2. void StepperMotorEnable(unsigned char Direction, unsigned char motorspeed)\n\n\nDescription: Enable the IIC motor driver to drive a 4-wire stepper.\n\n\nDirection: Stepper direction 1/0\n\n\nmotorspeed: defines the time interval the i2C motor driver, Change it output to drive the stepper. The actual interval time is\u00a0: motorspeed * 4ms. That is , When motor speed is 10, the interval time would be 40 ms.\n\n\nUsage:\n\n\nStepperMotorEnable(1, 1);// enable the i2c motor driver a stepper.\n\n\n\n3. void StepperMotorUnenable()\n\n\nDescription: Uneanble IIC motor drive to drive the stepper.\n\n\nUsage:\n\n\nStepperMotorUnenable();\n\n\n\n4. void MotorSpeedSetAB(unsigned char MotorSpeedA , unsigned char MotorSpeedB)\n\n\nDescription: defines the speed of motor 1 and motor 2\n\n\nMotorSpeedA: the DC motor A speed, should be 0~100;\n\n\nMotorSpeedB: the DC motor B speed, should be 0~100;\n\n\nUsage:\n\n\nSerial.println(\"sent DC speed 100\");\nMotorSpeedSetAB(100,100);//defines the speed of motor 1 and motor 2;\ndelay(10); //this delay needed\n\n\n\n5. void MotorPWMFrequenceSet(unsigned char Frequence)\n\n\nDescription:set the prescale frequency of PWM, 0x03 default\n\n\nFrequency: the prescale frequency of PWM\n\n\n6. void MotorDirectionSet(unsigned char Direction)\n\n\nDescription: Adjust the direction of the motors\n\n\nDirection:can be Forward/Reverse rotating.\n\n\nUsage:\n\n\nMotorDirectionSet(0b1010);  //\"0b1010\" defines the output polarity, \"10\" means the M+ is \"positive\" while the M- is \"negative\"\n                         // make sure M+ and M- is different polarity when driving DC motors.\ndelay(1000); \nMotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\ndelay(500);\n\n\n\n7. void MotorDriectionAndSpeedSet(unsigned char Direction,unsigned char MotorSpeedA,unsigned char MotorSpeedB)\n\n\nDescription: Adjust the direction and speed altogether.\n\n\nResources\n\n\n\n\nGrove - I2C Motor Driver V1.3 Eagle File\n\n\nI2C Motor DriverV13 Demo Code\n\n\nL298 Datasheet\n\n\n78M05 Datasheet\n\n\nOn-Chip Firmware for I2C motor driver\n\n\n\n\nHelp us make it better",
            "title": "Grove I2C Motor Driver V1.3"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#grove-i2c-motor-driver-v13",
            "text": "",
            "title": "Grove - I2C Motor Driver V1.3"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#introduction",
            "text": "The Grove - I2C Motor Driver V1.3 (latest version) can directly control Stepper Motor or DC Motor. Its heart is a dual channel H-bridge driver chip\uff08L298N\uff09that can handle current up to 2A per channel, controlled by an Atmel ATmega8L which handles the I2C communication with for example an Arduino. Both motors can be driven simultaneously while set to a different speed and direction. It can power two brushed DC motors or one 4-wire two-phase stepper motor. It requires a 6V to 15V power supply to power the motor and has an onboard 5V voltage regulator which can power the I2C bus and the Arduino(selectable by jumper). All driver lines are protected by diodes from back-EMF.  Contrast to the  Grove - I2C motor driver V1.2 , the V1.3 enables users to control the stepper more easily. You do not need to control the steppers all the time anymore, simply send a command to I2C motor driver V1.3 to drive a stepper, and it will act as your command, which would save your Arduino resource and simplify your code.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#version-tracker",
            "text": "Revision  Descriptions  Release      v1.0  Initial public release  May 17th, 2012    v1.2  Modify the I2C address set by hardware  July 2nd, 2012    v1.3  Modify the firmware to support off-line Stepper  Feb 18th, 2013",
            "title": "Version Tracker"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#features",
            "text": "Grove Compatible  I2C Interface  Adjustable motor speed and rotation direction  Changeable slave address by hardware",
            "title": "Features"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#specifications",
            "text": "Item  \nMin  \nTypical  \nMax  \nUnit    \nWorking Voltage  \n6  \n-  \n15  \nVDC    \nMax Output Current per channel  \n0.5  \nA    \nMaximum Total current  \n1.0  \nA    \nInput/output voltage on I2C bus  \n5  \nV    \nCommunication protocol  \nI2C  \n/",
            "title": "Specifications"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#hardware-overview",
            "text": "78M05 IC:  5V voltage regulator  L298 IC:  Dual full bridge driver  ATmega8 IC:  Control Motor Rotate.   Note \nInput voltage on screw terminals is regulated to 5V and connected to I2C +5V via a jumper (J4). Remove jumper if both external power via the screw terminals and power via the I2C header are used. Use jumper if 5V should be supplied to the I2C bus.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#application-ideas",
            "text": "Robots  Homebuilt RC cars  Case fans  High power LED illumination    Caution \nThe board will be very hot while operating over 1Amp. Do keep your hands off!",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#usage",
            "text": "The I2C Motor Driver can control motor which is based on the chip L298. The L298 isn\u2019t just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. Hooking up to a motor means you can have it spin in both directions; and with PWM input, you can use your Arduino to make them spin at any speed. Because the L298 has 2 H-bridges, you can make a robot turn around by spinning each wheel in different directions, and of course go forwards and backwards.  Now, let us use the I2C Motor Driver to control two DC motors or a stepper rotating clockwise and anticlockwise.",
            "title": "Usage"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#set-the-address-of-the-i2c-motor-driver",
            "text": "Set the address by dial switch is a new function added to the new I2C Motor Driver.     Then keep the address setup in the program the same as the address setup on the I2C motor driver. The default address setup in the program is 0x0f.    #define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver",
            "title": "Set the address of the I2C Motor Driver"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#how-to-drive-2-dc-motors",
            "text": "Note \nThe first thing to notice however, is that you need an external power source for your DC motors. The 5V pin on the Arduino cannot provide enough power to drive 2 motors, you may damage your Arduino if you do so.  And then program your Arduino as below:  #include <Wire.h>\n     .......\n     .......\n    < Driver functions >\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n  while(1)  {\n    MotorSpeedSetAB(100,20);\n    delay(10); //this delay needed\n    MotorDirectionSet(0b1010);  //0b1010  Rotating in the positive direction \n    delay(1000); \n    MotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\n    delay(500);\n  }\n}  In this program, Arduino first set the speed of the 2 DC motors with the  MotorSpeedSetAB() command, and then set the DC motors work directions with  MotorDirectionSet()  command. please refer to the  Function Reference  for details, you can download all the demo code in the  Resources .",
            "title": "How to drive 2 DC motors"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#how-to-drive-a-stepper-using-i2c-motor-driver-v13",
            "text": "As the upgraded version of  I2C motor DriverV1.2 , You can drive stepper via 2 methods for I2C motor driver V1.3.  1. Control the stepper directly by Arduino \nThe I2C motor Driver can also be used to drive a 4-wire stepper. Connect your stepper to the output pins of I2C motor driver, and then connect motor driver to your Arduino/Seeeduino with I2C bus. Program your Arduino as below:  #include <Wire.h>\n     .......\n     .......\n    < Driver functions >\n     .......\n     .......\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000); //wait for motor driver to initialization\n}\n\u00a0\nvoid loop()  {\n while(1)  {\n    MotorSpeedSetAB(100,100);//when driving a stepper, the speed should be set to 100;\n    delay(10);\n    MotorDirectionSet(0b0001);\n    delay(4);\n      MotorDirectionSet(0b0011);\n    delay(4);  \n    MotorDirectionSet(0b0010);\n    delay(4);\n      MotorDirectionSet(0b0110);\n    delay(4);  \n    MotorDirectionSet(0b0100);\n    delay(4);  \n    MotorDirectionSet(0b1100);\n    delay(4);\n      MotorDirectionSet(0b1000);\n    delay(4);\n      MotorDirectionSet(0b1001);\n    delay(4);\n  }\n}  This connected 4-wire stepper will rotate; you can adjust the rotation speed or step number in your Arduino program. You can also use some other stepper libraries to control it. For all the demo code please refer to  Resources .   2. Control the Stepper using the I2C motor Driver V1.3 on-chip ATmega8L.  Take  24BYJ48  as an example, The hardware installation as shown below:   The connection between 24BYJ48 Stepper Motor and I2C Motor Driver is as shown below:   Download the  Grove-I2C motor driver V1.3 demo code , and open the  StepperControlMode2.ino :  #include <Wire.h>\n#define MotorSpeedSet             0x82\n#define PWMFrequenceSet           0x84\n#define DirectionSet              0xaa\n#define MotorSetA                 0xa1\n#define MotorSetB                 0xa5\n#define Nothing                   0x01\n#define EnableStepper             0x1a\n#define UnenableStepper           0x1b\n#define Stepernu                  0x1c\n#define I2CMotorDriverAdd         0x0f   // Set the address of the I2CMotorDriver\n// set the steps you want, if 255, the stepper will rotate continuously;\nvoid SteperStepset(unsigned char stepnu)\n{\n  Wire.beginTransmission(I2CMotorDriverAdd); // transmit to device I2CMotorDriverAdd\n  Wire.write(Stepernu);          // Send the stepernu command \n  Wire.write(stepnu);            // send the steps\n  Wire.write(Nothing);           // send nothing   \n  Wire.endTransmission();        // stop transmitting \n}\n     .......\n     .......\n     .......\n     .......\nvoid stepperrun()\n{\n Serial.println(\"sent command to + direction, very fast\");\n SteperStepset(255);\n StepperMotorEnable(1, 1);// ennable the i2c motor driver a stepper. \n  delay(5000);\n  Serial.println(\"sent command to - direction, slow\");\n  SteperStepset(255);\n  StepperMotorEnable(0, 20);\n  delay(5000);\n   Serial.println(\"sent command to - direction, fast\");\n  StepperMotorEnable(0, 2);// ennable the i2c motor driver a stepper. \n  delay(5000);\n Serial.println(\"sent command to + direction,100 steps, fast\");\n SteperStepset(100);\n  StepperMotorEnable(1,5);\n delay(3000);\n\u00a0\n Serial.println(\"sent command to shut down the stepper\");\n StepperMotorUnenable();\n delay(1000);\n\u00a0\n  Serial.println(\"sent command to - direction, slow, and 10 steps then stop\");\n SteperStepset(10);\n StepperMotorEnable(0,40);\n delay(5000);\n Serial.println(\"sent command to shut down the stepper\");\n StepperMotorUnenable();\n delay(5000);\n}\nvoid setup()  {\n  Wire.begin(); // join i2c bus (address optional for master)\n  delayMicroseconds(10000);\n  Serial.begin(9600);\n  Serial.println(\"setup begin\");\n  stepperrun();\n}\nvoid loop()  {\n\u00a0\n}  In this demo code, Arduino sends stepper-control command to I2C motor driver via I2C bus, with SteperStepset() to set the step number, and StepperMotorEnable() to set the direction and speed. Please refer to the  Function Reference  for the details.  Note that if you have I2C motor driver V1.2 and want to use the off-line Stepper control methods, you will need to upgrade your firmware in your V1.2 motor driver with a  AVRISP  and upload the .hex file to your I2C motor driver. Please download the .hex file and source code and related tips in the  Resources .",
            "title": "How to drive a stepper using I2C motor driver V1.3"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#function-reference",
            "text": "1. void SteperStepset(unsigned char stepnu)  Description: Set the steps you want.  stepnu: the Parameter can be 1~255. if 255, the stepper will rotate continuously;  Usage:  Serial.println(\"sent command to + direction,100 steps, fast\");\nSteperStepset(100);  2. void StepperMotorEnable(unsigned char Direction, unsigned char motorspeed)  Description: Enable the IIC motor driver to drive a 4-wire stepper.  Direction: Stepper direction 1/0  motorspeed: defines the time interval the i2C motor driver, Change it output to drive the stepper. The actual interval time is\u00a0: motorspeed * 4ms. That is , When motor speed is 10, the interval time would be 40 ms.  Usage:  StepperMotorEnable(1, 1);// enable the i2c motor driver a stepper.  3. void StepperMotorUnenable()  Description: Uneanble IIC motor drive to drive the stepper.  Usage:  StepperMotorUnenable();  4. void MotorSpeedSetAB(unsigned char MotorSpeedA , unsigned char MotorSpeedB)  Description: defines the speed of motor 1 and motor 2  MotorSpeedA: the DC motor A speed, should be 0~100;  MotorSpeedB: the DC motor B speed, should be 0~100;  Usage:  Serial.println(\"sent DC speed 100\");\nMotorSpeedSetAB(100,100);//defines the speed of motor 1 and motor 2;\ndelay(10); //this delay needed  5. void MotorPWMFrequenceSet(unsigned char Frequence)  Description:set the prescale frequency of PWM, 0x03 default  Frequency: the prescale frequency of PWM  6. void MotorDirectionSet(unsigned char Direction)  Description: Adjust the direction of the motors  Direction:can be Forward/Reverse rotating.  Usage:  MotorDirectionSet(0b1010);  //\"0b1010\" defines the output polarity, \"10\" means the M+ is \"positive\" while the M- is \"negative\"\n                         // make sure M+ and M- is different polarity when driving DC motors.\ndelay(1000); \nMotorDirectionSet(0b0101);  //0b0101  Rotating in the opposite direction\ndelay(500);  7. void MotorDriectionAndSpeedSet(unsigned char Direction,unsigned char MotorSpeedA,unsigned char MotorSpeedB)  Description: Adjust the direction and speed altogether.",
            "title": "Function Reference"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#resources",
            "text": "Grove - I2C Motor Driver V1.3 Eagle File  I2C Motor DriverV13 Demo Code  L298 Datasheet  78M05 Datasheet  On-Chip Firmware for I2C motor driver",
            "title": "Resources"
        },
        {
            "location": "/Grove-I2C_Motor_Driver_V1.3/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/",
            "text": "Grove - I2C Touch Sensor\n\n\n\n\nIntroduction\n\n\nThe I2C Touch Sensor is based on the Proximity Capacitive Touch Sensor Controller from FreeScale - MPR121. It detects the touch or proximity of human fingers. This sensor includes a Touch Sensor controller and 4 finger feelers. One can insert the connectors of feelers into base of Sensor controller, and start sensing the touch. \n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nParameter\n\n\nValue/Range\n\n\n\n\n\n\n\n\n\n\nOperating voltage\n\n\n3~5.5V\n\n\n\n\n\n\nStandby Mode Current\n\n\n2\u03bcA\n\n\n\n\n\n\nTouch Channels\n\n\n12 (Including 4 with Touch feelers)\n\n\n\n\n\n\nCommunicating Protocol\n\n\nI2C\n\n\n\n\n\n\nI2C Address\n\n\n0x5A - 0x5D\n\n\n\n\n\n\n\n\nHardware Overview\n\n\n\n\nThere are 12 electrodes CH0-CH11. CH0-CH3 are connected to 4 Touch feelers.\n\n\nThe CH4-CH11 are for customer expanding the function. If you need more, you can make the feelers by yourself.\n\n\nThe wires of feelers are twisted to reduce the impact of environment. The black(ground) wire can be cut off if high sensitivity is needed.\n\n\nThe INT pin has to be led out if customers want to use the interrupt pin of MPR121.\n\n\nGetting Started\n\n\nGrove - Help\n\n\nFollowing documents help in getting the user started with Grove.\n\n\n\n\nPreface - Getting Started\n\n\nIntroduction to Grove\n\n\n\n\n\n\nNote\n\nSince each electrode needs to be auto-configured by the MPR121 during power up and there is no power reset on the touch sensor controller, everytime you insert or remove a feeler, you need to reset the power of Seeeduino.\n\n\n\n\nThe feelers can also feel the human being fingers with something between, that's to say, you do not need to touch the feelers with your fingers indeed.\n\n\n\n\n\n\nWith a paperboard about 3 mm thick, the feeler can feel the touch of fingers, makes it a good solution for many applications.\n\n\nResources\n\n\n\n\nI2C Touch Sensor Library\n\n\nI2C Touch Sensor eagle files(v1.1).zip\n\n\nI2C Touch Sensor PDF\n\n\nHow to detect finger touch?\n\n\nI2C Touch Sensor Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove I2C Touch Sensor"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#grove-i2c-touch-sensor",
            "text": "",
            "title": "Grove - I2C Touch Sensor"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#introduction",
            "text": "The I2C Touch Sensor is based on the Proximity Capacitive Touch Sensor Controller from FreeScale - MPR121. It detects the touch or proximity of human fingers. This sensor includes a Touch Sensor controller and 4 finger feelers. One can insert the connectors of feelers into base of Sensor controller, and start sensing the touch.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#specifications",
            "text": "Parameter  Value/Range      Operating voltage  3~5.5V    Standby Mode Current  2\u03bcA    Touch Channels  12 (Including 4 with Touch feelers)    Communicating Protocol  I2C    I2C Address  0x5A - 0x5D",
            "title": "Specifications"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#hardware-overview",
            "text": "There are 12 electrodes CH0-CH11. CH0-CH3 are connected to 4 Touch feelers.  The CH4-CH11 are for customer expanding the function. If you need more, you can make the feelers by yourself.  The wires of feelers are twisted to reduce the impact of environment. The black(ground) wire can be cut off if high sensitivity is needed.  The INT pin has to be led out if customers want to use the interrupt pin of MPR121.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#grove-help",
            "text": "Following documents help in getting the user started with Grove.   Preface - Getting Started  Introduction to Grove    Note \nSince each electrode needs to be auto-configured by the MPR121 during power up and there is no power reset on the touch sensor controller, everytime you insert or remove a feeler, you need to reset the power of Seeeduino.  The feelers can also feel the human being fingers with something between, that's to say, you do not need to touch the feelers with your fingers indeed.    With a paperboard about 3 mm thick, the feeler can feel the touch of fingers, makes it a good solution for many applications.",
            "title": "Grove - Help"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#resources",
            "text": "I2C Touch Sensor Library  I2C Touch Sensor eagle files(v1.1).zip  I2C Touch Sensor PDF  How to detect finger touch?  I2C Touch Sensor Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-I2C_Touch_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-IMU_10DOF/",
            "text": "Grove - IMU 10DOF\n\n\n\n\nIntroduction\n\n\nGrove - IMU 10DOF is a combination of \nGrove - IMU 9DOF\n and \nGrove - Barometer Sensor (BMP180)\n. This module is base on MPU-9250 and BMP180, the MPU-9250 is a 9-axis MotionTracking device that combines a 3-axis gyroscope, 3-axis accelerometer, 3-axis magnetometer and a Digital Motion Processor(DMP), and BMP180 is a high precision, ultra-low power digital pressure sensors for consumer applications. This module is very suitable for the application of smartphones, tablets and wearable devices.\n\n\n\n\nSpecifications\n\n\n\n\nI2C interface\n\n\nMPU-9250 I2C address selectable\n\n\nLow Power Consumption\n\n\n400kHz Fast Mode I2C for communicating with all registers\n\n\nDigital-output X-, Y-, and Z-Axis angular rate sensors (gyroscopes) with a user-programmable full-scale range of \u00b1250, \u00b1500, \u00b11000, and \u00b12000\u00b0/sec\n\n\nDigital-output 3-Axis accelerometer with a programmable full scale range of \u00b12g, \u00b14g, \u00b18g and \u00b116g\n\n\nDigital-output magnetometer with a full scale range of \u00b14800uT\n\n\nDigital-output barometer with range of 300 ~ 1100hPa(+9000m ~ -500m relating to sea level)\n\n\nDimensions: 25.43mm x 20.35mm\n\n\n\n\nHardware Overview\n\n\n\n\n\n\n1\uff1aMPU-9250 I2C address select Pad, default connected \na\n and \nb\n address is 0x68, if connect \nb\n and \nc\n address is 0x69\n\n\n2\uff1aMPU-9250 interrupt pin, the interrupt should be configured, available interrupt sources are: motion detection, fifo overflow, data ready, i2c master error\n\n\n\n\nUsage\n\n\nWe will provide an example here to show you how to use this sensor.\n\n\nHardware Installation\n\n\n\n\nSoftware Setup\n\n\n\n\nDownload the library from \nhttps://github.com/Seeed-Studio/IMU_10DOF\n.\n\n\nUnzip it into the libraries file of Arduino IDE by the path.\n\n\nOpen the code directly by the path: File -> Example -> IMU_10DOF_Test.\n\n\nUpload the code. Note that you should select the correct board type and COM port.\n\n\n\n\nYou can see:\n\n\n\nOrientation of Axes\n\nThe diagram below shows the orientation of the axes of sensitivity and the polarity of rotation.\n\n\n\nResources\n\n\n\n\nGrove - IMU 10DOF v1.0 eagle file\n\n\nGrove - IMU 10DOF v1.0 schematics pdf file\n\n\nGrove - IMU 10DOF v1.1 eagle file\n\n\nGet library from github\n\n\nBMP180 datasheet\n\n\nMPU-9250 datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove IMU 10DOF"
        },
        {
            "location": "/Grove-IMU_10DOF/#grove-imu-10dof",
            "text": "",
            "title": "Grove - IMU 10DOF"
        },
        {
            "location": "/Grove-IMU_10DOF/#introduction",
            "text": "Grove - IMU 10DOF is a combination of  Grove - IMU 9DOF  and  Grove - Barometer Sensor (BMP180) . This module is base on MPU-9250 and BMP180, the MPU-9250 is a 9-axis MotionTracking device that combines a 3-axis gyroscope, 3-axis accelerometer, 3-axis magnetometer and a Digital Motion Processor(DMP), and BMP180 is a high precision, ultra-low power digital pressure sensors for consumer applications. This module is very suitable for the application of smartphones, tablets and wearable devices.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-IMU_10DOF/#specifications",
            "text": "I2C interface  MPU-9250 I2C address selectable  Low Power Consumption  400kHz Fast Mode I2C for communicating with all registers  Digital-output X-, Y-, and Z-Axis angular rate sensors (gyroscopes) with a user-programmable full-scale range of \u00b1250, \u00b1500, \u00b11000, and \u00b12000\u00b0/sec  Digital-output 3-Axis accelerometer with a programmable full scale range of \u00b12g, \u00b14g, \u00b18g and \u00b116g  Digital-output magnetometer with a full scale range of \u00b14800uT  Digital-output barometer with range of 300 ~ 1100hPa(+9000m ~ -500m relating to sea level)  Dimensions: 25.43mm x 20.35mm",
            "title": "Specifications"
        },
        {
            "location": "/Grove-IMU_10DOF/#hardware-overview",
            "text": "1\uff1aMPU-9250 I2C address select Pad, default connected  a  and  b  address is 0x68, if connect  b  and  c  address is 0x69  2\uff1aMPU-9250 interrupt pin, the interrupt should be configured, available interrupt sources are: motion detection, fifo overflow, data ready, i2c master error",
            "title": "Hardware Overview"
        },
        {
            "location": "/Grove-IMU_10DOF/#usage",
            "text": "We will provide an example here to show you how to use this sensor.",
            "title": "Usage"
        },
        {
            "location": "/Grove-IMU_10DOF/#hardware-installation",
            "text": "",
            "title": "Hardware Installation"
        },
        {
            "location": "/Grove-IMU_10DOF/#software-setup",
            "text": "Download the library from  https://github.com/Seeed-Studio/IMU_10DOF .  Unzip it into the libraries file of Arduino IDE by the path.  Open the code directly by the path: File -> Example -> IMU_10DOF_Test.  Upload the code. Note that you should select the correct board type and COM port.   You can see:  Orientation of Axes \nThe diagram below shows the orientation of the axes of sensitivity and the polarity of rotation.",
            "title": "Software Setup"
        },
        {
            "location": "/Grove-IMU_10DOF/#resources",
            "text": "Grove - IMU 10DOF v1.0 eagle file  Grove - IMU 10DOF v1.0 schematics pdf file  Grove - IMU 10DOF v1.1 eagle file  Get library from github  BMP180 datasheet  MPU-9250 datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-IMU_10DOF/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-NFC_Tag/",
            "text": "Grove - NFC Tag\n\n\n\n\nIntroduction\n\n\nGrove - NFC Tag is a highly integrated Near Field Communication Tag module,this module is I2C interface,which base on M24LR64E-R,M24LR64E-R have a 64-bit unique identifier and 64 -Kbit EEPROM.Grove - NFC Tag attach an independent PCB antenna which can easily stretch out of any enclosure you use, leaving more room for you to design the exterior of your project.\n\n\n\n\nSpecifications\n\n\n\n\nWorking Voltage:5V or 3V3\n\n\nWorking Current<1mA\n\n\nEffective range<2cm\n\n\nServe for contactless communication at 13.56MHz\n\n\nISO 15693 and ISO 18000-3 mode 1 compatible\n\n\n64-bit unique identifier (UID)\n\n\nRead Block & Write (32-bit blocks)\n\n\nGrove I2C Interface\n\n\n\n\nUsage\n\n\nRead/Write from Mobile\n\n\n\n\nDownload \nNfcV-reader for Android\n and install it\n\n\nWe can Read/Write it from Mobile\n\n\n\n\n\n\n\n\n\n\n\n\nControl LED\n\n\n\n\nHardware Installation\n\n\n\n\n\n\n\n\nDownload \nNfcV-reader for Android\n and install it\n\n\nDownload \nNFC Tag Lib\n, rename it to NFC_Tag_M24LR6E and put it into Arduino's library .\n\n\nOpen Arduino IDE. If Arduino IDE is already opened, restart it.\n\n\nIn Arduino IDE, click menus: File -> Example -> NFC_Tag_M24LR6E -> ledControl\n\n\nNow, you can control LED from your phone.\n\n\n\n\n\u00a0\n#include \"NfcTag.h\"\n#include <Wire.h>\n\u00a0\nNfcTag nfcTag;\nint led = 5;\nbool flag = false;\nbool preFlag = false;\nvoid setup(){\n  Serial.begin(9600);\n  pinMode(led,OUTPUT);\n  nfcTag.init();\n}\n\u00a0\nvoid loop(){\n  flag = nfcTag.readByte(EEPROM_I2C_LENGTH-1) == 0xff?true:false;\n  if(flag != preFlag){\n    Serial.println(\"get remote NFC control signal!\");\n    if(flag == true){\n      Serial.println(\"led will light up!\");\n      digitalWrite(led,HIGH);\n    }else{\n      Serial.println(\"led will turn dark!\");\n      digitalWrite(led,LOW);\n    }\n    preFlag = flag;\n  }\n  delay(5*1000);\n}\n\n\n\n\nResources\n\n\n\n\nGrove - NFC Tag.PDF\n\n\nGrove - NFC Tag Eagle file\n\n\nM24LR64E-R datasheet.pdf\n\n\nNfcV-reader for Android\n\n\nNFC Tag M24LR6E Lib\n\n\n\n\nHelp us make it better",
            "title": "Grove NFC Tag"
        },
        {
            "location": "/Grove-NFC_Tag/#grove-nfc-tag",
            "text": "",
            "title": "Grove - NFC Tag"
        },
        {
            "location": "/Grove-NFC_Tag/#introduction",
            "text": "Grove - NFC Tag is a highly integrated Near Field Communication Tag module,this module is I2C interface,which base on M24LR64E-R,M24LR64E-R have a 64-bit unique identifier and 64 -Kbit EEPROM.Grove - NFC Tag attach an independent PCB antenna which can easily stretch out of any enclosure you use, leaving more room for you to design the exterior of your project.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-NFC_Tag/#specifications",
            "text": "Working Voltage:5V or 3V3  Working Current<1mA  Effective range<2cm  Serve for contactless communication at 13.56MHz  ISO 15693 and ISO 18000-3 mode 1 compatible  64-bit unique identifier (UID)  Read Block & Write (32-bit blocks)  Grove I2C Interface",
            "title": "Specifications"
        },
        {
            "location": "/Grove-NFC_Tag/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/Grove-NFC_Tag/#readwrite-from-mobile",
            "text": "Download  NfcV-reader for Android  and install it  We can Read/Write it from Mobile",
            "title": "Read/Write from Mobile"
        },
        {
            "location": "/Grove-NFC_Tag/#control-led",
            "text": "Hardware Installation     Download  NfcV-reader for Android  and install it  Download  NFC Tag Lib , rename it to NFC_Tag_M24LR6E and put it into Arduino's library .  Open Arduino IDE. If Arduino IDE is already opened, restart it.  In Arduino IDE, click menus: File -> Example -> NFC_Tag_M24LR6E -> ledControl  Now, you can control LED from your phone.   \u00a0\n#include \"NfcTag.h\"\n#include <Wire.h>\n\u00a0\nNfcTag nfcTag;\nint led = 5;\nbool flag = false;\nbool preFlag = false;\nvoid setup(){\n  Serial.begin(9600);\n  pinMode(led,OUTPUT);\n  nfcTag.init();\n}\n\u00a0\nvoid loop(){\n  flag = nfcTag.readByte(EEPROM_I2C_LENGTH-1) == 0xff?true:false;\n  if(flag != preFlag){\n    Serial.println(\"get remote NFC control signal!\");\n    if(flag == true){\n      Serial.println(\"led will light up!\");\n      digitalWrite(led,HIGH);\n    }else{\n      Serial.println(\"led will turn dark!\");\n      digitalWrite(led,LOW);\n    }\n    preFlag = flag;\n  }\n  delay(5*1000);\n}",
            "title": "Control LED"
        },
        {
            "location": "/Grove-NFC_Tag/#resources",
            "text": "Grove - NFC Tag.PDF  Grove - NFC Tag Eagle file  M24LR64E-R datasheet.pdf  NfcV-reader for Android  NFC Tag M24LR6E Lib",
            "title": "Resources"
        },
        {
            "location": "/Grove-NFC_Tag/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Speaker/",
            "text": "Grove - Speaker\n\n\n\n\nIntroduction\n\n\nThe Grove- Speaker is a module which consists of power amplification and voice outputs. The loudness can be adjusted by the on-board potentiometer. With different input frequencies, the loud-speaker generates different tones. Coding the music into arduino, DIY your own music box!\n\n\n\n\nFeatures\n\n\n\n\nVolume Adjustable\n\n\nGrove Interface\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nItem\n\n\nMin\n\n\nTypical\n\n\nMax\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nWorking Voltage\n\n\n4.0\n\n\n5.0\n\n\n5.5\n\n\nVDC\n\n\n\n\n\n\nVoltage Gain\n\n\n-\n\n\n-\n\n\n46\n\n\ndb\n\n\n\n\n\n\nBand Width\n\n\n-\n\n\n-\n\n\n20\n\n\nKHz\n\n\n\n\n\n\n\n\nUsage\n\n\nThe speaker can emit a variety of sounds like a car horn, doorbell and ignition . The different sounds are based on the frequency of the input signal.\n\n\nYou can supply different frequency signal to this module with Arduino. Arduino generates these signal via PWM or even digital write and delay.Here we are going to show you how to generate these signals using \ndelay()\n, the speaker sound bass 1~7.\n\n\n\n\n/*macro definition of Speaker pin*/\n#define SPEAKER 3\n\nint BassTab[]={1911,1702,1516,1431,1275,1136,1012};//bass 1~7\n\nvoid setup() \n{\n    pinInit();\n}\nvoid loop()\n{\n    /*sound bass 1~7*/\n    for(int note_index=0;note_index<7;note_index++)\n    {\n        sound(note_index);\n        delay(500);\n    }\n}\nvoid pinInit()\n{\n    pinMode(SPEAKER,OUTPUT);\n    digitalWrite(SPEAKER,LOW);\n}\nvoid sound(uint8_t note_index)\n{\n    for(int i=0;i<100;i++)   \n    {\n        digitalWrite(SPEAKER,HIGH);\n        delayMicroseconds(BassTab[note_index]);\n        digitalWrite(SPEAKER,LOW);\n        delayMicroseconds(BassTab[note_index]);\n    }\n}\n\n\n\n\n\nNote\n\nDue to the influence of the capacitance, the module can only output the bass signal, and the treble is unable to emit.\n\n\n\n\nResources\n\n\n\n\nGrove - Speaker Eagle File\n\n\nHow to generate different tone with MCU\n\n\nGrove_-_Speaker_v1.0_brd.pdf\n\n\nGrove_-_Speaker_v1.0_sch.pdf\n\n\nLM386 Low Voltage Audio Power Amplifier Datasheet\n\n\n\n\nHelp us make it better",
            "title": "Grove Speaker"
        },
        {
            "location": "/Grove-Speaker/#grove-speaker",
            "text": "",
            "title": "Grove - Speaker"
        },
        {
            "location": "/Grove-Speaker/#introduction",
            "text": "The Grove- Speaker is a module which consists of power amplification and voice outputs. The loudness can be adjusted by the on-board potentiometer. With different input frequencies, the loud-speaker generates different tones. Coding the music into arduino, DIY your own music box!",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Speaker/#features",
            "text": "Volume Adjustable  Grove Interface",
            "title": "Features"
        },
        {
            "location": "/Grove-Speaker/#specifications",
            "text": "Item  Min  Typical  Max  Unit      Working Voltage  4.0  5.0  5.5  VDC    Voltage Gain  -  -  46  db    Band Width  -  -  20  KHz",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Speaker/#usage",
            "text": "The speaker can emit a variety of sounds like a car horn, doorbell and ignition . The different sounds are based on the frequency of the input signal.  You can supply different frequency signal to this module with Arduino. Arduino generates these signal via PWM or even digital write and delay.Here we are going to show you how to generate these signals using  delay() , the speaker sound bass 1~7.   /*macro definition of Speaker pin*/\n#define SPEAKER 3\n\nint BassTab[]={1911,1702,1516,1431,1275,1136,1012};//bass 1~7\n\nvoid setup() \n{\n    pinInit();\n}\nvoid loop()\n{\n    /*sound bass 1~7*/\n    for(int note_index=0;note_index<7;note_index++)\n    {\n        sound(note_index);\n        delay(500);\n    }\n}\nvoid pinInit()\n{\n    pinMode(SPEAKER,OUTPUT);\n    digitalWrite(SPEAKER,LOW);\n}\nvoid sound(uint8_t note_index)\n{\n    for(int i=0;i<100;i++)   \n    {\n        digitalWrite(SPEAKER,HIGH);\n        delayMicroseconds(BassTab[note_index]);\n        digitalWrite(SPEAKER,LOW);\n        delayMicroseconds(BassTab[note_index]);\n    }\n}   Note \nDue to the influence of the capacitance, the module can only output the bass signal, and the treble is unable to emit.",
            "title": "Usage"
        },
        {
            "location": "/Grove-Speaker/#resources",
            "text": "Grove - Speaker Eagle File  How to generate different tone with MCU  Grove_-_Speaker_v1.0_brd.pdf  Grove_-_Speaker_v1.0_sch.pdf  LM386 Low Voltage Audio Power Amplifier Datasheet",
            "title": "Resources"
        },
        {
            "location": "/Grove-Speaker/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Switch-P/",
            "text": "Grove - Switch(P)\n\n\n\n\n\n\nIntroduction\n\n\nThis Grove \u2013 Switch is a mini SPDT slide, great for \u201cON/OFF\u201d situations. It is such a reliable switch of great build quality that we adopt it on many of our boards. You should stock some for your Grove prototyping system.\n\n\nWhat does \u201cP\u201d mean? \u201cP\u201d is for \u201cpanel mount\u201d in this product.\n\n\n\n\nFeatures\n\n\n\n\nGrove Interface\n\n\nEasy to use\n\n\nBasic Grove element\n\n\n\n\nUsage\n\n\nBelow is a simple example showing how to use a switch to turn on/off an LED.The working principle and use just the same as the \nGrove-Button\n.\n\n\n\n\nConnect the Grove-LED to the Digital 13 of Grove - Basic Shield and connect the Grove -Switch(P) to the Digital 2 of \nGrove-Base Shield\n with two Grove cables.\n\n\nPlug the Grove - Base Shield into Arduino and connect Arduino to PC by using a USB cable.\n\n\nCopy and paste code below to a new Arduino sketch. Please click \nhere\n if you do not know how to upload.\n\n\n\n\n\n    // constants won't change. They're used here to \n    // set pin numbers:\n    const int switchPin = 2;     // the number of the pushbutton pin\n    const int ledPin =  13;      // the number of the LED pin\n\n    // variables will change:\n    int switchState = 0;         // variable for reading the pushbutton status\n\n    void setup() {\n      // initialize the LED pin as an output:\n      //pinMode(ledPin, OUTPUT);      \n      // initialize the switch pin as an input:\n      Serial.begin(9600);\n      pinMode(switchPin, INPUT);     \n    }\n    void loop(){\n      // read the state of the switch value:\n      switchState = digitalRead(switchPin);\n\n\n      if (switchState == HIGH) {     \n        // turn LED on:    \n       // digitalWrite(ledPin, HIGH);  \n       Serial.println(\"switch high!\");\n      } \n      else {\n        // turn LED off:\n       // digitalWrite(ledPin, LOW); \n       Serial.println(\"switch low\");\n      }\n    }\n\n\n\n\n\nAfter uploading the code, you can see the led will light up when the switch is at \nhigh\n side.\n\n\nResources\n\n\n\n\nGrove - Switch(P) Eagle File\n\n\n\n\nHelp us make it better",
            "title": "Grove Switch P"
        },
        {
            "location": "/Grove-Switch-P/#grove-switchp",
            "text": "",
            "title": "Grove - Switch(P)"
        },
        {
            "location": "/Grove-Switch-P/#introduction",
            "text": "This Grove \u2013 Switch is a mini SPDT slide, great for \u201cON/OFF\u201d situations. It is such a reliable switch of great build quality that we adopt it on many of our boards. You should stock some for your Grove prototyping system.  What does \u201cP\u201d mean? \u201cP\u201d is for \u201cpanel mount\u201d in this product.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Switch-P/#features",
            "text": "Grove Interface  Easy to use  Basic Grove element",
            "title": "Features"
        },
        {
            "location": "/Grove-Switch-P/#usage",
            "text": "Below is a simple example showing how to use a switch to turn on/off an LED.The working principle and use just the same as the  Grove-Button .   Connect the Grove-LED to the Digital 13 of Grove - Basic Shield and connect the Grove -Switch(P) to the Digital 2 of  Grove-Base Shield  with two Grove cables.  Plug the Grove - Base Shield into Arduino and connect Arduino to PC by using a USB cable.  Copy and paste code below to a new Arduino sketch. Please click  here  if you do not know how to upload.   \n    // constants won't change. They're used here to \n    // set pin numbers:\n    const int switchPin = 2;     // the number of the pushbutton pin\n    const int ledPin =  13;      // the number of the LED pin\n\n    // variables will change:\n    int switchState = 0;         // variable for reading the pushbutton status\n\n    void setup() {\n      // initialize the LED pin as an output:\n      //pinMode(ledPin, OUTPUT);      \n      // initialize the switch pin as an input:\n      Serial.begin(9600);\n      pinMode(switchPin, INPUT);     \n    }\n    void loop(){\n      // read the state of the switch value:\n      switchState = digitalRead(switchPin);\n\n\n      if (switchState == HIGH) {     \n        // turn LED on:    \n       // digitalWrite(ledPin, HIGH);  \n       Serial.println(\"switch high!\");\n      } \n      else {\n        // turn LED off:\n       // digitalWrite(ledPin, LOW); \n       Serial.println(\"switch low\");\n      }\n    }  After uploading the code, you can see the led will light up when the switch is at  high  side.",
            "title": "Usage"
        },
        {
            "location": "/Grove-Switch-P/#resources",
            "text": "Grove - Switch(P) Eagle File",
            "title": "Resources"
        },
        {
            "location": "/Grove-Switch-P/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Touch_Sensor/",
            "text": "Grove - Touch Sensor\n\n\n\n\nIntroduction\n\n\nGrove - Touch Sensor enables you to replace press with touch. It can detect the change in capacitance when a finger is near by. That means no matter your finger directly touches the pad or just stays close to the pad, Grove - Touch Sensor would outputs HIGH also.\n\n\n\n\nSpecifications\n\n\n\n\nOperating Voltage: 2.0 - 5.5V\n\n\nOperating Current(Vcc=3V):1.5 - 3.0\u03bcA\n\n\nOperating Current(VDD=3V):3.5 - 7.0\u03bcA\n\n\nOutput Response Time: 60 - 220mS\n\n\nUsed Chipset: TTP223-BA6\n\n\n\n\nOption features\n\n\n\n\n\n\n\n\nAHLB\n\n\nTOG\n\n\nLPMB\n\n\nMOTB\n\n\nSLRFTB\n\n\nRST\n\n\nQ\n\n\nOPDO\n\n\n\n\n\n\n\n\n\n\nOutput Active High / Low\n\n\nToggle mode\n\n\nPower Mode\n\n\nMax. On Time\n\n\nSampling length\n\n\nRESET PIN\n\n\nCMOS Output\n\n\nOpen Drain Mode\n\n\n\n\n\n\nV\n\n\nV\n\n\n0\n\n\n1\n\n\n1\n\n\nX\n\n\nV\n\n\nX\n\n\n\n\n\n\nActive High\n\n\nDisabled\n\n\nLOW\n\n\nInfinite\n\n\n1.6 msec\n\n\nN/A\n\n\nPresent\n\n\nN/A\n\n\n\n\n\n\n\n\nDemonstration\n\n\nWith \nArduino\n\n\n\nThis demo is going to show you how to turn on/off an LED.\n\n\nDemo Code:\n\n\nconst int TouchPin=9;\nconst int ledPin=12;\nvoid setup() {\npinMode(TouchPin, INPUT);\npinMode(ledPin,OUTPUT);\n} \n\u00a0\nvoid loop() {\nint sensorValue = digitalRead(TouchPin);\nif(sensorValue==1)\n{\ndigitalWrite(ledPin,HIGH);\n}\nelse\n{\ndigitalWrite(ledPin,LOW);\n}\n}\n\n\n\n\nWith \nRaspberry Pi\n\n\n\n\nYou should have a raspberry pi and a grovepi or grovepi+.\n\n\nYou should have completed configuring the development environment, otherwise follow \nhere\n.\n\n\n\n\nConnection\n\n\n\n\nPlug the sensor to grovepi socket D4 by using a grove cable.\n\n\n\n\n\n\n\n\nNavigate to the demos' directory:\n\n\n\n\n\n\n    cd yourpath/GrovePi/Software/Python/\n\n\n\n\n\n\nTo see the code\n\n\n\n\n    nano grove_touch_sensor.py   # \"Ctrl+x\" to exit #\n\n\n\n\n    import time\n    import grovepi\n\n    # Connect the Grove Touch Sensor to digital port D4\n    # SIG,NC,VCC,GND\n    touch_sensor = 4\n\n    grovepi.pinMode(touch_sensor,\"INPUT\")\n\n    while True:\n        try:\n            print grovepi.digitalRead(touch_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print \"Error\"\n\n\n\n\n\n5.Run the demo.\n\n\n    sudo python grove_touch_sensor.py\n\n\n\nResources\n\n\n\n\nEagle Files\n\n\nTTP223pdf\n\n\nhow to upload code\n\n\n\n\nHelp us make it better",
            "title": "Grove Touch Sensor"
        },
        {
            "location": "/Grove-Touch_Sensor/#grove-touch-sensor",
            "text": "",
            "title": "Grove - Touch Sensor"
        },
        {
            "location": "/Grove-Touch_Sensor/#introduction",
            "text": "Grove - Touch Sensor enables you to replace press with touch. It can detect the change in capacitance when a finger is near by. That means no matter your finger directly touches the pad or just stays close to the pad, Grove - Touch Sensor would outputs HIGH also.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Touch_Sensor/#specifications",
            "text": "Operating Voltage: 2.0 - 5.5V  Operating Current(Vcc=3V):1.5 - 3.0\u03bcA  Operating Current(VDD=3V):3.5 - 7.0\u03bcA  Output Response Time: 60 - 220mS  Used Chipset: TTP223-BA6   Option features     AHLB  TOG  LPMB  MOTB  SLRFTB  RST  Q  OPDO      Output Active High / Low  Toggle mode  Power Mode  Max. On Time  Sampling length  RESET PIN  CMOS Output  Open Drain Mode    V  V  0  1  1  X  V  X    Active High  Disabled  LOW  Infinite  1.6 msec  N/A  Present  N/A",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Touch_Sensor/#demonstration",
            "text": "",
            "title": "Demonstration"
        },
        {
            "location": "/Grove-Touch_Sensor/#with-arduino",
            "text": "This demo is going to show you how to turn on/off an LED.  Demo Code:  const int TouchPin=9;\nconst int ledPin=12;\nvoid setup() {\npinMode(TouchPin, INPUT);\npinMode(ledPin,OUTPUT);\n} \n\u00a0\nvoid loop() {\nint sensorValue = digitalRead(TouchPin);\nif(sensorValue==1)\n{\ndigitalWrite(ledPin,HIGH);\n}\nelse\n{\ndigitalWrite(ledPin,LOW);\n}\n}",
            "title": "With Arduino"
        },
        {
            "location": "/Grove-Touch_Sensor/#with-raspberry-pi",
            "text": "You should have a raspberry pi and a grovepi or grovepi+.  You should have completed configuring the development environment, otherwise follow  here .   Connection   Plug the sensor to grovepi socket D4 by using a grove cable.     Navigate to the demos' directory:        cd yourpath/GrovePi/Software/Python/   To see the code       nano grove_touch_sensor.py   # \"Ctrl+x\" to exit #      import time\n    import grovepi\n\n    # Connect the Grove Touch Sensor to digital port D4\n    # SIG,NC,VCC,GND\n    touch_sensor = 4\n\n    grovepi.pinMode(touch_sensor,\"INPUT\")\n\n    while True:\n        try:\n            print grovepi.digitalRead(touch_sensor)\n            time.sleep(.5)\n\n        except IOError:\n            print \"Error\"  5.Run the demo.      sudo python grove_touch_sensor.py",
            "title": "With Raspberry Pi"
        },
        {
            "location": "/Grove-Touch_Sensor/#resources",
            "text": "Eagle Files  TTP223pdf  how to upload code",
            "title": "Resources"
        },
        {
            "location": "/Grove-Touch_Sensor/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Grove-Variable_Color_LED/",
            "text": "Grove - Variable Color LED\n\n\n \n\n\nIntroduction\n\n\nThis Grove consists of one 8mm RGB LED. It operates at 5V DC. When SIG pin is logic HIGH, the RGB LED will light up. Perfect for use on Seeeduino digital outputs, or also can be controlled by pulse-width modulation. And it uses three adjustable resistor to change the color of the RGB LED.\n\n\n\n\nFeatures\n\n\n\n\nGrove compatible\n\n\nColor adjustable\n\n\n\n\nApplication Ideas\n\n\n\n\nToys\n\n\nDecoration\n\n\n\n\n\n\nCaution\n\nBe gentle while adjusting the R, G and B adjustable resistances in case of over-turning.\n\n\n\n\nSpecifications\n\n\n\n\n\n\n\n\nItem\n\n\nTypical\n\n\nUnit\n\n\n\n\n\n\n\n\n\n\nOperate Voltage\n\n\n5.0\n\n\nVDC\n\n\n\n\n\n\nWorking Current\n\n\n20\n\n\nmA\n\n\n\n\n\n\nVariable Resistor\n\n\n<1\n\n\nK\u03a9\n\n\n\n\n\n\n\n\nUsage\n\n\nThe three resistances RED, GREEN and BLUE of the module control the R, G and B channels respectively. By adjusting the three adjustable resistances, it can turn out variable color. The thing to notice, however, is that be gentle when turning the adjustable resistances.\n\n\nThe following sketch demonstrates a simple application of controlling its brightness. As the picture on the below indicates, the Variable Color LED is connected to digital port 9 of the \nGrove - Base Shield\n. The hardware installation is as follows:\n\n\n\n\n\n\nCopy and paste code below to a new Arduino sketch.\n\n\n\n\nDemo code like:\n\n\nint ledPin = 9;    // LED connected to digital pin 9\n\nvoid setup()  { \n  // nothing happens in setup \n}\n\nvoid loop()  { \n  // fade in from min to max in increments of 5 points:\n  for(int fadeValue = 0\u00a0; fadeValue <= 255; fadeValue +=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  }\n\n  // fade out from max to min in increments of 5 points:\n  for(int fadeValue = 255\u00a0; fadeValue >= 0; fadeValue -=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  } \n}\n\n\n\n\n\nUpload the code, Please click \nhere\n if you do not know how to upload.\n    Adjust the three adjustable resistances, I am sure you will like it. Have a try!\n\n\n\n\nResources\n\n\n\n\nVariable Color LED eagle_file\n\n\n\n\nHelp us make it better",
            "title": "Grove Variable Color LED"
        },
        {
            "location": "/Grove-Variable_Color_LED/#grove-variable-color-led",
            "text": "",
            "title": "Grove - Variable Color LED"
        },
        {
            "location": "/Grove-Variable_Color_LED/#introduction",
            "text": "This Grove consists of one 8mm RGB LED. It operates at 5V DC. When SIG pin is logic HIGH, the RGB LED will light up. Perfect for use on Seeeduino digital outputs, or also can be controlled by pulse-width modulation. And it uses three adjustable resistor to change the color of the RGB LED.",
            "title": "Introduction"
        },
        {
            "location": "/Grove-Variable_Color_LED/#features",
            "text": "Grove compatible  Color adjustable",
            "title": "Features"
        },
        {
            "location": "/Grove-Variable_Color_LED/#application-ideas",
            "text": "Toys  Decoration    Caution \nBe gentle while adjusting the R, G and B adjustable resistances in case of over-turning.",
            "title": "Application Ideas"
        },
        {
            "location": "/Grove-Variable_Color_LED/#specifications",
            "text": "Item  Typical  Unit      Operate Voltage  5.0  VDC    Working Current  20  mA    Variable Resistor  <1  K\u03a9",
            "title": "Specifications"
        },
        {
            "location": "/Grove-Variable_Color_LED/#usage",
            "text": "The three resistances RED, GREEN and BLUE of the module control the R, G and B channels respectively. By adjusting the three adjustable resistances, it can turn out variable color. The thing to notice, however, is that be gentle when turning the adjustable resistances.  The following sketch demonstrates a simple application of controlling its brightness. As the picture on the below indicates, the Variable Color LED is connected to digital port 9 of the  Grove - Base Shield . The hardware installation is as follows:    Copy and paste code below to a new Arduino sketch.   Demo code like:  int ledPin = 9;    // LED connected to digital pin 9\n\nvoid setup()  { \n  // nothing happens in setup \n}\n\nvoid loop()  { \n  // fade in from min to max in increments of 5 points:\n  for(int fadeValue = 0\u00a0; fadeValue <= 255; fadeValue +=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  }\n\n  // fade out from max to min in increments of 5 points:\n  for(int fadeValue = 255\u00a0; fadeValue >= 0; fadeValue -=5) { \n    // sets the value (range from 0 to 255):\n    analogWrite(ledPin, fadeValue);         \n    // wait for 30 milliseconds to see the dimming effect    \n    delay(30);                            \n  } \n}   Upload the code, Please click  here  if you do not know how to upload.\n    Adjust the three adjustable resistances, I am sure you will like it. Have a try!",
            "title": "Usage"
        },
        {
            "location": "/Grove-Variable_Color_LED/#resources",
            "text": "Variable Color LED eagle_file",
            "title": "Resources"
        },
        {
            "location": "/Grove-Variable_Color_LED/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Linkit_Connect_7681/",
            "text": "Linkit Connect 7681\n\n\n\n\nIntroduction\n\n\nThe LinkIt Connect 7681 development board provides easy access to the five GPIO pins and one UART port \u2014 each with an LED \u2014 of the MT7681, to quickly connect peripheral controllers and electronic circuits. The MT7681 is provided on the LinkIt Connect 7681 module, which was co-designed with AcSiP. This module, which is only 15 x 18mm, will also be available separately for direct integration into your product\u2019s PCB.\n\n\n\n\nKey Features\n\n\n\n\nAccess to the five GPIO pins and one UART port provided by MT7681, with attached LEDs\n\n\nWiFi antenna integrated on Linkit 7681 module\n\n\nPower over USB (Micro USB port).\n\n\nOpen source hardware board reference design, including schematic, layouts, and pin details.\n\n\n\n\nSpecifications\n\n\n\n\nChipset Core: MT7681 ANDES N9\n\n\nClock Speed: 80MHz\n\n\nFlash: 1MB\n\n\nRAM: 64KB\n\n\nPower: on-board 1A 3.3V voltage regulator (can be powered from USB connector)\n\n\nConnectors: UART/GPIO/SPI pins are available on connectors(100mil/2.54mm pitch);micro USB connector.\n\n\nGPIO Voltage: 3.3V\n\n\nPWM Output pin Count: 5\n\n\nPWM levels: 0~20\n\n\nUART Voltage: 3.3V\n\n\nWi-Fi Spec: 802.11 b/g/n for Station mode; 802.11 b/g for AP mode\n\n\nDimensions: 50 x 31 mm\n\n\nOther: Onboard reset push-button.\n\n\n\n\nHardware Overview\n\n\n\n\nGetting Started\n\n\nInstall USB Driver\n\n\nConnect LinkIt Connect 7681 development board to PC\u2019s USB port using a USB cable. The driver will be automatically installed.(As shown below in Windows7 OS)\n\n\n\n\n\n\n\n\nNote\n\nIf the driver does not install successfully, you can download and install \nFTDI Driver\n manually.\n\n\n\n\nGetting started with \nMediaTek LinkIt Connect 7681 Developer\u2019s Guide\n\n\nThis document provides you with a detailed introduction to the MediaTek LinkIt Connect 7681 SDK, step-by-step installation guide, and details on how to use it to create and run Wi-Fi applications. It also covers how to use the board upgrade tool provided in the SDK, an overview of the APIs and several how-to guides to undertake common Wi-Fi operations with code example. Details on how to create MediaTek Smart Connection apps for Android and iOS are also included.\n\n\nResources\n\n\n\n\nMediaTek LinkIt Connect 7681 Developer\u2019s Guide\n\n\nMediaTek LinkIt Connect 7681 API Reference\n\n\nLinkIt Connect 7681 Hardware Reference Design\n\n\nMediaTek LinkIt\u2122 Connect 7681 SDK\n\n\n\n\nHelp us make it better",
            "title": "Linkit Connect 7681"
        },
        {
            "location": "/Linkit_Connect_7681/#linkit-connect-7681",
            "text": "",
            "title": "Linkit Connect 7681"
        },
        {
            "location": "/Linkit_Connect_7681/#introduction",
            "text": "The LinkIt Connect 7681 development board provides easy access to the five GPIO pins and one UART port \u2014 each with an LED \u2014 of the MT7681, to quickly connect peripheral controllers and electronic circuits. The MT7681 is provided on the LinkIt Connect 7681 module, which was co-designed with AcSiP. This module, which is only 15 x 18mm, will also be available separately for direct integration into your product\u2019s PCB.",
            "title": "Introduction"
        },
        {
            "location": "/Linkit_Connect_7681/#key-features",
            "text": "Access to the five GPIO pins and one UART port provided by MT7681, with attached LEDs  WiFi antenna integrated on Linkit 7681 module  Power over USB (Micro USB port).  Open source hardware board reference design, including schematic, layouts, and pin details.",
            "title": "Key Features"
        },
        {
            "location": "/Linkit_Connect_7681/#specifications",
            "text": "Chipset Core: MT7681 ANDES N9  Clock Speed: 80MHz  Flash: 1MB  RAM: 64KB  Power: on-board 1A 3.3V voltage regulator (can be powered from USB connector)  Connectors: UART/GPIO/SPI pins are available on connectors(100mil/2.54mm pitch);micro USB connector.  GPIO Voltage: 3.3V  PWM Output pin Count: 5  PWM levels: 0~20  UART Voltage: 3.3V  Wi-Fi Spec: 802.11 b/g/n for Station mode; 802.11 b/g for AP mode  Dimensions: 50 x 31 mm  Other: Onboard reset push-button.",
            "title": "Specifications"
        },
        {
            "location": "/Linkit_Connect_7681/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Linkit_Connect_7681/#getting-started",
            "text": "",
            "title": "Getting Started"
        },
        {
            "location": "/Linkit_Connect_7681/#install-usb-driver",
            "text": "Connect LinkIt Connect 7681 development board to PC\u2019s USB port using a USB cable. The driver will be automatically installed.(As shown below in Windows7 OS)     Note \nIf the driver does not install successfully, you can download and install  FTDI Driver  manually.  Getting started with  MediaTek LinkIt Connect 7681 Developer\u2019s Guide  This document provides you with a detailed introduction to the MediaTek LinkIt Connect 7681 SDK, step-by-step installation guide, and details on how to use it to create and run Wi-Fi applications. It also covers how to use the board upgrade tool provided in the SDK, an overview of the APIs and several how-to guides to undertake common Wi-Fi operations with code example. Details on how to create MediaTek Smart Connection apps for Android and iOS are also included.",
            "title": "Install USB Driver"
        },
        {
            "location": "/Linkit_Connect_7681/#resources",
            "text": "MediaTek LinkIt Connect 7681 Developer\u2019s Guide  MediaTek LinkIt Connect 7681 API Reference  LinkIt Connect 7681 Hardware Reference Design  MediaTek LinkIt\u2122 Connect 7681 SDK",
            "title": "Resources"
        },
        {
            "location": "/Linkit_Connect_7681/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/RS232_Shield/",
            "text": "RS232 Shield\n\n\n\n\nIntroduction\n\n\nRS232 Shield is a standard communication port for industry equipment.This module is base on MAX232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.\n\n\n\n\nSpecifications\n\n\n\n\nMeets or Exceeds TIA/EIA-232-F and ITU\n\n\nOperates Up To 120 kbit/s\n\n\nLow Supply Current\n\n\nLED Indicator\n\n\nDB9 Connectors(female)\n\n\nWelding Areas\n\n\n\n\nInterface Function\n\n\nUsage\n\n\nFirst,we can test it by computer.\n\n\nHardware Installation\n\n\n\n\nSeeeduino v3.0,Mini usb Cable,RS232 Shield,RS232 to USB Cable.\n\n\nMake the connections as below. The jumper hats can be used to select the software serial port from the digital pins. You can set them to D7(232_TX) and D6(232_RX), and modify the code to \"\nSoftwareSerial mySerial(7, 6); // 232_TX, 232_RX\n\"\n\n\n\n\n\n\nSoftware Part\n\n\n\n\n1) Open Arduino IDE, and paste the code below.\n\n\n\n\n\u00a0\n#include <SoftwareSerial.h>\n\u00a0\nSoftwareSerial mySerial(7, 6); //232_TX,232_RX\n\u00a0\nvoid setup()\n{\n    // Open serial communications and wait for port to open:\n    Serial.begin(9600);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for Leonardo only\n    }\n\u00a0\n\u00a0\n    Serial.println(\"Goodnight moon!\");\n\u00a0\n    // set the data rate for the SoftwareSerial port\n    mySerial.begin(9600);\n    mySerial.println(\"Hello, world?\");\n}\n\u00a0\nvoid loop() // run over and over\n{\n    if (mySerial.available())\n    Serial.write(mySerial.read());\n    if (Serial.available())\n    mySerial.write(Serial.read());\n}\n\n\n\n\n\n\n2) Upload the code. Note that you should select the correct board type and COM port.\n\n\n3) Open the Serial Monitor.\n\n\n\n\nYou can see\u00a0:\n\n\n\nResources\n\n\n\n\nRS232 Shield eagle file\n\n\nRS232_Shield_v1.0.pdf\n\n\nDatasheet MAX232D.pdf\n\n\n\n\nHelp us make it better",
            "title": "RS232 Shield"
        },
        {
            "location": "/RS232_Shield/#rs232-shield",
            "text": "",
            "title": "RS232 Shield"
        },
        {
            "location": "/RS232_Shield/#introduction",
            "text": "RS232 Shield is a standard communication port for industry equipment.This module is base on MAX232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.",
            "title": "Introduction"
        },
        {
            "location": "/RS232_Shield/#specifications",
            "text": "Meets or Exceeds TIA/EIA-232-F and ITU  Operates Up To 120 kbit/s  Low Supply Current  LED Indicator  DB9 Connectors(female)  Welding Areas",
            "title": "Specifications"
        },
        {
            "location": "/RS232_Shield/#interface-function",
            "text": "Usage  First,we can test it by computer.",
            "title": "Interface Function"
        },
        {
            "location": "/RS232_Shield/#hardware-installation",
            "text": "Seeeduino v3.0,Mini usb Cable,RS232 Shield,RS232 to USB Cable.  Make the connections as below. The jumper hats can be used to select the software serial port from the digital pins. You can set them to D7(232_TX) and D6(232_RX), and modify the code to \" SoftwareSerial mySerial(7, 6); // 232_TX, 232_RX \"",
            "title": "Hardware Installation"
        },
        {
            "location": "/RS232_Shield/#software-part",
            "text": "1) Open Arduino IDE, and paste the code below.   \u00a0\n#include <SoftwareSerial.h>\n\u00a0\nSoftwareSerial mySerial(7, 6); //232_TX,232_RX\n\u00a0\nvoid setup()\n{\n    // Open serial communications and wait for port to open:\n    Serial.begin(9600);\n    while (!Serial) {\n        ; // wait for serial port to connect. Needed for Leonardo only\n    }\n\u00a0\n\u00a0\n    Serial.println(\"Goodnight moon!\");\n\u00a0\n    // set the data rate for the SoftwareSerial port\n    mySerial.begin(9600);\n    mySerial.println(\"Hello, world?\");\n}\n\u00a0\nvoid loop() // run over and over\n{\n    if (mySerial.available())\n    Serial.write(mySerial.read());\n    if (Serial.available())\n    mySerial.write(Serial.read());\n}   2) Upload the code. Note that you should select the correct board type and COM port.  3) Open the Serial Monitor.   You can see\u00a0:",
            "title": "Software Part"
        },
        {
            "location": "/RS232_Shield/#resources",
            "text": "RS232 Shield eagle file  RS232_Shield_v1.0.pdf  Datasheet MAX232D.pdf",
            "title": "Resources"
        },
        {
            "location": "/RS232_Shield/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/",
            "text": "Raspberry Pi Breakout Board v1.0\n\n\n\n\nIntroduction\n\n\nRaspberry Pi Breakout Board for Raspberry Pi is a prototype board that you can combine your raspberry pi with other components, modules.\nAs a prototype board, it also provides power, state indicator light, button and universal transistor,such as NPN, PNP, N-MOS, P-MOS.\n\n\n\n\nFeatures\n\n\n\n\nRaspberry pi compatible\n\n\nMicro USB power supply\n\n\nBasic Circuit\u00a0: state indicator light, button and universal transistor\uff08NPN,PNP,N-MOS,P-MOS\uff09\n\n\n3.3 volts, 5 volts and ground power rails are easily available anywhere on the board\n\n\n\n\nHardware Overview\n\n\n\n\nAssembly\n\n\n\n\nYou can design circuit on the Raspberry Pi Breakout Board, then connect to raspberry pi as shown below.\n\n\n\n\n\n\nResources\n\n\n\n\nRaspberry Pi Breakout Board v1.0 sch pcb-.zip\n\n\n\n\nHelp us make it better",
            "title": "Raspberry Pi Breakout Board v1.0"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#raspberry-pi-breakout-board-v10",
            "text": "",
            "title": "Raspberry Pi Breakout Board v1.0"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#introduction",
            "text": "Raspberry Pi Breakout Board for Raspberry Pi is a prototype board that you can combine your raspberry pi with other components, modules.\nAs a prototype board, it also provides power, state indicator light, button and universal transistor,such as NPN, PNP, N-MOS, P-MOS.",
            "title": "Introduction"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#features",
            "text": "Raspberry pi compatible  Micro USB power supply  Basic Circuit\u00a0: state indicator light, button and universal transistor\uff08NPN,PNP,N-MOS,P-MOS\uff09  3.3 volts, 5 volts and ground power rails are easily available anywhere on the board",
            "title": "Features"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#assembly",
            "text": "You can design circuit on the Raspberry Pi Breakout Board, then connect to raspberry pi as shown below.",
            "title": "Assembly"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#resources",
            "text": "Raspberry Pi Breakout Board v1.0 sch pcb-.zip",
            "title": "Resources"
        },
        {
            "location": "/Raspberry_Pi_Breakout_Board_v1.0/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/",
            "text": "Raspberry Pi RS232 Board v1.0\n\n\n\n\nIntroduction\n\n\nRaspberry Pi RS232 Board v1.0 is a standard communication port for industry equipment.This module is base on MAX3232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.\n\n\n\n\nFeatures\n\n\n\n\nLow Supply Current:300\u03bcA\n\n\nGuaranteed Data Rate:120kbps\n\n\nMeets EIA/TIA-232 Specifications Down to 3.0V\n\n\nPin Compatible with Industry-Standard MAX232\n\n\nGuaranteed Slew Rate:6V/\u03bcs\n\n\nLED Indicator\n\n\nDB9 Connectors(female)\n\n\n\n\nSpecifications\n\n\n\n\n\n\n Item\n\n\n\n Min\n\n\n\n Typical\n\n\n\n Max\n\n\n\n Unit\n\n\n\n\n\n Input Voltage Range\n\n\n\n -25\n\n\n\n /\n\n\n\n 25\n\n\n\n V\n\n\n\n\n\n Input Threshold Low(VCC=3.3V/5.0V)\n\n\n\n 0.6 / 0.8\n\n\n\n 1.2 / 1.5\n\n\n\n /\n\n\n\n V\n\n\n\n\n\n Input Threshold High (VCC=3.3V/5.0V)\n\n\n\n /\n\n\n\n 1.5 / 1.8\n\n\n\n 2.4 / 2.4\n\n\n\n V\n\n\n\n\n\n Maximum Data Rate\n\n\n\n 120\n\n\n\n 235\n\n\n\n\n\n\n\n kHz\n\n\n\n\n\n Operating Temperature\n\n\n\n 0\n\n\n\n /\n\n\n\n 70\n\n\n\n \u2103\n\n\n\n\n\n Dimension\n\n\n\n 91.20 * 56.15*32\n\n\n\n mm\n\n\n\n\nHardware Overview\n\n\n\n\nUART Pin must be pup joint if you want to connect to raspberry pi.\n\n\nUsage\n\n\nUsing serial COM ports to Configure system on Raspberry Pi.\n\n\nHardware Installation\n\n\n\n\n\n\nRaspberry Pi&USB to serial COM Port line.\n\n\n\n\n\n\nConnect as in the following picture:\n\n\n\n\n\n\n\n\nFine out which com it is using on you PC's device management.\n\n\n\n\n\n\nRun a serial port assistant, and set it as shown:\n\n\nCOM must be set as what you fine on you PC's device management.Then power on your raspberry pi. You can see the serial port assistant as shown below.\n\n\n\n\n\n\n\n\nHave communication with Raspberry Pi successfully.\n\n\n\n\n\n\n\n\nResources\n\n\n\n\nRaspberry_Pi_RS232_Board_v1.0_sch_pcb\n\n\nMAX3232\n\n\n\n\nHelp us make it better",
            "title": "Raspberry Pi R232 Board v1.0"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#raspberry-pi-rs232-board-v10",
            "text": "",
            "title": "Raspberry Pi RS232 Board v1.0"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#introduction",
            "text": "Raspberry Pi RS232 Board v1.0 is a standard communication port for industry equipment.This module is base on MAX3232,which is a dual driver/receiver that includes a capacitive voltage generator to supply TIA/EIA-232-F voltage levels from a single 5-V supply. The shield integrates DB9 connectors (female) that provide connection to various devices with RS232 interface. Also the RS232 headers will facilitate your connections and commissioning. It provides the welding areas to make full use of extra space on it, which is highly convenient for prototyping.",
            "title": "Introduction"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#features",
            "text": "Low Supply Current:300\u03bcA  Guaranteed Data Rate:120kbps  Meets EIA/TIA-232 Specifications Down to 3.0V  Pin Compatible with Industry-Standard MAX232  Guaranteed Slew Rate:6V/\u03bcs  LED Indicator  DB9 Connectors(female)",
            "title": "Features"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#specifications",
            "text": "Item   Min   Typical   Max   Unit    Input Voltage Range   -25   /   25   V    Input Threshold Low(VCC=3.3V/5.0V)   0.6 / 0.8   1.2 / 1.5   /   V    Input Threshold High (VCC=3.3V/5.0V)   /   1.5 / 1.8   2.4 / 2.4   V    Maximum Data Rate   120   235     kHz    Operating Temperature   0   /   70   \u2103    Dimension   91.20 * 56.15*32   mm",
            "title": "Specifications"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#hardware-overview",
            "text": "UART Pin must be pup joint if you want to connect to raspberry pi.",
            "title": "Hardware Overview"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#usage",
            "text": "Using serial COM ports to Configure system on Raspberry Pi.",
            "title": "Usage"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#hardware-installation",
            "text": "Raspberry Pi&USB to serial COM Port line.    Connect as in the following picture:     Fine out which com it is using on you PC's device management.    Run a serial port assistant, and set it as shown:  COM must be set as what you fine on you PC's device management.Then power on your raspberry pi. You can see the serial port assistant as shown below.     Have communication with Raspberry Pi successfully.",
            "title": "Hardware Installation"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#resources",
            "text": "Raspberry_Pi_RS232_Board_v1.0_sch_pcb  MAX3232",
            "title": "Resources"
        },
        {
            "location": "/Raspberry_Pi_R232_Board_v1.0/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/UartSBee_v5/",
            "text": "UartSBee v5\n\n\n\n\nIntroduction\n\n\nUartSBee v5'\n is FTDI cable compatible \nUSB to Serial\n adapter equipped with BEE socket(20pin 2.0mm). The integrated \nFT232RL\n can be used for programming or communicating with MCUs. On the other hand, you might connect your PC to various wireless applications via a \nBee\n compatible module. UartSBee provides breakouts for the bit-bang mode pins of \nFT232RL\n as well.This Bit-bang mode pins (8 I/O pins) can be used as a replacement for applications involving PC parallel port which is scares now a day.\n\n\n\n\nUartSBee v5 is the Mesh Bee programmer version based on UartSBee v4.\n\n\nPlease refer to \nUartSBee v4's wiki page\n for general help topics. In this wiki we focus on the difference between v4 and v5.\n\n\nAdded Features\n\n\n\n\nMicroUSB interface\n\n\nCan program Mesh Bee\n\n\nAdded SW3 to switch the connection of FT232's UART between the TX1/RX1 pins of BEE socket and the program interface of Mesh Bee\n\n\n\n\nHardware Overview\n\n\n\n\nResources\n\n\n\n\nEagle file for UartSBee v5\n\n\nHow to program Mesh Bee\n\n\n\n\nHelp us make it better",
            "title": "UartSBee v5"
        },
        {
            "location": "/UartSBee_v5/#uartsbee-v5",
            "text": "",
            "title": "UartSBee v5"
        },
        {
            "location": "/UartSBee_v5/#introduction",
            "text": "UartSBee v5'  is FTDI cable compatible  USB to Serial  adapter equipped with BEE socket(20pin 2.0mm). The integrated  FT232RL  can be used for programming or communicating with MCUs. On the other hand, you might connect your PC to various wireless applications via a  Bee  compatible module. UartSBee provides breakouts for the bit-bang mode pins of  FT232RL  as well.This Bit-bang mode pins (8 I/O pins) can be used as a replacement for applications involving PC parallel port which is scares now a day.   UartSBee v5 is the Mesh Bee programmer version based on UartSBee v4.  Please refer to  UartSBee v4's wiki page  for general help topics. In this wiki we focus on the difference between v4 and v5.",
            "title": "Introduction"
        },
        {
            "location": "/UartSBee_v5/#added-features",
            "text": "MicroUSB interface  Can program Mesh Bee  Added SW3 to switch the connection of FT232's UART between the TX1/RX1 pins of BEE socket and the program interface of Mesh Bee",
            "title": "Added Features"
        },
        {
            "location": "/UartSBee_v5/#hardware-overview",
            "text": "",
            "title": "Hardware Overview"
        },
        {
            "location": "/UartSBee_v5/#resources",
            "text": "Eagle file for UartSBee v5  How to program Mesh Bee",
            "title": "Resources"
        },
        {
            "location": "/UartSBee_v5/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/",
            "text": "Wio Link Bootcamp Kit\n\n\n\n\nIntroduction\n\n\nIf you have no programming skills, and you want to build some cool gadgets for your life, this kit will be a perfect starter. It contains a relay, a recorder, a strip of LEDs, a buzzer and a servo motor which will perform basic actions required in daily life. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's get started to build some useful stuff.\n\n\n\n\nFeatures\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCompletely easy to make things around you smarter and add fun to daily life.\n\n\nCost-effective\n\n\nWeight: 285 g\n\n\n\n\nParts list\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Relay\n\n\n1PC\n\n\n\n\n\n\nGrove - Recorder\n\n\n1PC\n\n\n\n\n\n\nGrove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter\n\n\n1PC\n\n\n\n\n\n\nGrove - Buzzer\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\nGrove - Servo\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\n\nPlease go to \nRecipe\n for the detailed manual.\n\n\nHelp us make it better",
            "title": "Wio Link Bootcamp Kit"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#wio-link-bootcamp-kit",
            "text": "",
            "title": "Wio Link Bootcamp Kit"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#introduction",
            "text": "If you have no programming skills, and you want to build some cool gadgets for your life, this kit will be a perfect starter. It contains a relay, a recorder, a strip of LEDs, a buzzer and a servo motor which will perform basic actions required in daily life. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's get started to build some useful stuff.",
            "title": "Introduction"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#features",
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Completely easy to make things around you smarter and add fun to daily life.  Cost-effective  Weight: 285 g",
            "title": "Features"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#parts-list",
            "text": "Parts name  Quantity      Grove - Relay  1PC    Grove - Recorder  1PC    Grove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter  1PC    Grove - Buzzer  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC    Grove - Servo  1PC",
            "title": "Parts list"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#a-simple-demo",
            "text": "This demo can used as a compilation result-indicator.",
            "title": "A simple demo"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#preliminary-guide",
            "text": "Travis CI  Wio Link",
            "title": "Preliminary Guide"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#prerequisites",
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light",
            "title": "Prerequisites"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#a-detailed-how-to",
            "text": "Please go to  Recipe  for the detailed manual.",
            "title": "A detailed how-to"
        },
        {
            "location": "/Wio_Link_Bootcamp_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Wio_Link_Environment_Kit/",
            "text": "Wio Link Environment Kit\n\n\n\n\nIntroduction\n\n\nWe are always closely connected with our surrounding environment. So it is important for us to get some details from an environment. This kit is supposed to do this task perfectly, at least at a primary level. In this kit, you can find common functional modules to collect data, such as humidity or light level indoor, from the environment in our house. The most amazing part of this kit is the Wio Link development board which can be utilized for various purposes, without requiring any programming skills. All the actions you want your modules to perform and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet from anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. So let's get an understanding for those conditions you are in.\n\n\n\n\nFeatures\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCost-effective\n\n\nWeight\u00a0: 154 g\n\n\n\n\nParts list\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Moisture Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Temp&Humi Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Digital Light Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Air quality sensor v1.3\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\n\nPlease go to \nRecipe\n for the detailed manual.\n\n\nHelp us make it better",
            "title": "Wio Link Environment Kit"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#wio-link-environment-kit",
            "text": "",
            "title": "Wio Link Environment Kit"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#introduction",
            "text": "We are always closely connected with our surrounding environment. So it is important for us to get some details from an environment. This kit is supposed to do this task perfectly, at least at a primary level. In this kit, you can find common functional modules to collect data, such as humidity or light level indoor, from the environment in our house. The most amazing part of this kit is the Wio Link development board which can be utilized for various purposes, without requiring any programming skills. All the actions you want your modules to perform and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet from anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. So let's get an understanding for those conditions you are in.",
            "title": "Introduction"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#features",
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Cost-effective  Weight\u00a0: 154 g",
            "title": "Features"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#parts-list",
            "text": "Parts name  Quantity      Grove - Moisture Sensor  1PC    Grove - Temp&Humi Sensor  1PC    Grove - Digital Light Sensor  1PC    Grove - Air quality sensor v1.3  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC",
            "title": "Parts list"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#a-simple-demo",
            "text": "This demo can used as a compilation result-indicator.",
            "title": "A simple demo"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#preliminary-guide",
            "text": "Travis CI  Wio Link",
            "title": "Preliminary Guide"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#prerequisites",
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light",
            "title": "Prerequisites"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#a-detailed-how-to",
            "text": "Please go to  Recipe  for the detailed manual.",
            "title": "A detailed how-to"
        },
        {
            "location": "/Wio_Link_Environment_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Wio_Link_Event_Kit/",
            "text": "Wio Link Event Kit\n\n\n\n\nIntroduction\n\n\nWio Link Event Kit is a event-monitoring kit which include some typical event-triggered \nGrove\n functional modules to build smart IoT devices. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over the internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's get familiar with some event-triggered modules included in this Kit.\n\n\n\n\nFeatures\n\n\n\n\nInclude common frequently-used event-monitoring functional modules.\n\n\nCompletely easy to make things around you smarter.\n\n\nGrove port interfaced, more practical function and less work.\n\n\nWeight: 145 g\n\n\n\n\nParts list\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - IR Distance Interrupt\n\n\n1PC\n\n\n\n\n\n\nGrove - Button\n\n\n1PC\n\n\n\n\n\n\nGrove - Magnetic Switch\n\n\n1PC\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\n\nPlease go to \nRecipe\n for the detailed manual:\n\n\nHelp us make it better",
            "title": "Wio Link Event Kit"
        },
        {
            "location": "/Wio_Link_Event_Kit/#wio-link-event-kit",
            "text": "",
            "title": "Wio Link Event Kit"
        },
        {
            "location": "/Wio_Link_Event_Kit/#introduction",
            "text": "Wio Link Event Kit is a event-monitoring kit which include some typical event-triggered  Grove  functional modules to build smart IoT devices. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over the internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's get familiar with some event-triggered modules included in this Kit.",
            "title": "Introduction"
        },
        {
            "location": "/Wio_Link_Event_Kit/#features",
            "text": "Include common frequently-used event-monitoring functional modules.  Completely easy to make things around you smarter.  Grove port interfaced, more practical function and less work.  Weight: 145 g",
            "title": "Features"
        },
        {
            "location": "/Wio_Link_Event_Kit/#parts-list",
            "text": "Parts name  Quantity      Grove - IR Distance Interrupt  1PC    Grove - Button  1PC    Grove - Magnetic Switch  1PC    Grove - 3-Axis Digital Accelerometer(\u00b11.5g)  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC",
            "title": "Parts list"
        },
        {
            "location": "/Wio_Link_Event_Kit/#a-simple-demo",
            "text": "This demo can used as a compilation result-indicator.",
            "title": "A simple demo"
        },
        {
            "location": "/Wio_Link_Event_Kit/#preliminary-guide",
            "text": "Travis CI  Wio Link",
            "title": "Preliminary Guide"
        },
        {
            "location": "/Wio_Link_Event_Kit/#prerequisites",
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light",
            "title": "Prerequisites"
        },
        {
            "location": "/Wio_Link_Event_Kit/#a-detailed-how-to",
            "text": "Please go to  Recipe  for the detailed manual:",
            "title": "A detailed how-to"
        },
        {
            "location": "/Wio_Link_Event_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        },
        {
            "location": "/Wio_Link_Starter_Kit/",
            "text": "Wio Link Starter Kit\n\n\n\n\nIntroduction\n\n\nThis kit is aimed at novices wanting to become a maker. The functional modules included in this kit are selected especially for a beginner which all are frequently required modules, and it is cost-effective. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's enjoy being a maker.\n\n\n\n\nFeatures\n\n\n\n\nInclude common frequently-used environment-monitoring functional modules\n\n\nGrove port interfaced, more practical function and less work\n\n\nCompletely easy to make things around you smarter and add fun to daily life.\n\n\nCost-effective\n\n\nWeight: 267 g\n\n\n\n\nParts list\n\n\n\n\n\n\n\n\nParts name\n\n\nQuantity\n\n\n\n\n\n\n\n\n\n\nGrove - Button\n\n\n1PC\n\n\n\n\n\n\nGrove - Relay\n\n\n1PC\n\n\n\n\n\n\nGrove - Temp&Humi Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - Digital Light Sensor\n\n\n1PC\n\n\n\n\n\n\nGrove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter\n\n\n1PC\n\n\n\n\n\n\nGrove - 3-Axis Digital Accelerometer(\u00b11.5g)\n\n\n1PC\n\n\n\n\n\n\nWio Link\n\n\n1PC\n\n\n\n\n\n\nMicro USB Cable - 48cm\n\n\n1PC\n\n\n\n\n\n\n\n\nA simple demo\n\n\nThis demo can used as a compilation result-indicator.\n\n\nPreliminary Guide\n\n\n\n\nTravis CI\n\n\nWio Link\n\n\n\n\nPrerequisites\n\n\n\n\nWio Link APP\n\n\nWio Link\n\n\nGrove Relay\n \u00d7 3\n\n\nA Travis CI Account\n\n\nA GitHub Account\n\n\nTraffic Light\n\n\n\n\nA detailed how-to\n\n\nPlease go to \nRecipe\n for the detailed manual.\n\n\nHelp us make it better",
            "title": "Wio Link Starter Kit"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#wio-link-starter-kit",
            "text": "",
            "title": "Wio Link Starter Kit"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#introduction",
            "text": "This kit is aimed at novices wanting to become a maker. The functional modules included in this kit are selected especially for a beginner which all are frequently required modules, and it is cost-effective. The most amazing part of this kit is the Wio Link development board which can be utilized for various devices: without a bit programming skill required. All the actions you want your modules performed and the flashing-code operation to Wio Link could be completed with taps in a mobile app. And you can send instructions to your devices over Internet at anywhere. So Wio Link will be a perfect utility to making things around smarter for everyone. Now let's enjoy being a maker.",
            "title": "Introduction"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#features",
            "text": "Include common frequently-used environment-monitoring functional modules  Grove port interfaced, more practical function and less work  Completely easy to make things around you smarter and add fun to daily life.  Cost-effective  Weight: 267 g",
            "title": "Features"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#parts-list",
            "text": "Parts name  Quantity      Grove - Button  1PC    Grove - Relay  1PC    Grove - Temp&Humi Sensor  1PC    Grove - Digital Light Sensor  1PC    Grove - WS2812 Waterproof LED Strip - 30 LEDs 1 meter  1PC    Grove - 3-Axis Digital Accelerometer(\u00b11.5g)  1PC    Wio Link  1PC    Micro USB Cable - 48cm  1PC",
            "title": "Parts list"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#a-simple-demo",
            "text": "This demo can used as a compilation result-indicator.",
            "title": "A simple demo"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#preliminary-guide",
            "text": "Travis CI  Wio Link",
            "title": "Preliminary Guide"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#prerequisites",
            "text": "Wio Link APP  Wio Link  Grove Relay  \u00d7 3  A Travis CI Account  A GitHub Account  Traffic Light",
            "title": "Prerequisites"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#a-detailed-how-to",
            "text": "Please go to  Recipe  for the detailed manual.",
            "title": "A detailed how-to"
        },
        {
            "location": "/Wio_Link_Starter_Kit/#help-us-make-it-better",
            "text": "",
            "title": "Help us make it better"
        }
    ]
}