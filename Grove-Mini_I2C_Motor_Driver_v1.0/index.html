<html><head><meta name="viewport" content="width=device-width, initial-scale=1"><link href=//fonts.googleapis.com/css?family=Raleway:400,300,600 rel=stylesheet type=text/css><link rel="stylesheet" type="text/css" href="../common/css/normalize.css"><link rel="stylesheet" type="text/css" href="../common/css/skeleton.css"><link rel="stylesheet" type="text/css" href="../common/css/wiki.css"><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><title>Grove - Mini I2C Motor Driver v1.0</title><meta charset="utf-8"/></head><body><div class"container"><a href="../index.html"><img src="../common/logo.png"/></a></div><div class="mw-content-ltr container" dir="ltr" id="mw-content-text" lang="en"><h1>Grove - Mini I2C Motor Driver v1.0</h1><div class="thumb tright"><div class="thumbinner" style="width:502px;"><img src="img/Mini_I2C_motor_2.png" width="500"/> <div class="thumbcaption"></div></div></div>
<p><br/>
This Grove - MIni I2C motor driver included two DRV8830, The DRV8830 provides an integrated motor driver solution for battery-powered toys, printers, and other low-voltage or battery-powered motion control applications. The module has two H-bridge drivers, and can drive two DC motors or two winding of stepper motors, as well as other loads like solenoids.It requires an onboard 5V voltage regulator which can power the I2C bus. All driver lines are diode protected from back EMF.It features two LEDs for fault indicator and four LEDs to indicate which direction each motor is running. GROVE system plug and I2C interface enables you to daisy-chain the driver with many other devices.
</p><p><br/>
<a href="http://www.seeedstudio.com/depot/Grove%C2%A0%C2%A0I2C%C2%A0Mini%C2%A0Motor%C2%A0Driver-p-2508.html?cPath=91_92"><img src="../common/Get_One_Now_Banner.png" width="300"/></a>
</p><p><br/>
</p>
<h2> Features</h2>
<ul><li> Without external power supply
</li><li> Two leds for fault indicator
</li><li> Default maximum drive current 200 mA
</li><li> Grove compatible
</li><li> I2C interface
</li><li> Motor's speed and direction can control
</li><li> Number of channels: 2 
</li><li> Easy to use
</li></ul>
<p><br/>
</p>
<h2> Application Ideas </h2>
<p>This motor driver can be used to drive any brushed electronic motor as long as it doesn't consume more than 1A at 5v. <br/>
Two motors can be driven simultaneously while set to a different speed and direction.<br/>
The speed can be set fully proportional and is controlled by I2C command.
</p>
<ul><li> Battery-Powered:
</li></ul>
<dl><dd><ul><li> Printers
</li><li> Toys
</li><li> Robotics
</li><li> Cameras
</li><li> Phones
</li></ul>
</dd></dl>
<ul><li> Small Actuators, Pumps, etc.
</li></ul>
<p><br/>
</p>
<h2> Specifications</h2>
<table  cellspacing="0" width="80%">
<tr>
<th scope="col"> Item
</th>
<th scope="col"> Min
</th>
<th scope="col"> Typical
</th>
<th scope="col"> Max
</th>
<th scope="col"> Unit
</th></tr>
<tr>
<th scope="row">Working Voltage
</th>
<td> 2.75
</td>
<td> 5
</td>
<td> 6.8
</td>
<td> VDC
</td></tr>
<tr>
<th scope="row"> Max Output Current per channel
</th>
<td> 0.2(default)
</td>
<td> -
</td>
<td> 1
</td>
<td> A
</td></tr>
<tr>
<th scope="row"> Input/output voltage on I2C bus
</th>
<td colspan="3"> 3.3/5
</td>
<td> V
</td></tr>
<tr>
<th scope="row">  Communication protocol
</th>
<td colspan="3"> I2C
</td>
<td> /
</td></tr>
<tr>
<th scope="row"> Default I2C Address
</th>
<td colspan="3"> 0xC0, 0xC4
</td>
<td> /
</td></tr></table>
<p><br/>
</p>
<h2> Interface Function </h2>
<br/><div class="center"><div class="floatnone"><img src="img/Mini_motor_driver.jpg" width="950"/></div></div><br/>
<ul><li> <b>Grove Interface</b> - Grove products have a eco system and all have a same connector which can plug onto the <a href="/index.php-title=Base_shield_v2Anduselang=en">Base Shield</a>. Connect this module to the I<sup>2</sup>C port of Base Shield, and then it can work well with Arduino. However, you can also connect Grove - Mini I2C Motor Driver to Arduino without Base Shield by jumper wires.<br/>
</li></ul>
<center>
<table>
<tr>
<th width="150">Arduino UNO </th>
<th width="150">Base Shield </th>
<th width="150">Grove - Mini I2C Motor Driver
</th></tr>
<tr>
<td> 5V </td>
<td rowspan="4">I2C port </td>
<td> VCC
</td></tr>
<tr>
<td> GND </td>
<td> GND
</td></tr>
<tr>
<td> SDA </td>
<td> SDA
</td></tr>
<tr>
<td> SCL</td>
<td> SCL
</td></tr></table></center>
<ul><li> <b>CH1 fault indicator</b> - Channel 1 fault indicator.
</li><li> <b>CH2 fault indicator</b> - Channel 2 fault indicator.
</li><li> <b>Direction indicator</b> - Motor direction indicator.
</li><li> <b>CH1 Output Connector</b> - Motor 1 connector.
</li><li> <b>CH2 Output Connector</b> - Motor 2 connector.
</li></ul>
<p><br/>
<br/>
</p>
<h2> Hardware function </h2>
<h3>  Change Default maximum drive current </h3>
<p><br/>
The default maximum drive current of each channel is 200mA, see the front picture of the board<br/>
</p>
<div class="center"><div class="floatnone"><img src="img/QQ20150817-3.png" width="600"/></div></div>
<p><br/>
Each channel (CH1,CH2) has been added a resistor, and each value of resistor (R5,R12) is 1 Ω, so the maximum drive current is 200mA according to the following equation
</p>
<center><div class="center"><div class="floatnone"><img src="img/Mini_I2C_motor_7.png" width="300"/></div></div></center>
<p><br/>
Meantime, each channel provides a reserved solderable pad (R6 for CH1, R13 for CH2), so you can solder a resistor onto the board to change the resistor value of each channel. Following is the new equation if adding resistor to the board
</p>
<center> <img src="img/Mini_I2C_motor_8.png" width="300"/> <img src="img/Mini_I2C_motor_9.png" width="300"/> </center>
<p><font color="Red">Caution: </font>
</p>
<ul><li> Maximum working current of each channel must be less than 1A. So the minimum value of resistor soldered to the reserved pad should not less than 0.2 Ω.
</li></ul>
<h3>  Change Default I<sup>2</sup>C Address </h3>
<p>The I<sup>2</sup>C address of each channel is changeable. Please take a look at the back side of the board, you will find there's 4 jumper pads, A0_CH1 and A1_CH1 are for channel 1, A0_CH2 and A1_CH2 are for channel 2. As shown below:
</p>
<center><img src="img/Address_mini_i2c_motor_driver.png" width="500"/></center>
<p><br/>
</p><p><br/>
You can solder or unsolder each jumper to change the I2C address:
</p>
<ul><li> 1 - You need a solder iron, just solder two sides of the jumper together
</li><li> 0 - You need a solder iron, just unsolder two sides of the jumper.
</li></ul>
<p><br/>
</p>
<center><img src="img/Mini_I2C_motor_12.png" width="650"/></center>
<p><br/>
<br/>
<font color="Red">Note1: The library of Grove - Mini I2C Motor driver is depended on the default address.</font>
<br/>
</p>
<h2> Getting Started </h2>
<p>Now, Let's begin to use the Grove - Mini I2C Motor Driver. 
<br/>
<br/>
</p>
<h3> Preparations</h3>
<p>Now we are making a demo for Grove - Mini I2C Motor Driver v1.0 which require following modules.
</p>
<ul><li> 2 * DC Motor 2V-6V
</li><li> <a href="http://www.seeedstudio.com/depot/Seeeduino-Lite-p-1487.html">Seeeduino Lite</a>
</li></ul>
<p><b>Seeeduino Lite is compatible with Arduino.</b>
</p><p>If you are using an Arduino UNO or any others Arduino compatible boards that with out a Grove connect,
</p><p>You'll need a <a href="http://www.seeedstudio.com/depot/base-shield-v13-p-1378.html?cPath=132_134">Grove Base Shield</a> to connect the Grove easily.
</p><p>If this is your first time using Arduino or Seeeduino, Please put hand on <a href="/Getting_Started_with_Seeeduino">here</a> to start your Arduino journey.
</p><p><br/>
</p>
<h3>  Hardware Installation </h3>
<p>Grove - Mini I2C Motor Driver got one Grove socket for connecting two modules above.<br/>
They are:
</p>
<ul><li> 2 * DC Motor 2V-6V - connnect to CH1 &amp; CH2 Output connecter.
</li><li> Seeeduino Lite - connect Seeeduino's Grove I2C Interface to Mini Motor Driver's Grove Interface. 
</li></ul>
<p><br/>
As shown below:<br/>
<img src="img/Mini_motor_driver_demo.jpg" width="700"/>
</p><p><br/>
<br/>
<br/>
<br/>
</p>
<h3>  Software Work </h3>
<div class="thumb tright"><div class="thumbinner" style="width:502px;"><a href="http://https://www.arduino.cc/"><img src="img/Arduino_mini_i2c_motor_driver.jpg" width="500"/></a> <div class="thumbcaption"></div></div></div>
<p>The Grove - Mini I2C Motor Driver can control motor which is based on the chip DRV8830. The DRV8830 is not just a dual motor driver, it is a dual H-bridge. An h-bridge is basically a specific setup of transistors that allow you to switch direction of current. You can use your Arduino to make them spin at any speed. Because the module has 2 H-bridges, you can not only make a robot go forwards and backwards, but also turn around by having each wheel spin in a different direction.<br/>
Connect Seeeduino to computer use a micro USB cable. <br/>
Now, let's use the Grove - Mini I2C Motor Driver to control two DC motors rotating in the positive or opposite direction.<br/>
The below is an example program to be used with an Arduino. The code for this is very basic, but you can also change it up and do it your own way. 
</p>
<div class="mw-geshi mw-code mw-content-ltr container" dir="ltr"><div class="arduino source-arduino"><pre class="de1"><span class="coMULTI">/****************************************************************
Example code demonstrating the use of the Arduino Library for
the SparkFun MiniMoto board, which uses the TI DRV8830 IC for I2C
low-voltage DC motor control.
 
This code is beerware; if you use it, please buy me (or any other
SparkFun employee) a cold beverage next time you run into one of
us at the local.
 
17 Sep 2013- Mike Hord, SparkFun Electronics
 
Code developed in Arduino 1.0.5, on a Fio classic board.
 
**Updated for Arduino 1.6.4 5/2015**
****************************************************************/</span>
 
<span class="co2">#include &lt;SparkFunMiniMoto.h&gt;  // Include the MiniMoto library</span>
 
<span class="co1">// Create two MiniMoto instances, with different address settings.</span>
MiniMoto motor0<span class="br0">(</span><span class="nu12">0xC4</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// A1 = 1, A0 = clear</span>
MiniMoto motor1<span class="br0">(</span><span class="nu12">0xC0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// A1 = 1, A0 = 1 (default)</span>
 
<span class="co2">#define FAULTn  16     // Pin used for fault detection.</span>
 
<span class="co1">// Nothing terribly special in the setup() function- prep the</span>
<span class="co1">//  serial port, print a little greeting, and set up our fault</span>
<span class="co1">//  pin as an input.</span>
<span class="kw4">void</span> <span class="kw2">setup</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw2">Serial</span>.<span class="kw3">begin</span><span class="br0">(</span><span class="nu0">9600</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Hello, world!"</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw3">pinMode</span><span class="br0">(</span>FAULTn, <span class="kw2">INPUT</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co1">// The loop() function just spins the motors one way, then the</span>
<span class="co1">//  other, while constantly monitoring for any fault conditions</span>
<span class="co1">//  to occur. If a fault does occur, it will be reported over</span>
<span class="co1">//  the serial port, and then operation continues.</span>
<span class="kw4">void</span> <span class="kw2">loop</span><span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Forward!"</span><span class="br0">)</span><span class="sy4">;</span>
    motor0.<span class="me1">drive</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy4">;</span>
    motor1.<span class="me1">drive</span><span class="br0">(</span><span class="nu0">100</span><span class="br0">)</span><span class="sy4">;</span>
    delayUntil<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Stop!"</span><span class="br0">)</span><span class="sy4">;</span>
    motor0.<span class="kw3">stop</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    motor1.<span class="kw3">stop</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw3">delay</span><span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Reverse!"</span><span class="br0">)</span><span class="sy4">;</span>
    motor0.<span class="me1">drive</span><span class="br0">(</span><span class="sy2">-</span><span class="nu0">100</span><span class="br0">)</span><span class="sy4">;</span>
    motor1.<span class="me1">drive</span><span class="br0">(</span><span class="sy2">-</span><span class="nu0">100</span><span class="br0">)</span><span class="sy4">;</span>
    delayUntil<span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Brake!"</span><span class="br0">)</span><span class="sy4">;</span>
    motor0.<span class="me1">brake</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    motor1.<span class="me1">brake</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw3">delay</span><span class="br0">(</span><span class="nu0">1000</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co1">// delayUntil() is a little function to run the motor either for</span>
<span class="co1">//  a designated time OR until a fault occurs. Note that this is</span>
<span class="co1">//  a very simple demonstration; ideally, an interrupt would be</span>
<span class="co1">//  used to service faults rather than blocking the application</span>
<span class="co1">//  during motion and polling for faults.</span>
<span class="kw4">void</span> delayUntil<span class="br0">(</span><span class="kw4">unsigned</span> <span class="kw4">long</span> elapsedTime<span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// See the "BlinkWithoutDelay" example for more details on how</span>
    <span class="co1">//  and why this loop works the way it does.</span>
    <span class="kw4">unsigned</span> <span class="kw4">long</span> startTime <span class="sy1">=</span> <span class="kw3">millis</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">while</span> <span class="br0">(</span>startTime <span class="sy2">+</span> elapsedTime <span class="sy1">&gt;</span> <span class="kw3">millis</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="co1">// If FAULTn goes low, a fault condition *may* exist. To be</span>
        <span class="co1">//  sure, we'll need to check the FAULT bit.</span>
        <span class="kw1">if</span> <span class="br0">(</span><span class="kw3">digitalRead</span><span class="br0">(</span>FAULTn<span class="br0">)</span> <span class="sy1">==</span> <span class="kw2">LOW</span><span class="br0">)</span>
        <span class="br0">{</span>
            <span class="co1">// We're going to check both motors; the logic is the same</span>
            <span class="co1">//  for each...</span>
            byte result <span class="sy1">=</span> motor0.<span class="me1">getFault</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
            <span class="co1">// If result masked by FAULT is non-zero, we've got a fault</span>
            <span class="co1">//  condition, and we should report it.</span>
            <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> FAULT<span class="br0">)</span>
            <span class="br0">{</span>
                <span class="kw2">Serial</span>.<span class="kw3">print</span><span class="br0">(</span><span class="st0">"Motor 0 fault: "</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> OCP<span class="br0">)</span> <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Chip overcurrent!"</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> ILIMIT<span class="br0">)</span> <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Load current limit!"</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> UVLO<span class="br0">)</span> <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Undervoltage!"</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> OTS<span class="br0">)</span> <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Over temp!"</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">break</span><span class="sy4">;</span> <span class="co1">// We want to break out of the motion immediately,</span>
                <span class="co1">//  so we can stop motion in response to our fault.</span>
            <span class="br0">}</span>
            result <span class="sy1">=</span> motor1.<span class="me1">getFault</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
            <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> FAULT<span class="br0">)</span>
            <span class="br0">{</span>
                <span class="kw2">Serial</span>.<span class="kw3">print</span><span class="br0">(</span><span class="st0">"Motor 1 fault: "</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> OCP<span class="br0">)</span> <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Chip overcurrent!"</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> ILIMIT<span class="br0">)</span> <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Load current limit!"</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> UVLO<span class="br0">)</span> <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Undervoltage!"</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">if</span> <span class="br0">(</span>result <span class="sy3">&amp;</span> OTS<span class="br0">)</span> <span class="kw2">Serial</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"Over temp!"</span><span class="br0">)</span><span class="sy4">;</span>
                <span class="kw1">break</span><span class="sy4">;</span>
            <span class="br0">}</span>
        <span class="br0">}</span>
    <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>Now click Upload(CTRL+U) to burn testing code. Please refer to <a href="/Arduino_Common_Error" title="Arduino Common Error">here</a> for any error prompt and you can also add comment on <a href="http://www.seeedstudio.com/forum/">forum</a>
</p><p><br/>
</p><p><br/>
</p>
<h3> Review Results</h3>
<p>After upload completed, the motors will rotating in the positive or opposite direction in cycle.<br/>
<br/>
</p>
<h2> Related Projects</h2>
<p>If you want to make some awesome projects by this lovely board, here are some references for you.
</p>
<h3> Make a Mini Toy Car</h3>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://www.seeedstudio.com/recipe/391-make-a-mini-toy-car-with-arduino.html"><img src="img/Mini_toy_car.jpg" width="300"/></a> <div class="thumbcaption"></div></div></div>
<p>Every boy have the dream to make a car. Days ago I made a Never Fall Beetle, it’s very funny and so many people said the like it. Here it will make another toy car, which is much smaller and, it’s programmable. I am not going to use Shield Bot again, I will cut the car body with wooden board. And today I will just make a basic version, that means if you want you make a full and cool car, you need to make something yourself. There is 3 sensor include: Digital compass to detect the direction IR distance sensor to detect black line Ultrasonic sensor to detect the edge of desk, to avoid falling I will improve the code and outline when I get time.
</p><p><br/>
<a href="http://www.seeedstudio.com/recipe/391-make-a-mini-toy-car-with-arduino.html"><img src="img/Wiki_makeitnow_logo.png" width="200"/></a>
</p>
<h3> Make a Steampunk Style Award</h3>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="http://www.seeedstudio.com/recipe/1131-make-a-steam-punk-style-cup.html"><img src="img/Seeed_award2015.jpg" width="300"/></a> <div class="thumbcaption"></div></div></div>
<p>Every boy have the dream to make a car. Days ago I made a Never Fall Beetle, it’s very funny and so many people said the like it. Here it will make another toy car, which is much smaller and, it’s programmable. I am not going to use Shield Bot again, I will cut the car body with wooden board. And today I will just make a basic version, that means if you want you make a full and cool car, you need to make something yourself. There is 3 sensor include: Digital compass to detect the direction IR distance sensor to detect black line Ultrasonic sensor to detect the edge of desk, to avoid falling I will improve the code and outline when I get time.
</p><p><br/>
<a href="http://www.seeedstudio.com/recipe/1131-make-a-steam-punk-style-cup.html"><img src="img/Wiki_makeitnow_logo.png" width="200"/></a>
</p><p><br/>
<br/>
</p>
<h2> Resources</h2>
<ul><li><a href="res/DRV8830.pdf">DRV8830 Datasheet</a>
</li><li><a href="res/Grove-Mini_I2C_Motor_Driver_v1.0_SCH_PCB.rar">Grove - Mini I2C Motor Driver_Eagle_File</a>
</li><li><a href="res/Grove-Mini_I2C_Motor_Driver_v1.0_SCH.pdf">Grove - Mini I2C Motor Driver Schematic Document</a>
</li><li><a href="https://github.com/Seeed-Studio/Drv8830_Motor_Driver">Grove - Mini I2C Motor Driver Source Library</a>
</li></ul>
Copyright (c) 2008-2016 Seeed Development Limited (<a href="http://www.seeedstudio.com">www.seeedstudio.com</a> / <a href="http://www.seeed.cc">www.seeed.cc</a>)<h6>This static html page was created from http://www.seeedstudio.com/wiki</h6></div></body></html>