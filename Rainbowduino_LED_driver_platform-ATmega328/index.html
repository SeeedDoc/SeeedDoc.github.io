<html><head><meta name="viewport" content="width=device-width, initial-scale=1"><link href=//fonts.googleapis.com/css?family=Raleway:400,300,600 rel=stylesheet type=text/css><link rel="stylesheet" type="text/css" href="../common/css/normalize.css"><link rel="stylesheet" type="text/css" href="../common/css/skeleton.css"><link rel="stylesheet" type="text/css" href="../common/css/wiki.css"><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><title>Rainbowduino LED driver platform - ATmega328</title><meta charset="utf-8"/></head><body><div class"container"><a href="../"><img src="../common/logo.png"/></a></div><div class="mw-content-ltr container" dir="ltr" id="mw-content-text" lang="en"><h1>Rainbowduino LED driver platform - ATmega328</h1><div class="thumb tright"><div class="thumbinner" style="width:452px;"><img src="img/RAINBOW-Rainbowduino_LRG.jpg" width="450"/> <div class="thumbcaption"></div></div></div>
<div class="thumb tright"><div class="thumbinner" style="width:452px;"><img src="img/RAINBOW-Rainbowduino_01_LRG.jpg" width="450"/> <div class="thumbcaption"></div></div></div>

<h1> Introduction </h1>
<p>The Rainbowduino board is an Arduino compatible controller board with professional LED driving capacity. It will drive an 8x8 RGB Led Matrix (Common Anode).
</p>
<ul><li> No external circuit required, plug and shine!
</li><li> 24 constant current channels of 120mA each
</li><li> 8 super source driver channel of 500mA each
</li><li> Wide output voltage adaption from 6.5V-12VDC
</li><li> Dedicated GPIO and ADC
</li><li> Hardware UART and I2C communication
</li><li> Easy cascading
</li><li> Small form and light weight
</li></ul>
<p><br/>
</p>
<h2>  Standalone Mode (plug and shine) </h2>
<p>Needed Hardware:
</p>
<ul><li> 1 x Rainbowduino
</li><li> 1 x RGB LED Matrix
</li></ul>
<p>The simplest work mode, no external Systems needed (only a ttl serial adapter to upload the firmware). The LED matrix content is generated by the Rainbowduino itself.<br/>
Use Case:
</p>
<ul><li> Simple real-time animations calculated by the Rainbowduino
</li><li> Display pre-stored animations, limited due the 32kb ROM of the Rainbowduino
</li></ul>
<h2>  UART Mode </h2>
<p>Needed Hardware:<br/>
</p>
<ul><li> 1x Rainbowduino
</li><li> 1x RGB LED Matrix
</li><li> 1x TTL Level converter
</li><li> 1x UART sender unit (Arduino, PC...)
</li></ul>
<p>Send data (LED matrix content) from your computer to one Rainbowduino. As the Rainbowduino does not have a USB connector but a TTL serial connection you need a TTL serial level converter (BusPirate, UartSBee, Arduino...). 
</p><p><b>Use Case:</b><br/>
PC or Arduino generated frames displayed on ONE Led Matrix
</p>
<h2>  I2C Mode </h2>
<p>Needed Hardware: <br/>
</p>
<ul><li> 1..n x Rainbowduino
</li><li> 1..n x RGB LED Matrix
</li><li> 1 x I2C master device (for example an Arduino)
</li><li> Some cables
</li></ul>
<p>Send data (LED matrix content) from your computer to multiple Rainbowduino’s. A side-note if you use an Arduino with an FTDI USB to Serial adapter (Duemillanove, Diecimila...) - there is a Latency of ~16ms to send data from your computer to the Arduino. The new Arduino UNO have a much lower latency ~4ms.<br/>
Use Case:<br/>
PC or Arduino generated frames displayed on <b>multiple</b> Led Matrices<br/>
</p><p><img src="img/RAINBOW-i2c-cabling.png" width="443"/>
</p>
<h2>  I2C Cascading </h2>
<p>Rainbowduino is designed for easy casacading. After physically connected, power is passed on, and you may control the chain by I2C. Please note that each Rainbowduino must be assigned for a uniqe address for I2C communication.
</p><p>Prepare the power connection:<br/>
<img src="img/RAINBOW-chain-prepare.png" width="500"/><br/>
</p><p>Rainbowduino cascaded:<br/>
<img src="img/RAINBOW-chained.png" width="1000"/><br/>
</p><p><br/>
</p>
<h1>  Specification </h1>
<p>Microprocessor：Atmega 328<br/>
PCB size：60mm * 60mm * 1.6mm<br/>
Indicators：Reset, Power, Pin 13 LED<br/>
Power supply：6.5-12 VDC (9 VDC recommended)<br/>
Power connector：2 pin JST Terminal Blocks, 3mm DC Jacks<br/>
Cascading Power Connector：Terminal Blocks<br/>
Program interface：UART / ISP<br/>
LED dot-matrix sockets：32<br/>
Expansion socket：2.54mm bended pinheader pair<br/>
Communication Protocols：I2C / UART<br/>
RHOS：Yes<br/>
Input Voltage：6.5~12V<br/>
Global Current Consumption：600~2000mA<br/>
Constant Current Channels (Cathode)：24<br/>
Constant Current per channel (Cathode)：20~120mA<br/>
Source Driver Current per channel (Common-Anode)：500mA<br/>
Source Driver Voltage per channel (Common-Anode)：9~12V<br/>
Source Drive Channels：8<br/>
Drive LED count：192<br/>
Circuit Response Time：10ns<br/>
RGB Led Matrix color resolution per dot：4096：Uart Baud Rate：115200baud<br/>
</p>
<h2>  LED devices Compatibility </h2>
<p>Before direct plug into the female pin-headers, please verify if the RGB dot matrix are proven compatible. The concern is mainly on the pin out, where same color LEDs are in cluster, here we attach the scheme and photo demonstration. The color sequence might change, since the controlling logic are open source and easily reprogrammable.
</p><p><img src="img/RAINBOW-ledmatrix-schema.png" width="914"/>
</p><p>The power of Rainbowduino is well beyond driving a RGB dot-matrix. With 192 output count, and up to 120mA constant current capacity, you may easily populate massive LED setups.
The output current of each channel (IOUT) is set by an external resistor, Rext. The relationship between Iout and Rext is shown in the following figure. Please refer to MBI5168 data-sheet for more details. Adjusting the 1k Potentiometer clockwise to reduce the output current (default minimal 20mA for RGB dotmatrix), rotating counter-clockwise to increase the output current. The potentiometers are single circle, please NOTE that strong force will break it into unlimited rotatable, then you would need a multimeter to adjust. :)
</p><p>This means you can build your own LED matrix without any additional resistors.
</p><p><img src="img/RAINBOW-ledmatrix-voltage.png" width="900"/>
</p><p><br/>
</p>
<h1>  Demonstration </h1>
<h2>  Requirements </h2>
<ul><li> Rainbowduino board
</li><li> A Common Anode RGB Matrix
</li><li> An Arduino board (Optional)
</li></ul>
<p><img src="img/RAINBOW-connected-matrix.png" width="368"/>
</p>
<h2>  Prepare Rainbowduino Hardware </h2>
<p>Connect the RGB LED Matrix to the Rainbowduino and connect "Pin 1" to the red connection block. Pin1 is marked by a square solder point, while the other pins use a round solder point.
</p>
<h2>  Upload Firmware </h2>
<p>1.Upload a piece of code to Arduino first:
In order to use the Arduino to upload the firmware to the Rainbowduino, make sure that the Arduino is clean - we need to upload an empty firmware sketch as below shows to it. 
</p>
<table>
<tr>
<td><code>
<pre>void setup() {}<br/>
void loop() {}<br/>
</pre>
<p></p></code>
</td></tr></table>
<p><br/>
2. Upload Firmware to Rainbowduino
</p><p>Open the Rainbowduino firmware, <b>select the correct board</b> (Tools--&gt;board--&gt; Arduino Duemilanove or Nano w/ ATmega328) and upload the Firmware. At least that’s the theory ;)<br/> For your viewing pleasure, here is the connection scheme:
<img src="img/RAINBOW-fritz-uploadfw.png" width="809"/><br/>
We use an external power source, however you could also use the 5V from the Arduino.<br/>
<b>NOTE:</b> If you own a Rainbowduino v1 board, you need to select the "Arduino Diecimila, Duemilanove, or Nano w/ ATmega168"!
</p>
<table >
<tr>
<th>Arduino
</th>
<th>Rainbowduino
</th>
<caption>
</caption>
<td>RESET
</td>
<td>DTR
</td>
<caption>
</caption>
<td>GND
</td>
<td>GND
</td>
<caption>
</caption>
<td>RX
</td>
<td>RX
</td>
<caption>
</caption>
<td>TX
</td>
<td>TX
</td></tr></table>
<p>3.Use UartSB to Upload firmware
</p><p>Those screenshot's shows how to connect the UartSBee to the Rainbowduino:
</p>
<table>
<tr>
<td> <img src="img/RAINBOW-beeONE.jpg" width="450"/>
</td>
<td> <img src="img/RAINBOW-beeTWO.jpg" width="450"/>
</td></tr></table>
<p>If you connect the UartSBee to the USB bus, it should register a new serial port. Now simply upload your firmware using the new serial port.
</p><p>4.Use a Buspirate to Upload firmware / bootloader
</p><p>I'm explaining three methods of programming (all using the buspirate):
</p><p>- programming through the ISP.
- programming using avrdude and manual reset (no patching necessary)
- programming through avrdude with a tiny patch.
</p><p><br/>
</p><p>DISCONNECT THE RAINBOWDUINO FROM THE DISPLAY AND POWER. 
</p><p>STEP 1: To use the Buspirate you need a new version of avrdude <a href="http://download.savannah.gnu.org/releases/avrdude/">[1]</a>. I'm using version 5.10 and that recognizes the '-c buspirate' programmer option. You can test this with 
</p>
<pre>./avrdude -c buspirate -C ./avrdude.conf
</pre>
<p>If this complains about the programmer, then you need a newer version of the buspirate. 
</p><p>STEP 2: connect the buspirate to the rainbowduino ISP connector like this: <br/>
</p>
<table >
<tr>
<th> Buspirate<br/>
</th>
<th> ISP<br/>
</th>
<th> ISP pin
</th></tr>
<tr>
<td width="80px"> GND<br/>
</td>
<td width="80px"> GND<br/>
</td>
<td width="80px"> 6
</td></tr>
<tr>
<td> +5V<br/>
</td>
<td> Vcc<br/>
</td>
<td> 2
</td></tr>
<tr>
<td> CS<br/>
</td>
<td> RESET<br/>
</td>
<td> 5
</td></tr>
<tr>
<td> MOSI<br/>
</td>
<td> MOSI<br/>
</td>
<td> 4
</td></tr>
<tr>
<td> MISO<br/>
</td>
<td> MISO<br/>
</td>
<td> 1
</td></tr>
<tr>
<td> SCL/CLK<br/>
</td>
<td> SCK<br/>
</td>
<td> 3
</td></tr></table>
<p><br/>
</p><p>STEP 3: find the correct bootloader (I'm using the tiny optiboot firmware). Copy this file to your freshly compiled avrdude directory. 
</p><p>STEP 4: program the atmega 328p with 
</p>
<pre>./avrdude -v -c buspirate -p m328p -C ./avrdude.conf -P /dev/ttyUSB0 -U flash:w:optiboot_atmega328.hex
</pre>
<p>This takes a very long time...<br/>
</p><p>I started with uploading firmwares without the bootloader and that works fine. Trick is to get the HEX files from the arduino IDE. In version 0.22-Linux they are stored in /tmp/buildXXXXXXXXXXXX and NOT in the sketches directory. Just issue the 'Upload' command without any programmer connected (press &lt;shift&gt; during while pressing the 'upload' button to get much debug info from the arduino ide).<br/>
</p><p>After you have the bootloader on the rainbowduino you can use the transparent serial interface of the buspirate. Set the baudrate to 115200 and enter the '(3)' macro to activate transparent mode. The buspirate now acts like a USB-serial converter (any other FTDI like usb-serial converter could be used). Issue with the buspirate is that there is no DTR to reset the arduino with. You now have to time the reset and upload manually. Pressing reset after starting the upload seems to work best.<br/>
</p>
<pre>HiZ&gt;m
1. HiZ
2. 1-WIRE
3. UART
4. I2C
5. SPI
6. JTAG
7. RAW2WIRE
8. RAW3WIRE
9. PC KEYBOARD
10. LCD
(1) &gt;3
Mode selected
Set serial port speed: (bps)
1. 300
2. 1200
3. 2400
4. 4800
5. 9600
6. 19200
7. 38400
8. 57600
9. 115200
10. 31250 (MIDI)
(1) &gt;9
Data bits and parity:
1. 8, NONE *default
2. 8, EVEN
3. 8, ODD
4. 9, NONE
(1) &gt;
Stop bits:
1. 1 *default
2. 2
(1) &gt;
Receive polarity:
1. Idle 1 *default
2. Idle 0
(1) &gt;
Select output type:
1. Open drain (H=Hi-Z, L=GND)
2. Normal (H=3.3V, L=GND)
(1) &gt;2
READY
UART&gt;(3)
UART bridge. Space continues, anything else exits.
Reset to exit. </pre>
<p>After that you can program the arduino with the bootloader:<br/>
</p>
<pre>./avrdude -v -c stk500v1 -p m328p -b 115200 -F -C ./avrdude.conf -P /dev/ttyUSB0 -U flash:w:Rainbow_Plasma.cpp.hex
</pre>
<p>One step further is to patch avrdude in the file 'arduino.c'. The buspirate sends the 'rts' signal with the wrong polarity to the arduino but by swapping 1 for 0 and 0 for 1 that is fixed.From then on you have to choose 'arduino' as programmer instead of 'stk500v1'.<br/>
</p>
<pre>static int arduino_open(PROGRAMMER * pgm, char * port)
{
  fprintf(stderr, "arduino_open...\n");
  strcpy(pgm-&gt;port, port);
  serial_open(port, pgm-&gt;baudrate? pgm-&gt;baudrate: 115200, &amp;pgm-&gt;fd);

  /* Clear DTR and RTS to unload the RESET capacitor 
   * (for example in Arduino) */
  serial_set_dtr_rts(&amp;pgm-&gt;fd, 1);
  usleep(50*1000);
  /* Set DTR and RTS back to high */
  serial_set_dtr_rts(&amp;pgm-&gt;fd, 0);
  usleep(50*1000);

  /*
   * drain any extraneous input
   */
  stk500_drain(pgm, 0);

  if (stk500_getsync(pgm) &lt; 0)
    return -1;

  return 0;
}
</pre>
<p><i>Note: change the programmer type used by the arduino ide in the 'boards.txt' file.</i>
</p><p>Source: buspirate-avr-programming <a href="http://hintshop.ludvig.co.nz/show/buspirate-avr-programming/">[2]</a>, Bus_Pirate_AVR_Programming <a href="http://dangerousprototypes.com/docs/Bus_Pirate_AVR_Programming">[3]</a>, Optiboot <a href="http://code.google.com/p/optiboot/">[4]</a>
</p><p><br/>
</p>
<h1>  Rainbowdunio Firmware </h1>
<h2> Neorainbowduino Firmware</h2>
<p>This firmware bundle comes with two firmwares (one for a Arduino, one for the Rainbowduino) and a Processing library. You can send data from any Application via the serial line to the Arduino - the Arduino then sends the images to the corresponding Rainbowduino device. I created an easy-to-use Processing library to get started.
</p><p>Source: <a href="http://code.google.com/p/neorainbowduino/">http://code.google.com/p/neorainbowduino/</a>
</p><p><b>Features:</b><br/>
</p>
<ul><li> I2C enabled firmware (supports multiple Rainbowduino’s)
</li><li> Processing library, so you can easily control your Rainbowduino from Processing!
</li><li> Send full frames from Processing to Rainbowduino
</li><li> Send frames from Processing to your RGB matrix, each frame has a size of 8x8 pixel, 12bit color resolution (4096 colors). The color conversion is handled by the library
</li><li> Optimized processing lib - send only frames to Rainbowduino if needed (save ~50% of traffic - of course it depends on your frames)
</li><li> Fixed buffer swapping (no more flickering)
</li><li> Added i2c bus scanner, find your Rainbowduinos if you forget their addresses
</li></ul>
<p>Supported Work Modes: I2C 
</p>
<h3>  Requirements </h3>
<p>This firmware allows you to use Processing to control the rainbowduino, so its obvious you need:
</p>
<ul><li> Processing Software, get it from <a href="http://processing.org/">http://processing.org/</a>
</li></ul>
<p>If you don't like Processing (JAVA) you are not limited to it. Check <a href="http://wish.seeedstudio.com/?p=320">http://wish.seeedstudio.com/?p=320</a> for an example using <a href="http://www.autoitscript.com/autoit3/index.shtml">autoitscript</a> sending data to the Arduino.
</p>
<h3>  Patches for Arduino IDE </h3>
<p>Because the neorainbowduino firmware sends full frames via I2c (92 bytes) we need to patch the I2c buffer size for the arduino (to optimize transfer speed). I hope the Arduino supports variable buffer size in near future. Make sure your <b>Arduino IDE is closed</b> if you patch the files!
</p><p><b>File to patch:</b> Java/libraries/Wire/utility/twi.h<br/>
<b>Reason:</b> Increase the I2C speed from 100kHz to 400kHz, increase the I2C buffer size from 32 bytes to 98 bytes<br/>
</p>
<table>
<tr>
<th>Original File
</th>
<th>Patched File
</th>
<caption>
</caption>
<td width="300px">
<p><code>
</code></p>
<pre>#ifndef TWI_FREQ
#define TWI_FREQ 100000L
#endif<br/> 
#ifndef TWI_BUFFER_LENGTH
#define TWI_BUFFER_LENGTH 32
#endif
</pre>
<p>
</p>
</td>
<td width="300px">
<p><code>
</code></p>
<pre>#ifndef TWI_FREQ
#define TWI_FREQ <b>400000L</b>
#endif<br/> 
#ifndef TWI_BUFFER_LENGTH
#define TWI_BUFFER_LENGTH <b>98</b>
#endif
</pre>
<p>
</p>
</td></tr></table>
<p><b>File to patch:</b> Java/libraries/Wire/Wire.h<br/>
<b>Reason:</b> Increase the Serial buffer size from 32 bytes to 98 bytes<br/>
</p>
<table>
<tr>
<th>Original File
</th>
<th>Patched File
</th>
<caption>
</caption>
<td width="300px">
<p><code>
</code></p>
<pre>#define BUFFER_LENGTH 32
</pre>
<p>
</p>
</td>
<td width="300px">
<p><code>
</code></p>
<pre>#define BUFFER_LENGTH <b>98</b>
</pre>
<p>
</p>
</td></tr></table>
<h3>  Upload Firmware to Rainbowduino </h3>
<p>Upload the firmware (see Upload Firmware), the firmware file you need is <b>rainbowduinoFw/Rainbow_V2_71/Rainbow_V2_71.pde</b>.
</p><p><b>Note:</b> This firmware use the I2C protocol to communicate - each Rainbowduino needs a unique I2C address. The address can be configured by editing the Rainbowduino.h file (<code>#define I2C_DEVICE_ADDRESS 0x06</code>). So dont forget to change the address if you upload this firmware to more than one rainbowduino's!
</p>
<h3>  Upload Firmware to Arduino </h3>
<p>Disconnect the RX/TX lines between Rainbowduino and Arduino. Upload the Arduino firmware <b>arduinoFw/neoLed/neoLed.pde</b> to the Arduino.
</p>
<h3> Interact with Rainbowduino</h3>
<p>This chapter will show you a <b>simple way to communicate</b> with your Rainbowduino. You need an Arduino (working as a serial to I2C gateway) and a Rainbowduino with an I2C address of 0x06.
</p><p>The connection between the Rainbowduino and Arduino should look like this:
<img src="img/RAINBOW-neorainbow.png" width="811"/><br/>
We use an external power source, however you could also use the 5V from the Arduino.
</p>
<table >
<tr>
<th> Arduino
</th>
<th> Rainbowduino
</th></tr>
<tr>
<td width="150px">RESET
</td>
<td width="150px">DTR
</td></tr>
<tr>
<td>GND
</td>
<td>GND
</td></tr>
<tr>
<td>Analog IN 4
</td>
<td>SDA
</td></tr>
<tr>
<td>Analog IN 5
</td>
<td>SDL
</td></tr></table>
<h3>  Install Processing Libraries </h3>
<p>After you installed the Processing Software, you'll need to install the neorainbowduino libraray. You can find the processing library in the <b>processingLib\distribution\neorainbowduino-x.y\download</b> directory. Unpack the zip-file to your Processing home folder (there is a README.TXT file inside for detailed instructions, how to install).
</p><p>When you start Processing you should able to import the neorainbowduino library):<br/>
<img src="img/RAINBOW-processing-lib.png" width="598"/><br/>
</p>
<h4>  Simple Example </h4>
<p>Here is a very simple Processing sketch to send som random rectangles to the rainbowduino.
</p>
<div class="mw-geshi mw-code mw-content-ltr container" dir="ltr"><div class="arduino source-arduino"><pre class="de1"> import processing.<span class="me1">serial</span>.<span class="sy2">*</span><span class="sy4">;</span>
 import com.<span class="me1">neophob</span>.<span class="me1">lib</span>.<span class="me1">rainbowduino</span>.<span class="me1">test</span>.<span class="sy2">*</span><span class="sy4">;</span>
 import com.<span class="me1">neophob</span>.<span class="me1">lib</span>.<span class="me1">rainbowduino</span>.<span class="sy2">*</span><span class="sy4">;</span>
 
 <span class="kw4">static</span> final <span class="kw4">int</span> SIZE <span class="sy1">=</span> <span class="nu0">400</span><span class="sy4">;</span>
 Rainbowduino r<span class="sy4">;</span>
 
 <span class="kw4">void</span> <span class="kw2">setup</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
   frameRate<span class="br0">(</span><span class="nu0">15</span><span class="br0">)</span><span class="sy4">;</span>
   background<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
   size<span class="br0">(</span>SIZE, SIZE<span class="br0">)</span><span class="sy4">;</span>
 
   <span class="co1">//initialize rainbowduino</span>
   List<span class="sy1">&lt;</span>Integer<span class="sy1">&gt;</span> list <span class="sy1">=</span> <span class="kw3">new</span> ArrayList<span class="sy1">&lt;</span>Integer<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
   list.<span class="me1">add</span><span class="br0">(</span><span class="nu0">6</span><span class="br0">)</span><span class="sy4">;</span>         <span class="co1">//use rainbowduino with slave id 6</span>
   <span class="kw2">try</span> <span class="br0">{</span>
     r <span class="sy1">=</span> <span class="kw3">new</span> Rainbowduino<span class="br0">(</span><span class="kw3">this</span>, list<span class="br0">)</span><span class="sy4">;</span>
     System.<span class="me1">out</span>.<span class="kw3">println</span><span class="br0">(</span><span class="st0">"ping: "</span><span class="sy2">+</span>r.<span class="me1">ping</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
   <span class="br0">}</span> <span class="kw2">catch</span> <span class="br0">(</span>Exception e<span class="br0">)</span> <span class="br0">{</span>
     <span class="kw3">println</span><span class="br0">(</span><span class="st0">"FAILED to open serial port!!"</span><span class="br0">)</span><span class="sy4">;</span>
     e.<span class="me1">printStackTrace</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
   <span class="br0">}</span>
 
   smooth<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
   noStroke<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
 <span class="br0">}</span>
 
 <span class="kw4">void</span> draw<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="co1">//draw some simple stuff on screen</span>
   color c1 <span class="sy1">=</span> color<span class="br0">(</span><span class="nu0">128</span><span class="sy2">+</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="kw3">random</span><span class="br0">(</span><span class="nu0">64</span><span class="br0">)</span>, <span class="nu0">128</span>, <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="kw3">random</span><span class="br0">(</span><span class="nu0">255</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
   fill<span class="br0">(</span>c1<span class="br0">)</span><span class="sy4">;</span>
 
   <span class="kw4">int</span> size <span class="sy1">=</span> <span class="nu0">80</span><span class="sy2">+</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="kw3">random</span><span class="br0">(</span><span class="nu0">80</span><span class="br0">)</span><span class="sy4">;</span>
   <span class="kw4">int</span> x <span class="sy1">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="kw3">random</span><span class="br0">(</span>SIZE<span class="br0">)</span><span class="sy4">;</span>
   <span class="kw4">int</span> y <span class="sy1">=</span> <span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="kw3">random</span><span class="br0">(</span>SIZE<span class="br0">)</span><span class="sy4">;</span>  
   rect<span class="br0">(</span>x, y, size, size<span class="br0">)</span><span class="sy4">;</span><span class="sy1">&lt;</span>br<span class="sy1">&gt;</span>
   <span class="co1">//send PApplet to the Rainbowduino lib - and send it to slave id 6</span>
   r.<span class="me1">sendRgbFrame</span><span class="br0">(</span><span class="br0">(</span>byte<span class="br0">)</span><span class="nu0">6</span>, <span class="kw3">this</span><span class="br0">)</span><span class="sy4">;</span> 
 <span class="br0">}</span></pre></div></div>
<p>TODO add some screenshots
</p>
<h4>  How Image resizing works </h4>
<p>The image will be resized using an Area Averaging Filter. So its important to know, that the image should be correctly aligned. Aligned means, that the result looks good if the image can be divided by 8. Here is a good and bad example:
</p>
<table  cellpadding="10" cellspacing="0">
<tr>
<th> Good example (aligned)
</th>
<th> Bad example (not aligned)
</th>
<caption>
</caption>
<td> <img src="img/RAINBOW-resize-good-src.png" width="350"/>
</td>
<td> <img src="img/RAINBOW-resize-bad-src.png" width="350"/>
</td>
<caption>
</caption>
<td> <img src="img/RAINBOW-resize-good-dst.png" width="350"/>
</td>
<td> <img src="img/RAINBOW-resize-bad-dst.png" width="350"/>
</td></tr></table>
<h2> mtXcontrol Firmware</h2>
<p>Source: <a href="http://www.rngtng.com/mtxcontrol/">http://www.rngtng.com/mtxcontrol/</a>
<br/><b>Features:</b><br/>
</p>
<ul><li> mtXcontrol is an editor written in Processing to easily create image sequences for several output devices containing multicolor LED matrix.
</li></ul>
<p>Supported Work Modes: ???
</p>
<h2> Firmware 3</h2>
<p>Source: <a href="http://code.google.com/p/rainbowduino-firmware/">http://code.google.com/p/rainbowduino-firmware/</a>
</p><p><b>Features:</b><br/>
</p>
<ul><li> double-buffering synced with refresh rate
</li><li> 4 auxiliary buffers
</li><li> hi-level instruction set
</li><li> multiple controlled hardware
</li><li> I2C communication protocol
</li><li> permanent data storage in Eeprom
</li></ul>
<p>Supported Work Modes: I2C
</p>
<h2> RainbowDashboard</h2>
<p>Source: <a href="http://code.google.com/p/rainbowdash/">http://code.google.com/p/rainbowdash/</a>
</p><p><b>Features:</b><br/>
</p>
<ul><li> Clean, maintainable code base.
</li><li> Compatible with standard firmware.
</li><li> Supports UART mode (no Arduino host needed - talk to Rainbowduino directly).
</li><li> Double-buffered graphics operations.
</li><li> Software real-time clock.
</li><li> Animation driven by the Rainbowduino itself.
</li><li> Full Windows ANSI (CP1252) character set.
</li><li> High-level command set.
</li></ul>
<p>Supported Work Modes: UART
</p><p>Can easily be changed to use I2C; only one file (RainbowDash.pde) needs to be changed.
</p>
<h1>  How the Firmware works </h1>
<h2> Microprocessor - Atmega 168/328</h2>
<p><img src="img/RAINBOW-Schema.png" width="600"/><br/>
</p>
<table >
<tr>
<th> PORTD
</th>
<th> PORTB
</th>
<th> PORTC
</th></tr>
<tr>
<td width="150px">pin02 / PD0 / RXD
</td>
<td width="150px">pin14 / PB0 / INT0
</td>
<td width="150px">pin23 / PC0 / SDI
</td></tr>
<tr>
<td>pin03 / PD1 / TXD
</td>
<td>pin15 / PB1 / INT1
</td>
<td>pin24 / PC1 / CLK
</td></tr>
<tr>
<td>pin04 / PD2 / INT0
</td>
<td>pin16 / PB2 / INT2
</td>
<td>pin25 / PC2 / LE
</td></tr>
<tr>
<td>pin05 / PD3 / INT19
</td>
<td>pin17 / PB3 / INT3
</td>
<td>pin26 / PC3 / OE
</td></tr>
<tr>
<td>pin06 / PD4 / INT20
</td>
<td>pin18 / PB4 / INT4
</td>
<td>pin27 / PC4 / SDA
</td></tr>
<tr>
<td>pin11 / PD5 / INT21
</td>
<td>pin19 / PB5 / INT5/SCK
</td>
<td>pin28 / PC5 / SDL
</td></tr>
<tr>
<td>pin12 / PD6 / INT22
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td>pin13 / PD7 / INT23
</td>
<td>
</td>
<td>
</td></tr></table>
<p><b>PORTB</b> maps to Arduino digital pins 8 to 13 The two high bits (6 &amp; 7) map to the crystal pins and are not usable.<br/>
<b>PORTC</b> maps to Arduino analog pins 0 to 5. Pins 6 &amp; 7 are only accessible on the Arduino Mini.<br/>
<b>PORTD</b> maps to Arduino digital pins 0 to 7.<br/>
</p>
<h2>  Constant Current LED driver </h2>
<p>This driver uses the MBI5168. The MBI5168 is a 8bit <a href="http://en.wikipedia.org/wiki/Shift_register">shift register</a>. It converts the serial data to parallel data. All 3 MBI5168 share the LE,CLK and OE input.<br/>
<img src="img/RAINBOW-Mbi-schema.png" width="1000"/><br/>
</p>
<table >
<tr>
<th> Name
</th>
<th> Desc
</th></tr>
<tr>
<td width="50px">OE
</td>
<td width="950px">Output Enabled, when (active) low, the output drivers are enabled; when high, all output drivers are turned OFF (blanked).
</td></tr>
<tr>
<td>LE
</td>
<td>Data strobe input terminal, Serial data is transfered to the respective latch when LE is high. The data is latched when LE goes low.
</td></tr>
<tr>
<td>SDI
</td>
<td>Serial data input to the shift register.
</td></tr>
<tr>
<td>SDO
</td>
<td>Serial data output to the following SDI of next driver IC.
</td></tr>
<tr>
<td>R-EXT
</td>
<td>Input terminal used to connect an external resistor dor setting up output current for all output channels.
</td></tr>
<tr>
<td>CLK
</td>
<td>Clock input terminal for data shift on rising edge
</td></tr></table>
<h2>  Super Source Driver </h2>
<p><img src="img/RAINBOW-schema-M5456.png" width="500"/>
</p>
<h2>  Shift out data</h2>
<p>To display a full frame on the LED Matrix, the Rainbowduino interrupt method needs to be called 128 times. There are 8 lines and 16 brightness levels. Each time the displayNextLine() method gets called, one line gets updated by the current brightness level. After all 8 lines are updated the brightness level gets updated. That’s why this function needs 128 cycles until a full frame is populated on the LED Matrix. 
</p><p>Below you see the LED Matrix display after 32, 64, 96 and 128 cycles. You notice how the brightness is increased.
<img src="img/RAINBOW-fw.1.png" width="640"/>
</p>
<h2> Support more than 4096 colors (12bit)</h2>
<p>The stock firmware (and most 3rd party firmwares) support 12bit color resolution. It is possible to increase this: 
</p>
<table >
<tr>
<th> Color Resolution
</th>
<th> Payload
</th>
<th> Brightness Level
</th></tr>
<tr>
<td width="250px">12 bit (4bit per color), 4096 Colors
</td>
<td width="250px">96 bytes (12bit*64=768bit)
</td>
<td>16
</td></tr>
<tr>
<td>15 bit (5bit per color), 32768 Colors
</td>
<td>120 bytes (15bit*64=960bit)
</td>
<td>32
</td></tr></table>
<p>The benefit of using 4bits per color is the data storage, one byte takes 2 color values - thus it's easy to get the color from a byte buffer. Using 5bits per color needs more cpu power or more buffer space (use 2 bytes for 3 color values - wasting 1bit per color).
</p><p>To achieve 15 bit color resolution, the firmware needs two changes:
</p>
<ul><li> loop over 32 instead 16 brightness levels
</li><li> change the shift out function
</li></ul>
<p><br/>
</p><p><br/>
</p><p><br/>
</p>
<h1>  Resources  </h1>
<ul><li> <a href="http://www.neophob.com/2010/11/huge-rgb-led-matrix/">A Huge DIY LED Matrix</a>
</li><li> <a href="http://www.neophob.com/2010/07/rainbowduino-fun-aka-neorainbowduino/">Generic Rainbowduino information</a>
</li><li><a href="res/RAINBOW-MBI5168_Datasheet_VA.02-English.pdf" title="File:RAINBOW-MBI5168 Datasheet VA.02-English.pdf">File:RAINBOW-MBI5168 Datasheet VA.02-English.pdf</a>
</li><li>[<a href="http://www.atmel.com/dyn/resources/prod_documents/doc2545.pdf">prod_documents</a>]
</li><li><a href="res/RAINBOW-MBI5168_Datasheet_VA.02-English.pdf" title="File:RAINBOW-MBI5168 Datasheet VA.02-English.pdf">File:RAINBOW-MBI5168 Datasheet VA.02-English.pdf</a>
</li></ul>
Copyright (c) 2008-2016 Seeed Development Limited (<a href="http://www.seeedstudio.com">www.seeedstudio.com</a> / <a href="http://www.seeed.cc">www.seeed.cc</a>)<h6>This static html page was created from http://www.seeedstudio.com/wiki</h6></div></body></html>